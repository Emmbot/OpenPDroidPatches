diff --git a/Android.mk b/Android.mk
index 83c4b5b..a7d65d9 100644
--- a/Android.mk
+++ b/Android.mk
@@ -58,6 +58,7 @@ LOCAL_SRC_FILES := $(filter-out \
 ## across process boundaries.
 ##
 ## READ ME: ########################################################
+# BEGIN privacy-added: IPrivacySettingsManager.aidl
 LOCAL_SRC_FILES += \
 	core/java/android/accessibilityservice/IAccessibilityServiceConnection.aidl \
 	core/java/android/accessibilityservice/IEventListener.aidl \
@@ -72,6 +73,7 @@ LOCAL_SRC_FILES += \
 	core/java/android/app/IBackupAgent.aidl \
 	core/java/android/app/IInstrumentationWatcher.aidl \
 	core/java/android/app/INotificationManager.aidl \
+	core/java/android/app/IProfileManager.aidl \
 	core/java/android/app/IProcessObserver.aidl \
 	core/java/android/app/ISearchManager.aidl \
 	core/java/android/app/ISearchManagerCallback.aidl \
@@ -123,6 +125,7 @@ LOCAL_SRC_FILES += \
 	core/java/android/os/IHardwareService.aidl \
 	core/java/android/os/IMessenger.aidl \
 	core/java/android/os/INetworkManagementService.aidl \
+	core/java/android/os/IHDMIService.aidl  \
 	core/java/android/os/IPermissionController.aidl \
 	core/java/android/os/IPowerManager.aidl \
 	core/java/android/os/IRemoteCallback.aidl \
@@ -147,6 +150,7 @@ LOCAL_SRC_FILES += \
 	core/java/com/android/internal/app/IBatteryStats.aidl \
 	core/java/com/android/internal/app/IUsageStats.aidl \
 	core/java/com/android/internal/app/IMediaContainerService.aidl \
+	core/java/com/android/internal/app/IAssetRedirectionManager.aidl \
 	core/java/com/android/internal/appwidget/IAppWidgetService.aidl \
 	core/java/com/android/internal/appwidget/IAppWidgetHost.aidl \
 	core/java/com/android/internal/backup/IBackupTransport.aidl \
@@ -187,6 +191,7 @@ LOCAL_SRC_FILES += \
 	media/java/android/media/IMediaScannerService.aidl \
 	media/java/android/media/IRemoteControlClient.aidl \
 	media/java/android/media/IRemoteControlDisplay.aidl \
+	privacy/java/android/privacy/IPrivacySettingsManager.aidl \
 	telephony/java/com/android/internal/telephony/IPhoneStateListener.aidl \
 	telephony/java/com/android/internal/telephony/IPhoneSubInfo.aidl \
 	telephony/java/com/android/internal/telephony/ITelephony.aidl \
@@ -199,8 +204,23 @@ LOCAL_SRC_FILES += \
 	telephony/java/com/android/internal/telephony/IExtendedNetworkService.aidl \
 	voip/java/android/net/sip/ISipSession.aidl \
 	voip/java/android/net/sip/ISipSessionListener.aidl \
-	voip/java/android/net/sip/ISipService.aidl
+	voip/java/android/net/sip/ISipService.aidl \
+	fmradio/java/com/stericsson/hardware/fm/IFmReceiver.aidl \
+	fmradio/java/com/stericsson/hardware/fm/IFmTransmitter.aidl \
+	fmradio/java/com/stericsson/hardware/fm/IOnStateChangedListener.aidl \
+	fmradio/java/com/stericsson/hardware/fm/IOnStartedListener.aidl \
+	fmradio/java/com/stericsson/hardware/fm/IOnErrorListener.aidl \
+	fmradio/java/com/stericsson/hardware/fm/IOnScanListener.aidl \
+	fmradio/java/com/stericsson/hardware/fm/IOnForcedPauseListener.aidl \
+	fmradio/java/com/stericsson/hardware/fm/IOnForcedResetListener.aidl \
+	fmradio/java/com/stericsson/hardware/fm/IOnBlockScanListener.aidl \
+	fmradio/java/com/stericsson/hardware/fm/IOnRDSDataFoundListener.aidl \
+	fmradio/java/com/stericsson/hardware/fm/IOnSignalStrengthListener.aidl \
+	fmradio/java/com/stericsson/hardware/fm/IOnStereoListener.aidl \
+	fmradio/java/com/stericsson/hardware/fm/IOnExtraCommandListener.aidl \
+	fmradio/java/com/stericsson/hardware/fm/IOnAutomaticSwitchListener.aidl
 #
+# END privacy-added: IPrivacySettingsManager.aidl
 
 
 # FRAMEWORKS_BASE_JAVA_SRC_DIRS comes from build/core/pathmap.mk
@@ -243,12 +263,15 @@ framework_built := $(call java-lib-deps,framework)
 # AIDL files to be preprocessed and included in the SDK,
 # relative to the root of the build tree.
 # ============================================================
+# BEGIN privacy-added: PrivacySettings.aidl
 aidl_files := \
 	frameworks/base/core/java/android/accounts/IAccountManager.aidl \
 	frameworks/base/core/java/android/accounts/IAccountManagerResponse.aidl \
 	frameworks/base/core/java/android/accounts/IAccountAuthenticator.aidl \
 	frameworks/base/core/java/android/accounts/IAccountAuthenticatorResponse.aidl \
 	frameworks/base/core/java/android/app/Notification.aidl \
+	frameworks/base/core/java/android/app/NotificationGroup.aidl \
+	frameworks/base/core/java/android/app/Profile.aidl \
 	frameworks/base/core/java/android/app/PendingIntent.aidl \
 	frameworks/base/core/java/android/bluetooth/BluetoothDevice.aidl \
 	frameworks/base/core/java/android/bluetooth/BluetoothHealthAppConfiguration.aidl \
@@ -288,11 +311,13 @@ aidl_files := \
 	frameworks/base/graphics/java/android/graphics/Region.aidl \
 	frameworks/base/location/java/android/location/Criteria.aidl \
 	frameworks/base/location/java/android/location/Location.aidl \
+	frameworks/base/privacy/java/android/privacy/PrivacySettings.aidl \
 	frameworks/base/telephony/java/android/telephony/ServiceState.aidl \
 	frameworks/base/telephony/java/com/android/internal/telephony/IPhoneSubInfo.aidl \
 	frameworks/base/telephony/java/com/android/internal/telephony/ITelephony.aidl \
 
 gen := $(TARGET_OUT_COMMON_INTERMEDIATES)/framework.aidl
+# END privacy-added: PrivacySettings.aidl
 $(gen): PRIVATE_SRC_FILES := $(aidl_files)
 ALL_SDK_FILES += $(gen)
 $(gen): $(aidl_files) | $(AIDL)
@@ -523,7 +548,7 @@ include $(CLEAR_VARS)
 
 LOCAL_SRC_FILES:=$(framework_docs_LOCAL_API_CHECK_SRC_FILES)
 LOCAL_INTERMEDIATE_SOURCES:=$(framework_docs_LOCAL_INTERMEDIATE_SOURCES)
-LOCAL_JAVA_LIBRARIES:=$(framework_docs_LOCAL_JAVA_LIBRARIES)
+LOCAL_JAVA_LIBRARIES:=$(framework_docs_LOCAL_JAVA_LIBRARIES) framework
 LOCAL_MODULE_CLASS:=$(framework_docs_LOCAL_MODULE_CLASS)
 LOCAL_DROIDDOC_SOURCE_PATH:=$(framework_docs_LOCAL_DROIDDOC_SOURCE_PATH)
 LOCAL_DROIDDOC_HTML_DIR:=$(framework_docs_LOCAL_DROIDDOC_HTML_DIR)
diff --git a/cmds/bootanimation/Android.mk b/cmds/bootanimation/Android.mk
index 7d39912..7f1857d 100644
--- a/cmds/bootanimation/Android.mk
+++ b/cmds/bootanimation/Android.mk
@@ -20,6 +20,18 @@ LOCAL_SHARED_LIBRARIES := \
 LOCAL_C_INCLUDES := \
 	$(call include-path-for, corecg graphics)
 
+ifeq ($(TARGET_BOOTANIMATION_PRELOAD),true)
+    LOCAL_CFLAGS += -DPRELOAD_BOOTANIMATION
+endif
+
+ifeq ($(TARGET_BOOTANIMATION_TEXTURE_CACHE),true)
+    LOCAL_CFLAGS += -DNO_TEXTURE_CACHE=0
+endif
+
+ifeq ($(TARGET_BOOTANIMATION_TEXTURE_CACHE),false)
+    LOCAL_CFLAGS += -DNO_TEXTURE_CACHE=1
+endif
+
 LOCAL_MODULE:= bootanimation
 
 
diff --git a/cmds/bootanimation/BootAnimation.cpp b/cmds/bootanimation/BootAnimation.cpp
index 154dbb8..2f06ad5 100644
--- a/cmds/bootanimation/BootAnimation.cpp
+++ b/cmds/bootanimation/BootAnimation.cpp
@@ -281,6 +281,38 @@ status_t BootAnimation::readyToRun() {
         mAndroidAnimation = false;
     }
 
+
+#ifdef PRELOAD_BOOTANIMATION
+    // Preload the bootanimation zip on memory, so we don't stutter
+    // when showing the animation
+    FILE* fd;
+    if (encryptedAnimation && access(SYSTEM_ENCRYPTED_BOOTANIMATION_FILE, R_OK) == 0)
+        fd = fopen(SYSTEM_ENCRYPTED_BOOTANIMATION_FILE, "r");
+    else if (access(USER_BOOTANIMATION_FILE, R_OK) == 0)
+        fd = fopen(USER_BOOTANIMATION_FILE, "r");
+    else if (access(SYSTEM_BOOTANIMATION_FILE, R_OK) == 0)
+        fd = fopen(SYSTEM_BOOTANIMATION_FILE, "r");
+    else
+        return NO_ERROR;
+
+    if (fd != NULL) {
+        // We could use readahead..
+        // ... if bionic supported it :(
+        //readahead(fd, 0, INT_MAX);
+        void *crappyBuffer = malloc(2*1024*1024);
+        if (crappyBuffer != NULL) {
+            // Read all the zip
+            while (!feof(fd))
+                fread(crappyBuffer, 1024, 2*1024, fd);
+
+            free(crappyBuffer);
+        } else {
+            LOGW("Unable to allocate memory to preload the animation");
+        }
+        fclose(fd);
+    }
+#endif
+
     return NO_ERROR;
 }
 
@@ -420,7 +452,7 @@ bool BootAnimation::movie()
             const String8 path(entryName.getPathDir());
             const String8 leaf(entryName.getPathLeaf());
             if (leaf.size() > 0) {
-                for (int j=0 ; j<pcount ; j++) {
+                for (size_t j=0 ; j<pcount ; j++) {
                     if (path == animation.parts[j].path) {
                         int method;
                         // supports only stored png files
@@ -468,16 +500,25 @@ bool BootAnimation::movie()
     Region clearReg(Rect(mWidth, mHeight));
     clearReg.subtractSelf(Rect(xc, yc, xc+animation.width, yc+animation.height));
 
-    for (int i=0 ; i<pcount && !exitPending() ; i++) {
+    for (size_t i=0 ; i<pcount && !exitPending() ; i++) {
         const Animation::Part& part(animation.parts[i]);
         const size_t fcount = part.frames.size();
+
+        // can be 1, 0, or not set
+        #ifdef NO_TEXTURE_CACHE
+        const int noTextureCache = NO_TEXTURE_CACHE;
+        #else
+        const int noTextureCache = ((animation.width * animation.height * fcount) >
+                                 48 * 1024 * 1024) ? 1 : 0;
+        #endif
+
         glBindTexture(GL_TEXTURE_2D, 0);
 
         for (int r=0 ; !part.count || r<part.count ; r++) {
-            for (int j=0 ; j<fcount && !exitPending(); j++) {
+            for (size_t j=0 ; j<fcount && !exitPending(); j++) {
                 const Animation::Frame& frame(part.frames[j]);
 
-                if (r > 0) {
+                if (r > 0 && !noTextureCache) {
                     glBindTexture(GL_TEXTURE_2D, frame.tid);
                 } else {
                     if (part.count != 1) {
@@ -512,13 +553,15 @@ bool BootAnimation::movie()
                 long wait = ns2us(frameDuration);
                 if (wait > 0)
                     usleep(wait);
+                if (noTextureCache)
+                    glDeleteTextures(1, &frame.tid);
             }
             usleep(part.pause * ns2us(frameDuration));
         }
 
         // free the textures for this part
-        if (part.count != 1) {
-            for (int j=0 ; j<fcount ; j++) {
+        if (part.count != 1 && !noTextureCache) {
+            for (size_t j=0 ; j<fcount ; j++) {
                 const Animation::Frame& frame(part.frames[j]);
                 glDeleteTextures(1, &frame.tid);
             }
diff --git a/cmds/bootanimation/bootanimation_main.cpp b/cmds/bootanimation/bootanimation_main.cpp
index 5f8b744..161ba44 100644
--- a/cmds/bootanimation/bootanimation_main.cpp
+++ b/cmds/bootanimation/bootanimation_main.cpp
@@ -45,7 +45,7 @@ int main(int argc, char** argv)
 #endif
 
     char value[PROPERTY_VALUE_MAX];
-    property_get("debug.sf.nobootanimation", value, "0");
+    property_get("persist.sys.nobootanimation", value, "0");
     int noBootAnimation = atoi(value);
     LOGI_IF(noBootAnimation,  "boot animation disabled");
     if (!noBootAnimation) {
diff --git a/cmds/hdmid/Android.mk b/cmds/hdmid/Android.mk
new file mode 100644
index 0000000..57659ab
--- /dev/null
+++ b/cmds/hdmid/Android.mk
@@ -0,0 +1,52 @@
+# Copyright (C) 2008 The Android Open Source Project
+#
+#  Licensed under the Apache License, Version 2.0 (the "License");
+#  you may not use this file except in compliance with the License.
+#  You may obtain a copy of the License at
+#
+#       http://www.apache.org/licenses/LICENSE-2.0
+#
+#  Unless required by applicable law or agreed to in writing, software
+#  distributed under the License is distributed on an "AS IS" BASIS,
+#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+#  See the License for the specific language governing permissions and
+#  limitations under the License
+#
+
+ifeq ($(TARGET_QCOM_HDMI_OUT),true)
+LOCAL_PATH:= $(call my-dir)
+include $(CLEAR_VARS)
+
+LOCAL_SRC_FILES:= \
+	hdmid_main.cpp \
+	HDMIDaemon.cpp \
+
+# need "-lrt" on Linux simulator to pick up clock_gettime
+ifeq ($(TARGET_SIMULATOR),true)
+	ifeq ($(HOST_OS),linux)
+		LOCAL_LDLIBS += -lrt
+	endif
+endif
+
+LOCAL_CFLAGS += -DGL_GLEXT_PROTOTYPES -DEGL_EGLEXT_PROTOTYPES -DQCOM_HDMI_OUT
+
+ifeq ($(TARGET_QCOM_HDMI_RESOLUTION_AUTO),true)
+	LOCAL_CFLAGS += -DFORCE_AUTO_RESOLUTION
+endif
+
+LOCAL_SHARED_LIBRARIES := \
+    libcutils \
+    libutils \
+    libbinder \
+    libgui \
+    libmedia \
+
+LOCAL_C_INCLUDES := \
+	$(call include-path-for, corecg graphics)
+
+LOCAL_MODULE:= hdmid
+LOCAL_MODULE_TAGS:= eng
+
+include $(BUILD_EXECUTABLE)
+
+endif
diff --git a/cmds/hdmid/HDMIDaemon.cpp b/cmds/hdmid/HDMIDaemon.cpp
new file mode 100644
index 0000000..bd740b1
--- /dev/null
+++ b/cmds/hdmid/HDMIDaemon.cpp
@@ -0,0 +1,792 @@
+/*
+ * Copyright (C) 2007 The Android Open Source Project
+ * Copyright (c) 2010-2012, Code Aurora Forum. All rights reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#define LOG_TAG "HDMIDaemon"
+
+#include <ctype.h>
+#include <stdint.h>
+#include <sys/types.h>
+#include <math.h>
+#include <fcntl.h>
+#include <utils/misc.h>
+#include <signal.h>
+
+#include <binder/IPCThreadState.h>
+#include <binder/IServiceManager.h>
+#include <media/IAudioPolicyService.h>
+#include <media/AudioSystem.h>
+#include <utils/threads.h>
+#include <utils/Atomic.h>
+#include <utils/Errors.h>
+#include <utils/Log.h>
+#include <utils/AssetManager.h>
+
+#include <ui/DisplayInfo.h>
+#include <ui/FramebufferNativeWindow.h>
+#include <linux/msm_mdp.h>
+#include <linux/fb.h>
+#include <sys/ioctl.h>
+
+#include <cutils/properties.h>
+
+#include "HDMIDaemon.h"
+
+namespace android {
+
+// ---------------------------------------------------------------------------
+
+#define DEVICE_ROOT "/sys/devices/virtual/graphics"
+#define DEVICE_NODE "fb1"
+
+#define HDMI_SOCKET_NAME        "hdmid"
+
+#define HDMI_EVT_CONNECTED      "hdmi_connected"
+#define HDMI_EVT_DISCONNECTED   "hdmi_disconnected"
+#define HDMI_EVT_AUDIO_ON       "hdmi_audio_on"
+#define HDMI_EVT_AUDIO_OFF      "hdmi_audio_off"
+
+#define HDMI_CMD_ENABLE_HDMI    "enable_hdmi"
+#define HDMI_CMD_DISABLE_HDMI   "disable_hdmi"
+#define HDMI_CMD_CHANGE_MODE    "change_mode: "
+#define HDMI_CMD_SET_ASWIDTH    "set_aswidth: "
+#define HDMI_CMD_SET_ASHEIGHT   "set_asheight: "
+#define HDMI_CMD_HPDOPTION      "hdmi_hpd: "
+
+#define SYSFS_CONNECTED         DEVICE_ROOT "/" DEVICE_NODE "/connected"
+#define SYSFS_EDID_MODES        DEVICE_ROOT "/" DEVICE_NODE "/edid_modes"
+#define SYSFS_HPD               DEVICE_ROOT "/" DEVICE_NODE "/hpd"
+#define SYSFS_HDCP_PRESENT      DEVICE_ROOT "/" DEVICE_NODE "/hdcp_present"
+#define SYSFS_HDMI_MODE         DEVICE_ROOT "/" DEVICE_NODE "/hdmi_mode"
+
+#ifdef QCOM_HARDWARE
+//Should match to the external_display_type HDMI in QComUI
+#define EXT_DISPLAY_HDMI        1
+#endif
+
+HDMIDaemon::HDMIDaemon() : Thread(false),
+           mFrameworkSock(-1), mAcceptedConnection(-1), mUeventSock(-1),
+           mHDMIUeventQueueHead(NULL), fd1(-1), mCurrentID(-1), mNxtMode(-1)
+{
+}
+
+HDMIDaemon::~HDMIDaemon() {
+    HDMIUeventQueue* tmp = mHDMIUeventQueueHead, *tmp1;
+    while (tmp != NULL) {
+        tmp1 = tmp;
+        tmp = tmp->next;
+        delete tmp1;
+    }
+    mHDMIUeventQueueHead = NULL;
+    if (fd1 > 0)
+        close(fd1);
+}
+
+void HDMIDaemon::onFirstRef() {
+    run("HDMIDaemon", PRIORITY_AUDIO);
+}
+
+void HDMIDaemon::binderDied(const wp<IBinder>& who)
+{
+    requestExit();
+}
+
+status_t HDMIDaemon::readyToRun() {
+
+    if ((mFrameworkSock = android_get_control_socket(HDMI_SOCKET_NAME)) < 0) {
+        LOGE("Obtaining file descriptor socket '%s' failed: %s",
+             HDMI_SOCKET_NAME, strerror(errno));
+        return -1;
+    }
+
+    if (listen(mFrameworkSock, 4) < 0) {
+        LOGE("Unable to listen on fd '%d' for socket '%s': %s",
+             mFrameworkSock, HDMI_SOCKET_NAME, strerror(errno));
+        return -1;
+    }
+
+    struct sockaddr_nl nladdr;
+    memset(&nladdr, 0, sizeof(nladdr));
+    nladdr.nl_family = AF_NETLINK;
+    nladdr.nl_pid = getpid();
+    nladdr.nl_groups = 0xffffffff;
+
+    if ((mUeventSock = socket(PF_NETLINK,
+                             SOCK_DGRAM,NETLINK_KOBJECT_UEVENT)) < 0) {
+        LOGE("Unable to create uevent socket: %s", strerror(errno));
+        return -1;
+    }
+
+    int uevent_sz = 64 * 1024;
+    if (setsockopt(mUeventSock, SOL_SOCKET, SO_RCVBUF, &uevent_sz,
+                   sizeof(uevent_sz)) < 0) {
+        LOGE("Unable to set uevent socket options: %s", strerror(errno));
+        return -1;
+    }
+
+    if (bind(mUeventSock, (struct sockaddr *) &nladdr, sizeof(nladdr)) < 0) {
+        LOGE("Unable to bind uevent socket: %s", strerror(errno));
+        return -1;
+    }
+
+    LOGD("readyToRun: success");
+
+    return NO_ERROR;
+}
+
+bool HDMIDaemon::threadLoop()
+{
+    int max = -1;
+    fd_set read_fds;
+    FD_ZERO(&read_fds);
+
+    FD_SET(mFrameworkSock, &read_fds);
+    if (max < mFrameworkSock)
+        max = mFrameworkSock;
+    FD_SET(mUeventSock, &read_fds);
+    if (max < mUeventSock)
+        max = mUeventSock;
+
+    if (mAcceptedConnection != -1) {
+        FD_SET(mAcceptedConnection, &read_fds);
+        if (max < mAcceptedConnection)
+            max = mAcceptedConnection;
+    }
+
+    struct timeval to;
+    to.tv_sec = (60 * 60);
+    to.tv_usec = 0;
+
+    int ret;
+    if ((ret = select(max + 1, &read_fds, NULL, NULL, &to)) < 0) {
+        LOGE("select() failed (%s)", strerror(errno));
+        sleep(1);
+        return true;
+    }
+
+    if (!ret) {
+        return true;
+    }
+
+    if (mAcceptedConnection != -1 && FD_ISSET(mAcceptedConnection, &read_fds)) {
+        if (processFrameworkCommand() == -1)
+            mAcceptedConnection = -1;
+    }
+
+    if (FD_ISSET(mFrameworkSock, &read_fds)) {
+        struct sockaddr addr;
+        socklen_t alen;
+        alen = sizeof(addr);
+
+        if (mAcceptedConnection != -1) {
+            close(mAcceptedConnection);
+            mAcceptedConnection = accept(mFrameworkSock, &addr, &alen);
+            return true;
+        }
+
+        if ((mAcceptedConnection = accept(mFrameworkSock, &addr, &alen)) < 0) {
+            LOGE("Unable to accept framework connection (%s)",
+                strerror(errno));
+        }
+        else {
+            processUeventQueue();
+
+            if (!mDriverOnline) {
+                LOGE("threadLoop: driver not online; use state-file");
+                sendCommandToFramework(action_offline);
+            }
+        }
+
+        LOGD("threadLoop: Accepted connection from framework");
+    }
+
+    if (FD_ISSET(mUeventSock, &read_fds)) {
+        if (mAcceptedConnection == -1)
+            queueUevent();
+        else
+            processUevent();
+    }
+
+    return true;
+}
+
+bool HDMIDaemon::isHDCPPresent() {
+    char present = '0';
+    //Open the hdcp file - to know if HDCP is supported
+    int hdcpFile = open(SYSFS_HDCP_PRESENT, O_RDONLY, 0);
+    if (hdcpFile < 0) {
+        LOGE("%s: hdcp_present file '%s' not found", __func__, SYSFS_HDCP_PRESENT);
+    } else {
+        //Read from the hdcp_present file
+        int r = read(hdcpFile, &present, 1);
+        if (r <= 0) {
+            LOGE("%s: hdcp_present file empty '%s'", __func__, SYSFS_HDCP_PRESENT);
+        }
+    }
+    close(hdcpFile);
+    return (present == '1') ? true : false;
+}
+
+bool HDMIDaemon::isHDMIMode() {
+    bool ret = false;
+    char mode = '0';
+    int modeFile = open (SYSFS_HDMI_MODE, O_RDONLY, 0);
+    if(modeFile < 0) {
+        LOGE("%s:hdmi_mode_file '%s' not found", __func__, SYSFS_HDMI_MODE);
+    } else {
+        //Read from the hdmi_mode file
+        int r = read(modeFile, &mode, 1);
+        if (r <= 0) {
+            LOGE("%s: hdmi_mode file empty '%s'", __func__, SYSFS_HDMI_MODE);
+        }
+    }
+    close(modeFile);
+    return (mode == '1') ? true : false;
+}
+
+void HDMIDaemon::enableAudio() {
+    sp<IServiceManager> sm = defaultServiceManager();
+    sp<IAudioPolicyService> binder;
+    binder = interface_cast<IAudioPolicyService>(
+            sm->getService(String16("media.audio_policy")));
+    if(binder != 0) {
+        binder->setDeviceConnectionState(AUDIO_DEVICE_OUT_AUX_DIGITAL,
+            AUDIO_POLICY_DEVICE_STATE_AVAILABLE, "");
+    } else {
+        LOGE("%s: Failed to contact audio service", __FUNCTION__);
+    }
+}
+
+void HDMIDaemon::disableAudio() {
+    sp<IServiceManager> sm = defaultServiceManager();
+    sp<IAudioPolicyService> binder;
+    binder = interface_cast<IAudioPolicyService>(
+            sm->getService(String16("media.audio_policy")));
+    if(binder != 0) {
+        binder->setDeviceConnectionState(AUDIO_DEVICE_OUT_AUX_DIGITAL,
+            AUDIO_POLICY_DEVICE_STATE_UNAVAILABLE, "");
+    } else {
+        LOGE("%s: Failed to contact audio service", __FUNCTION__);
+    }
+}
+
+bool isAudioEnabled() {
+    sp<IServiceManager> sm = defaultServiceManager();
+    sp<IAudioPolicyService> binder;
+    binder = interface_cast<IAudioPolicyService>(
+            sm->getService(String16("media.audio_policy")));
+    if(binder != 0) {
+        if(binder->getDeviceConnectionState(AUDIO_DEVICE_OUT_AUX_DIGITAL, "")
+                == AUDIO_POLICY_DEVICE_STATE_AVAILABLE)
+            return true;
+    }
+    return false;
+}
+
+bool HDMIDaemon::cableConnected(bool defaultValue) const
+{
+    int hdmiStateFile = open(SYSFS_CONNECTED, O_RDONLY, 0);
+    if (hdmiStateFile < 0) {
+        LOGE("cableConnected: state file '%s' not found", SYSFS_CONNECTED);
+        return defaultValue;
+    } else {
+        char buf;
+        bool ret = defaultValue;
+        int err = read(hdmiStateFile, &buf, 1);
+        if (err <= 0) {
+            LOGE("cableConnected: empty state file '%s'", SYSFS_CONNECTED);
+        } else {
+            if (buf == '1') {
+                LOGD("cableConnected: %s indicates CONNECTED", SYSFS_CONNECTED);
+                ret = true;
+            } else {
+                LOGD("cableConnected: %s indicates DISCONNECTED", SYSFS_CONNECTED);
+                ret = false;
+            }
+        }
+        close(hdmiStateFile);
+        return ret;
+    }
+}
+
+bool HDMIDaemon::processUeventMessage(uevent& event)
+{
+    char buffer[64 * 1024];
+    int count;
+    char *s = buffer;
+    char *end;
+    int param_idx = 0;
+    int i;
+    bool first = true;
+
+    if ((count = recv(mUeventSock, buffer, sizeof(buffer), 0)) < 0) {
+        LOGE("Error receiving uevent (%s)", strerror(errno));
+        return false;
+    }
+
+    end = s + count;
+    while (s < end) {
+        if (first) {
+            char *p;
+            for (p = s; *p != '@'; p++);
+            p++;
+            if (!strcasestr(p, DEVICE_NODE)) {
+                return false;
+            }
+            LOGD("device uevent (%s)", buffer);
+            event.path = new char[strlen(p) + 1];
+            strcpy(event.path, p);
+            first = false;
+        } else {
+            if (!strncmp(s, "ACTION=", strlen("ACTION="))) {
+                char *a = s + strlen("ACTION=");
+
+                if (!strcmp(a, "add"))
+                    event.action = action_add;
+                else if (!strcmp(a, "change"))
+                    event.action = action_change;
+                else if (!strcmp(a, "remove"))
+                    event.action = action_remove;
+                else if (!strcmp(a, "online"))
+                    event.action = action_online;
+                else if (!strcmp(a, "offline"))
+                    event.action = action_offline;
+                else
+                    LOGD("%s: action (%s) unknown", __func__, a);
+            } else if (!strncmp(s, "SEQNUM=", strlen("SEQNUM="))) {
+                event.seqnum = atoi(s + strlen("SEQNUM="));
+            } else if (!strncmp(s, "SUBSYSTEM=", strlen("SUBSYSTEM="))) {
+                event.subsystem = new char[strlen(s + strlen("SUBSYSTEM=")) + 1];
+                strcpy(event.subsystem, (s + strlen("SUBSYSTEM=")));
+            } else if (!strncmp(s, "HDCP_STATE=", strlen("HDCP_STATE="))) {
+                if(!strcmp(s+strlen("HDCP_STATE="),"PASS")) {
+                    //Event HDCP_STATE=PASS, send Audio On.
+                    event.action = action_audio_on;
+                } else if(!strcmp(s+strlen("HDCP_STATE="), "FAIL")) {
+                    //Event HDCP_STATE=FAIL, send Audio Off
+                    event.action = action_audio_off;
+                }
+            } else {
+                event.param[param_idx] = new char[strlen(s) + 1];
+                strcpy(event.param[param_idx], s);
+                param_idx++;
+            }
+        }
+        s += strlen(s) + 1;
+    }
+    return true;
+}
+
+void HDMIDaemon::queueUevent()
+{
+    HDMIUeventQueue* tmp = mHDMIUeventQueueHead, *tmp1;
+    while (tmp != NULL && tmp->next != NULL)
+        tmp = tmp->next;
+    if (!tmp) {
+        tmp = new HDMIUeventQueue();
+        tmp->next = NULL;
+        if(!processUeventMessage(tmp->mEvent))
+            delete tmp;
+        else
+            mHDMIUeventQueueHead = tmp;
+    }
+    else {
+        tmp1 = new HDMIUeventQueue();
+        tmp1->next = NULL;
+        if(!processUeventMessage(tmp1->mEvent))
+            delete tmp1;
+        else
+            tmp->next = tmp1;
+    }
+}
+
+void HDMIDaemon::processUeventQueue()
+{
+    HDMIUeventQueue* tmp = mHDMIUeventQueueHead, *tmp1;
+    while (tmp != NULL) {
+        tmp1 = tmp;
+        if (tmp->mEvent.action) {
+            LOGD("processUeventQueue: event.action == %d", tmp->mEvent.action);
+            mDriverOnline = true;
+            sendCommandToFramework(tmp->mEvent.action);
+        }
+        tmp = tmp->next;
+        delete tmp1;
+    }
+    mHDMIUeventQueueHead = NULL;
+}
+
+void HDMIDaemon::processUevent()
+{
+    uevent event;
+    if(processUeventMessage(event)) {
+        if (event.action) {
+            LOGD("processUevent: event.action == %d", event.action);
+            mDriverOnline = true;
+            sendCommandToFramework(event.action);
+        }
+    }
+}
+
+struct disp_mode_timing_type {
+    int  video_format;
+
+    int  active_h;
+    int  active_v;
+
+    int  front_porch_h;
+    int  pulse_width_h;
+    int  back_porch_h;
+
+    int  front_porch_v;
+    int  pulse_width_v;
+    int  back_porch_v;
+
+    int  pixel_freq;
+    bool interlaced;
+
+    void set_info(struct fb_var_screeninfo &info) const;
+};
+
+void disp_mode_timing_type::set_info(struct fb_var_screeninfo &info) const
+{
+    info.reserved[0] = 0;
+    info.reserved[1] = 0;
+    info.reserved[2] = 0;
+    info.reserved[3] = video_format;
+
+    info.xoffset = 0;
+    info.yoffset = 0;
+    info.xres = active_h;
+    info.yres = active_v;
+
+    info.pixclock = pixel_freq*1000;
+    info.vmode = interlaced ? FB_VMODE_INTERLACED : FB_VMODE_NONINTERLACED;
+
+    info.right_margin = front_porch_h;
+    info.hsync_len = pulse_width_h;
+    info.left_margin = back_porch_h;
+    info.lower_margin = front_porch_v;
+    info.vsync_len = pulse_width_v;
+    info.upper_margin = back_porch_v;
+}
+
+/* Video formates supported by the HDMI Standard */
+/* Indicates the resolution, pix clock and the aspect ratio */
+#define m640x480p60_4_3         1
+#define m720x480p60_4_3         2
+#define m720x480p60_16_9        3
+#define m1280x720p60_16_9       4
+#define m1920x1080i60_16_9      5
+#define m1440x480i60_4_3        6
+#define m1440x480i60_16_9       7
+#define m1920x1080p60_16_9      16
+#define m720x576p50_4_3         17
+#define m720x576p50_16_9        18
+#define m1280x720p50_16_9       19
+#define m1440x576i50_4_3        21
+#define m1440x576i50_16_9       22
+#define m1920x1080p50_16_9      31
+#define m1920x1080p24_16_9      32
+#define m1920x1080p25_16_9      33
+#define m1920x1080p30_16_9      34
+
+static struct disp_mode_timing_type supported_video_mode_lut[] = {
+    {m640x480p60_4_3,     640,  480,  16,  96,  48, 10, 2, 33,  25200, false},
+    {m720x480p60_4_3,     720,  480,  16,  62,  60,  9, 6, 30,  27030, false},
+    {m720x480p60_16_9,    720,  480,  16,  62,  60,  9, 6, 30,  27030, false},
+    {m1280x720p60_16_9,  1280,  720, 110,  40, 220,  5, 5, 20,  74250, false},
+    {m1920x1080i60_16_9, 1920,  540,  88,  44, 148,  2, 5,  5,  74250, false},
+    {m1440x480i60_4_3,   1440,  240,  38, 124, 114,  4, 3, 15,  27000, true},
+    {m1440x480i60_16_9,  1440,  240,  38, 124, 114,  4, 3, 15,  27000, true},
+    {m1920x1080p60_16_9, 1920, 1080,  88,  44, 148,  4, 5, 36, 148500, false},
+    {m720x576p50_4_3,     720,  576,  12,  64,  68,  5, 5, 39,  27000, false},
+    {m720x576p50_16_9,    720,  576,  12,  64,  68,  5, 5, 39,  27000, false},
+    {m1280x720p50_16_9,  1280,  720, 440,  40, 220,  5, 5, 20,  74250, false},
+    {m1440x576i50_4_3,   1440,  288,  24, 126, 138,  2, 3, 19,  27000, true},
+    {m1440x576i50_16_9,  1440,  288,  24, 126, 138,  2, 3, 19,  27000, true},
+    {m1920x1080p50_16_9, 1920, 1080, 528,  44, 148,  4, 5, 36, 148500, false},
+    {m1920x1080p24_16_9, 1920, 1080, 638,  44, 148,  4, 5, 36,  74250, false},
+    {m1920x1080p25_16_9, 1920, 1080, 528,  44, 148,  4, 5, 36,  74250, false},
+    {m1920x1080p30_16_9, 1920, 1080,  88,  44, 148,  4, 5, 36,  74250, false},
+};
+
+bool HDMIDaemon::readResolution()
+{
+    int hdmiEDIDFile = open(SYSFS_EDID_MODES, O_RDONLY, 0);
+
+    memset(mEDIDs, 0, sizeof(mEDIDs));
+    if (hdmiEDIDFile < 0) {
+        LOGE("%s: edid_modes file '%s' not found", __func__, SYSFS_EDID_MODES);
+        return false;
+    } else {
+        int r = read(hdmiEDIDFile, mEDIDs, sizeof(mEDIDs)-1);
+        if (r <= 0)
+            LOGE("%s: edid_modes file empty '%s'", __func__, SYSFS_EDID_MODES);
+        else {
+            while (r > 1 && isspace(mEDIDs[r-1]))
+                --r;
+            mEDIDs[r] = 0;
+        }
+    }
+    close(hdmiEDIDFile);
+
+    return (strlen(mEDIDs) > 0);
+}
+
+bool HDMIDaemon::openFramebuffer()
+{
+    if (fd1 == -1) {
+        fd1 = open("/dev/graphics/fb1", O_RDWR);
+        if (fd1 < 0)
+            LOGE("ERROR: /dev/graphics/fb1 not available\n");
+    }
+    return (fd1 > 0);
+}
+
+inline bool HDMIDaemon::isValidMode(int ID)
+{
+    return ((ID >= m640x480p60_4_3) && (ID <= m1920x1080p30_16_9));
+}
+
+void HDMIDaemon::setResolution(int ID)
+{
+    struct fb_var_screeninfo info;
+    if (!openFramebuffer())
+        return;
+#ifdef FORCE_AUTO_RESOLUTION
+    ID = 0;
+#endif
+    //If its a valid mode and its a new ID - update var_screeninfo
+    if ((isValidMode(ID)) && mCurrentID != ID) {
+        const struct disp_mode_timing_type *mode = &supported_video_mode_lut[0];
+        for (unsigned int i = 0; i < sizeof(supported_video_mode_lut)/sizeof(*supported_video_mode_lut); ++i) {
+            const struct disp_mode_timing_type *cur = &supported_video_mode_lut[i];
+            if (cur->video_format == ID)
+                mode = cur;
+        }
+#ifdef QCOM_HARDWARE
+        SurfaceComposerClient::enableExternalDisplay(EXT_DISPLAY_HDMI, 0);
+#else
+        SurfaceComposerClient::enableHDMIOutput(0);
+#endif
+        ioctl(fd1, FBIOGET_VSCREENINFO, &info);
+        LOGD("GET Info<ID=%d %dx%d (%d,%d,%d), (%d,%d,%d) %dMHz>",
+            info.reserved[3], info.xres, info.yres,
+            info.right_margin, info.hsync_len, info.left_margin,
+            info.lower_margin, info.vsync_len, info.upper_margin,
+            info.pixclock/1000/1000);
+            mode->set_info(info);
+        LOGD("SET Info<ID=%d => Info<ID=%d %dx%d (%d,%d,%d), (%d,%d,%d) %dMHz>", ID,
+            info.reserved[3], info.xres, info.yres,
+            info.right_margin, info.hsync_len, info.left_margin,
+            info.lower_margin, info.vsync_len, info.upper_margin,
+            info.pixclock/1000/1000);
+        info.activate = FB_ACTIVATE_NOW | FB_ACTIVATE_ALL | FB_ACTIVATE_FORCE;
+        ioctl(fd1, FBIOPUT_VSCREENINFO, &info);
+        mCurrentID = ID;
+    }
+    //Powerup
+    ioctl(fd1, FBIOBLANK, FB_BLANK_UNBLANK);
+    ioctl(fd1, FBIOGET_VSCREENINFO, &info);
+    //Pan_Display
+    ioctl(fd1, FBIOPAN_DISPLAY, &info);
+    property_set("hw.hdmiON", "1");
+    //Inform SF about HDMI
+#ifdef QCOM_HARDWARE
+    SurfaceComposerClient::enableExternalDisplay(EXT_DISPLAY_HDMI, 1);
+#else
+    SurfaceComposerClient::enableHDMIOutput(1);
+#endif
+}
+
+int HDMIDaemon::processFrameworkCommand()
+{
+    char buffer[128];
+    int ret;
+
+    if ((ret = read(mAcceptedConnection, buffer, sizeof(buffer) -1)) < 0) {
+        LOGE("Unable to read framework command (%s)", strerror(errno));
+        return -1;
+    }
+    else if (!ret)
+        return -1;
+
+    buffer[ret] = 0;
+#ifdef QCOM_HARDWARE
+    char actionsafe[PROPERTY_VALUE_MAX];
+#endif
+    if (!strcmp(buffer, HDMI_CMD_ENABLE_HDMI)) {
+        if (!openFramebuffer())
+            return -1;
+        LOGD(HDMI_CMD_ENABLE_HDMI);
+        if(mNxtMode != -1) {
+            LOGD("processFrameworkCommand: setResolution with =%d", mNxtMode);
+            if(isAudioEnabled()) {
+                //If Audio is enabled, turn it off because setResolution() will
+                //call power off. Also treat the following as a single
+                //transaction
+                disableAudio();
+                setResolution(mNxtMode);
+                enableAudio();
+            } else {
+                setResolution(mNxtMode);
+            }
+        }
+    } else if (!strcmp(buffer, HDMI_CMD_DISABLE_HDMI)) {
+        LOGD(HDMI_CMD_DISABLE_HDMI);
+
+        if (!openFramebuffer())
+            return -1;
+        property_set("hw.hdmiON", "0");
+#ifdef QCOM_HARDWARE
+        SurfaceComposerClient::enableExternalDisplay(EXT_DISPLAY_HDMI, 0);
+#else
+        SurfaceComposerClient::enableHDMIOutput(0);
+#endif
+        close(fd1);
+        fd1 = -1;
+    } else if (!strncmp(buffer, HDMI_CMD_SET_ASWIDTH, strlen(HDMI_CMD_SET_ASWIDTH))) {
+        float asWidthRatio;
+        int ret = sscanf(buffer, HDMI_CMD_SET_ASWIDTH "%f", &asWidthRatio);
+        if(ret==1) {
+#ifdef QCOM_HARDWARE
+            sprintf(actionsafe, "%0.2f", asWidthRatio);
+            property_set("hw.actionsafe.width", actionsafe);
+#else
+            SurfaceComposerClient::setActionSafeWidthRatio(asWidthRatio);
+#endif
+        }
+    } else if (!strncmp(buffer, HDMI_CMD_SET_ASHEIGHT, strlen(HDMI_CMD_SET_ASHEIGHT))) {
+        float asHeightRatio;
+        int ret = sscanf(buffer, HDMI_CMD_SET_ASHEIGHT "%f", &asHeightRatio);
+        if(ret==1) {
+#ifdef QCOM_HARDWARE
+            sprintf(actionsafe, "%0.2f", asHeightRatio);
+            property_set("hw.actionsafe.height", actionsafe);
+#else
+            SurfaceComposerClient::setActionSafeHeightRatio(asHeightRatio);
+#endif
+        }
+    } else if (!strncmp(buffer, HDMI_CMD_HPDOPTION, strlen(HDMI_CMD_HPDOPTION))) {
+        int option;
+        int ret = sscanf(buffer, HDMI_CMD_HPDOPTION "%d", &option);
+        if (ret == 1) {
+            LOGD(HDMI_CMD_HPDOPTION ": %d", option);
+            writeHPDOption(option);
+        }
+    } else {
+        int mode;
+        int ret = sscanf(buffer, HDMI_CMD_CHANGE_MODE "%d", &mode);
+        if (ret == 1) {
+            LOGD(HDMI_CMD_CHANGE_MODE);
+            /* To change the resolution */
+            char prop_val[PROPERTY_VALUE_MAX];
+            property_get("enable.hdmi.edid", prop_val, "0");
+            int val = atoi(prop_val);
+            if(val == 1) {
+                 /* Based on the hw.yRes set the resolution */
+                 char property_value[PROPERTY_VALUE_MAX];
+                 property_get("hdmi.yRes", property_value, "0");
+                 int yres = atoi(property_value);
+                 switch(yres){
+                 case 480:
+                     mode = 3;
+                     break;
+                 case 720:
+                    mode = 4;
+                    break;
+                 case 1080:
+                    mode = 16;
+                    break;
+                default:
+                    break;
+                 }
+            }
+            // If we have a valid fd1 - setresolution
+            if(fd1 > 0) {
+                if(isAudioEnabled()) {
+                    // Disable audio before changing resolution, since that calls
+                    // a poweroff, which could time out audio output.
+                    disableAudio();
+                    setResolution(mode);
+                    // Enable audio once we are done with resolution change.
+                    enableAudio();
+                } else {
+                    setResolution(mode);
+                }
+            } else {
+            // Store the mode
+                mNxtMode = mode;
+            }
+        }
+    }
+
+    return 0;
+}
+
+bool HDMIDaemon::sendCommandToFramework(uevent_action action)
+{
+    char message[512];
+
+    switch (action)
+    {
+    case action_offline:
+        strncpy(message, HDMI_EVT_DISCONNECTED, sizeof(message));
+        break;
+    case action_online:
+        readResolution();
+        snprintf(message, sizeof(message), "%s: %s", HDMI_EVT_CONNECTED, mEDIDs);
+        break;
+    case action_audio_on:
+    case action_audio_off:
+        return true;
+    default:
+        LOGE("sendCommandToFramework: Unknown event received");
+        return false;
+    }
+    int result = write(mAcceptedConnection, message, strlen(message) + 1);
+    LOGD("sendCommandToFramework: '%s' %s", message, result >= 0 ? "successful" : "failed");
+    return result >= 0;
+}
+
+bool HDMIDaemon::writeHPDOption(int userOption) const
+{
+    bool ret = true;
+    int hdmiHPDFile = open(SYSFS_HPD,O_RDWR, 0);
+    if (hdmiHPDFile < 0) {
+        LOGE("writeHPDOption: state file '%s' not found", SYSFS_HPD);
+        ret = false;
+    } else {
+        int err = -1;
+        if(userOption)
+            err = write(hdmiHPDFile, "1", 2);
+        else
+            err = write(hdmiHPDFile, "0" , 2);
+        if (err <= 0) {
+            LOGE("writeHPDOption: file write failed '%s'", SYSFS_HPD);
+            ret = false;
+        }
+        close(hdmiHPDFile);
+    }
+    return ret;
+}
+
+
+// ---------------------------------------------------------------------------
+
+}
+; // namespace android
diff --git a/cmds/hdmid/HDMIDaemon.h b/cmds/hdmid/HDMIDaemon.h
new file mode 100644
index 0000000..a234ea0
--- /dev/null
+++ b/cmds/hdmid/HDMIDaemon.h
@@ -0,0 +1,129 @@
+/*
+ * Copyright (C) 2007 The Android Open Source Project
+ * Copyright (c) 2010-2012, Code Aurora Forum. All rights reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef ANDROID_HDMISERVICE_H
+#define ANDROID_HDMISERVICE_H
+
+#include <stdint.h>
+#include <sys/types.h>
+
+#include <utils/threads.h>
+#include <utils/AssetManager.h>
+
+#include <surfaceflinger/ISurfaceComposer.h>
+#include <surfaceflinger/SurfaceComposerClient.h>
+#include <errno.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include <string.h>
+#include <fcntl.h>
+#include <pthread.h>
+
+#include <sys/socket.h>
+#include <sys/select.h>
+#include <sys/time.h>
+#include <sys/types.h>
+#include <sys/un.h>
+
+#include <cutils/config_utils.h>
+#include <cutils/cpu_info.h>
+#include <cutils/properties.h>
+#include <cutils/sockets.h>
+
+#include <linux/netlink.h>
+
+#include <private/android_filesystem_config.h>
+
+
+namespace android {
+
+enum uevent_action { action_add, action_remove, action_change,
+                                  action_online, action_offline, action_audio_on, action_audio_off };
+const int ueventParamMax = 32;
+struct uevent {
+    char *path;
+    enum uevent_action action;
+    char *subsystem;
+    char *param[ueventParamMax];
+    unsigned int seqnum;
+    uevent() : path(NULL), subsystem(NULL) {
+	for (int i = 0; i < ueventParamMax; i++)
+	    param[i] = NULL;
+    }
+};
+
+struct HDMIUeventQueue {
+    HDMIUeventQueue* next;
+    uevent mEvent;
+    ~HDMIUeventQueue() {
+        delete[] mEvent.path;
+        delete[] mEvent.subsystem;
+        for (int i = 0; i < ueventParamMax; i++) {
+            if (!mEvent.param[i])
+                break;
+            delete[] mEvent.param[i];
+        }
+    }
+};
+
+class HDMIDaemon : public Thread, public IBinder::DeathRecipient
+{
+    /*Overrides*/
+    virtual bool        threadLoop();
+    virtual status_t    readyToRun();
+    virtual void        onFirstRef();
+    virtual void        binderDied(const wp<IBinder>& who);
+
+    bool processUeventMessage(uevent& event);
+    void queueUevent();
+    void processUeventQueue();
+    void processUevent();
+    int processFrameworkCommand();
+    bool sendCommandToFramework(uevent_action action = action_offline);
+    bool cableConnected(bool defaultValue = true) const;
+    bool readResolution();
+    void setResolution(int ID);
+    bool openFramebuffer();
+    bool writeHPDOption(int userOption) const;
+    bool isValidMode(int ID);
+
+    static bool isHDCPPresent();
+    static bool isHDMIMode();
+    static void enableAudio();
+    static void disableAudio();
+
+    int mFrameworkSock;
+    int mAcceptedConnection;
+    int mUeventSock;
+    HDMIUeventQueue* mHDMIUeventQueueHead;
+    int fd1;
+    bool mDriverOnline;
+    int mCurrentID;
+    int mNxtMode;
+    char mEDIDs[128];
+
+public:
+    HDMIDaemon();
+    virtual ~HDMIDaemon();
+};
+
+// ---------------------------------------------------------------------------
+
+}; // namespace android
+
+#endif
diff --git a/cmds/hdmid/hdmid_main.cpp b/cmds/hdmid/hdmid_main.cpp
new file mode 100644
index 0000000..b47f2a5
--- /dev/null
+++ b/cmds/hdmid/hdmid_main.cpp
@@ -0,0 +1,52 @@
+/*
+ * Copyright (C) 2007 The Android Open Source Project
+ * Copyright (c) 2010, Code Aurora Forum. All rights reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#define LOG_TAG "HDMIDaemon"
+
+#include <cutils/properties.h>
+
+#include <binder/IPCThreadState.h>
+#include <binder/ProcessState.h>
+#include <binder/IServiceManager.h>
+
+#include <utils/Log.h>
+#include <utils/threads.h>
+
+#if defined(HAVE_PTHREADS)
+# include <pthread.h>
+# include <sys/resource.h>
+#endif
+
+#include "HDMIDaemon.h"
+
+using namespace android;
+
+// ---------------------------------------------------------------------------
+
+int main(int argc, char** argv)
+{
+#if defined(HAVE_PTHREADS)
+    setpriority(PRIO_PROCESS, 0, ANDROID_PRIORITY_AUDIO);
+#endif
+
+    sp<ProcessState> proc(ProcessState::self());
+    ProcessState::self()->startThreadPool();
+    sp<HDMIDaemon> hdmiService = new HDMIDaemon();
+    IPCThreadState::self()->joinThreadPool();
+
+    return 0;
+}
diff --git a/cmds/installd/commands.c b/cmds/installd/commands.c
index 4ede33f..11c8605 100644
--- a/cmds/installd/commands.c
+++ b/cmds/installd/commands.c
@@ -19,6 +19,7 @@
 
 /* Directory records that are used in execution of commands. */
 dir_rec_t android_data_dir;
+dir_rec_t android_datadata_dir;
 dir_rec_t android_asec_dir;
 dir_rec_t android_app_dir;
 dir_rec_t android_app_private_dir;
@@ -162,7 +163,11 @@ int delete_cache(const char *pkgname)
 static int64_t disk_free()
 {
     struct statfs sfs;
-    if (statfs(android_data_dir.path, &sfs) == 0) {
+    /* Scanning /data/data because on some devices, it's on a different partition
+     * and scanning /data will yield the incorrect result. (This function is only
+     * used for freeing space on /data/data so it is okay to be more specific.)
+     */
+    if (statfs(android_datadata_dir.path, &sfs) == 0) {
         return sfs.f_bavail * sfs.f_bsize;
     } else {
         LOGE("Couldn't statfs %s: %s\n", android_data_dir.path, strerror(errno));
@@ -397,6 +402,7 @@ int create_cache_path(char path[PKG_PATH_MAX], const char *src)
     char *tmp;
     int srclen;
     int dstlen;
+    char dexopt_data_only[PROPERTY_VALUE_MAX];
 
     srclen = strlen(src);
 
@@ -409,7 +415,15 @@ int create_cache_path(char path[PKG_PATH_MAX], const char *src)
         return -1;
     }
 
-    dstlen = srclen + strlen(DALVIK_CACHE_PREFIX) + 
+    const char *cache_path = DALVIK_CACHE_PREFIX;
+    if (!strncmp(src, "/system", 7)) {
+        property_get("dalvik.vm.dexopt-data-only", dexopt_data_only, "");
+        if (strcmp(dexopt_data_only, "1") != 0) {
+            cache_path = DALVIK_SYSTEM_CACHE_PREFIX;
+        }
+    }
+
+    dstlen = srclen + strlen(cache_path) + 
         strlen(DALVIK_CACHE_POSTFIX) + 1;
     
     if (dstlen > PKG_PATH_MAX) {
@@ -417,11 +431,11 @@ int create_cache_path(char path[PKG_PATH_MAX], const char *src)
     }
 
     sprintf(path,"%s%s%s",
-            DALVIK_CACHE_PREFIX,
+            cache_path,
             src + 1, /* skip the leading / */
             DALVIK_CACHE_POSTFIX);
     
-    for(tmp = path + strlen(DALVIK_CACHE_PREFIX); *tmp; tmp++) {
+    for(tmp = path + strlen(cache_path); *tmp; tmp++) {
         if (*tmp == '/') {
             *tmp = '@';
         }
diff --git a/cmds/installd/installd.c b/cmds/installd/installd.c
index feb6b92..9beee90 100644
--- a/cmds/installd/installd.c
+++ b/cmds/installd/installd.c
@@ -270,6 +270,11 @@ int initialize_globals() {
         return -1;
     }
 
+    // Get the android datadata directory.
+    if (copy_and_append(&android_datadata_dir, &android_data_dir, DATA_SUBDIR) < 0) {
+        return -1;
+    }
+
     // Get the android app directory.
     if (copy_and_append(&android_app_dir, &android_data_dir, APP_SUBDIR) < 0) {
         return -1;
diff --git a/cmds/installd/installd.h b/cmds/installd/installd.h
index 173cabf..78a8e0c 100644
--- a/cmds/installd/installd.h
+++ b/cmds/installd/installd.h
@@ -58,6 +58,7 @@
 
 #define CACHE_DIR_POSTFIX      "/cache"
 
+#define DATA_SUBDIR             "data/" // sub-directory under ANDROID_DATA
 #define APP_SUBDIR             "app/" // sub-directory under ANDROID_DATA
 
 /* other handy constants */
@@ -65,6 +66,7 @@
 #define PRIVATE_APP_SUBDIR     "app-private/" // sub-directory under ANDROID_DATA
 
 #define DALVIK_CACHE_PREFIX    "/data/dalvik-cache/"
+#define DALVIK_SYSTEM_CACHE_PREFIX "/cache/dalvik-cache/"
 #define DALVIK_CACHE_POSTFIX   "/classes.dex"
 
 #define UPDATE_COMMANDS_DIR_PREFIX  "/system/etc/updatecmds/"
@@ -87,6 +89,7 @@ typedef struct {
 extern dir_rec_t android_app_dir;
 extern dir_rec_t android_app_private_dir;
 extern dir_rec_t android_data_dir;
+extern dir_rec_t android_datadata_dir;
 extern dir_rec_t android_asec_dir;
 extern dir_rec_array_t android_system_dirs;
 
diff --git a/cmds/servicemanager/Android.mk b/cmds/servicemanager/Android.mk
index ea80c7d..11916a7 100644
--- a/cmds/servicemanager/Android.mk
+++ b/cmds/servicemanager/Android.mk
@@ -12,4 +12,10 @@ LOCAL_MODULE := servicemanager
 ifeq ($(BOARD_USE_LVMX),true)
     LOCAL_CFLAGS += -DLVMX
 endif
+ifeq ($(BOARD_USE_YAMAHAPLAYER),true)
+    LOCAL_CFLAGS += -DYAMAHAPLAYER
+endif
+ifeq ($(BOARD_USE_SECTVOUT),true)
+    LOCAL_CFLAGS += -DSECTVOUT
+endif
 include $(BUILD_EXECUTABLE)
diff --git a/cmds/servicemanager/service_manager.c b/cmds/servicemanager/service_manager.c
index 2df450f..1bd21a6 100644
--- a/cmds/servicemanager/service_manager.c
+++ b/cmds/servicemanager/service_manager.c
@@ -34,6 +34,13 @@ static struct {
     { AID_MEDIA, "media.player" },
     { AID_MEDIA, "media.camera" },
     { AID_MEDIA, "media.audio_policy" },
+#ifdef YAMAHAPLAYER
+    { AID_MEDIA, "media.yamahaplayer" },
+#endif
+    { AID_MEDIA, "media.nvidia.audio_alsa" },
+#ifdef SECTVOUT
+    { AID_MEDIA, "SecTVOutService" },
+#endif
     { AID_DRM,   "drm.drmManager" },
     { AID_NFC,   "nfc" },
     { AID_RADIO, "radio.phone" },
diff --git a/cmds/stagefright/Android.mk b/cmds/stagefright/Android.mk
index e9642f7..8c0561b 100644
--- a/cmds/stagefright/Android.mk
+++ b/cmds/stagefright/Android.mk
@@ -15,13 +15,17 @@ LOCAL_C_INCLUDES:= \
 	frameworks/base/media/libstagefright \
 	frameworks/base/media/libstagefright/include \
 	$(TOP)/frameworks/base/include/media/stagefright/openmax \
-        external/skia/include/core \
-        external/skia/include/images \
+	external/skia/include/core \
+	external/skia/include/images \
 
 LOCAL_CFLAGS += -Wno-multichar
 
 LOCAL_MODULE_TAGS := debug
 
+ifeq ($(BOARD_USES_QCOM_HARDWARE),true)
+	LOCAL_C_INCLUDES += $(TOP)/vendor/qcom/opensource/omx/mm-core/omxcore/inc
+endif
+
 LOCAL_MODULE:= stagefright
 
 include $(BUILD_EXECUTABLE)
@@ -70,6 +74,10 @@ LOCAL_CFLAGS += -Wno-multichar
 
 LOCAL_MODULE_TAGS := debug
 
+ifeq ($(BOARD_USES_QCOM_HARDWARE),true)
+	LOCAL_C_INCLUDES += $(TOP)/vendor/qcom/opensource/omx/mm-core/omxcore/inc
+endif
+
 LOCAL_MODULE:= recordvideo
 
 include $(BUILD_EXECUTABLE)
@@ -119,6 +127,10 @@ LOCAL_CFLAGS += -Wno-multichar
 
 LOCAL_MODULE_TAGS := debug
 
+ifeq ($(BOARD_USES_QCOM_HARDWARE),true)
+	LOCAL_C_INCLUDES += $(TOP)/vendor/qcom/opensource/omx/mm-core/omxcore/inc
+endif
+
 LOCAL_MODULE:= stream
 
 include $(BUILD_EXECUTABLE)
@@ -143,6 +155,10 @@ LOCAL_CFLAGS += -Wno-multichar
 
 LOCAL_MODULE_TAGS := debug
 
+ifeq ($(BOARD_USES_QCOM_HARDWARE),true)
+	LOCAL_C_INCLUDES += $(TOP)/vendor/qcom/opensource/omx/mm-core/omxcore/inc
+endif
+
 LOCAL_MODULE:= sf2
 
 include $(BUILD_EXECUTABLE)
diff --git a/cmds/stagefright/recordvideo.cpp b/cmds/stagefright/recordvideo.cpp
index c402286..8e07f1f 100644
--- a/cmds/stagefright/recordvideo.cpp
+++ b/cmds/stagefright/recordvideo.cpp
@@ -26,6 +26,9 @@
 #include <media/stagefright/OMXClient.h>
 #include <media/stagefright/OMXCodec.h>
 #include <media/MediaPlayerInterface.h>
+#ifdef QCOM_HARDWARE
+#include <OMX_QCOMExtns.h>
+#endif
 
 using namespace android;
 
diff --git a/cmds/surfaceflinger/Android.mk b/cmds/surfaceflinger/Android.mk
index 1df32bb..56606fc 100644
--- a/cmds/surfaceflinger/Android.mk
+++ b/cmds/surfaceflinger/Android.mk
@@ -12,6 +12,10 @@ LOCAL_SHARED_LIBRARIES := \
 LOCAL_C_INCLUDES := \
 	$(LOCAL_PATH)/../../services/surfaceflinger
 
+ifeq ($(BOARD_USES_QCOM_HARDWARE),true)
+LOCAL_C_INCLUDES +=  hardware/qcom/display/libqcomui
+endif
+
 LOCAL_MODULE:= surfaceflinger
 
 include $(BUILD_EXECUTABLE)
diff --git a/cmds/system_server/library/Android.mk b/cmds/system_server/library/Android.mk
index e8afce3..0596e89 100644
--- a/cmds/system_server/library/Android.mk
+++ b/cmds/system_server/library/Android.mk
@@ -14,6 +14,10 @@ LOCAL_C_INCLUDES := \
 	$(base)/media/libmediaplayerservice \
 	$(JNI_H_INCLUDE)
 
+ifeq ($(BOARD_USES_QCOM_HARDWARE),true)
+LOCAL_C_INCLUDES +=  hardware/qcom/display/libqcomui
+endif
+
 LOCAL_SHARED_LIBRARIES := \
 	libandroid_runtime \
 	libsensorservice \
diff --git a/core/java/android/app/ActivityManager.java b/core/java/android/app/ActivityManager.java
index 4fe9cef..0f20809 100644
--- a/core/java/android/app/ActivityManager.java
+++ b/core/java/android/app/ActivityManager.java
@@ -1,5 +1,6 @@
 /*
  * Copyright (C) 2007 The Android Open Source Project
+ * This code has been modified.  Portions copyright (C) 2010, T-Mobile USA, Inc.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -212,26 +213,33 @@ public class ActivityManager {
     /**
      * Used by persistent processes to determine if they are running on a
      * higher-end device so should be okay using hardware drawing acceleration
-     * (which tends to consume a lot more RAM).
+     * (which tends to consume a lot more RAM). Alternatively, setting
+     * ro.config.disable_hw_accel=true disables hardware acceleration even if the
+     * device meets the other criteria since not all devices currently have
+     * the ability to support it.
      * @hide
      */
     static public boolean isHighEndGfx(Display display) {
-        MemInfoReader reader = new MemInfoReader();
-        reader.readMemInfo();
-        if (reader.getTotalSize() >= (512*1024*1024)) {
-            // If the device has at least 512MB RAM available to the kernel,
-            // we can afford the overhead of graphics acceleration.
-            return true;
-        }
-        Point p = new Point();
-        display.getRealSize(p);
-        int pixels = p.x * p.y;
-        if (pixels >= (1024*600)) {
-            // If this is a sufficiently large screen, then there are enough
-            // pixels on it that we'd really like to use hw drawing.
-            return true;
+        if (SystemProperties.get("ro.config.disable_hw_accel").equals("true")) {
+            return false;
+        } else {
+            MemInfoReader reader = new MemInfoReader();
+            reader.readMemInfo();
+            if (reader.getTotalSize() >= (512*1024*1024)) {
+                // If the device has at least 512MB RAM available to the kernel,
+                // we can afford the overhead of graphics acceleration.
+                return true;
+            }
+            Point p = new Point();
+            display.getRealSize(p);
+            int pixels = p.x * p.y;
+            if (pixels >= (1024*600)) {
+                // If this is a sufficiently large screen, then there are enough
+                // pixels on it that we'd really like to use hw drawing.
+                return true;
+            }
+            return false;
         }
-        return false;
     }
 
     /**
@@ -1541,6 +1549,16 @@ public class ActivityManager {
             return new HashMap<String, Integer>();
         }
     }
+    /**
+     * @hide
+     */
+    public Configuration getConfiguration() {
+        try {
+            return ActivityManagerNative.getDefault().getConfiguration();
+        } catch (RemoteException e) {
+            return null;
+        }
+    }
 
     /**
      * Returns the usage statistics of each installed package.
@@ -1572,4 +1590,16 @@ public class ActivityManager {
         }
     }
 
+    /**
+     * @throws SecurityException Throws SecurityException if the caller does
+     * not hold the {@link android.Manifest.permission#CHANGE_CONFIGURATION} permission.
+     *
+     * @hide
+     */
+    public void updateConfiguration(Configuration values) throws SecurityException {
+        try {
+            ActivityManagerNative.getDefault().updateConfiguration(values);
+        } catch (RemoteException e) {
+        }
+    }
 }
diff --git a/core/java/android/app/ActivityThread.java b/core/java/android/app/ActivityThread.java
index 0c761fc..9901df9 100644
--- a/core/java/android/app/ActivityThread.java
+++ b/core/java/android/app/ActivityThread.java
@@ -1,5 +1,6 @@
 /*
  * Copyright (C) 2006 The Android Open Source Project
+ * This code has been modified.  Portions copyright (C) 2010, T-Mobile USA, Inc.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -16,19 +17,28 @@
 
 package android.app;
 
+import com.android.internal.app.IAssetRedirectionManager;
+import com.android.internal.os.BinderInternal;
+import com.android.internal.os.RuntimeInit;
+import com.android.internal.os.SamplingProfilerIntegration;
+
+import org.apache.harmony.xnet.provider.jsse.OpenSSLSocketImpl;
+
 import android.app.backup.BackupAgent;
 import android.content.BroadcastReceiver;
 import android.content.ComponentCallbacks2;
 import android.content.ComponentName;
 import android.content.ContentProvider;
 import android.content.Context;
+import android.content.ContextWrapper;
 import android.content.IContentProvider;
-import android.content.Intent;
 import android.content.IIntentReceiver;
+import android.content.Intent;
 import android.content.pm.ActivityInfo;
 import android.content.pm.ApplicationInfo;
 import android.content.pm.IPackageManager;
 import android.content.pm.InstrumentationInfo;
+import android.content.pm.PackageInfo;
 import android.content.pm.PackageManager;
 import android.content.pm.PackageManager.NameNotFoundException;
 import android.content.pm.ProviderInfo;
@@ -36,6 +46,8 @@ import android.content.pm.ServiceInfo;
 import android.content.res.AssetManager;
 import android.content.res.CompatibilityInfo;
 import android.content.res.Configuration;
+import android.content.res.CustomTheme;
+import android.content.res.PackageRedirectionMap;
 import android.content.res.Resources;
 import android.database.sqlite.SQLiteDatabase;
 import android.database.sqlite.SQLiteDebug;
@@ -47,6 +59,7 @@ import android.net.Proxy;
 import android.net.ProxyProperties;
 import android.opengl.GLUtils;
 import android.os.AsyncTask;
+import android.net.Uri;
 import android.os.Bundle;
 import android.os.Debug;
 import android.os.Handler;
@@ -60,6 +73,7 @@ import android.os.RemoteException;
 import android.os.ServiceManager;
 import android.os.StrictMode;
 import android.os.SystemClock;
+import android.text.TextUtils;
 import android.util.AndroidRuntimeException;
 import android.util.DisplayMetrics;
 import android.util.EventLog;
@@ -68,6 +82,7 @@ import android.util.LogPrinter;
 import android.util.Slog;
 import android.view.Display;
 import android.view.HardwareRenderer;
+import android.view.InflateException;
 import android.view.View;
 import android.view.ViewDebug;
 import android.view.ViewManager;
@@ -76,12 +91,6 @@ import android.view.Window;
 import android.view.WindowManager;
 import android.view.WindowManagerImpl;
 
-import com.android.internal.os.BinderInternal;
-import com.android.internal.os.RuntimeInit;
-import com.android.internal.os.SamplingProfilerIntegration;
-
-import org.apache.harmony.xnet.provider.jsse.OpenSSLSocketImpl;
-
 import java.io.File;
 import java.io.FileDescriptor;
 import java.io.FileOutputStream;
@@ -140,6 +149,7 @@ public final class ActivityThread {
     static ContextImpl mSystemContext = null;
 
     static IPackageManager sPackageManager;
+    static IAssetRedirectionManager sAssetRedirectionManager;
 
     final ApplicationThread mAppThread = new ApplicationThread();
     final Looper mLooper = Looper.myLooper();
@@ -1355,12 +1365,14 @@ public final class ActivityThread {
     private static class ResourcesKey {
         final private String mResDir;
         final private float mScale;
+        final private boolean mIsThemeable;
         final private int mHash;
 
-        ResourcesKey(String resDir, float scale) {
+        ResourcesKey(String resDir, float scale, boolean isThemeable) {
             mResDir = resDir;
             mScale = scale;
-            mHash = mResDir.hashCode() << 2 + (int) (mScale * 2);
+            mIsThemeable = isThemeable;
+            mHash = mResDir.hashCode() << 3 + ((mIsThemeable ? 1 : 0) << 2) + (int) (mScale * 2);
         }
 
         @Override
@@ -1374,7 +1386,8 @@ public final class ActivityThread {
                 return false;
             }
             ResourcesKey peer = (ResourcesKey) obj;
-            return mResDir.equals(peer.mResDir) && mScale == peer.mScale;
+            return mResDir.equals(peer.mResDir) && mScale == peer.mScale &&
+                    mIsThemeable == peer.mIsThemeable;
         }
     }
 
@@ -1405,6 +1418,18 @@ public final class ActivityThread {
         return sPackageManager;
     }
 
+    // NOTE: this method can return null if the SystemServer is still
+    // initializing (for example, of another SystemServer component is accessing
+    // a resources object)
+    public static IAssetRedirectionManager getAssetRedirectionManager() {
+        if (sAssetRedirectionManager != null) {
+            return sAssetRedirectionManager;
+        }
+        IBinder b = ServiceManager.getService("assetredirection");
+        sAssetRedirectionManager = IAssetRedirectionManager.Stub.asInterface(b);
+        return sAssetRedirectionManager;
+    }
+
     DisplayMetrics getDisplayMetricsLocked(CompatibilityInfo ci, boolean forceUpdate) {
         DisplayMetrics dm = mDisplayMetrics.get(ci);
         if (dm != null && !forceUpdate) {
@@ -1454,7 +1479,7 @@ public final class ActivityThread {
      * null.
      */
     Resources getTopLevelResources(String resDir, CompatibilityInfo compInfo) {
-        ResourcesKey key = new ResourcesKey(resDir, compInfo.applicationScale);
+        ResourcesKey key = new ResourcesKey(resDir, compInfo.applicationScale, compInfo.isThemeable);
         Resources r;
         synchronized (mPackages) {
             // Resources is app scale dependent.
@@ -1480,10 +1505,23 @@ public final class ActivityThread {
         //}
 
         AssetManager assets = new AssetManager();
+        assets.setThemeSupport(compInfo.isThemeable);
         if (assets.addAssetPath(resDir) == 0) {
             return null;
         }
 
+        /* Attach theme information to the resulting AssetManager when appropriate. */
+        Configuration config = getConfiguration();
+        if (compInfo.isThemeable && config != null) {
+            if (config.customTheme == null) {
+                config.customTheme = CustomTheme.getBootTheme();
+            }
+
+            if (!TextUtils.isEmpty(config.customTheme.getThemePackageName())) {
+                attachThemeAssets(assets, config.customTheme);
+            }
+        }
+
         //Slog.i(TAG, "Resource: key=" + key + ", display metrics=" + metrics);
         DisplayMetrics metrics = getDisplayMetricsLocked(null, false);
         r = new Resources(assets, metrics, getConfiguration(), compInfo);
@@ -1509,6 +1547,81 @@ public final class ActivityThread {
         }
     }
 
+    private void detachThemeAssets(AssetManager assets) {
+        String themePackageName = assets.getThemePackageName();
+        int themeCookie = assets.getThemeCookie();
+        if (!TextUtils.isEmpty(themePackageName) && themeCookie != 0) {
+            assets.detachThemePath(themePackageName, themeCookie);
+            assets.setThemePackageName(null);
+            assets.setThemeCookie(0);
+            assets.clearRedirections();
+        }
+    }
+
+    /**
+     * Attach the necessary theme asset paths and meta information to convert an
+     * AssetManager to being globally "theme-aware".
+     *
+     * @param assets
+     * @param theme
+     * @return true if the AssetManager is now theme-aware; false otherwise.
+     *         This can fail, for example, if the theme package has been been
+     *         removed and the theme manager has yet to revert formally back to
+     *         the framework default.
+     */
+    private boolean attachThemeAssets(AssetManager assets, CustomTheme theme) {
+        IAssetRedirectionManager rm = getAssetRedirectionManager();
+        if (rm == null) {
+            return false;
+        }
+        PackageInfo pi = null;
+        try {
+            pi = getPackageManager().getPackageInfo(theme.getThemePackageName(), 0);
+        } catch (RemoteException e) {
+        }
+        if (pi != null && pi.applicationInfo != null && pi.themeInfos != null) {
+            String themeResDir = pi.applicationInfo.publicSourceDir;
+            int cookie = assets.attachThemePath(themeResDir);
+            if (cookie != 0) {
+                String themePackageName = theme.getThemePackageName();
+                String themeId = theme.getThemeId();
+                int N = assets.getBasePackageCount();
+                for (int i = 0; i < N; i++) {
+                    String packageName = assets.getBasePackageName(i);
+                    int packageId = assets.getBasePackageId(i);
+
+                    /*
+                     * For now, we only consider redirections coming from the
+                     * framework or regular android packages. This excludes
+                     * themes and other specialty APKs we are not aware of.
+                     */
+                    if (packageId != 0x01 && packageId != 0x7f) {
+                        continue;
+                    }
+
+                    try {
+                        PackageRedirectionMap map = rm.getPackageRedirectionMap(themePackageName, themeId,
+                                packageName);
+                        if (map != null) {
+                            assets.addRedirections(map);
+                        }
+                    } catch (RemoteException e) {
+                        Log.e(TAG, "Failure accessing package redirection map, removing theme support.");
+                        assets.detachThemePath(themePackageName, cookie);
+                        return false;
+                    }
+                }
+
+                assets.setThemePackageName(theme.getThemePackageName());
+                assets.setThemeCookie(cookie);
+                return true;
+            } else {
+                Log.e(TAG, "Unable to attach theme assets at " + themeResDir);
+            }
+        }
+        return false;
+    }
+
     /**
      * Creates the top level resources for the given package.
      */
@@ -1953,6 +2066,16 @@ public final class ActivityThread {
 
         } catch (Exception e) {
             if (!mInstrumentation.onException(activity, e)) {
+                if (e instanceof InflateException) {
+                    Log.e(TAG, "Failed to inflate", e);
+                    String pkg = null;
+                    if (r.packageInfo != null && !TextUtils.isEmpty(r.packageInfo.getPackageName())) {
+                        pkg = r.packageInfo.getPackageName();
+                    }
+                    Intent intent = new Intent(Intent.ACTION_APP_LAUNCH_FAILURE,
+                            (pkg != null)? Uri.fromParts("package", pkg, null) : null);
+                    getSystemContext().sendBroadcast(intent);
+                }
                 throw new RuntimeException(
                     "Unable to start activity " + component
                     + ": " + e.toString(), e);
@@ -3478,7 +3601,7 @@ public final class ActivityThread {
         }
     }
 
-    final boolean applyConfigurationToResourcesLocked(Configuration config,
+    final int applyConfigurationToResourcesLocked(Configuration config,
             CompatibilityInfo compat) {
         if (mResConfiguration == null) {
             mResConfiguration = new Configuration();
@@ -3486,7 +3609,7 @@ public final class ActivityThread {
         if (!mResConfiguration.isOtherSeqNewer(config) && compat == null) {
             if (DEBUG_CONFIGURATION) Slog.v(TAG, "Skipping new config: curSeq="
                     + mResConfiguration.seq + ", newSeq=" + config.seq);
-            return false;
+            return 0;
         }
         int changes = mResConfiguration.updateFrom(config);
         DisplayMetrics dm = getDisplayMetricsLocked(null, true);
@@ -3519,7 +3642,20 @@ public final class ActivityThread {
             if (r != null) {
                 if (DEBUG_CONFIGURATION) Slog.v(TAG, "Changing resources "
                         + r + " config to: " + config);
+                boolean themeChanged = (changes & ActivityInfo.CONFIG_THEME_RESOURCE) != 0;
+                if (themeChanged) {
+                    AssetManager am = r.getAssets();
+                    if (am.hasThemeSupport()) {
+                        detachThemeAssets(am);
+                        if (!TextUtils.isEmpty(config.customTheme.getThemePackageName())) {
+                            attachThemeAssets(am, config.customTheme);
+                        }
+                    }
+                }
                 r.updateConfiguration(config, dm, compat);
+                if (themeChanged) {
+                    r.updateStringCache();
+                }
                 //Slog.i(TAG, "Updated app resources " + v.getKey()
                 //        + " " + r + ": " + r.getConfiguration());
             } else {
@@ -3528,7 +3664,7 @@ public final class ActivityThread {
             }
         }
         
-        return changes != 0;
+        return changes;
     }
 
     final Configuration applyCompatConfiguration() {
@@ -3548,6 +3684,8 @@ public final class ActivityThread {
 
         ArrayList<ComponentCallbacks2> callbacks = null;
 
+        int diff = 0;
+
         synchronized (mPackages) {
             if (mPendingConfiguration != null) {
                 if (!mPendingConfiguration.isOtherSeqNewer(config)) {
@@ -3563,7 +3701,7 @@ public final class ActivityThread {
             if (DEBUG_CONFIGURATION) Slog.v(TAG, "Handle configuration changed: "
                     + config);
         
-            applyConfigurationToResourcesLocked(config, compat);
+            diff = applyConfigurationToResourcesLocked(config, compat);
             
             if (mConfiguration == null) {
                 mConfiguration = new Configuration();
@@ -3582,7 +3720,20 @@ public final class ActivityThread {
         if (callbacks != null) {
             final int N = callbacks.size();
             for (int i=0; i<N; i++) {
-                performConfigurationChanged(callbacks.get(i), config);
+                ComponentCallbacks2 cb = callbacks.get(i);
+
+                // We removed the old resources object from the mActiveResources
+                // cache, now we need to trigger an update for each application.
+                if ((diff & ActivityInfo.CONFIG_THEME_RESOURCE) != 0) {
+                    if (cb instanceof ContextWrapper) {
+                        Context context = ((ContextWrapper)cb).getBaseContext();
+                        if (context instanceof ContextImpl) {
+                            ((ContextImpl)context).refreshResourcesIfNecessary();
+                        }
+                    }
+                }
+
+                performConfigurationChanged(cb, config);
             }
         }
     }
@@ -4356,7 +4507,7 @@ public final class ActivityThread {
                     // We need to apply this change to the resources
                     // immediately, because upon returning the view
                     // hierarchy will be informed about it.
-                    if (applyConfigurationToResourcesLocked(newConfig, null)) {
+                    if (applyConfigurationToResourcesLocked(newConfig, null) != 0) {
                         // This actually changed the resources!  Tell
                         // everyone about it.
                         if (mPendingConfiguration == null ||
diff --git a/core/java/android/app/ApplicationPackageManager.java b/core/java/android/app/ApplicationPackageManager.java
index 180a442..ce8fd39 100644
--- a/core/java/android/app/ApplicationPackageManager.java
+++ b/core/java/android/app/ApplicationPackageManager.java
@@ -403,6 +403,16 @@ final class ApplicationPackageManager extends PackageManager {
 
     @SuppressWarnings("unchecked")
     @Override
+    public List<PackageInfo> getInstalledThemePackages() {
+        try {
+            return mPM.getInstalledThemePackages();
+        } catch (RemoteException e) {
+            throw new RuntimeException("Package manager has died", e);
+        }
+    }
+
+    @SuppressWarnings("unchecked")
+    @Override
     public List<ApplicationInfo> getInstalledApplications(int flags) {
         try {
             final List<ApplicationInfo> applicationInfos = new ArrayList<ApplicationInfo>();
diff --git a/core/java/android/app/ConnectionSettings.java b/core/java/android/app/ConnectionSettings.java
new file mode 100755
index 0000000..00af439
--- /dev/null
+++ b/core/java/android/app/ConnectionSettings.java
@@ -0,0 +1,216 @@
+package android.app;
+
+import android.bluetooth.BluetoothAdapter;
+import android.content.ContentResolver;
+import android.content.Context;
+import android.location.LocationManager;
+import android.net.ConnectivityManager;
+import android.net.wifi.WifiManager;
+import android.net.wimax.WimaxHelper;
+import android.os.Parcel;
+import android.os.Parcelable;
+import android.provider.Settings;
+
+import org.xmlpull.v1.XmlPullParser;
+import org.xmlpull.v1.XmlPullParserException;
+
+import java.io.IOException;
+
+/** @hide */
+public final class ConnectionSettings implements Parcelable {
+
+    private int mConnectionId;
+    private int mValue;
+    private boolean mOverride;
+    private boolean mDirty;
+
+    public static final int PROFILE_CONNECTION_MOBILEDATA = 0;
+    public static final int PROFILE_CONNECTION_WIFI = 1;
+    public static final int PROFILE_CONNECTION_WIFIAP = 2;
+    public static final int PROFILE_CONNECTION_WIMAX = 3;
+    public static final int PROFILE_CONNECTION_GPS = 4;
+    public static final int PROFILE_CONNECTION_SYNC = 5;
+    public static final int PROFILE_CONNECTION_BLUETOOTH = 7;
+
+    /** @hide */
+    public static final Parcelable.Creator<ConnectionSettings> CREATOR = new Parcelable.Creator<ConnectionSettings>() {
+        public ConnectionSettings createFromParcel(Parcel in) {
+            return new ConnectionSettings(in);
+        }
+
+        @Override
+        public ConnectionSettings[] newArray(int size) {
+            return new ConnectionSettings[size];
+        }
+    };
+
+
+    public ConnectionSettings(Parcel parcel) {
+        readFromParcel(parcel);
+    }
+
+    public ConnectionSettings(int connectionId) {
+        this(connectionId, 0, false);
+    }
+
+    public ConnectionSettings(int connectionId, int value, boolean override) {
+        mConnectionId = connectionId;
+        mValue = value;
+        mOverride = override;
+        mDirty = false;
+    }
+
+    public int getConnectionId() {
+        return mConnectionId;
+    }
+
+    public int getValue() {
+        return mValue;
+    }
+
+    public void setValue(int value) {
+        mValue = value;
+        mDirty = true;
+    }
+
+    public void setOverride(boolean override) {
+        mOverride = override;
+        mDirty = true;
+    }
+
+    public boolean isOverride() {
+        return mOverride;
+    }
+
+    /** @hide */
+    public boolean isDirty() {
+        return mDirty;
+    }
+
+    public void processOverride(Context context) {
+        BluetoothAdapter bta = BluetoothAdapter.getDefaultAdapter();
+        LocationManager lm = (LocationManager) context.getSystemService(Context.LOCATION_SERVICE);
+        WifiManager wm = (WifiManager) context.getSystemService(Context.WIFI_SERVICE);
+        ConnectivityManager cm = (ConnectivityManager) context.getSystemService(Context.CONNECTIVITY_SERVICE);
+
+        boolean forcedState = getValue() == 1;
+        boolean currentState;
+
+        switch (getConnectionId()) {
+            case PROFILE_CONNECTION_MOBILEDATA:
+                currentState = cm.getMobileDataEnabled();
+                if (forcedState != currentState) {
+                    cm.setMobileDataEnabled(forcedState);
+                }
+                break;
+            case PROFILE_CONNECTION_BLUETOOTH:
+                currentState = bta.isEnabled();
+                if (forcedState && !currentState) {
+                    bta.enable();
+                } else if (!forcedState && currentState) {
+                    bta.disable();
+                }
+                break;
+            case PROFILE_CONNECTION_GPS:
+                currentState = lm.isProviderEnabled(LocationManager.GPS_PROVIDER);
+                if (currentState != forcedState) {
+                    Settings.Secure.setLocationProviderEnabled(context.getContentResolver(),
+                            LocationManager.GPS_PROVIDER, forcedState);
+                }
+                break;
+            case PROFILE_CONNECTION_SYNC:
+                currentState = ContentResolver.getMasterSyncAutomatically();
+                if (forcedState != currentState) {
+                    ContentResolver.setMasterSyncAutomatically(forcedState);
+                }
+                break;
+            case PROFILE_CONNECTION_WIFI:
+                int wifiApState = wm.getWifiApState();
+                currentState = wm.isWifiEnabled();
+                if (currentState != forcedState) {
+                    // Disable wifi tether
+                    if (forcedState && (wifiApState == WifiManager.WIFI_AP_STATE_ENABLING) ||
+                            (wifiApState == WifiManager.WIFI_AP_STATE_ENABLED)) {
+                        wm.setWifiApEnabled(null, false);
+                    }
+                    wm.setWifiEnabled(forcedState);
+                }
+                break;
+            case PROFILE_CONNECTION_WIFIAP:
+                int wifiState = wm.getWifiState();
+                currentState = wm.isWifiApEnabled();
+                if (currentState != forcedState) {
+                    // Disable wifi
+                    if (forcedState && (wifiState == WifiManager.WIFI_STATE_ENABLING) || (wifiState == WifiManager.WIFI_STATE_ENABLED)) {
+                        wm.setWifiEnabled(false);
+                    }
+                    wm.setWifiApEnabled(null, forcedState);
+                }
+                break;
+            case PROFILE_CONNECTION_WIMAX:
+                if (WimaxHelper.isWimaxSupported(context)) {
+                    currentState = WimaxHelper.isWimaxEnabled(context);
+                    if (currentState != forcedState) {
+                        WimaxHelper.setWimaxEnabled(context, forcedState);
+                    }
+                }
+                break;
+        }
+    }
+
+    /** @hide */
+    public static ConnectionSettings fromXml(XmlPullParser xpp, Context context)
+            throws XmlPullParserException, IOException {
+        int event = xpp.next();
+        ConnectionSettings connectionDescriptor = new ConnectionSettings(0);
+        while (event != XmlPullParser.END_TAG || !xpp.getName().equals("connectionDescriptor")) {
+            if (event == XmlPullParser.START_TAG) {
+                String name = xpp.getName();
+                if (name.equals("connectionId")) {
+                    connectionDescriptor.mConnectionId = Integer.parseInt(xpp.nextText());
+                } else if (name.equals("value")) {
+                    connectionDescriptor.mValue = Integer.parseInt(xpp.nextText());
+                } else if (name.equals("override")) {
+                    connectionDescriptor.mOverride = Boolean.parseBoolean(xpp.nextText());
+                }
+            }
+            event = xpp.next();
+        }
+        return connectionDescriptor;
+    }
+
+    /** @hide */
+    public void getXmlString(StringBuilder builder, Context context) {
+        builder.append("<connectionDescriptor>\n<connectionId>");
+        builder.append(mConnectionId);
+        builder.append("</connectionId>\n<value>");
+        builder.append(mValue);
+        builder.append("</value>\n<override>");
+        builder.append(mOverride);
+        builder.append("</override>\n</connectionDescriptor>\n");
+    }
+
+    @Override
+    public int describeContents() {
+        return 0;
+    }
+
+    /** @hide */
+    @Override
+    public void writeToParcel(Parcel dest, int flags) {
+        dest.writeInt(mConnectionId);
+        dest.writeInt(mOverride ? 1 : 0);
+        dest.writeInt(mValue);
+        dest.writeInt(mDirty ? 1 : 0);
+    }
+
+    /** @hide */
+    public void readFromParcel(Parcel in) {
+        mConnectionId = in.readInt();
+        mOverride = in.readInt() != 0;
+        mValue = in.readInt();
+        mDirty = in.readInt() != 0;
+    }
+
+
+}
diff --git a/core/java/android/app/ContextImpl.java b/core/java/android/app/ContextImpl.java
index 2bf1fb7..957ccd8 100644
--- a/core/java/android/app/ContextImpl.java
+++ b/core/java/android/app/ContextImpl.java
@@ -1,5 +1,6 @@
 /*
  * Copyright (C) 2006 The Android Open Source Project
+ * This code has been modified.  Portions copyright (C) 2010, T-Mobile USA, Inc.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -18,15 +19,17 @@ package android.app;
 
 import com.android.internal.policy.PolicyManager;
 
+import android.accounts.AccountManager;
+import android.accounts.IAccountManager;
 import android.content.BroadcastReceiver;
 import android.content.ComponentName;
 import android.content.ContentResolver;
 import android.content.Context;
 import android.content.ContextWrapper;
 import android.content.IContentProvider;
+import android.content.IIntentReceiver;
 import android.content.Intent;
 import android.content.IntentFilter;
-import android.content.IIntentReceiver;
 import android.content.IntentSender;
 import android.content.ReceiverCallNotAllowedException;
 import android.content.ServiceConnection;
@@ -36,6 +39,8 @@ import android.content.pm.IPackageManager;
 import android.content.pm.PackageManager;
 import android.content.res.AssetManager;
 import android.content.res.CompatibilityInfo;
+import android.content.res.Configuration;
+import android.content.res.CustomTheme;
 import android.content.res.Resources;
 import android.database.DatabaseErrorHandler;
 import android.database.sqlite.SQLiteDatabase;
@@ -61,6 +66,8 @@ import android.net.wifi.IWifiManager;
 import android.net.wifi.WifiManager;
 import android.net.wifi.p2p.IWifiP2pManager;
 import android.net.wifi.p2p.WifiP2pManager;
+import android.net.wimax.WimaxHelper;
+import android.net.wimax.WimaxManagerConstants;
 import android.nfc.NfcManager;
 import android.os.Binder;
 import android.os.Bundle;
@@ -77,6 +84,13 @@ import android.os.RemoteException;
 import android.os.ServiceManager;
 import android.os.Vibrator;
 import android.os.storage.StorageManager;
+// BEGIN privacy-added
+import android.privacy.IPrivacySettingsManager;
+import android.privacy.PrivacySettingsManager;
+import android.privacy.surrogate.PrivacyAccountManager;
+import android.privacy.surrogate.PrivacyLocationManager;
+import android.privacy.surrogate.PrivacyTelephonyManager;
+// END privacy-added
 import android.telephony.TelephonyManager;
 import android.content.ClipboardManager;
 import android.util.AndroidRuntimeException;
@@ -100,6 +114,13 @@ import java.io.InputStream;
 import java.util.ArrayList;
 import java.util.HashMap;
 
+import com.stericsson.hardware.fm.IFmReceiver;
+import com.stericsson.hardware.fm.IFmTransmitter;
+import com.stericsson.hardware.fm.FmReceiver;
+import com.stericsson.hardware.fm.FmTransmitter;
+import com.stericsson.hardware.fm.FmReceiverImpl;
+import com.stericsson.hardware.fm.FmTransmitterImpl;
+
 class ReceiverRestrictedContext extends ContextWrapper {
     ReceiverRestrictedContext(Context base) {
         super(base);
@@ -147,6 +168,7 @@ class ContextImpl extends Context {
     private Resources mResources;
     /*package*/ ActivityThread mMainThread;
     private Context mOuterContext;
+    private static Context sOuterContext;
     private IBinder mActivityToken = null;
     private ApplicationContentResolver mContentResolver;
     private int mThemeResource = 0;
@@ -260,7 +282,9 @@ class ContextImpl extends Context {
                 public Object createService(ContextImpl ctx) {
                     IBinder b = ServiceManager.getService(ACCOUNT_SERVICE);
                     IAccountManager service = IAccountManager.Stub.asInterface(b);
-                    return new AccountManager(ctx, service);
+                    // BEGIN privacy-modified
+                    return new PrivacyAccountManager(ctx, service);
+                    // END privacy-modified
                 }});
 
         registerService(ACTIVITY_SERVICE, new ServiceFetcher() {
@@ -345,7 +369,10 @@ class ContextImpl extends Context {
         registerService(LOCATION_SERVICE, new StaticServiceFetcher() {
                 public Object createStaticService() {
                     IBinder b = ServiceManager.getService(LOCATION_SERVICE);
-                    return new LocationManager(ILocationManager.Stub.asInterface(b));
+                    // BEGIN privacy-modified
+                    ILocationManager service = ILocationManager.Stub.asInterface(b);
+                    return new PrivacyLocationManager(service,getStaticOuterContext());
+                    // END privacy-modified
                 }});
 
         registerService(NETWORK_POLICY_SERVICE, new ServiceFetcher() {
@@ -407,7 +434,9 @@ class ContextImpl extends Context {
 
         registerService(TELEPHONY_SERVICE, new ServiceFetcher() {
                 public Object createService(ContextImpl ctx) {
-                    return new TelephonyManager(ctx.getOuterContext());
+                    // BEGIN privacy-modified
+                    return new PrivacyTelephonyManager(ctx.getOuterContext());
+                    // END privacy-modified
                 }});
 
         registerService(THROTTLE_SERVICE, new StaticServiceFetcher() {
@@ -452,6 +481,41 @@ class ContextImpl extends Context {
                 public Object getService(ContextImpl ctx) {
                     return WindowManagerImpl.getDefault(ctx.mPackageInfo.mCompatibilityInfo);
                 }});
+
+        registerService(WimaxManagerConstants.WIMAX_SERVICE, new ServiceFetcher() {
+                public Object createService(ContextImpl ctx) {
+                    return WimaxHelper.createWimaxService(ctx, ctx.mMainThread.getHandler());
+                }});
+
+        registerService(PROFILE_SERVICE, new ServiceFetcher() {
+                public Object createService(ContextImpl ctx) {
+                    final Context outerContext = ctx.getOuterContext();
+                    return new ProfileManager (outerContext, ctx.mMainThread.getHandler());
+                }});
+
+        registerService("fm_receiver", new ServiceFetcher() {
+                public Object createService(ContextImpl ctx) {
+                    IBinder b = ServiceManager.getService("fm_receiver");
+                    IFmReceiver service = IFmReceiver.Stub.asInterface(b);
+                    return new FmReceiverImpl(service);
+                }});
+
+        registerService("fm_transmitter", new ServiceFetcher() {
+                public Object createService(ContextImpl ctx) {
+                    IBinder b = ServiceManager.getService("fm_transmitter");
+                    IFmTransmitter service = IFmTransmitter.Stub.asInterface(b);
+                    return new FmTransmitterImpl(service);
+                }});
+
+        // BEGIN privacy-added
+        registerService("privacy", new StaticServiceFetcher() {
+                public Object createStaticService() {
+                    IBinder b = ServiceManager.getService("privacy");
+                    IPrivacySettingsManager service = IPrivacySettingsManager.Stub.asInterface(b);
+                    return new PrivacySettingsManager(getStaticOuterContext(),service);
+                }});
+        // END privacy-added
+
     }
 
     static ContextImpl getImpl(Context context) {
@@ -478,6 +542,20 @@ class ContextImpl extends Context {
         return mResources;
     }
 
+    /**
+     * Refresh resources object which may have been changed by a theme
+     * configuration change.
+     */
+    /* package */ void refreshResourcesIfNecessary() {
+        if (mResources == Resources.getSystem()) {
+            return;
+        }
+
+        if (mPackageInfo.mCompatibilityInfo.get().isThemeable) {
+            mTheme = null;
+        }
+    }
+
     @Override
     public PackageManager getPackageManager() {
         if (mPackageManager != null) {
@@ -1462,7 +1540,7 @@ class ContextImpl extends Context {
     }
 
     ContextImpl() {
-        mOuterContext = this;
+        sOuterContext = mOuterContext = this;
     }
 
     /**
@@ -1477,7 +1555,7 @@ class ContextImpl extends Context {
         mResources = context.mResources;
         mMainThread = context.mMainThread;
         mContentResolver = context.mContentResolver;
-        mOuterContext = this;
+        sOuterContext = mOuterContext = this;
     }
 
     final void init(LoadedApk packageInfo,
@@ -1537,13 +1615,17 @@ class ContextImpl extends Context {
     }
 
     final void setOuterContext(Context context) {
-        mOuterContext = context;
+        sOuterContext = mOuterContext = context;
     }
 
     final Context getOuterContext() {
         return mOuterContext;
     }
 
+    final static Context getStaticOuterContext() {
+        return sOuterContext;
+    }
+
     final IBinder getActivityToken() {
         return mActivityToken;
     }
diff --git a/core/java/android/app/DownloadManager.java b/core/java/android/app/DownloadManager.java
index ad8d41f..60ca9d6 100644
--- a/core/java/android/app/DownloadManager.java
+++ b/core/java/android/app/DownloadManager.java
@@ -341,6 +341,13 @@ public class DownloadManager {
          */
         public static final int NETWORK_WIFI = 1 << 1;
 
+        /**
+         * Bit flag for {@link #setAllowedNetworkTypes} corresponding to
+         * {@link ConnectivityManager#TYPE_WIMAX}.
+         * @hide
+         */
+        public static final int NETWORK_WIMAX = 1 << 6;
+
         private Uri mUri;
         private Uri mDestinationUri;
         private List<Pair<String, String>> mRequestHeaders = new ArrayList<Pair<String, String>>();
diff --git a/core/java/android/app/FragmentManager.java b/core/java/android/app/FragmentManager.java
index 1abb7de..7e1daa4 100644
--- a/core/java/android/app/FragmentManager.java
+++ b/core/java/android/app/FragmentManager.java
@@ -1538,6 +1538,9 @@ final class FragmentManagerImpl extends FragmentManager {
                     FragmentManagerImpl.VIEW_STATE_TAG, f.mSavedViewState);
         }
         if (!f.mUserVisibleHint) {
+            if (result == null) {
+                result = new Bundle();
+            }
             // Only add this if it's not the default value
             result.putBoolean(FragmentManagerImpl.USER_VISIBLE_HINT_TAG, f.mUserVisibleHint);
         }
@@ -1887,7 +1890,7 @@ final class FragmentManagerImpl extends FragmentManager {
         if (mActive != null) {
             for (int i=0; i<mAdded.size(); i++) {
                 Fragment f = mAdded.get(i);
-                if (f != null && !f.mHidden) {
+                if (f != null && !f.mHidden && f.mUserVisibleHint) {
                     if (f.onContextItemSelected(item)) {
                         return true;
                     }
diff --git a/core/java/android/app/IProfileManager.aidl b/core/java/android/app/IProfileManager.aidl
new file mode 100644
index 0000000..c7c6744
--- /dev/null
+++ b/core/java/android/app/IProfileManager.aidl
@@ -0,0 +1,50 @@
+/* //device/java/android/android/app/IProfileManager.aidl
+**
+** Copyright 2007, The Android Open Source Project
+**
+** Licensed under the Apache License, Version 2.0 (the "License");
+** you may not use this file except in compliance with the License.
+** You may obtain a copy of the License at
+**
+**     http://www.apache.org/licenses/LICENSE-2.0
+**
+** Unless required by applicable law or agreed to in writing, software
+** distributed under the License is distributed on an "AS IS" BASIS,
+** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+** See the License for the specific language governing permissions and
+** limitations under the License.
+*/
+
+package android.app;
+
+import android.app.Profile;
+import android.app.NotificationGroup;
+import android.os.ParcelUuid;
+
+/** {@hide} */
+interface IProfileManager
+{
+    boolean setActiveProfile(in ParcelUuid profileParcelUuid);
+    boolean setActiveProfileByName(String profileName);
+    Profile getActiveProfile();
+
+    boolean addProfile(in Profile profile);
+    boolean removeProfile(in Profile profile);
+    void updateProfile(in Profile profile);
+
+    Profile getProfile(in ParcelUuid profileParcelUuid);
+    Profile getProfileByName(String profileName);
+    Profile[] getProfiles();
+    boolean profileExists(in ParcelUuid profileUuid);
+    boolean profileExistsByName(String profileName);
+    boolean notificationGroupExistsByName(String notificationGroupName);
+
+    NotificationGroup[] getNotificationGroups();
+    void addNotificationGroup(in NotificationGroup group);
+    void removeNotificationGroup(in NotificationGroup group);
+    void updateNotificationGroup(in NotificationGroup group);
+    NotificationGroup getNotificationGroupForPackage(in String pkg);
+    NotificationGroup getNotificationGroup(in ParcelUuid groupParcelUuid);
+
+    void resetAll();
+}
diff --git a/core/java/android/app/Notification.java b/core/java/android/app/Notification.java
index d569e20..c30fc80 100644
--- a/core/java/android/app/Notification.java
+++ b/core/java/android/app/Notification.java
@@ -308,6 +308,15 @@ public class Notification implements Parcelable
      */
     public static final int FLAG_HIGH_PRIORITY = 0x00000080;
 
+    /**
+     * Bit to be bitwise-ored into the {@link #flags} field that should be
+     * set if this notification should force the led to pulse even if the
+     * screen has been shut off while the notification was active.
+     *
+     * @hide
+     */
+    public static final int FLAG_FORCE_LED_SCREEN_OFF = 0x00000100;
+
     public int flags;
 
     /**
diff --git a/core/java/android/app/NotificationGroup.aidl b/core/java/android/app/NotificationGroup.aidl
new file mode 100644
index 0000000..44b6290
--- /dev/null
+++ b/core/java/android/app/NotificationGroup.aidl
@@ -0,0 +1,19 @@
+/**
+ * Copyright (c) 2012, The CyanogenMod Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package android.app;
+
+parcelable NotificationGroup;
diff --git a/core/java/android/app/NotificationGroup.java b/core/java/android/app/NotificationGroup.java
new file mode 100644
index 0000000..bcb70d3
--- /dev/null
+++ b/core/java/android/app/NotificationGroup.java
@@ -0,0 +1,201 @@
+/*
+ * Copyright (C) 2011 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package android.app;
+
+import org.xmlpull.v1.XmlPullParser;
+import org.xmlpull.v1.XmlPullParserException;
+
+import android.content.Context;
+import android.os.Parcel;
+import android.os.Parcelable;
+import android.os.ParcelUuid;
+import android.os.RemoteException;
+import android.text.TextUtils;
+import android.util.Log;
+
+import java.io.IOException;
+import java.util.Arrays;
+import java.util.HashSet;
+import java.util.Set;
+import java.util.UUID;
+
+/** @hide */
+public class NotificationGroup implements Parcelable {
+    private static final String TAG = "NotificationGroup";
+
+    private String mName;
+    private int mNameResId;
+
+    private UUID mUuid;
+
+    private Set<String> mPackages = new HashSet<String>();
+
+    private boolean mDirty;
+
+    public static final Parcelable.Creator<NotificationGroup> CREATOR = new Parcelable.Creator<NotificationGroup>() {
+        public NotificationGroup createFromParcel(Parcel in) {
+            return new NotificationGroup(in);
+        }
+
+        @Override
+        public NotificationGroup[] newArray(int size) {
+            return new NotificationGroup[size];
+        }
+    };
+
+    public NotificationGroup(String name) {
+        this(name, -1, null);
+    }
+
+    public NotificationGroup(String name, int nameResId, UUID uuid) {
+        mName = name;
+        mNameResId = nameResId;
+        mUuid = (uuid != null) ? uuid : UUID.randomUUID();
+        mDirty = uuid == null;
+    }
+
+    private NotificationGroup(Parcel in) {
+        readFromParcel(in);
+    }
+
+    @Override
+    public String toString() {
+        return getName();
+    }
+
+    public String getName() {
+        return mName;
+    }
+
+    public void setName(String name) {
+        mName = name;
+        mNameResId = -1;
+        mDirty = true;
+    }
+
+    public UUID getUuid() {
+        return mUuid;
+    }
+
+    public void addPackage(String pkg) {
+        mPackages.add(pkg);
+        mDirty = true;
+    }
+
+    public String[] getPackages() {
+        return mPackages.toArray(new String[mPackages.size()]);
+    }
+
+    public void removePackage(String pkg) {
+        mPackages.remove(pkg);
+        mDirty = true;
+    }
+
+    public boolean hasPackage(String pkg) {
+        return mPackages.contains(pkg);
+    }
+
+    public boolean isDirty() {
+        return mDirty;
+    }
+
+    @Override
+    public int describeContents() {
+        return 0;
+    }
+
+    @Override
+    public void writeToParcel(Parcel dest, int flags) {
+        dest.writeString(mName);
+        dest.writeInt(mNameResId);
+        dest.writeInt(mDirty ? 1 : 0);
+        new ParcelUuid(mUuid).writeToParcel(dest, 0);
+        dest.writeStringArray(getPackages());
+    }
+
+    public void readFromParcel(Parcel in) {
+        mName = in.readString();
+        mNameResId = in.readInt();
+        mDirty = in.readInt() != 0;
+        mUuid = ParcelUuid.CREATOR.createFromParcel(in).getUuid();
+        mPackages.addAll(Arrays.asList(in.readStringArray()));
+    }
+
+    public void getXmlString(StringBuilder builder, Context context) {
+        builder.append("<notificationGroup ");
+        if (mNameResId > 0) {
+            builder.append("nameres=\"");
+            builder.append(context.getResources().getResourceEntryName(mNameResId));
+        } else {
+            builder.append("name=\"");
+            builder.append(TextUtils.htmlEncode(getName()));
+        }
+        builder.append("\" uuid=\"");
+        builder.append(TextUtils.htmlEncode(getUuid().toString()));
+        builder.append("\">\n");
+        for (String pkg : mPackages) {
+            builder.append("<package>" + TextUtils.htmlEncode(pkg) + "</package>\n");
+        }
+        builder.append("</notificationGroup>\n");
+        mDirty = false;
+    }
+
+    public static NotificationGroup fromXml(XmlPullParser xpp, Context context)
+            throws XmlPullParserException, IOException {
+        String value = xpp.getAttributeValue(null, "nameres");
+        int nameResId = -1;
+        String name = null;
+        UUID uuid = null;
+
+        if (value != null) {
+            nameResId = context.getResources().getIdentifier(value, "string", "android");
+            if (nameResId > 0) {
+                name = context.getResources().getString(nameResId);
+            }
+        }
+
+        if (name == null) {
+            name = xpp.getAttributeValue(null, "name");
+        }
+
+        value = xpp.getAttributeValue(null, "uuid");
+        if (value != null) {
+            try {
+                uuid = UUID.fromString(value);
+            } catch (IllegalArgumentException e) {
+                Log.w(TAG, "UUID not recognized for " + name + ", using new one.");
+            }
+        }
+
+        NotificationGroup notificationGroup = new NotificationGroup(name, nameResId, uuid);
+        int event = xpp.next();
+        while (event != XmlPullParser.END_TAG || !xpp.getName().equals("notificationGroup")) {
+            if (event == XmlPullParser.START_TAG) {
+                if (xpp.getName().equals("package")) {
+                    String pkg = xpp.nextText();
+                    notificationGroup.addPackage(pkg);
+                }
+            }
+            event = xpp.next();
+        }
+
+        /* we just loaded from XML, no need to save */
+        notificationGroup.mDirty = false;
+
+        return notificationGroup;
+    }
+}
diff --git a/core/java/android/app/Profile.aidl b/core/java/android/app/Profile.aidl
new file mode 100644
index 0000000..d75bd76
--- /dev/null
+++ b/core/java/android/app/Profile.aidl
@@ -0,0 +1,19 @@
+/**
+ * Copyright (c) 2007, The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package android.app;
+
+parcelable Profile;
diff --git a/core/java/android/app/Profile.java b/core/java/android/app/Profile.java
new file mode 100644
index 0000000..54e187d
--- /dev/null
+++ b/core/java/android/app/Profile.java
@@ -0,0 +1,595 @@
+/*
+ * Copyright (C) 2011 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package android.app;
+
+import android.content.Context;
+import android.content.Intent;
+import android.media.AudioManager;
+import android.os.Parcel;
+import android.os.ParcelUuid;
+import android.os.Parcelable;
+import android.provider.Settings;
+import android.text.TextUtils;
+import android.util.Log;
+
+import org.xmlpull.v1.XmlPullParser;
+import org.xmlpull.v1.XmlPullParserException;
+
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+import java.util.UUID;
+
+/**
+ * @hide
+ */
+public final class Profile implements Parcelable, Comparable {
+
+    private String mName;
+
+    private int mNameResId;
+
+    private UUID mUuid;
+
+    private ArrayList<UUID> mSecondaryUuids = new ArrayList<UUID>();
+
+    private Map<UUID, ProfileGroup> profileGroups = new HashMap<UUID, ProfileGroup>();
+
+    private ProfileGroup mDefaultGroup;
+
+    private boolean mStatusBarIndicator = false;
+
+    private boolean mDirty;
+
+    private static final String TAG = "Profile";
+
+    private int mProfileType;
+
+    private static final int CONDITIONAL_TYPE = 1;
+
+    private static final int TOGGLE_TYPE = 0;
+
+    private Map<Integer, StreamSettings> streams = new HashMap<Integer, StreamSettings>();
+
+    private Map<Integer, ConnectionSettings> connections = new HashMap<Integer, ConnectionSettings>();
+
+    private Map<Integer, VibratorSettings> vibrators = new HashMap<Integer, VibratorSettings>();
+
+    private int mScreenLockMode = LockMode.DEFAULT;
+
+    private int mAirplaneMode = AirplaneMode.DEFAULT;
+
+    /** @hide */
+    public static class LockMode {
+        public static final int DEFAULT = 0;
+        public static final int INSECURE = 1;
+        public static final int DISABLE = 2;
+    }
+
+    /** @hide */
+    public static class AirplaneMode {
+        public static final int DEFAULT = 0;
+        public static final int ENABLE = 1;
+        public static final int DISABLE = 2;
+    }
+
+    /** @hide */
+    public static final Parcelable.Creator<Profile> CREATOR = new Parcelable.Creator<Profile>() {
+        public Profile createFromParcel(Parcel in) {
+            return new Profile(in);
+        }
+
+        @Override
+        public Profile[] newArray(int size) {
+            return new Profile[size];
+        }
+    };
+
+    /** @hide */
+    public Profile(String name) {
+        this(name, -1, UUID.randomUUID());
+    }
+
+    private Profile(String name, int nameResId, UUID uuid) {
+        mName = name;
+        mNameResId = nameResId;
+        mUuid = uuid;
+        mProfileType = TOGGLE_TYPE;  //Default to toggle type
+        mDirty = false;
+    }
+
+    private Profile(Parcel in) {
+        readFromParcel(in);
+    }
+
+    public int compareTo(Object obj)
+    {
+        Profile tmp = (Profile) obj;
+        if (mName.compareTo(tmp.mName) < 0) {
+            return -1;
+        } else if (mName.compareTo(tmp.mName) > 0) {
+            return 1;
+        }
+        return 0;
+    }
+
+    /** @hide */
+    public void addProfileGroup(ProfileGroup value) {
+        if (value.isDefaultGroup()) {
+            /* we must not have more than one default group */
+            if (mDefaultGroup != null) {
+                return;
+            }
+            mDefaultGroup = value;
+        }
+        profileGroups.put(value.getUuid(), value);
+        mDirty = true;
+    }
+
+    /** @hide */
+    public void removeProfileGroup(UUID uuid) {
+        if (!profileGroups.get(uuid).isDefaultGroup()) {
+            profileGroups.remove(uuid);
+        } else {
+            Log.e(TAG, "Cannot remove default group: " + uuid);
+        }
+    }
+
+    public ProfileGroup[] getProfileGroups() {
+        return profileGroups.values().toArray(new ProfileGroup[profileGroups.size()]);
+    }
+
+    public ProfileGroup getProfileGroup(UUID uuid) {
+        return profileGroups.get(uuid);
+    }
+
+    public ProfileGroup getDefaultGroup() {
+        return mDefaultGroup;
+    }
+
+    /** @hide */
+    @Override
+    public int describeContents() {
+        return 0;
+    }
+
+    /** @hide */
+    @Override
+    public void writeToParcel(Parcel dest, int flags) {
+        dest.writeString(mName);
+        dest.writeInt(mNameResId);
+        new ParcelUuid(mUuid).writeToParcel(dest, 0);
+        ArrayList<ParcelUuid> uuids = new ArrayList<ParcelUuid>(mSecondaryUuids.size());
+        for (UUID u : mSecondaryUuids) {
+            uuids.add(new ParcelUuid(u));
+        }
+        dest.writeParcelableArray(uuids.toArray(new Parcelable[uuids.size()]), flags);
+        dest.writeInt(mStatusBarIndicator ? 1 : 0);
+        dest.writeInt(mProfileType);
+        dest.writeInt(mDirty ? 1 : 0);
+        dest.writeParcelableArray(
+                profileGroups.values().toArray(new Parcelable[profileGroups.size()]), flags);
+        dest.writeParcelableArray(
+                streams.values().toArray(new Parcelable[streams.size()]), flags);
+        dest.writeParcelableArray(
+                connections.values().toArray(new Parcelable[connections.size()]), flags);
+        dest.writeParcelableArray(vibrators.values().toArray(new Parcelable[vibrators.size()]), flags);
+        dest.writeInt(mScreenLockMode);
+        dest.writeInt(mAirplaneMode);
+    }
+
+    /** @hide */
+    public void readFromParcel(Parcel in) {
+        mName = in.readString();
+        mNameResId = in.readInt();
+        mUuid = ParcelUuid.CREATOR.createFromParcel(in).getUuid();
+        for (Parcelable parcel : in.readParcelableArray(null)) {
+            ParcelUuid u = (ParcelUuid) parcel;
+            mSecondaryUuids.add(u.getUuid());
+        }
+        mStatusBarIndicator = (in.readInt() == 1);
+        mProfileType = in.readInt();
+        mDirty = (in.readInt() == 1);
+        for (Parcelable group : in.readParcelableArray(null)) {
+            ProfileGroup grp = (ProfileGroup) group;
+            profileGroups.put(grp.getUuid(), grp);
+            if (grp.isDefaultGroup()) {
+                mDefaultGroup = grp;
+            }
+        }
+        for (Parcelable parcel : in.readParcelableArray(null)) {
+            StreamSettings stream = (StreamSettings) parcel;
+            streams.put(stream.getStreamId(), stream);
+        }
+        for (Parcelable parcel : in.readParcelableArray(null)) {
+            ConnectionSettings connection = (ConnectionSettings) parcel;
+            connections.put(connection.getConnectionId(), connection);
+        }
+        for (Parcelable parcel : in.readParcelableArray(null)) {
+            VibratorSettings vibrator = (VibratorSettings) parcel;
+            vibrators.put(vibrator.getVibratorId(), vibrator);
+        }
+        mScreenLockMode = in.readInt();
+        mAirplaneMode = in.readInt();
+    }
+
+    public String getName() {
+        return mName;
+    }
+
+    /** @hide */
+    public void setName(String name) {
+        mName = name;
+        mNameResId = -1;
+        mDirty = true;
+    }
+
+    public int getProfileType() {
+        return mProfileType;
+    }
+
+    /** @hide */
+    public void setProfileType(int type) {
+        mProfileType = type;
+        mDirty = true;
+    }
+
+    public UUID getUuid() {
+        if (this.mUuid == null) this.mUuid = UUID.randomUUID();
+        return this.mUuid;
+    }
+
+    public UUID[] getSecondaryUuids() {
+        return mSecondaryUuids.toArray(new UUID[mSecondaryUuids.size()]);
+    }
+
+    public void setSecondaryUuids(List<UUID> uuids) {
+        mSecondaryUuids.clear();
+        if (uuids != null) {
+            mSecondaryUuids.addAll(uuids);
+            mDirty = true;
+        }
+    }
+
+    public void addSecondaryUuid(UUID uuid) {
+        if (uuid != null) {
+            mSecondaryUuids.add(uuid);
+            mDirty = true;
+        }
+    }
+
+    public boolean getStatusBarIndicator() {
+        return mStatusBarIndicator;
+    }
+
+    public void setStatusBarIndicator(boolean newStatusBarIndicator) {
+        mStatusBarIndicator = newStatusBarIndicator;
+        mDirty = true;
+    }
+
+    public boolean isConditionalType() {
+        return(mProfileType == CONDITIONAL_TYPE ? true : false);
+    }
+
+    public void setConditionalType() {
+        mProfileType = CONDITIONAL_TYPE;
+        mDirty = true;
+    }
+
+    public int getScreenLockMode() {
+        return mScreenLockMode;
+    }
+
+    public void setScreenLockMode(int screenLockMode) {
+        if (screenLockMode < LockMode.DEFAULT || screenLockMode > LockMode.DISABLE) {
+            mScreenLockMode = LockMode.DEFAULT;
+        } else {
+            mScreenLockMode = screenLockMode;
+        }
+        mDirty = true;
+    }
+
+    public int getAirplaneMode() {
+        return mAirplaneMode;
+    }
+
+    public void setAirplaneMode(int airplaneMode) {
+        if (airplaneMode < AirplaneMode.DEFAULT || airplaneMode > AirplaneMode.DISABLE) {
+            mAirplaneMode = AirplaneMode.DEFAULT;
+        } else {
+            mAirplaneMode = airplaneMode;
+        }
+        mDirty = true;
+    }
+
+    /** @hide */
+    public boolean isDirty() {
+        if (mDirty) {
+            return true;
+        }
+        for (ProfileGroup group : profileGroups.values()) {
+            if (group.isDirty()) {
+                return true;
+            }
+        }
+        for (StreamSettings stream : streams.values()) {
+            if (stream.isDirty()) {
+                return true;
+            }
+        }
+        for (ConnectionSettings conn : connections.values()) {
+            if (conn.isDirty()) {
+                return true;
+            }
+        }
+        for (VibratorSettings vibrator : vibrators.values()) {
+            if (vibrator.isDirty()) {
+                return true;
+            }
+        }
+        return false;
+    }
+
+    /** @hide */
+    public void getXmlString(StringBuilder builder, Context context) {
+        builder.append("<profile ");
+        if (mNameResId > 0) {
+            builder.append("nameres=\"");
+            builder.append(context.getResources().getResourceEntryName(mNameResId));
+        } else {
+            builder.append("name=\"");
+            builder.append(TextUtils.htmlEncode(getName()));
+        }
+        builder.append("\" uuid=\"");
+        builder.append(TextUtils.htmlEncode(getUuid().toString()));
+        builder.append("\">\n");
+
+        builder.append("<uuids>");
+        for (UUID u : mSecondaryUuids) {
+            builder.append("<uuid>");
+            builder.append(TextUtils.htmlEncode(u.toString()));
+            builder.append("</uuid>");
+        }
+        builder.append("</uuids>\n");
+
+        builder.append("<profiletype>");
+        builder.append(getProfileType() == TOGGLE_TYPE ? "toggle" : "conditional");
+        builder.append("</profiletype>\n");
+
+        builder.append("<statusbar>");
+        builder.append(getStatusBarIndicator() ? "yes" : "no");
+        builder.append("</statusbar>\n");
+
+        builder.append("<screen-lock-mode>");
+        builder.append(mScreenLockMode);
+        builder.append("</screen-lock-mode>\n");
+
+        builder.append("<airplane-mode>");
+        builder.append(mAirplaneMode);
+        builder.append("</airplane-mode>\n");
+
+        for (ProfileGroup pGroup : profileGroups.values()) {
+            pGroup.getXmlString(builder, context);
+        }
+        for (StreamSettings sd : streams.values()) {
+            sd.getXmlString(builder, context);
+        }
+        for (ConnectionSettings cs : connections.values()) {
+            cs.getXmlString(builder, context);
+        }
+        for (VibratorSettings vs : vibrators.values()) {
+            vs.getXmlString(builder, context);
+        }
+        builder.append("</profile>\n");
+        mDirty = false;
+    }
+
+    private static List<UUID> readSecondaryUuidsFromXml(XmlPullParser xpp, Context context)
+            throws XmlPullParserException,
+            IOException {
+        ArrayList<UUID> uuids = new ArrayList<UUID>();
+        int event = xpp.next();
+        while (event != XmlPullParser.END_TAG || !xpp.getName().equals("uuids")) {
+            if (event == XmlPullParser.START_TAG) {
+                String name = xpp.getName();
+                if (name.equals("uuid")) {
+                    try {
+                        uuids.add(UUID.fromString(xpp.nextText()));
+                    } catch (NullPointerException e) {
+                        Log.w(TAG, "Null Pointer - invalid UUID");
+                    } catch (IllegalArgumentException e) {
+                        Log.w(TAG, "UUID not recognized");
+                    }
+                }
+            }
+            event = xpp.next();
+        }
+        return uuids;
+    }
+
+    /** @hide */
+    public static Profile fromXml(XmlPullParser xpp, Context context)
+            throws XmlPullParserException, IOException {
+        String value = xpp.getAttributeValue(null, "nameres");
+        int profileNameResId = -1;
+        String profileName = null;
+
+        if (value != null) {
+            profileNameResId = context.getResources().getIdentifier(value, "string", "android");
+            if (profileNameResId > 0) {
+                profileName = context.getResources().getString(profileNameResId);
+            }
+        }
+
+        if (profileName == null) {
+            profileName = xpp.getAttributeValue(null, "name");
+        }
+
+        UUID profileUuid = UUID.randomUUID();
+        try {
+            profileUuid = UUID.fromString(xpp.getAttributeValue(null, "uuid"));
+        } catch (NullPointerException e) {
+            Log.w(TAG,
+                    "Null Pointer - UUID not found for "
+                    + profileName
+                    + ".  New UUID generated: "
+                    + profileUuid.toString()
+                    );
+        } catch (IllegalArgumentException e) {
+            Log.w(TAG,
+                    "UUID not recognized for "
+                    + profileName
+                    + ".  New UUID generated: "
+                    + profileUuid.toString()
+                    );
+        }
+
+        Profile profile = new Profile(profileName, profileNameResId, profileUuid);
+        int event = xpp.next();
+        while (event != XmlPullParser.END_TAG) {
+            if (event == XmlPullParser.START_TAG) {
+                String name = xpp.getName();
+                if (name.equals("uuids")) {
+                    profile.setSecondaryUuids(readSecondaryUuidsFromXml(xpp, context));
+                }
+                if (name.equals("statusbar")) {
+                    profile.setStatusBarIndicator(xpp.nextText().equals("yes"));
+                }
+                if (name.equals("profiletype")) {
+                    profile.setProfileType(xpp.nextText().equals("toggle") ? TOGGLE_TYPE : CONDITIONAL_TYPE);
+                }
+                if (name.equals("screen-lock-mode")) {
+                    profile.setScreenLockMode(Integer.valueOf(xpp.nextText()));
+                }
+                if (name.equals("airplane-mode")) {
+                    profile.setAirplaneMode(Integer.valueOf(xpp.nextText()));
+                }
+                if (name.equals("profileGroup")) {
+                    ProfileGroup pg = ProfileGroup.fromXml(xpp, context);
+                    profile.addProfileGroup(pg);
+                }
+                if (name.equals("streamDescriptor")) {
+                    StreamSettings sd = StreamSettings.fromXml(xpp, context);
+                    profile.setStreamSettings(sd);
+                }
+                if (name.equals("connectionDescriptor")) {
+                    ConnectionSettings cs = ConnectionSettings.fromXml(xpp, context);
+                    profile.connections.put(cs.getConnectionId(), cs);
+                }
+                if (name.equals("vibratorDescriptor")) {
+                    VibratorSettings vs = VibratorSettings.fromXml(xpp, context);
+                    profile.setVibratorSettings(vs);
+                }
+            }
+            event = xpp.next();
+        }
+
+        /* we just loaded from XML, so nothing needs saving */
+        profile.mDirty = false;
+
+        return profile;
+    }
+
+    /** @hide */
+    public void doSelect(Context context) {
+        // Set stream volumes
+        AudioManager am = (AudioManager) context.getSystemService(Context.AUDIO_SERVICE);
+        for (StreamSettings sd : streams.values()) {
+            if (sd.isOverride()) {
+                am.setStreamVolume(sd.getStreamId(), sd.getValue(), 0);
+            }
+        }
+        // Set connections
+        for (ConnectionSettings cs : connections.values()) {
+            if (cs.isOverride()) {
+                cs.processOverride(context);
+            }
+        }
+        // Set vibrators
+        for (VibratorSettings vs : vibrators.values()) {
+            if (vs.isOverride()) {
+                vs.processOverride(context);
+            }
+        }
+        // Set airplane mode
+        doSelectAirplaneMode(context);
+    }
+
+    private void doSelectAirplaneMode(Context context) {
+        if (getAirplaneMode() != AirplaneMode.DEFAULT) {
+            int current = Settings.System.getInt(context.getContentResolver(), Settings.System.AIRPLANE_MODE_ON, 0);
+            int target = getAirplaneMode();
+            if (current == 1 && target == AirplaneMode.DISABLE || current == 0 && target == AirplaneMode.ENABLE) {
+                Settings.System.putInt(context.getContentResolver(), Settings.System.AIRPLANE_MODE_ON, 1 - current);
+                Intent intent = new Intent(Intent.ACTION_AIRPLANE_MODE_CHANGED);
+                intent.putExtra("state", target != AirplaneMode.DISABLE);
+                context.sendBroadcast(intent);
+            }
+        }
+    }
+
+    /** @hide */
+    public StreamSettings getSettingsForStream(int streamId){
+        return streams.get(streamId);
+    }
+
+    /** @hide */
+    public void setStreamSettings(StreamSettings descriptor){
+        streams.put(descriptor.getStreamId(), descriptor);
+        mDirty = true;
+    }
+
+    /** @hide */
+    public Collection<StreamSettings> getStreamSettings(){
+        return streams.values();
+    }
+
+    /** @hide */
+    public VibratorSettings getSettingsForVibrator(int vibratorId) {
+        return vibrators.get(vibratorId);
+    }
+
+    /** @hide */
+    public void setVibratorSettings(VibratorSettings descriptor) {
+        vibrators.put(descriptor.getVibratorId(), descriptor);
+        mDirty = true;
+    }
+
+    /** @hide */
+    public Collection<VibratorSettings> getVibratorSettings() {
+        return vibrators.values();
+    }
+
+    /** @hide */
+    public ConnectionSettings getSettingsForConnection(int connectionId){
+        return connections.get(connectionId);
+    }
+
+    /** @hide */
+    public void setConnectionSettings(ConnectionSettings descriptor){
+        connections.put(descriptor.getConnectionId(), descriptor);
+    }
+
+    /** @hide */
+    public Collection<ConnectionSettings> getConnectionSettings(){
+        return connections.values();
+    }
+
+}
diff --git a/core/java/android/app/ProfileGroup.java b/core/java/android/app/ProfileGroup.java
new file mode 100644
index 0000000..b3b70d6
--- /dev/null
+++ b/core/java/android/app/ProfileGroup.java
@@ -0,0 +1,348 @@
+/*
+ * Copyright (C) 2011 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package android.app;
+
+import org.xmlpull.v1.XmlPullParser;
+import org.xmlpull.v1.XmlPullParserException;
+
+import android.content.Context;
+import android.media.RingtoneManager;
+import android.net.Uri;
+import android.os.Parcel;
+import android.os.Parcelable;
+import android.os.ParcelUuid;
+import android.text.TextUtils;
+import android.util.Log;
+
+import java.io.IOException;
+import java.util.UUID;
+
+/**
+ * @hide
+ */
+public final class ProfileGroup implements Parcelable {
+    private static final String TAG = "ProfileGroup";
+
+    private String mName;
+    private int mNameResId;
+
+    private UUID mUuid;
+
+    private Uri mSoundOverride = RingtoneManager.getDefaultUri(RingtoneManager.TYPE_NOTIFICATION);
+    private Uri mRingerOverride = RingtoneManager.getDefaultUri(RingtoneManager.TYPE_RINGTONE);
+
+    private Mode mSoundMode = Mode.DEFAULT;
+    private Mode mRingerMode = Mode.DEFAULT;
+    private Mode mVibrateMode = Mode.DEFAULT;
+    private Mode mLightsMode = Mode.DEFAULT;
+
+    private boolean mDefaultGroup = false;
+    private boolean mDirty;
+
+    /** @hide */
+    public static final Parcelable.Creator<ProfileGroup> CREATOR = new Parcelable.Creator<ProfileGroup>() {
+        public ProfileGroup createFromParcel(Parcel in) {
+            return new ProfileGroup(in);
+        }
+
+        @Override
+        public ProfileGroup[] newArray(int size) {
+            return new ProfileGroup[size];
+        }
+    };
+
+    /** @hide */
+    public ProfileGroup(UUID uuid, boolean defaultGroup) {
+        this(null, uuid, defaultGroup);
+    }
+
+    private ProfileGroup(String name, UUID uuid, boolean defaultGroup) {
+        mName = name;
+        mUuid = (uuid != null) ? uuid : UUID.randomUUID();
+        mDefaultGroup = defaultGroup;
+        mDirty = uuid == null;
+    }
+
+    /** @hide */
+    private ProfileGroup(Parcel in) {
+        readFromParcel(in);
+    }
+
+    /** @hide */
+    public boolean matches(NotificationGroup group, boolean defaultGroup) {
+        if (mUuid.equals(group.getUuid())) {
+            return true;
+        }
+
+        /* fallback matches for backwards compatibility */
+        boolean matches = false;
+
+        /* fallback attempt 1: match name */
+        if (mName != null && mName.equals(group.getName())) {
+            matches = true;
+        /* fallback attempt 2: match for the 'defaultGroup' flag to match the wildcard group */
+        } else if (mDefaultGroup && defaultGroup) {
+            matches = true;
+        }
+
+        if (!matches) {
+            return false;
+        }
+
+        mName = null;
+        mUuid = group.getUuid();
+        mDirty = true;
+
+        return true;
+    }
+
+    public UUID getUuid() {
+        return mUuid;
+    }
+
+    public boolean isDefaultGroup() {
+        return mDefaultGroup;
+    }
+
+    /** @hide */
+    public boolean isDirty() {
+        return mDirty;
+    }
+
+    /** @hide */
+    public void setSoundOverride(Uri sound) {
+        mSoundOverride = sound;
+        mDirty = true;
+    }
+
+    public Uri getSoundOverride() {
+        return mSoundOverride;
+    }
+
+    /** @hide */
+    public void setRingerOverride(Uri ringer) {
+        mRingerOverride = ringer;
+        mDirty = true;
+    }
+
+    public Uri getRingerOverride() {
+        return mRingerOverride;
+    }
+
+    /** @hide */
+    public void setSoundMode(Mode soundMode) {
+        mSoundMode = soundMode;
+        mDirty = true;
+    }
+
+    public Mode getSoundMode() {
+        return mSoundMode;
+    }
+
+    /** @hide */
+    public void setRingerMode(Mode ringerMode) {
+        mRingerMode = ringerMode;
+        mDirty = true;
+    }
+
+    public Mode getRingerMode() {
+        return mRingerMode;
+    }
+
+    /** @hide */
+    public void setVibrateMode(Mode vibrateMode) {
+        mVibrateMode = vibrateMode;
+        mDirty = true;
+    }
+
+    public Mode getVibrateMode() {
+        return mVibrateMode;
+    }
+
+    /** @hide */
+    public void setLightsMode(Mode lightsMode) {
+        mLightsMode = lightsMode;
+        mDirty = true;
+    }
+
+    public Mode getLightsMode() {
+        return mLightsMode;
+    }
+
+    // TODO : add support for LEDs / screen etc.
+
+    /** @hide */
+    public Notification processNotification(Notification notification) {
+
+        switch (mSoundMode) {
+            case OVERRIDE:
+                notification.sound = mSoundOverride;
+                break;
+            case SUPPRESS:
+                silenceNotification(notification);
+                break;
+            case DEFAULT:
+        }
+        switch (mVibrateMode) {
+            case OVERRIDE:
+                notification.defaults |= Notification.DEFAULT_VIBRATE;
+                break;
+            case SUPPRESS:
+                suppressVibrate(notification);
+                break;
+            case DEFAULT:
+        }
+        switch (mLightsMode) {
+            case OVERRIDE:
+                notification.defaults |= Notification.DEFAULT_LIGHTS;
+                break;
+            case SUPPRESS:
+                suppressLights(notification);
+                break;
+            case DEFAULT:
+        }
+        return notification;
+    }
+
+    private void silenceNotification(Notification notification) {
+        notification.defaults &= (~Notification.DEFAULT_SOUND);
+        notification.sound = null;
+    }
+
+    private void suppressVibrate(Notification notification) {
+        notification.defaults &= (~Notification.DEFAULT_VIBRATE);
+        notification.vibrate = null;
+    }
+
+    private void suppressLights(Notification notification) {
+        notification.defaults &= (~Notification.DEFAULT_LIGHTS);
+        notification.flags &= (~Notification.FLAG_SHOW_LIGHTS);
+    }
+
+    /** @hide */
+    @Override
+    public int describeContents() {
+        return 0;
+    }
+
+    /** @hide */
+    @Override
+    public void writeToParcel(Parcel dest, int flags) {
+        dest.writeString(mName);
+        new ParcelUuid(mUuid).writeToParcel(dest, 0);
+        dest.writeInt(mDefaultGroup ? 1 : 0);
+        dest.writeInt(mDirty ? 1 : 0);
+        dest.writeParcelable(mSoundOverride, flags);
+        dest.writeParcelable(mRingerOverride, flags);
+
+        dest.writeString(mSoundMode.name());
+        dest.writeString(mRingerMode.name());
+        dest.writeString(mVibrateMode.name());
+        dest.writeString(mLightsMode.name());
+    }
+
+    /** @hide */
+    public void readFromParcel(Parcel in) {
+        mName = in.readString();
+        mUuid = ParcelUuid.CREATOR.createFromParcel(in).getUuid();
+        mDefaultGroup = in.readInt() != 0;
+        mDirty = in.readInt() != 0;
+        mSoundOverride = in.readParcelable(null);
+        mRingerOverride = in.readParcelable(null);
+
+        mSoundMode = Mode.valueOf(Mode.class, in.readString());
+        mRingerMode = Mode.valueOf(Mode.class, in.readString());
+        mVibrateMode = Mode.valueOf(Mode.class, in.readString());
+        mLightsMode = Mode.valueOf(Mode.class, in.readString());
+    }
+
+    public enum Mode {
+        SUPPRESS, DEFAULT, OVERRIDE;
+    }
+
+    /** @hide */
+    public void getXmlString(StringBuilder builder, Context context) {
+        builder.append("<profileGroup uuid=\"");
+        builder.append(TextUtils.htmlEncode(mUuid.toString()));
+        if (mName != null) {
+            builder.append("\" name=\"");
+            builder.append(mName);
+        }
+        builder.append("\" default=\"");
+        builder.append(isDefaultGroup());
+        builder.append("\">\n<sound>");
+        builder.append(TextUtils.htmlEncode(mSoundOverride.toString()));
+        builder.append("</sound>\n<ringer>");
+        builder.append(TextUtils.htmlEncode(mRingerOverride.toString()));
+        builder.append("</ringer>\n<soundMode>");
+        builder.append(mSoundMode);
+        builder.append("</soundMode>\n<ringerMode>");
+        builder.append(mRingerMode);
+        builder.append("</ringerMode>\n<vibrateMode>");
+        builder.append(mVibrateMode);
+        builder.append("</vibrateMode>\n<lightsMode>");
+        builder.append(mLightsMode);
+        builder.append("</lightsMode>\n</profileGroup>\n");
+        mDirty = false;
+    }
+
+    /** @hide */
+    public static ProfileGroup fromXml(XmlPullParser xpp, Context context)
+            throws XmlPullParserException, IOException {
+        String name = xpp.getAttributeValue(null, "name");
+        UUID uuid = null;
+        String value = xpp.getAttributeValue(null, "uuid");
+
+        if (value != null) {
+            try {
+                uuid = UUID.fromString(value);
+            } catch (IllegalArgumentException e) {
+                Log.w(TAG, "UUID not recognized for " + name + ", using new one.");
+            }
+        }
+
+        value = xpp.getAttributeValue(null, "default");
+        boolean defaultGroup = TextUtils.equals(value, "true");
+
+        ProfileGroup profileGroup = new ProfileGroup(name, uuid, defaultGroup);
+        int event = xpp.next();
+        while (event != XmlPullParser.END_TAG || !xpp.getName().equals("profileGroup")) {
+            if (event == XmlPullParser.START_TAG) {
+                name = xpp.getName();
+                if (name.equals("sound")) {
+                    profileGroup.setSoundOverride(Uri.parse(xpp.nextText()));
+                } else if (name.equals("ringer")) {
+                    profileGroup.setRingerOverride(Uri.parse(xpp.nextText()));
+                } else if (name.equals("soundMode")) {
+                    profileGroup.setSoundMode(Mode.valueOf(xpp.nextText()));
+                } else if (name.equals("ringerMode")) {
+                    profileGroup.setRingerMode(Mode.valueOf(xpp.nextText()));
+                } else if (name.equals("vibrateMode")) {
+                    profileGroup.setVibrateMode(Mode.valueOf(xpp.nextText()));
+                } else if (name.equals("lightsMode")) {
+                    profileGroup.setLightsMode(Mode.valueOf(xpp.nextText()));
+                }
+            }
+            event = xpp.next();
+        }
+
+        /* we just loaded from XML, no need to save */
+        profileGroup.mDirty = false;
+
+        return profileGroup;
+    }
+}
diff --git a/core/java/android/app/ProfileManager.java b/core/java/android/app/ProfileManager.java
new file mode 100644
index 0000000..4a0f1b7
--- /dev/null
+++ b/core/java/android/app/ProfileManager.java
@@ -0,0 +1,260 @@
+/*
+ * Copyright (C) 2011 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package android.app;
+
+import java.util.UUID;
+
+import android.content.Context;
+import android.os.Handler;
+import android.os.IBinder;
+import android.os.ParcelUuid;
+import android.os.RemoteException;
+import android.os.ServiceManager;
+import android.util.Log;
+
+/**
+ * @hide
+ */
+public class ProfileManager {
+
+    private static IProfileManager sService;
+
+    private Context mContext;
+
+    private static final String TAG = "ProfileManager";
+
+    /** @hide */
+    static public IProfileManager getService() {
+        if (sService != null) {
+            return sService;
+        }
+        IBinder b = ServiceManager.getService(Context.PROFILE_SERVICE);
+        sService = IProfileManager.Stub.asInterface(b);
+        return sService;
+    }
+
+    /** @hide */
+    ProfileManager(Context context, Handler handler) {
+        mContext = context;
+    }
+
+    @Deprecated
+    public void setActiveProfile(String profileName) {
+        try {
+            getService().setActiveProfileByName(profileName);
+        } catch (RemoteException e) {
+            Log.e(TAG, e.getLocalizedMessage(), e);
+        }
+    }
+
+    public void setActiveProfile(UUID profileUuid) {
+        try {
+            getService().setActiveProfile(new ParcelUuid(profileUuid));
+        } catch (RemoteException e) {
+            Log.e(TAG, e.getLocalizedMessage(), e);
+        }
+    }
+
+    public Profile getActiveProfile() {
+        try {
+            return getService().getActiveProfile();
+        } catch (RemoteException e) {
+            Log.e(TAG, e.getLocalizedMessage(), e);
+        }
+        return null;
+    }
+
+    /** @hide */
+    public void addProfile(Profile profile) {
+        try {
+            getService().addProfile(profile);
+        } catch (RemoteException e) {
+            Log.e(TAG, e.getLocalizedMessage(), e);
+        }
+    }
+
+    /** @hide */
+    public void removeProfile(Profile profile) {
+        try {
+            getService().removeProfile(profile);
+        } catch (RemoteException e) {
+            Log.e(TAG, e.getLocalizedMessage(), e);
+        }
+    }
+
+    /** @hide */
+    public void updateProfile(Profile profile) {
+        try {
+            getService().updateProfile(profile);
+        } catch (RemoteException e) {
+            Log.e(TAG, e.getLocalizedMessage(), e);
+        }
+    }
+
+    @Deprecated
+    public Profile getProfile(String profileName) {
+        try {
+            return getService().getProfileByName(profileName);
+        } catch (RemoteException e) {
+            Log.e(TAG, e.getLocalizedMessage(), e);
+        }
+        return null;
+    }
+
+    public Profile getProfile(UUID profileUuid) {
+        try {
+            return getService().getProfile(new ParcelUuid(profileUuid));
+        } catch (RemoteException e) {
+            Log.e(TAG, e.getLocalizedMessage(), e);
+        }
+        return null;
+    }
+
+    public String[] getProfileNames() {
+        try {
+            Profile[] profiles = getService().getProfiles();
+            String[] names = new String[profiles.length];
+            for (int i = 0; i < profiles.length; i++) {
+                names[i] = profiles[i].getName();
+            }
+            return names;
+        } catch (RemoteException e) {
+            Log.e(TAG, e.getLocalizedMessage(), e);
+        }
+        return null;
+    }
+
+    public Profile[] getProfiles() {
+        try {
+            return getService().getProfiles();
+        } catch (RemoteException e) {
+            Log.e(TAG, e.getLocalizedMessage(), e);
+        }
+        return null;
+    }
+
+    public boolean profileExists(String profileName) {
+        try {
+            return getService().profileExistsByName(profileName);
+        } catch (RemoteException e) {
+            Log.e(TAG, e.getLocalizedMessage(), e);
+            // To be on the safe side, we'll return "true", to prevent duplicate profiles
+            // from being created.
+            return true;
+        }
+    }
+
+    public boolean profileExists(UUID profileUuid) {
+        try {
+            return getService().profileExists(new ParcelUuid(profileUuid));
+        } catch (RemoteException e) {
+            Log.e(TAG, e.getLocalizedMessage(), e);
+            // To be on the safe side, we'll return "true", to prevent duplicate profiles
+            // from being created.
+            return true;
+        }
+    }
+
+    public boolean notificationGroupExists(String notificationGroupName) {
+        try {
+            return getService().notificationGroupExistsByName(notificationGroupName);
+        } catch (RemoteException e) {
+            Log.e(TAG, e.getLocalizedMessage(), e);
+            // To be on the safe side, we'll return "true", to prevent duplicate notification
+            // groups from being created.
+            return true;
+        }
+    }
+
+    /** @hide */
+    public NotificationGroup[] getNotificationGroups() {
+        try {
+            return getService().getNotificationGroups();
+        } catch (RemoteException e) {
+            Log.e(TAG, e.getLocalizedMessage(), e);
+        }
+        return null;
+    }
+
+    /** @hide */
+    public void addNotificationGroup(NotificationGroup group) {
+        try {
+            getService().addNotificationGroup(group);
+        } catch (RemoteException e) {
+            Log.e(TAG, e.getLocalizedMessage(), e);
+        }
+    }
+
+    /** @hide */
+    public void removeNotificationGroup(NotificationGroup group) {
+        try {
+            getService().removeNotificationGroup(group);
+        } catch (RemoteException e) {
+            Log.e(TAG, e.getLocalizedMessage(), e);
+        }
+    }
+
+    /** @hide */
+    public void updateNotificationGroup(NotificationGroup group) {
+        try {
+            getService().updateNotificationGroup(group);
+        } catch (RemoteException e) {
+            Log.e(TAG, e.getLocalizedMessage(), e);
+        }
+    }
+
+    /** @hide */
+    public NotificationGroup getNotificationGroupForPackage(String pkg) {
+        try {
+            return getService().getNotificationGroupForPackage(pkg);
+        } catch (RemoteException e) {
+            Log.e(TAG, e.getLocalizedMessage(), e);
+        }
+        return null;
+    }
+
+    /** @hide */
+    public NotificationGroup getNotificationGroup(UUID uuid) {
+        try {
+            return getService().getNotificationGroup(new ParcelUuid(uuid));
+        } catch (RemoteException e) {
+            Log.e(TAG, e.getLocalizedMessage(), e);
+        }
+        return null;
+    }
+
+    /** @hide */
+    public ProfileGroup getActiveProfileGroup(String packageName) {
+        NotificationGroup notificationGroup = getNotificationGroupForPackage(packageName);
+        if(notificationGroup == null){
+            ProfileGroup defaultGroup = getActiveProfile().getDefaultGroup();
+            return defaultGroup;
+        }
+        return getActiveProfile().getProfileGroup(notificationGroup.getUuid());
+    }
+
+    /** @hide */
+    public void resetAll() {
+        try {
+            getService().resetAll();
+        } catch (RemoteException e) {
+            Log.e(TAG, e.getLocalizedMessage(), e);
+        } catch (SecurityException e) {
+            Log.e(TAG, e.getLocalizedMessage(), e);
+        }
+    }
+}
diff --git a/core/java/android/app/StreamSettings.java b/core/java/android/app/StreamSettings.java
new file mode 100644
index 0000000..2f3bf27
--- /dev/null
+++ b/core/java/android/app/StreamSettings.java
@@ -0,0 +1,130 @@
+
+package android.app;
+
+import org.xmlpull.v1.XmlPullParser;
+import org.xmlpull.v1.XmlPullParserException;
+
+import android.content.Context;
+import android.os.Parcel;
+import android.os.Parcelable;
+
+import java.io.IOException;
+
+/** @hide */
+public final class StreamSettings implements Parcelable{
+
+    private int mStreamId;
+    private int mValue;
+    private boolean mOverride;
+    private boolean mDirty;
+
+    /** @hide */
+    public static final Parcelable.Creator<StreamSettings> CREATOR = new Parcelable.Creator<StreamSettings>() {
+        public StreamSettings createFromParcel(Parcel in) {
+            return new StreamSettings(in);
+        }
+
+        @Override
+        public StreamSettings[] newArray(int size) {
+            return new StreamSettings[size];
+        }
+    };
+
+
+    public StreamSettings(Parcel parcel) {
+        readFromParcel(parcel);
+    }
+
+    public StreamSettings(int streamId) {
+        this(streamId, 0, false);
+    }
+
+    public StreamSettings(int streamId, int value, boolean override) {
+        mStreamId = streamId;
+        mValue = value;
+        mOverride = override;
+        mDirty = false;
+    }
+
+    public int getStreamId() {
+        return mStreamId;
+    }
+
+    public int getValue() {
+        return mValue;
+    }
+
+    public void setValue(int value) {
+        mValue = value;
+        mDirty = true;
+    }
+
+    public void setOverride(boolean override) {
+        mOverride = override;
+        mDirty = true;
+    }
+
+    public boolean isOverride() {
+        return mOverride;
+    }
+
+    /** @hide */
+    public boolean isDirty() {
+        return mDirty;
+    }
+
+    /** @hide */
+    public static StreamSettings fromXml(XmlPullParser xpp, Context context)
+            throws XmlPullParserException, IOException {
+        int event = xpp.next();
+        StreamSettings streamDescriptor = new StreamSettings(0);
+        while (event != XmlPullParser.END_TAG || !xpp.getName().equals("streamDescriptor")) {
+            if (event == XmlPullParser.START_TAG) {
+                String name = xpp.getName();
+                if (name.equals("streamId")) {
+                    streamDescriptor.mStreamId = Integer.parseInt(xpp.nextText());
+                } else if (name.equals("value")) {
+                    streamDescriptor.mValue = Integer.parseInt(xpp.nextText());
+                } else if (name.equals("override")) {
+                    streamDescriptor.mOverride = Boolean.parseBoolean(xpp.nextText());
+                }
+            }
+            event = xpp.next();
+        }
+        return streamDescriptor;
+    }
+
+    /** @hide */
+    public void getXmlString(StringBuilder builder, Context context) {
+        builder.append("<streamDescriptor>\n<streamId>");
+        builder.append(mStreamId);
+        builder.append("</streamId>\n<value>");
+        builder.append(mValue);
+        builder.append("</value>\n<override>");
+        builder.append(mOverride);
+        builder.append("</override>\n</streamDescriptor>\n");
+        mDirty = false;
+    }
+
+    @Override
+    public int describeContents() {
+        return 0;
+    }
+
+    /** @hide */
+    @Override
+    public void writeToParcel(Parcel dest, int flags) {
+        dest.writeInt(mStreamId);
+        dest.writeInt(mOverride ? 1 : 0);
+        dest.writeInt(mValue);
+        dest.writeInt(mDirty ? 1 : 0);
+    }
+
+    /** @hide */
+    public void readFromParcel(Parcel in) {
+        mStreamId = in.readInt();
+        mOverride = in.readInt() != 0;
+        mValue = in.readInt();
+        mDirty = in.readInt() != 0;
+    }
+}
diff --git a/core/java/android/app/VibratorSettings.java b/core/java/android/app/VibratorSettings.java
new file mode 100644
index 0000000..10e5ca2
--- /dev/null
+++ b/core/java/android/app/VibratorSettings.java
@@ -0,0 +1,150 @@
+
+package android.app;
+
+import org.xmlpull.v1.XmlPullParser;
+import org.xmlpull.v1.XmlPullParserException;
+
+import android.content.Context;
+import android.media.AudioManager;
+import android.os.Parcel;
+import android.os.Parcelable;
+
+import java.io.IOException;
+
+/** @hide */
+public final class VibratorSettings implements Parcelable{
+
+    public static final int OFF = 0;
+    public static final int SILENT = 1;
+    public static final int ON = 2;
+
+    private int mVibratorId;
+    private int mValue;
+    private boolean mOverride;
+    private boolean mDirty;
+
+    /** @hide */
+    public static final Parcelable.Creator<VibratorSettings> CREATOR = new Parcelable.Creator<VibratorSettings>() {
+        public VibratorSettings createFromParcel(Parcel in) {
+            return new VibratorSettings(in);
+        }
+
+        @Override
+        public VibratorSettings[] newArray(int size) {
+            return new VibratorSettings[size];
+        }
+    };
+
+
+    public VibratorSettings(Parcel parcel) {
+        readFromParcel(parcel);
+    }
+
+    public VibratorSettings(int vibratorId) {
+        this(vibratorId, 0, false);
+    }
+
+    public VibratorSettings(int vibratorId, int value, boolean override) {
+        mVibratorId = vibratorId;
+        mValue = value;
+        mOverride = override;
+        mDirty = false;
+    }
+
+    public int getVibratorId() {
+        return mVibratorId;
+    }
+
+    public int getValue() {
+        return mValue;
+    }
+
+    public void setValue(int value) {
+        mValue = value;
+        mDirty = true;
+    }
+
+    public void setOverride(boolean override) {
+        mOverride = override;
+        mDirty = true;
+    }
+
+    public boolean isOverride() {
+        return mOverride;
+    }
+
+    /** @hide */
+    public boolean isDirty() {
+        return mDirty;
+    }
+
+    /** @hide */
+    public static VibratorSettings fromXml(XmlPullParser xpp, Context context)
+            throws XmlPullParserException, IOException {
+        int event = xpp.next();
+        VibratorSettings vibratorDescriptor = new VibratorSettings(0);
+        while (event != XmlPullParser.END_TAG || !xpp.getName().equals("vibratorDescriptor")) {
+            if (event == XmlPullParser.START_TAG) {
+                String name = xpp.getName();
+                if (name.equals("vibratorId")) {
+                    vibratorDescriptor.mVibratorId = Integer.parseInt(xpp.nextText());
+                } else if (name.equals("value")) {
+                    vibratorDescriptor.mValue = Integer.parseInt(xpp.nextText());
+                } else if (name.equals("override")) {
+                    vibratorDescriptor.mOverride = Boolean.parseBoolean(xpp.nextText());
+                }
+            }
+            event = xpp.next();
+        }
+        return vibratorDescriptor;
+    }
+
+    /** @hide */
+    public void getXmlString(StringBuilder builder, Context context) {
+        builder.append("<vibratorDescriptor>\n<vibratorId>");
+        builder.append(mVibratorId);
+        builder.append("</vibratorId>\n<value>");
+        builder.append(mValue);
+        builder.append("</value>\n<override>");
+        builder.append(mOverride);
+        builder.append("</override>\n</vibratorDescriptor>\n");
+        mDirty = false;
+    }
+
+    @Override
+    public int describeContents() {
+        return 0;
+    }
+
+    /** @hide */
+    @Override
+    public void writeToParcel(Parcel dest, int flags) {
+        dest.writeInt(mVibratorId);
+        dest.writeInt(mOverride ? 1 : 0);
+        dest.writeInt(mValue);
+        dest.writeInt(mDirty ? 1 : 0);
+    }
+
+    /** @hide */
+    public void readFromParcel(Parcel in) {
+        mVibratorId = in.readInt();
+        mOverride = in.readInt() != 0;
+        mValue = in.readInt();
+        mDirty = in.readInt() != 0;
+    }
+
+    /** @hide */
+    public void processOverride(Context context) {
+        AudioManager amgr = (AudioManager) context.getSystemService(Context.AUDIO_SERVICE);
+        switch (mValue) {
+        case OFF:
+            amgr.setVibrateSetting(mVibratorId, AudioManager.VIBRATE_SETTING_OFF);
+            break;
+        case SILENT:
+            amgr.setVibrateSetting(mVibratorId, AudioManager.VIBRATE_SETTING_ONLY_SILENT);
+        default:
+            amgr.setVibrateSetting(mVibratorId, AudioManager.VIBRATE_SETTING_ON);
+            break;
+        }
+    }
+}
diff --git a/core/java/android/bluetooth/BluetoothUuid.java b/core/java/android/bluetooth/BluetoothUuid.java
index 5962235..1a0bd02 100644
--- a/core/java/android/bluetooth/BluetoothUuid.java
+++ b/core/java/android/bluetooth/BluetoothUuid.java
@@ -56,6 +56,10 @@ public final class BluetoothUuid {
             ParcelUuid.fromString("00001105-0000-1000-8000-00805f9b34fb");
     public static final ParcelUuid Hid =
             ParcelUuid.fromString("00001124-0000-1000-8000-00805f9b34fb");
+    public static final ParcelUuid MessageAccessServer =
+            ParcelUuid.fromString("00001132-0000-1000-8000-00805f9b34fb");
+    public static final ParcelUuid MessageNotificationServer =
+            ParcelUuid.fromString("00001133-0000-1000-8000-00805f9b34fb");
     public static final ParcelUuid PANU =
             ParcelUuid.fromString("00001115-0000-1000-8000-00805F9B34FB");
     public static final ParcelUuid NAP =
@@ -67,7 +71,7 @@ public final class BluetoothUuid {
 
     public static final ParcelUuid[] RESERVED_UUIDS = {
         AudioSink, AudioSource, AdvAudioDist, HSP, Handsfree, AvrcpController, AvrcpTarget,
-        ObexObjectPush, PANU, NAP};
+        ObexObjectPush, MessageAccessServer, MessageNotificationServer, PANU, NAP};
 
     public static boolean isAudioSource(ParcelUuid uuid) {
         return uuid.equals(AudioSource);
@@ -131,6 +135,14 @@ public final class BluetoothUuid {
         return false;
     }
 
+    public static boolean isMessageAccessServer(ParcelUuid uuid) {
+        return uuid.equals(MessageAccessServer);
+    }
+
+    public static boolean isMessageNotificationServer(ParcelUuid uuid) {
+        return uuid.equals(MessageNotificationServer);
+    }
+
     /**
      * Returns true if there any common ParcelUuids in uuidA and uuidB.
      *
diff --git a/core/java/android/bluetooth/HeadsetBase.java b/core/java/android/bluetooth/HeadsetBase.java
index 9ef2eb5..1374377 100644
--- a/core/java/android/bluetooth/HeadsetBase.java
+++ b/core/java/android/bluetooth/HeadsetBase.java
@@ -109,6 +109,12 @@ public final class HeadsetBase {
 
     private native void initializeNativeDataNative(int socketFd);
 
+    // interface for dealing with special input situations
+    public interface SpecialPDUInputHandler {
+        void handleInput(String input);
+    }
+    public SpecialPDUInputHandler specialPDUInputHandler = null;
+
     /* Process an incoming AT command line
      */
     protected void handleInput(String input) {
@@ -122,7 +128,6 @@ public final class HeadsetBase {
                 sAtInputCount++;
             }
         }
-
         if (DBG) timestamp = System.currentTimeMillis();
         AtCommandResult result = mAtParser.process(input);
         if (DBG) Log.d(TAG, "Processing " + input + " took " +
@@ -158,10 +163,19 @@ public final class HeadsetBase {
                 public void run() {
                     int last_read_error;
                     while (!mEventThreadInterrupted) {
-                        String input = readNative(500);
-                        if (input != null) {
-                            handleInput(input);
+                        String input;
+                        if (null == specialPDUInputHandler) {
+                            input = readNative(500);
+                            if (input != null) {
+                                handleInput(input);
+                            }
                         } else {
+                            input = readNativePDUStream((500));
+                            if (input != null) {
+                                specialPDUInputHandler.handleInput(input);
+                            }
+                        }
+                        if (null == input) {
                             last_read_error = getLastReadStatusNative();
                             if (last_read_error != 0) {
                                 Log.i(TAG, "headset read error " + last_read_error);
@@ -181,6 +195,7 @@ public final class HeadsetBase {
     }
 
     private native String readNative(int timeout_ms);
+    private native String readNativePDUStream(int timeout_ms);
     private native int getLastReadStatusNative();
 
     private void stopEventThread() {
@@ -276,6 +291,15 @@ public final class HeadsetBase {
     }
     private native boolean sendURCNative(String urc);
 
+    public synchronized boolean sendURCChars(String urc) {
+        if (urc.length() > 0) {
+            boolean ret = sendURCNativeChars(urc);
+            return ret;
+        }
+        return true;
+    }
+    private native boolean sendURCNativeChars(String urc);
+
     private synchronized void acquireWakeLock() {
         if (!mWakeLock.isHeld()) {
             mWakeLock.acquire();
diff --git a/core/java/android/content/ContentResolver.java b/core/java/android/content/ContentResolver.java
index cc3219b..073eb76 100644
--- a/core/java/android/content/ContentResolver.java
+++ b/core/java/android/content/ContentResolver.java
@@ -38,6 +38,9 @@ import android.os.RemoteException;
 import android.os.ServiceManager;
 import android.os.StrictMode;
 import android.os.SystemClock;
+// BEGIN privacy-added
+import android.privacy.surrogate.PrivacyContentResolver;
+// END privacy-added
 import android.text.TextUtils;
 import android.util.EventLog;
 import android.util.Log;
@@ -184,6 +187,11 @@ public abstract class ContentResolver {
         mContext = context;
     }
 
+     /** @hide */
+    public final Context getContext() {
+        return mContext;
+    }
+
     /** @hide */
     protected abstract IContentProvider acquireProvider(Context c, String name);
     /** Providing a default implementation of this, to avoid having to change
@@ -309,6 +317,10 @@ public abstract class ContentResolver {
         try {
             long startTime = SystemClock.uptimeMillis();
             Cursor qCursor = provider.query(uri, projection, selection, selectionArgs, sortOrder);
+            // BEGIN privacy-added
+//            qCursor = PrivacyContentResolver.enforcePrivacyPermission(uri, mContext, qCursor);
+            qCursor = PrivacyContentResolver.enforcePrivacyPermission(uri, projection, mContext, qCursor);
+            // END privacy-added
             if (qCursor == null) {
                 releaseProvider(provider);
                 return null;
diff --git a/core/java/android/content/ContentService.java b/core/java/android/content/ContentService.java
index 0e83dc0..716a2c6 100644
--- a/core/java/android/content/ContentService.java
+++ b/core/java/android/content/ContentService.java
@@ -177,6 +177,7 @@ public final class ContentService extends IContentService.Stub {
                 ObserverCall oc = calls.get(i);
                 try {
                     oc.mObserver.onChange(oc.mSelfNotify);
+                    oc.mObserver.onChangeUri(uri, oc.mSelfNotify);
                     if (Log.isLoggable(TAG, Log.VERBOSE)) {
                         Log.v(TAG, "Notified " + oc.mObserver + " of " + "update at " + uri);
                     }
diff --git a/core/java/android/content/Context.java b/core/java/android/content/Context.java
index bfbd0ac..0d0402e 100644
--- a/core/java/android/content/Context.java
+++ b/core/java/android/content/Context.java
@@ -1513,6 +1513,18 @@ public abstract class Context {
 
     /**
      * Use with {@link #getSystemService} to retrieve a
+     * {@link android.app.ProfileManager} for setting
+     * notification profiles.
+     *
+     * @see #getSystemService
+     * @see android.app.ProfileManager
+     *
+     * @hide
+     */
+    public static final String PROFILE_SERVICE = "profile";
+
+    /**
+     * Use with {@link #getSystemService} to retrieve a
      * {@link android.view.accessibility.AccessibilityManager} for giving the user
      * feedback for UI events through the registered event listeners.
      *
diff --git a/core/java/android/content/Intent.java b/core/java/android/content/Intent.java
index 34966bb..af6f3b3 100644
--- a/core/java/android/content/Intent.java
+++ b/core/java/android/content/Intent.java
@@ -1,5 +1,6 @@
 /*
  * Copyright (C) 2006 The Android Open Source Project
+ * This code has been modified.  Portions copyright (C) 2010, T-Mobile USA, Inc.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -2140,6 +2141,19 @@ public class Intent implements Parcelable, Cloneable {
     public static final String ACTION_PRE_BOOT_COMPLETED =
             "android.intent.action.PRE_BOOT_COMPLETED";
 
+    /**
+     * Broadcast Action: Indicate that unrecoverable error happened during app launch.
+     * Could indicate that curently applied theme is malicious.
+     * @hide
+     */
+    public static final String ACTION_APP_LAUNCH_FAILURE = "com.tmobile.intent.action.APP_LAUNCH_FAILURE";
+
+    /**
+     * Broadcast Action: Request to reset the unrecoverable errors count to 0.
+     * @hide
+     */
+    public static final String ACTION_APP_LAUNCH_FAILURE_RESET = "com.tmobile.intent.action.APP_LAUNCH_FAILURE_RESET";
+
     // ---------------------------------------------------------------------
     // ---------------------------------------------------------------------
     // Standard intent categories (see addCategory()).
@@ -2272,6 +2286,7 @@ public class Intent implements Parcelable, Cloneable {
      */
     public static final String CATEGORY_FRAMEWORK_INSTRUMENTATION_TEST =
             "android.intent.category.FRAMEWORK_INSTRUMENTATION_TEST";
+
     /**
      * An activity to run when device is inserted into a car dock.
      * Used with {@link #ACTION_MAIN} to launch an activity.  For more
@@ -2308,6 +2323,14 @@ public class Intent implements Parcelable, Cloneable {
     @SdkConstant(SdkConstantType.INTENT_CATEGORY)
     public static final String CATEGORY_CAR_MODE = "android.intent.category.CAR_MODE";
 
+    /**
+     * Used to indicate that a theme package has been installed or un-installed.
+     *
+     * @hide
+     */
+    public static final String CATEGORY_THEME_PACKAGE_INSTALLED_STATE_CHANGE =
+            "com.tmobile.intent.category.THEME_PACKAGE_INSTALL_STATE_CHANGE";
+
     // ---------------------------------------------------------------------
     // ---------------------------------------------------------------------
     // Application launch intent categories (see addCategory()).
diff --git a/core/java/android/content/SyncManager.java b/core/java/android/content/SyncManager.java
index 3c4e545..e7c6222 100644
--- a/core/java/android/content/SyncManager.java
+++ b/core/java/android/content/SyncManager.java
@@ -17,6 +17,7 @@
 package android.content;
 
 import com.android.internal.R;
+import com.android.internal.app.ThemeUtils;
 import com.android.internal.util.ArrayUtils;
 import com.google.android.collect.Lists;
 import com.google.android.collect.Maps;
@@ -131,6 +132,7 @@ public class SyncManager implements OnAccountsUpdateListener {
     private static final int MAX_SIMULTANEOUS_INITIALIZATION_SYNCS;
 
     private Context mContext;
+    private Context mUiContext;
 
     private volatile Account[] mAccounts = INITIAL_ACCOUNTS_ARRAY;
 
@@ -183,6 +185,12 @@ public class SyncManager implements OnAccountsUpdateListener {
         }
     };
 
+    private BroadcastReceiver mThemeChangeReceiver = new BroadcastReceiver() {
+        public void onReceive(Context context, Intent intent) {
+            mUiContext = null;
+        }
+    };
+
     private BroadcastReceiver mBackgroundDataSettingChanged = new BroadcastReceiver() {
         public void onReceive(Context context, Intent intent) {
             if (getConnectivityManager().getBackgroundDataSetting()) {
@@ -337,6 +345,8 @@ public class SyncManager implements OnAccountsUpdateListener {
         intentFilter.setPriority(100);
         context.registerReceiver(mShutdownIntentReceiver, intentFilter);
 
+        ThemeUtils.registerThemeChangeReceiver(mContext, mThemeChangeReceiver);
+
         if (!factoryTest) {
             mNotificationMgr = (NotificationManager)
                 context.getSystemService(Context.NOTIFICATION_SERVICE);
@@ -891,6 +901,13 @@ public class SyncManager implements OnAccountsUpdateListener {
         }
     }
 
+    private Context getUiContext() {
+        if (mUiContext == null) {
+            mUiContext = ThemeUtils.createUiContext(mContext);
+        }
+        return mUiContext != null ? mUiContext : mContext;
+    }
+
     /**
      * @hide
      */
@@ -2402,7 +2419,7 @@ public class SyncManager implements OnAccountsUpdateListener {
                 new Notification(R.drawable.stat_notify_sync_error,
                         mContext.getString(R.string.contentServiceSync),
                         System.currentTimeMillis());
-            notification.setLatestEventInfo(mContext,
+            notification.setLatestEventInfo(getUiContext(),
                     mContext.getString(R.string.contentServiceSyncNotificationTitle),
                     String.format(tooManyDeletesDescFormat.toString(), authorityName),
                     pendingIntent);
diff --git a/core/java/android/content/pm/ActivityInfo.java b/core/java/android/content/pm/ActivityInfo.java
index 0e6694d..d320768 100644
--- a/core/java/android/content/pm/ActivityInfo.java
+++ b/core/java/android/content/pm/ActivityInfo.java
@@ -1,5 +1,6 @@
 /*
  * Copyright (C) 2007 The Android Open Source Project
+ * This code has been modified.  Portions copyright (C) 2010, T-Mobile USA, Inc.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -321,6 +322,10 @@ public class ActivityInfo extends ComponentInfo
      */
     public static final int CONFIG_ORIENTATION = 0x0080;
     /**
+     * @hide
+     */
+    public static final int CONFIG_THEME_RESOURCE = 0x008000;
+    /**
      * Bit in {@link #configChanges} that indicates that the activity
      * can itself handle changes to the screen layout.  Set from the
      * {@link android.R.attr#configChanges} attribute.
diff --git a/core/java/android/content/pm/ApplicationInfo.java b/core/java/android/content/pm/ApplicationInfo.java
index 65a8750..af7dcd2 100644
--- a/core/java/android/content/pm/ApplicationInfo.java
+++ b/core/java/android/content/pm/ApplicationInfo.java
@@ -1,5 +1,6 @@
 /*
  * Copyright (C) 2007 The Android Open Source Project
+ * This code has been modified.  Portions copyright (C) 2010, T-Mobile USA, Inc.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -419,6 +420,30 @@ public class ApplicationInfo extends PackageItemInfo implements Parcelable {
      * @hide
      */
     public int enabledSetting = PackageManager.COMPONENT_ENABLED_STATE_DEFAULT;
+    /**
+     * Is given application theme agnostic, i.e. behaves properly when default theme is changed.
+     * {@hide}
+     */
+    public boolean isThemeable = false;
+
+    private static final String PLUTO_SCHEMA = "http://www.w3.org/2001/pluto.html";
+
+    /**
+     * @hide
+     */
+    public static final String PLUTO_ISTHEMEABLE_ATTRIBUTE_NAME = "isThemeable";
+
+    /**
+     * @hide
+     */
+    public static final String PLUTO_HANDLE_THEME_CONFIG_CHANGES_ATTRIBUTE_NAME = "handleThemeConfigChanges";
+
+    /**
+     * @hide
+     */
+    public static boolean isPlutoNamespace(String namespace) {
+        return namespace != null && namespace.equalsIgnoreCase(PLUTO_SCHEMA);
+    }
 
     /**
      * For convenient access to package's install location.
@@ -520,6 +545,7 @@ public class ApplicationInfo extends PackageItemInfo implements Parcelable {
         manageSpaceActivityName = orig.manageSpaceActivityName;
         descriptionRes = orig.descriptionRes;
         uiOptions = orig.uiOptions;
+        isThemeable = orig.isThemeable;
     }
 
 
@@ -559,6 +585,7 @@ public class ApplicationInfo extends PackageItemInfo implements Parcelable {
         dest.writeString(backupAgentName);
         dest.writeInt(descriptionRes);
         dest.writeInt(uiOptions);
+        dest.writeInt(isThemeable? 1 : 0);
     }
 
     public static final Parcelable.Creator<ApplicationInfo> CREATOR
@@ -597,6 +624,7 @@ public class ApplicationInfo extends PackageItemInfo implements Parcelable {
         backupAgentName = source.readString();
         descriptionRes = source.readInt();
         uiOptions = source.readInt();
+        isThemeable = source.readInt() != 0;
     }
 
     /**
diff --git a/core/java/android/content/pm/BaseThemeInfo.java b/core/java/android/content/pm/BaseThemeInfo.java
new file mode 100644
index 0000000..0171137
--- /dev/null
+++ b/core/java/android/content/pm/BaseThemeInfo.java
@@ -0,0 +1,244 @@
+/*
+ * Copyright (C) 2010, T-Mobile USA, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package android.content.pm;
+
+import android.os.Parcelable;
+import android.os.Parcel;
+import android.util.Log;
+import android.util.AttributeSet;
+import android.content.res.Resources;
+
+/**
+ * @hide
+ */
+public class BaseThemeInfo implements Parcelable {
+
+    /**
+     * Wallpaper drawable.
+     *
+     * @see wallpaperImage attribute
+     */
+    public int wallpaperResourceId;
+
+    /**
+     * The resource id of theme thumbnail.
+     * Specifies a theme thumbnail image resource as @drawable/foo.
+     *
+     * @see thumbnail attribute
+     *
+     */
+    public int thumbnailResourceId;
+
+    /**
+     * The theme id, which does not change when the theme is modified.
+     * Specifies an Android UI Style using style name.
+     *
+     * @see themeId attribute
+     *
+     */
+    public String themeId;
+
+    /**
+     * The style resource id of Android UI Style, supplied by the resource commpiler.
+     * Specifies an Android UI Style id.
+     *
+     * @see styleId attribute
+     *
+     */
+    public int styleResourceId = 0;
+
+    /**
+     * The name of the theme (as displayed by UI).
+     *
+     * @see name attribute
+     *
+     */
+    public String name;
+
+    /**
+     * The name of the call ringtone audio file.
+     * Specifies a relative path in assets subfolder.
+     * If the parent's name is "locked" - DRM protected.
+     *
+     * @see ringtoneFileName attribute
+     *
+     */
+    public String ringtoneFileName;
+
+    /**
+     * The name of the call ringtone as shown to user.
+     *
+     * @see ringtoneName attribute
+     *
+     */
+    public String ringtoneName;
+
+    /**
+     * The name of the notification ringtone audio file.
+     * Specifies a relative path in assets subfolder.
+     * If the parent's name is "locked" - DRM protected.
+     *
+     * @see notificationRingtoneFileName attribute
+     *
+     */
+    public String notificationRingtoneFileName;
+
+    /**
+     * The name of the notification ringtone as shown to user.
+     *
+     * @see notificationRingtoneName attribute
+     *
+     */
+    public String notificationRingtoneName;
+
+    /**
+     * The author name of the theme package.
+     *
+     * @see author attribute
+     *
+     */
+    public String author;
+
+    /**
+     * The copyright text.
+     *
+     * @see copyright attribute
+     *
+     */
+    public String copyright;
+
+    /**
+     * {@hide}
+     */
+    // There is no corresposponding flag in manifest file
+    // This flag is set to true iff any media resource is DRM protected
+    public boolean isDrmProtected = false;
+
+    /**
+     * The name of the "main" theme style (as displayed by UI).
+     *
+     * @see themeStyleName attribute
+     *
+     */
+    public String themeStyleName;
+
+    /**
+     * Preview image drawable.
+     *
+     * @see preview attribute
+     */
+    public int previewResourceId;
+
+    /**
+     * The name of a sound pack.
+     *
+     * @see soundpack attribute
+     *
+     */
+    public String soundPackName;
+
+
+    private static final String LOCKED_NAME = "locked/";
+
+    /*
+     * Describe the kinds of special objects contained in this Parcelable's
+     * marshalled representation.
+     *
+     * @return a bitmask indicating the set of special object types marshalled
+     * by the Parcelable.
+     *
+     * @see android.os.Parcelable#describeContents()
+     */
+    public int describeContents() {
+        return 0;
+    }
+
+    /*
+     * Flatten this object in to a Parcel.
+     *
+     * @param dest The Parcel in which the object should be written.
+     * @param flags Additional flags about how the object should be written.
+     * May be 0 or {@link #PARCELABLE_WRITE_RETURN_VALUE}.
+     *
+     * @see android.os.Parcelable#writeToParcel(android.os.Parcel, int)
+     */
+    public void writeToParcel(Parcel dest, int flags) {
+        dest.writeInt(wallpaperResourceId);
+        dest.writeInt(thumbnailResourceId);
+        dest.writeString(themeId);
+        dest.writeInt(styleResourceId);
+        dest.writeString(name);
+        dest.writeString(ringtoneFileName);
+        dest.writeString(notificationRingtoneFileName);
+        dest.writeString(ringtoneName);
+        dest.writeString(notificationRingtoneName);
+        dest.writeString(author);
+        dest.writeString(copyright);
+        dest.writeInt(isDrmProtected? 1 : 0);
+        dest.writeString(soundPackName);
+        dest.writeString(themeStyleName);
+        dest.writeInt(previewResourceId);
+    }
+
+    /** @hide */
+    public static final Parcelable.Creator<BaseThemeInfo> CREATOR
+            = new Parcelable.Creator<BaseThemeInfo>() {
+        public BaseThemeInfo createFromParcel(Parcel source) {
+            return new BaseThemeInfo(source);
+        }
+
+        public BaseThemeInfo[] newArray(int size) {
+            return new BaseThemeInfo[size];
+        }
+    };
+
+    /** @hide */
+    public final String getResolvedString(Resources res, AttributeSet attrs, int index) {
+        int resId = attrs.getAttributeResourceValue(index, 0);
+        if (resId !=0 ) {
+            return res.getString(resId);
+        }
+        return attrs.getAttributeValue(index);
+    }
+
+    protected BaseThemeInfo() {
+    }
+
+    protected BaseThemeInfo(Parcel source) {
+        wallpaperResourceId = source.readInt();
+        thumbnailResourceId = source.readInt();
+        themeId = source.readString();
+        styleResourceId = source.readInt();
+        name = source.readString();
+        ringtoneFileName = source.readString();
+        notificationRingtoneFileName = source.readString();
+        ringtoneName = source.readString();
+        notificationRingtoneName = source.readString();
+        author = source.readString();
+        copyright = source.readString();
+        isDrmProtected = (source.readInt() != 0);
+        soundPackName = source.readString();
+        themeStyleName = source.readString();
+        previewResourceId = source.readInt();
+    }
+
+    protected void changeDrmFlagIfNeeded(String resourcePath) {
+        if (resourcePath != null && resourcePath.contains(LOCKED_NAME)) {
+            isDrmProtected = true;
+        }
+    }
+}
diff --git a/core/java/android/content/pm/IPackageManager.aidl b/core/java/android/content/pm/IPackageManager.aidl
index decb974..0842820 100644
--- a/core/java/android/content/pm/IPackageManager.aidl
+++ b/core/java/android/content/pm/IPackageManager.aidl
@@ -39,6 +39,7 @@ import android.content.pm.ResolveInfo;
 import android.content.pm.ServiceInfo;
 import android.content.pm.UserInfo;
 import android.content.pm.VerifierDeviceIdentity;
+import android.content.pm.ThemeInfo;
 import android.net.Uri;
 import android.content.IntentSender;
 
@@ -121,6 +122,8 @@ interface IPackageManager {
      */
     ParceledListSlice getInstalledPackages(int flags, in String lastRead);
 
+    List<PackageInfo> getInstalledThemePackages();
+
     /**
      * This implements getInstalledApplications via a "last returned row"
      * mechanism that is not exposed in the API. This is to get around the IPC
diff --git a/core/java/android/content/pm/PackageInfo.java b/core/java/android/content/pm/PackageInfo.java
index eb05d76..42dd621 100644
--- a/core/java/android/content/pm/PackageInfo.java
+++ b/core/java/android/content/pm/PackageInfo.java
@@ -1,5 +1,6 @@
 /*
  * Copyright (C) 2007 The Android Open Source Project
+ * This code has been modified.  Portions copyright (C) 2010, T-Mobile USA, Inc.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -194,9 +195,69 @@ public class PackageInfo implements Parcelable {
      */
     public int installLocation = INSTALL_LOCATION_INTERNAL_ONLY;
     
+    // Is Theme Apk
+    /**
+     * {@hide}
+     */
+    public boolean isThemeApk = false;
+
+    // ThemeInfo
+    /**
+     * {@hide}
+     */
+    public ThemeInfo [] themeInfos;
+
     public PackageInfo() {
     }
 
+    /*
+     * Is Theme Apk is DRM protected (contains DRM-protected resources)
+     *
+     */
+    private boolean drmProtectedThemeApk = false;
+
+    /**
+     * @hide
+     *
+     * @return Is Theme Apk is DRM protected (contains DRM-protected resources)
+     */
+    public boolean isDrmProtectedThemeApk() {
+        return drmProtectedThemeApk;
+    }
+
+    /**
+     * @hide
+     *
+     * @param value if Theme Apk is DRM protected (contains DRM-protected resources)
+     */
+    public void setDrmProtectedThemeApk(boolean value) {
+        drmProtectedThemeApk = value;
+    }
+
+    /*
+     * If isThemeApk and isDrmProtectedThemeApk are true - path to hidden locked zip file
+     *
+     */
+    private String lockedZipFilePath;
+
+    /**
+     * @hide
+     *
+     * @return path for hidden locked zip file
+     */
+    public String getLockedZipFilePath() {
+        return lockedZipFilePath;
+    }
+
+    /**
+     * @hide
+     *
+     * @param value path for hidden locked zip file
+     */
+    public void setLockedZipFilePath(String value) {
+        lockedZipFilePath = value;
+    }
+
     public String toString() {
         return "PackageInfo{"
             + Integer.toHexString(System.identityHashCode(this))
@@ -233,6 +294,12 @@ public class PackageInfo implements Parcelable {
         dest.writeTypedArray(configPreferences, parcelableFlags);
         dest.writeTypedArray(reqFeatures, parcelableFlags);
         dest.writeInt(installLocation);
+
+        /* Theme-specific. */
+        dest.writeInt((isThemeApk)? 1 : 0);
+        dest.writeInt((drmProtectedThemeApk)? 1 : 0);
+        dest.writeTypedArray(themeInfos, parcelableFlags);
+        dest.writeString(lockedZipFilePath);
     }
 
     public static final Parcelable.Creator<PackageInfo> CREATOR
@@ -270,5 +337,11 @@ public class PackageInfo implements Parcelable {
         configPreferences = source.createTypedArray(ConfigurationInfo.CREATOR);
         reqFeatures = source.createTypedArray(FeatureInfo.CREATOR);
         installLocation = source.readInt();
+
+        /* Theme-specific. */
+        isThemeApk = (source.readInt() != 0);
+        drmProtectedThemeApk = (source.readInt() != 0);
+        themeInfos = source.createTypedArray(ThemeInfo.CREATOR);
+        lockedZipFilePath = source.readString();
     }
 }
diff --git a/core/java/android/content/pm/PackageManager.java b/core/java/android/content/pm/PackageManager.java
index 8541748..ca1aa4f 100644
--- a/core/java/android/content/pm/PackageManager.java
+++ b/core/java/android/content/pm/PackageManager.java
@@ -1,5 +1,6 @@
 /*
  * Copyright (C) 2006 The Android Open Source Project
+ * This code has been modified.  Portions copyright (C) 2010, T-Mobile USA, Inc.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -806,6 +807,22 @@ public abstract class PackageManager {
 
     /**
      * Feature for {@link #getSystemAvailableFeatures} and
+     * {@link #hasSystemFeature}: The device is able to receive FM radio.
+     * @hide
+     */
+    @SdkConstant(SdkConstantType.FEATURE)
+    public static final String FEATURE_RADIO_FM_RECEIVER = "com.stericsson.hardware.fm.receiver";
+
+    /**
+     * Feature for {@link #getSystemAvailableFeatures} and
+     * {@link #hasSystemFeature}: The device is able to transmit FM radio.
+     * @hide
+     */
+    @SdkConstant(SdkConstantType.FEATURE)
+    public static final String FEATURE_RADIO_FM_TRANSMITTER = "com.stericsson.hardware.fm.transmitter";
+
+    /**
+     * Feature for {@link #getSystemAvailableFeatures} and
      * {@link #hasSystemFeature}: The device supports one or more methods of
      * reporting current location.
      */
@@ -1407,6 +1424,17 @@ public abstract class PackageManager {
     public abstract List<PackageInfo> getInstalledPackages(int flags);
 
     /**
+     * Return a List of all theme packages that are installed
+     * on the device.
+     *
+     * @return A List of PackageInfo objects, one for each theme package
+     *         that is installed on the device.
+     *
+     * @hide
+     */
+    public abstract List<PackageInfo> getInstalledThemePackages();
+
+    /**
      * Check whether a particular package has been granted a particular
      * permission.
      *
diff --git a/core/java/android/content/pm/PackageParser.java b/core/java/android/content/pm/PackageParser.java
index e593d5b..fddd0bc 100644
--- a/core/java/android/content/pm/PackageParser.java
+++ b/core/java/android/content/pm/PackageParser.java
@@ -1,5 +1,6 @@
 /*
  * Copyright (C) 2007 The Android Open Source Project
+ * This code has been modified.  Portions copyright (C) 2010, T-Mobile USA, Inc.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -200,6 +201,17 @@ public class PackageParser {
         return name.endsWith(".apk");
     }
 
+    public static String getLockedZipFilePath(String path) {
+        if (path == null) {
+            return null;
+        }
+        if (isPackageFilename(path)) {
+            return path.substring(0, path.length() - 4) + ".locked.zip";
+        } else {
+            return path + ".locked.zip";
+        }
+    }
+
     /**
      * Generate and return the {@link PackageInfo} for a parsed package.
      *
@@ -215,6 +227,21 @@ public class PackageParser {
         pi.versionName = p.mVersionName;
         pi.sharedUserId = p.mSharedUserId;
         pi.sharedUserLabel = p.mSharedUserLabel;
+        pi.isThemeApk = p.mIsThemeApk;
+        pi.setDrmProtectedThemeApk(false);
+        if (pi.isThemeApk) {
+            int N = p.mThemeInfos.size();
+            if (N > 0) {
+                pi.themeInfos = new ThemeInfo[N];
+                for (int i = 0; i < N; i++) {
+                    pi.themeInfos[i] = p.mThemeInfos.get(i);
+                    pi.setDrmProtectedThemeApk(pi.isDrmProtectedThemeApk() || pi.themeInfos[i].isDrmProtected);
+                }
+                if (pi.isDrmProtectedThemeApk()) {
+                    pi.setLockedZipFilePath(PackageParser.getLockedZipFilePath(p.mPath));
+                }
+            }
+        }
         pi.applicationInfo = generateApplicationInfo(p, flags);
         pi.installLocation = p.installLocation;
         pi.firstInstallTime = firstInstallTime;
@@ -1180,7 +1207,10 @@ public class PackageParser {
                 // Just skip this tag
                 XmlUtils.skipCurrentTag(parser);
                 continue;
-                
+            } else if (tagName.equals("theme")) {
+                // this is a theme apk.
+                pkg.mIsThemeApk = true;
+                pkg.mThemeInfos.add(new ThemeInfo(parser, res, attrs));
             } else if (RIGID_PARSER) {
                 outError[0] = "Bad element under <manifest>: "
                     + parser.getName();
@@ -1253,6 +1283,9 @@ public class PackageParser {
                         >= android.os.Build.VERSION_CODES.DONUT)) {
             pkg.applicationInfo.flags |= ApplicationInfo.FLAG_SUPPORTS_SCREEN_DENSITIES;
         }
+        if (pkg.mIsThemeApk) {
+            pkg.applicationInfo.isThemeable = false;
+        }
 
         return pkg;
     }
@@ -1536,12 +1569,43 @@ public class PackageParser {
         return a;
     }
 
+    private void parseApplicationThemeAttributes(XmlPullParser parser, AttributeSet attrs,
+            ApplicationInfo appInfo) {
+        for (int i = 0; i < attrs.getAttributeCount(); i++) {
+            if (!ApplicationInfo.isPlutoNamespace(parser.getAttributeNamespace(i))) {
+                continue;
+            }
+            String attrName = attrs.getAttributeName(i);
+            if (attrName.equalsIgnoreCase(ApplicationInfo.PLUTO_ISTHEMEABLE_ATTRIBUTE_NAME)) {
+                appInfo.isThemeable = attrs.getAttributeBooleanValue(i, false);
+                return;
+            }
+        }
+    }
+
+    private void parseActivityThemeAttributes(XmlPullParser parser, AttributeSet attrs,
+            ActivityInfo ai) {
+        for (int i = 0; i < attrs.getAttributeCount(); i++) {
+            if (!ApplicationInfo.isPlutoNamespace(parser.getAttributeNamespace(i))) {
+                continue;
+            }
+            String attrName = attrs.getAttributeName(i);
+            if (attrName.equalsIgnoreCase(ApplicationInfo.PLUTO_HANDLE_THEME_CONFIG_CHANGES_ATTRIBUTE_NAME)) {
+                ai.configChanges |= ActivityInfo.CONFIG_THEME_RESOURCE;
+            }
+        }
+    }
+
     private boolean parseApplication(Package owner, Resources res,
             XmlPullParser parser, AttributeSet attrs, int flags, String[] outError)
         throws XmlPullParserException, IOException {
         final ApplicationInfo ai = owner.applicationInfo;
         final String pkgName = owner.applicationInfo.packageName;
 
+        // assume that this package is themeable unless explicitly set to false.
+        ai.isThemeable = true;
+        parseApplicationThemeAttributes(parser, attrs, ai);
+
         TypedArray sa = res.obtainAttributes(attrs,
                 com.android.internal.R.styleable.AndroidManifestApplication);
 
@@ -2045,6 +2109,8 @@ public class PackageParser {
             return null;
         }
 
+        parseActivityThemeAttributes(parser, attrs, a.info);
+
         int outerDepth = parser.getDepth();
         int type;
         while ((type=parser.next()) != XmlPullParser.END_DOCUMENT
@@ -2982,6 +3048,12 @@ public class PackageParser {
         // For use by package manager to keep track of where it has done dexopt.
         public boolean mDidDexOpt;
         
+        // Is Theme Apk
+        public boolean mIsThemeApk = false;
+
+        // Theme info
+        public final ArrayList<ThemeInfo> mThemeInfos = new ArrayList<ThemeInfo>(0);
+
         // User set enabled state.
         public int mSetEnabled = PackageManager.COMPONENT_ENABLED_STATE_DEFAULT;
 
diff --git a/core/java/android/content/pm/ThemeInfo.aidl b/core/java/android/content/pm/ThemeInfo.aidl
new file mode 100755
index 0000000..acbc85e
--- /dev/null
+++ b/core/java/android/content/pm/ThemeInfo.aidl
@@ -0,0 +1,3 @@
+package android.content.pm;
+
+parcelable ThemeInfo;
diff --git a/core/java/android/content/pm/ThemeInfo.java b/core/java/android/content/pm/ThemeInfo.java
new file mode 100644
index 0000000..e51dbb6
--- /dev/null
+++ b/core/java/android/content/pm/ThemeInfo.java
@@ -0,0 +1,205 @@
+/*
+ * Copyright (C) 2010, T-Mobile USA, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package android.content.pm;
+
+import java.util.HashMap;
+import java.util.Map;
+
+import org.xmlpull.v1.XmlPullParserException;
+import org.xmlpull.v1.XmlPullParser;
+
+import android.os.Parcel;
+import android.os.Parcelable;
+import android.util.AttributeSet;
+import android.content.res.Resources;
+
+/**
+ * Overall information about "theme" package.  This corresponds
+ * to the information collected from AndroidManifest.xml (theme tag).
+ *
+ * Below is an example of theme tag
+ *    <theme
+ *        pluto:name="Pluto Default"
+ *        pluto:preview="@drawable/preview"
+ *        pluto:author="John Doe"
+ *        pluto:ringtoneFileName="media/audio/ringtone.mp3"
+ *        pluto:notificationRingtoneFileName="media/audio/locked/notification.mp3"
+ *        pluto:copyright="T-Mobile, 2009"
+ *    />
+ *
+ * @hide
+ */
+public final class ThemeInfo extends BaseThemeInfo {
+    private enum AttributeIndex {
+        THEME_PACKAGE_INDEX,
+        PREVIEW_INDEX,
+        AUTHOR_INDEX,
+        THEME_INDEX,
+        THEME_STYLE_NAME_INDEX,
+        THUMBNAIL_INDEX,
+        RINGTONE_FILE_NAME_INDEX,
+        NOTIFICATION_RINGTONE_FILE_NAME_INDEX,
+        WALLPAPER_IMAGE_INDEX,
+        COPYRIGHT_INDEX,
+        RINGTONE_NAME_INDEX,
+        NOTIFICATION_RINGTONE_NAME_INDEX,
+        STYLE_INDEX;
+
+        public static AttributeIndex get(int ordinal) {
+            return values()[ordinal];
+        }
+    };
+
+    private static final String [] compulsoryAttributes = new String [] {
+        "name",
+        "preview",
+        "author",
+        "themeId",
+        "styleName",
+    };
+
+    private static final String [] optionalAttributes = new String [] {
+        "thumbnail",
+        "ringtoneFileName",
+        "notificationRingtoneFileName",
+        "wallpaperImage",
+        "copyright",
+        "ringtoneName",
+        "notificationRingtoneName",
+        "styleId",
+    };
+
+    private static final Map<String, AttributeIndex> sAttributesLookupTable;
+
+    static {
+        sAttributesLookupTable = new HashMap<String, AttributeIndex>();
+        for (int i = 0; i < compulsoryAttributes.length; i++) {
+            sAttributesLookupTable.put(compulsoryAttributes[i], AttributeIndex.get(i));
+        }
+
+        for (int i = 0; i < optionalAttributes.length; i++) {
+            sAttributesLookupTable.put(optionalAttributes[i],
+                    AttributeIndex.get(compulsoryAttributes.length + i));
+        }
+    }
+
+    public ThemeInfo(XmlPullParser parser, Resources res, AttributeSet attrs) throws XmlPullParserException {
+        super();
+
+        Map<String, AttributeIndex> tempMap =
+                new HashMap<String, AttributeIndex>(sAttributesLookupTable);
+        int numberOfCompulsoryAttributes = 0;
+        for (int i = 0; i < attrs.getAttributeCount(); i++) {
+            if (!ApplicationInfo.isPlutoNamespace(parser.getAttributeNamespace(i))) {
+                continue;
+            }
+            String key = attrs.getAttributeName(i);
+            if (tempMap.containsKey(key)) {
+                AttributeIndex index = tempMap.get(key);
+                tempMap.remove(key);
+
+                if (index.ordinal() < compulsoryAttributes.length) {
+                    numberOfCompulsoryAttributes++;
+                }
+                switch (index) {
+                    case THEME_PACKAGE_INDEX:
+                        // theme name
+                        name = getResolvedString(res, attrs, i);
+                        break;
+
+                    case THUMBNAIL_INDEX:
+                        // theme thumbprint
+                        thumbnailResourceId = attrs.getAttributeResourceValue(i, 0);
+                        break;
+
+                    case AUTHOR_INDEX:
+                        // theme author
+                        author = getResolvedString(res, attrs, i);
+                        break;
+
+                    case THEME_INDEX:
+                        // androidUiStyle attribute
+                        themeId = attrs.getAttributeValue(i);
+                        break;
+
+                    case THEME_STYLE_NAME_INDEX:
+                        themeStyleName = getResolvedString(res, attrs, i);
+                        break;
+
+                    case RINGTONE_FILE_NAME_INDEX:
+                        // ringtone
+                        ringtoneFileName = attrs.getAttributeValue(i);
+                        changeDrmFlagIfNeeded(ringtoneFileName);
+                        break;
+
+                    case NOTIFICATION_RINGTONE_FILE_NAME_INDEX:
+                        // notification ringtone
+                        notificationRingtoneFileName = attrs.getAttributeValue(i);
+                        changeDrmFlagIfNeeded(notificationRingtoneFileName);
+                        break;
+
+                    case WALLPAPER_IMAGE_INDEX:
+                        // wallpaperImage attribute
+                        wallpaperResourceId = attrs.getAttributeResourceValue(i, 0);
+                        break;
+
+                    case COPYRIGHT_INDEX:
+                        // themeCopyright attribute
+                        copyright = getResolvedString(res, attrs, i);
+                        break;
+
+                    case RINGTONE_NAME_INDEX:
+                        // ringtone UI name
+                        ringtoneName = attrs.getAttributeValue(i);
+                        break;
+
+                    case NOTIFICATION_RINGTONE_NAME_INDEX:
+                        // notification ringtone UI name
+                        notificationRingtoneName = attrs.getAttributeValue(i);
+                        break;
+
+                    case STYLE_INDEX:
+                        styleResourceId = attrs.getAttributeResourceValue(i, 0);
+                        break;
+
+                    case PREVIEW_INDEX:
+                        // theme thumbprint
+                        previewResourceId = attrs.getAttributeResourceValue(i, 0);
+                        break;
+                }
+            }
+        }
+        if (numberOfCompulsoryAttributes < compulsoryAttributes.length) {
+            throw new XmlPullParserException("Not all compulsory attributes are specified in <theme>");
+        }
+    }
+
+    public static final Parcelable.Creator<ThemeInfo> CREATOR
+            = new Parcelable.Creator<ThemeInfo>() {
+        public ThemeInfo createFromParcel(Parcel source) {
+            return new ThemeInfo(source);
+        }
+
+        public ThemeInfo[] newArray(int size) {
+            return new ThemeInfo[size];
+        }
+    };
+
+    private ThemeInfo(Parcel source) {
+        super(source);
+    }
+}
diff --git a/core/java/android/content/res/AssetManager.java b/core/java/android/content/res/AssetManager.java
index ffefaa2..80d0946 100644
--- a/core/java/android/content/res/AssetManager.java
+++ b/core/java/android/content/res/AssetManager.java
@@ -1,5 +1,6 @@
 /*
  * Copyright (C) 2006 The Android Open Source Project
+ * This code has been modified.  Portions copyright (C) 2010, T-Mobile USA, Inc.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -18,6 +19,7 @@ package android.content.res;
 
 import android.os.ParcelFileDescriptor;
 import android.util.Log;
+import android.util.SparseArray;
 import android.util.TypedValue;
 
 import java.io.FileNotFoundException;
@@ -77,6 +79,20 @@ public final class AssetManager {
     private boolean mOpen = true;
     private HashMap<Integer, RuntimeException> mRefStacks; 
  
+    private String mAssetDir;
+    private String mAppName;
+
+    private boolean mThemeSupport;
+    private String mThemePackageName;
+    private int mThemeCookie;
+
+    /**
+     * Organize all added redirection maps using Java strong references to keep
+     * the native layer cleanup simple (that is, finalize() in Java will be
+     * responsible for delete in C++).
+     */
+    private SparseArray<PackageRedirectionMap> mRedirections;
+
     /**
      * Create a new AssetManager containing only the basic system assets.
      * Applications will not generally use this method, instead retrieving the
@@ -252,6 +268,12 @@ public final class AssetManager {
         }
     }
 
+    /*package*/ final void recreateStringBlocks() {
+        synchronized (this) {
+            makeStringBlocks(true);
+        }
+    }
+
     /*package*/ final void makeStringBlocks(boolean copyFromSystem) {
         final int sysNum = copyFromSystem ? sSystem.mStringBlocks.length : 0;
         final int num = getStringBlockCount();
@@ -460,6 +482,18 @@ public final class AssetManager {
 
     /**
      * {@hide}
+     * Split a theme package with DRM-protected resources into two files.
+     * 
+     * @param packageFileName Original theme package file name.
+     * @param lockedFileName Name of the new "locked" file with DRM resources.
+     * @param drmProtectedresources Array of names of DRM-protected assets.
+     */
+    public final int splitDrmProtectedThemePackage(String packageFileName, String lockedFileName, String [] drmProtectedresources) {
+        return splitThemePackage(packageFileName, lockedFileName, drmProtectedresources);
+    }
+
+    /**
+     * {@hide}
      * Retrieve a non-asset as a compiled XML file.  Not for use by
      * applications.
      * 
@@ -625,6 +659,110 @@ public final class AssetManager {
     }
 
     /**
+     * Delete a set of theme assets from the asset manager. Not for use by
+     * applications. Returns true if succeeded or false on failure.
+     *
+     * @hide
+     */
+    public native final boolean detachThemePath(String packageName, int cookie);
+
+    /**
+     * Attach a set of theme assets to the asset manager. If necessary, this
+     * method will forcefully update the internal ResTable data structure.
+     *
+     * @return Cookie of the added asset or 0 on failure.
+     * @hide
+     */
+    public native final int attachThemePath(String path);
+
+    /**
+     * Sets a flag indicating that this AssetManager should have themes
+     * attached, according to the initial request to create it by the
+     * ApplicationContext.
+     *
+     * {@hide}
+     */
+    public final void setThemeSupport(boolean themeSupport) {
+        mThemeSupport = themeSupport;
+    }
+
+    /**
+     * Should this AssetManager have themes attached, according to the initial
+     * request to create it by the ApplicationContext?
+     *
+     * {@hide}
+     */
+    public final boolean hasThemeSupport() {
+        return mThemeSupport;
+    }
+
+    /**
+     * Apply a heuristic to match-up all attributes from the source style with
+     * attributes in the destination style. For each match, an entry in the
+     * package redirection map will be inserted.
+     *
+     * {@hide}
+     */
+    public native final boolean generateStyleRedirections(int resMapNative, int sourceStyle,
+            int destStyle);
+
+    /**
+     * Get package name of current theme (may return null).
+     * {@hide}
+     */
+    public String getThemePackageName() {
+        return mThemePackageName;
+    }
+
+    /**
+     * Sets package name and highest level style id for current theme (null, 0 is allowed).
+     * {@hide}
+     */
+    public void setThemePackageName(String packageName) {
+        mThemePackageName = packageName;
+    }
+
+    /**
+     * Get asset cookie for current theme (may return 0).
+     * {@hide}
+     */
+    public int getThemeCookie() {
+        return mThemeCookie;
+    }
+
+    /**
+     * Sets asset cookie for current theme (0 if not a themed asset manager).
+     * {@hide}
+     */
+    public void setThemeCookie(int cookie) {
+        mThemeCookie = cookie;
+    }
+
+    /**
+     * Add a redirection map to the asset manager. All future resource lookups
+     * will consult this map.
+     * {@hide}
+     */
+    public void addRedirections(PackageRedirectionMap map) {
+        if (mRedirections == null) {
+            mRedirections = new SparseArray<PackageRedirectionMap>(2);
+        }
+        mRedirections.append(map.getPackageId(), map);
+        addRedirectionsNative(map.getNativePointer());
+    }
+
+    /**
+     * Clear redirection map for the asset manager.
+     * {@hide}
+     */
+    public void clearRedirections() {
+        if (mRedirections != null) {
+            mRedirections.clear();
+        }
+        clearRedirectionsNative();
+    }
+
+    /**
      * Determine whether the state in this asset manager is up-to-date with
      * the files on the filesystem.  If false is returned, you need to
      * instantiate a new AssetManager class to see the new data.
@@ -741,6 +879,26 @@ public final class AssetManager {
     private native final int[] getArrayStringInfo(int arrayRes);
     /*package*/ native final int[] getArrayIntResource(int arrayRes);
 
+    private native final int splitThemePackage(String srcFileName, String dstFileName, String [] drmProtectedAssetNames);
+
+    /**
+     * {@hide}
+     */
+    public native final int getBasePackageCount();
+
+    /**
+     * {@hide}
+     */
+    public native final String getBasePackageName(int index);
+
+    /**
+     * {@hide}
+     */
+    public native final int getBasePackageId(int index);
+
+    private native final void addRedirectionsNative(int redirectionMapNativePointer);
+    private native final void clearRedirectionsNative();
+
     private native final void init();
     private native final void destroy();
 
diff --git a/core/java/android/content/res/CompatibilityInfo.java b/core/java/android/content/res/CompatibilityInfo.java
index 1c9285e..d6856c9 100644
--- a/core/java/android/content/res/CompatibilityInfo.java
+++ b/core/java/android/content/res/CompatibilityInfo.java
@@ -92,9 +92,15 @@ public class CompatibilityInfo implements Parcelable {
      */
     public final float applicationInvertedScale;
 
+    /**
+     * Whether the application supports third-party theming.
+     */
+    public final boolean isThemeable;
+
     public CompatibilityInfo(ApplicationInfo appInfo, int screenLayout, int sw,
             boolean forceCompat) {
         int compatFlags = 0;
+        isThemeable = appInfo.isThemeable;
 
         if (appInfo.requiresSmallestWidthDp != 0 || appInfo.compatibleWidthLimitDp != 0
                 || appInfo.largestWidthLimitDp != 0) {
@@ -242,17 +248,19 @@ public class CompatibilityInfo implements Parcelable {
     }
 
     private CompatibilityInfo(int compFlags,
-            int dens, float scale, float invertedScale) {
+            int dens, float scale, float invertedScale, boolean isThemeable) {
         mCompatibilityFlags = compFlags;
         applicationDensity = dens;
         applicationScale = scale;
         applicationInvertedScale = invertedScale;
+        this.isThemeable = isThemeable;
     }
 
     private CompatibilityInfo() {
         this(NEVER_NEEDS_COMPAT, DisplayMetrics.DENSITY_DEVICE,
                 1.0f,
-                1.0f);
+                1.0f,
+                true);
     }
 
     /**
@@ -519,6 +527,7 @@ public class CompatibilityInfo implements Parcelable {
             if (applicationDensity != oc.applicationDensity) return false;
             if (applicationScale != oc.applicationScale) return false;
             if (applicationInvertedScale != oc.applicationInvertedScale) return false;
+            if (isThemeable != oc.isThemeable) return false;
             return true;
         } catch (ClassCastException e) {
             return false;
@@ -556,6 +565,7 @@ public class CompatibilityInfo implements Parcelable {
         result = 31 * result + applicationDensity;
         result = 31 * result + Float.floatToIntBits(applicationScale);
         result = 31 * result + Float.floatToIntBits(applicationInvertedScale);
+        result = 31 * result + (isThemeable ? 1 : 0);
         return result;
     }
 
@@ -570,6 +580,7 @@ public class CompatibilityInfo implements Parcelable {
         dest.writeInt(applicationDensity);
         dest.writeFloat(applicationScale);
         dest.writeFloat(applicationInvertedScale);
+        dest.writeInt(isThemeable ? 1 : 0);
     }
 
     public static final Parcelable.Creator<CompatibilityInfo> CREATOR
@@ -588,5 +599,6 @@ public class CompatibilityInfo implements Parcelable {
         applicationDensity = source.readInt();
         applicationScale = source.readFloat();
         applicationInvertedScale = source.readFloat();
+        isThemeable = source.readInt() == 1 ? true : false;
     }
 }
diff --git a/core/java/android/content/res/Configuration.java b/core/java/android/content/res/Configuration.java
index 5c3a17a..9822936 100644
--- a/core/java/android/content/res/Configuration.java
+++ b/core/java/android/content/res/Configuration.java
@@ -1,5 +1,6 @@
 /*
  * Copyright (C) 2008 The Android Open Source Project
+ * This code has been modified.  Portions copyright (C) 2010, T-Mobile USA, Inc.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -20,6 +21,9 @@ import android.content.pm.ActivityInfo;
 import android.os.Parcel;
 import android.os.Parcelable;
 import android.util.LocaleUtil;
+import android.util.Log;
+import android.os.SystemProperties;
+import android.text.TextUtils;
 
 import java.util.Locale;
 
@@ -56,6 +60,11 @@ public final class Configuration implements Parcelable, Comparable<Configuration
     public Locale locale;
 
     /**
+     * @hide
+     */
+    public CustomTheme customTheme;
+
+    /**
      * Locale should persist on setting.  This is hidden because it is really
      * questionable whether this is the right way to expose the functionality.
      * @hide
@@ -214,7 +223,22 @@ public final class Configuration implements Parcelable, Comparable<Configuration
     public static final int ORIENTATION_PORTRAIT = 1;
     public static final int ORIENTATION_LANDSCAPE = 2;
     public static final int ORIENTATION_SQUARE = 3;
-    
+
+    /**
+     * @hide
+     */
+    public static final int THEME_UNDEFINED = 0;
+
+    /**
+     * @hide
+     */
+    public static final String THEME_ID_PERSISTENCE_PROPERTY = "persist.sys.themeId";
+
+    /**
+     * @hide
+     */
+    public static final String THEME_PACKAGE_NAME_PERSISTENCE_PROPERTY = "persist.sys.themePackageName";
+
     /**
      * Overall orientation of the screen.  May be one of
      * {@link #ORIENTATION_LANDSCAPE}, {@link #ORIENTATION_PORTRAIT},
@@ -327,6 +351,9 @@ public final class Configuration implements Parcelable, Comparable<Configuration
         compatScreenHeightDp = o.compatScreenHeightDp;
         compatSmallestScreenWidthDp = o.compatSmallestScreenWidthDp;
         seq = o.seq;
+        if (o.customTheme != null) {
+            customTheme = (CustomTheme) o.customTheme.clone();
+        }
     }
     
     public String toString() {
@@ -444,6 +471,8 @@ public final class Configuration implements Parcelable, Comparable<Configuration
             sb.append(" s.");
             sb.append(seq);
         }
+        sb.append(" themeResource=");
+        sb.append(customTheme);
         sb.append('}');
         return sb.toString();
     }
@@ -470,6 +499,7 @@ public final class Configuration implements Parcelable, Comparable<Configuration
         smallestScreenWidthDp = compatSmallestScreenWidthDp = SMALLEST_SCREEN_WIDTH_DP_UNDEFINED;
         textLayoutDirection = LocaleUtil.TEXT_LAYOUT_DIRECTION_LTR_DO_NOT_USE;
         seq = 0;
+        customTheme = null;
     }
 
     /** {@hide} */
@@ -589,7 +619,13 @@ public final class Configuration implements Parcelable, Comparable<Configuration
         if (delta.seq != 0) {
             seq = delta.seq;
         }
-        
+
+        if (delta.customTheme != null
+                && (customTheme == null || !customTheme.equals(delta.customTheme))) {
+            changed |= ActivityInfo.CONFIG_THEME_RESOURCE;
+            customTheme = (CustomTheme)delta.customTheme.clone();
+        }
+
         return changed;
     }
 
@@ -685,6 +721,10 @@ public final class Configuration implements Parcelable, Comparable<Configuration
                 && smallestScreenWidthDp != delta.smallestScreenWidthDp) {
             changed |= ActivityInfo.CONFIG_SMALLEST_SCREEN_SIZE;
         }
+        if (delta.customTheme != null &&
+                (customTheme == null || !customTheme.equals(delta.customTheme))) {
+            changed |= ActivityInfo.CONFIG_THEME_RESOURCE;
+        }
         
         return changed;
     }
@@ -701,7 +741,9 @@ public final class Configuration implements Parcelable, Comparable<Configuration
      * @return Return true if the resource needs to be loaded, else false.
      */
     public static boolean needNewResources(int configChanges, int interestingChanges) {
-        return (configChanges & (interestingChanges|ActivityInfo.CONFIG_FONT_SCALE)) != 0;
+        return (configChanges & (interestingChanges |
+                ActivityInfo.CONFIG_FONT_SCALE |
+                ActivityInfo.CONFIG_THEME_RESOURCE)) != 0;
     }
     
     /**
@@ -774,6 +816,14 @@ public final class Configuration implements Parcelable, Comparable<Configuration
         dest.writeInt(compatSmallestScreenWidthDp);
         dest.writeInt(textLayoutDirection);
         dest.writeInt(seq);
+
+        if (customTheme == null) {
+            dest.writeInt(0);
+        } else {
+            dest.writeInt(1);
+            dest.writeString(customTheme.getThemeId());
+            dest.writeString(customTheme.getThemePackageName());
+        }
     }
 
     public void readFromParcel(Parcel source) {
@@ -802,6 +852,12 @@ public final class Configuration implements Parcelable, Comparable<Configuration
         compatSmallestScreenWidthDp = source.readInt();
         textLayoutDirection = source.readInt();
         seq = source.readInt();
+
+        if (source.readInt() != 0) {
+            String themeId = source.readString();
+            String themePackage = source.readString();
+            customTheme = new CustomTheme(themeId, themePackage);
+        }
     }
     
     public static final Parcelable.Creator<Configuration> CREATOR
@@ -868,6 +924,17 @@ public final class Configuration implements Parcelable, Comparable<Configuration
         if (n != 0) return n;
         n = this.smallestScreenWidthDp - that.smallestScreenWidthDp;
         //if (n != 0) return n;
+        if (this.customTheme == null) {
+            if (that.customTheme != null) return 1;
+        } else if (that.customTheme == null) {
+            return -1;
+        } else {
+            n = this.customTheme.getThemeId().compareTo(that.customTheme.getThemeId());
+            if (n != 0) return n;
+            n = this.customTheme.getThemePackageName().compareTo(that.customTheme.getThemePackageName());
+            if (n != 0) return n;
+        }
+
         return n;
     }
 
@@ -903,6 +970,8 @@ public final class Configuration implements Parcelable, Comparable<Configuration
         result = 31 * result + screenWidthDp;
         result = 31 * result + screenHeightDp;
         result = 31 * result + smallestScreenWidthDp;
+        result = 31 * result + (this.customTheme != null ?
+                                  this.customTheme.hashCode() : 0);
         return result;
     }
 }
diff --git a/core/java/android/content/res/CustomTheme.java b/core/java/android/content/res/CustomTheme.java
new file mode 100644
index 0000000..364fb11
--- /dev/null
+++ b/core/java/android/content/res/CustomTheme.java
@@ -0,0 +1,117 @@
+/*
+ * Copyright (C) 2010, T-Mobile USA, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package android.content.res;
+
+import android.os.SystemProperties;
+import android.text.TextUtils;
+
+/**
+ * @hide
+ */
+public final class CustomTheme implements Cloneable {
+    private final String mThemeId;
+    private final String mThemePackageName;
+
+    private static final CustomTheme sBootTheme = new CustomTheme();
+    private static final CustomTheme sSystemTheme = new CustomTheme("", "");
+
+    private CustomTheme() {
+        mThemeId = SystemProperties.get("persist.sys.themeId");
+        mThemePackageName = SystemProperties.get("persist.sys.themePackageName");
+    }
+
+    public CustomTheme(String themeId, String packageName) {
+        mThemeId = themeId;
+        mThemePackageName = packageName;
+    }
+
+    @Override
+    public Object clone() {
+        try {
+            return super.clone();
+        } catch (CloneNotSupportedException e) {
+            return null;
+        }
+    }
+
+    @Override
+    public boolean equals(Object object) {
+        if (object == this) {
+            return true;
+        }
+        if (object instanceof CustomTheme) {
+            CustomTheme o = (CustomTheme) object;
+            if (!mThemeId.equals(o.mThemeId)) {
+                return false;
+            }
+            String currentPackageName = (mThemePackageName == null)? "" : mThemePackageName;
+            String newPackageName = (o.mThemePackageName == null)? "" : o.mThemePackageName;
+            String currentThemeId = (mThemeId == null)? "" : mThemeId;
+            String newThemeId = (o.mThemeId == null)? "" : o.mThemeId;
+
+            /* uhh, why are we trimming here instead of when the object is
+             * constructed? actually, why are we trimming at all? */
+            return (currentPackageName.trim().equalsIgnoreCase(newPackageName.trim())) &&
+                    (currentThemeId.trim().equalsIgnoreCase(newThemeId.trim()));
+        }
+        return false;
+    }
+
+    @Override
+    public final String toString() {
+        StringBuilder result = new StringBuilder();
+        if (!TextUtils.isEmpty(mThemePackageName) && !TextUtils.isEmpty(mThemeId)) {
+            result.append(mThemePackageName);
+            result.append('(');
+            result.append(mThemeId);
+            result.append(')');
+        } else {
+            result.append("system");
+        }
+        return result.toString();
+    }
+
+    @Override
+    public synchronized int hashCode() {
+        return mThemeId.hashCode() + mThemePackageName.hashCode();
+    }
+
+    public String getThemeId() {
+        return mThemeId;
+    }
+
+    public String getThemePackageName() {
+        return mThemePackageName;
+    }
+
+    /**
+     * Represents the theme that the device booted into. This is used to
+     * simulate a "default" configuration based on the user's last known
+     * preference until the theme is switched at runtime.
+     */
+    public static CustomTheme getBootTheme() {
+        return sBootTheme;
+    }
+
+    /**
+     * Represents the system framework theme, perceived by the system as there
+     * being no theme applied.
+     */
+    public static CustomTheme getSystemTheme() {
+        return sSystemTheme;
+    }
+}
diff --git a/core/java/android/content/res/PackageRedirectionMap.aidl b/core/java/android/content/res/PackageRedirectionMap.aidl
new file mode 100644
index 0000000..4f47525
--- /dev/null
+++ b/core/java/android/content/res/PackageRedirectionMap.aidl
@@ -0,0 +1,22 @@
+/*
+ * Copyright (C) 2011, T-Mobile USA, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package android.content.res;
+
+/**
+ * @hide
+ */
+parcelable PackageRedirectionMap;
diff --git a/core/java/android/content/res/PackageRedirectionMap.java b/core/java/android/content/res/PackageRedirectionMap.java
new file mode 100644
index 0000000..55c4282
--- /dev/null
+++ b/core/java/android/content/res/PackageRedirectionMap.java
@@ -0,0 +1,90 @@
+package android.content.res;
+
+import android.os.Parcel;
+import android.os.Parcelable;
+
+/**
+ * Native transport for package asset redirection information coming from the
+ * AssetRedirectionManagerService.
+ *
+ * @hide
+ */
+public class PackageRedirectionMap implements Parcelable {
+    private final int mNativePointer;
+
+    public static final Parcelable.Creator<PackageRedirectionMap> CREATOR
+            = new Parcelable.Creator<PackageRedirectionMap>() {
+        public PackageRedirectionMap createFromParcel(Parcel in) {
+            return new PackageRedirectionMap(in);
+        }
+
+        public PackageRedirectionMap[] newArray(int size) {
+            return new PackageRedirectionMap[size];
+        }
+    };
+
+    public PackageRedirectionMap() {
+        this(nativeConstructor());
+    }
+
+    private PackageRedirectionMap(Parcel in) {
+        this(nativeCreateFromParcel(in));
+    }
+
+    private PackageRedirectionMap(int nativePointer) {
+        if (nativePointer == 0) {
+            throw new RuntimeException();
+        }
+        mNativePointer = nativePointer;
+    }
+
+    @Override
+    protected void finalize() throws Throwable {
+        nativeDestructor(mNativePointer);
+    }
+
+    public int getNativePointer() {
+        return mNativePointer;
+    }
+
+    @Override
+    public int describeContents() {
+        return 0;
+    }
+
+    @Override
+    public void writeToParcel(Parcel dest, int flags) {
+        if (!nativeWriteToParcel(mNativePointer, dest)) {
+            throw new RuntimeException();
+        }
+    }
+
+    public int getPackageId() {
+        return nativeGetPackageId(mNativePointer);
+    }
+
+    public void addRedirection(int fromIdent, int toIdent) {
+        nativeAddRedirection(mNativePointer, fromIdent, toIdent);
+    }
+
+    // Used for debugging purposes only.
+    public int[] getRedirectionKeys() {
+        return nativeGetRedirectionKeys(mNativePointer);
+    }
+
+    // Used for debugging purposes only.
+    public int lookupRedirection(int fromIdent) {
+        return nativeLookupRedirection(mNativePointer, fromIdent);
+    }
+
+    private static native int nativeConstructor();
+    private static native void nativeDestructor(int nativePointer);
+
+    private static native int nativeCreateFromParcel(Parcel p);
+    private static native boolean nativeWriteToParcel(int nativePointer, Parcel p);
+
+    private native void nativeAddRedirection(int nativePointer, int fromIdent, int toIdent);
+    private native int nativeGetPackageId(int nativePointer);
+    private native int[] nativeGetRedirectionKeys(int nativePointer);
+    private native int nativeLookupRedirection(int nativePointer, int fromIdent);
+}
diff --git a/core/java/android/content/res/Resources.java b/core/java/android/content/res/Resources.java
index b6b6a8d..8fa0041 100755
--- a/core/java/android/content/res/Resources.java
+++ b/core/java/android/content/res/Resources.java
@@ -26,6 +26,7 @@ import android.graphics.Movie;
 import android.graphics.drawable.Drawable;
 import android.graphics.drawable.ColorDrawable;
 import android.graphics.drawable.Drawable.ConstantState;
+import android.graphics.PorterDuff.Mode;
 import android.os.Build;
 import android.os.Bundle;
 import android.util.AttributeSet;
@@ -708,6 +709,36 @@ public class Resources {
         }
     }
 
+     /**
+     * Return a drawable object associated with a particular resource ID.
+     * Various types of objects will be returned depending on the underlying
+     * resource -- for example, a solid color, PNG image, scalable image, etc.
+     * The Drawable API hides these implementation details.
+     *
+     * mtwebster: This version also applies a Porter Duff color mask onto the object before
+     * returning the object. Put in Resources to give reusability, I plan on
+     * applying this to other parts of the gui
+     *
+     * @param id The desired resource identifier, as generated by the aapt tool.
+     *            This integer encodes the package, type, and resource entry.
+     *            The value 0 is an invalid identifier.
+     * @param mask The color mask to use (alpha-r-g-b)
+     * @param masktype The Porter Duff filter mode
+     * @throws NotFoundException Throws NotFoundException if the given ID does
+     *             not exist.
+     * @return Drawable An object that can be used to draw this resource.
+     * @hide
+     */
+    public Drawable getDrawable(int id, int mask, Mode maskType) throws NotFoundException {
+        synchronized (mTmpValue) {
+            TypedValue value = mTmpValue;
+            getValue(id, value, true);
+            Drawable tmpDrawable = loadDrawable(value, id);
+            tmpDrawable.setColorFilter(mask, maskType);
+            return tmpDrawable;
+        }
+    }
+
     /**
      * Return a movie object associated with the particular resource ID.
      * @param id The desired resource identifier, as generated by the aapt
@@ -1446,7 +1477,15 @@ public class Resources {
                     mTmpConfig.locale = Locale.getDefault();
                 }
                 configChanges = mConfiguration.updateFrom(mTmpConfig);
-                configChanges = ActivityInfo.activityInfoConfigToNative(configChanges);
+
+                /* This is ugly, but modifying the activityInfoConfigToNative
+                 * adapter would be messier */
+                if ((configChanges & ActivityInfo.CONFIG_THEME_RESOURCE) != 0) {
+                    configChanges = ActivityInfo.activityInfoConfigToNative(configChanges);
+                    configChanges |= ActivityInfo.CONFIG_THEME_RESOURCE;
+                } else {
+                    configChanges = ActivityInfo.activityInfoConfigToNative(configChanges);
+                }
             }
             if (mConfiguration.locale == null) {
                 mConfiguration.locale = Locale.getDefault();
@@ -1508,6 +1547,18 @@ public class Resources {
     private void clearDrawableCache(
             LongSparseArray<WeakReference<ConstantState>> cache,
             int configChanges) {
+        /*
+         * Quick test to find out if the config change that occurred should
+         * trigger a full cache wipe.
+         */
+        if (Configuration.needNewResources(configChanges, 0)) {
+            if (DEBUG_CONFIG) {
+                Log.d(TAG, "Clear drawable cache from config changes: 0x"
+                        + Integer.toHexString(configChanges));
+            }
+            cache.clear();
+            return;
+        }
         int N = cache.size();
         if (DEBUG_CONFIG) {
             Log.d(TAG, "Cleaning up drawables config changes: 0x"
@@ -1859,7 +1910,16 @@ public class Resources {
             flushLayoutCache();
         }
     }
-    
+
+    /**
+     * @hide
+     */
+    public final void updateStringCache() {
+        synchronized (mTmpValue) {
+            mAssets.recreateStringBlocks();
+        }
+    }
+ 
     /*package*/ Drawable loadDrawable(TypedValue value, int id)
             throws NotFoundException {
 
diff --git a/core/java/android/database/ContentObserver.java b/core/java/android/database/ContentObserver.java
index 3b829a3..8809a60 100644
--- a/core/java/android/database/ContentObserver.java
+++ b/core/java/android/database/ContentObserver.java
@@ -16,6 +16,7 @@
 
 package android.database;
 
+import android.net.Uri;
 import android.os.Handler;
 
 /**
@@ -34,13 +35,24 @@ public abstract class ContentObserver {
     private final class NotificationRunnable implements Runnable {
 
         private boolean mSelf;
+	private Uri mUri = null;
 
         public NotificationRunnable(boolean self) {
             mSelf = self;
         }
 
-        public void run() {
-            ContentObserver.this.onChange(mSelf);
+
+        public NotificationRunnable(Uri uri, boolean self) {
+            mSelf = self;
+            mUri = uri;
+        }
+
+        public void run() { 
+            if (mUri != null) {
+                ContentObserver.this.onChangeUri(mUri, mSelf);
+            } else {
+                ContentObserver.this.onChange(mSelf);
+            }
         }
     }
 
@@ -59,6 +71,13 @@ public abstract class ContentObserver {
             return false;
         }
 
+        public void onChangeUri(Uri uri, boolean selfChange) {
+            ContentObserver contentObserver = mContentObserver;
+            if (contentObserver != null) {
+                contentObserver.dispatchChange(uri, selfChange);
+            }
+        }
+
         public void onChange(boolean selfChange) {
             ContentObserver contentObserver = mContentObserver;
             if (contentObserver != null) {
@@ -128,6 +147,9 @@ public abstract class ContentObserver {
      */
     public void onChange(boolean selfChange) {}
 
+    /** @hide */
+    public void onChangeUri(Uri uri, boolean selfChange) {}
+
     public final void dispatchChange(boolean selfChange) {
         if (mHandler == null) {
             onChange(selfChange);
@@ -135,4 +157,15 @@ public abstract class ContentObserver {
             mHandler.post(new NotificationRunnable(selfChange));
         }
     }
+
+
+    /** @hide */
+    public final void dispatchChange(Uri uri, boolean selfChange) {
+        if (mHandler == null) {
+            onChangeUri(uri, selfChange);
+        } else {
+            mHandler.post(new NotificationRunnable(uri, selfChange));
+        }
+    }
+
 }
diff --git a/core/java/android/database/IContentObserver.aidl b/core/java/android/database/IContentObserver.aidl
index ac2f975..f66c29d 100755
--- a/core/java/android/database/IContentObserver.aidl
+++ b/core/java/android/database/IContentObserver.aidl
@@ -17,6 +17,8 @@
 
 package android.database;
 
+import android.net.Uri;
+
 /**
  * @hide
  */
@@ -28,4 +30,5 @@ interface IContentObserver
      * commit on the cursor that is being observed.
      */
     oneway void onChange(boolean selfUpdate);
+    oneway void onChangeUri(in Uri uri, boolean selfUpdate);
 }
diff --git a/core/java/android/hardware/Camera.java b/core/java/android/hardware/Camera.java
index 7ca6155..1e8ea4e 100644
--- a/core/java/android/hardware/Camera.java
+++ b/core/java/android/hardware/Camera.java
@@ -137,6 +137,8 @@ public class Camera {
     private static final int CAMERA_MSG_RAW_IMAGE        = 0x080;
     private static final int CAMERA_MSG_COMPRESSED_IMAGE = 0x100;
     private static final int CAMERA_MSG_RAW_IMAGE_NOTIFY = 0x200;
+    private static final int CAMERA_MSG_STATS_DATA       = 0x800;
+    private static final int CAMERA_MSG_META_DATA        = 0x8000;
     private static final int CAMERA_MSG_PREVIEW_METADATA = 0x400;
     private static final int CAMERA_MSG_ALL_MSGS         = 0x4FF;
 
@@ -148,6 +150,8 @@ public class Camera {
     private PreviewCallback mPreviewCallback;
     private PictureCallback mPostviewCallback;
     private AutoFocusCallback mAutoFocusCallback;
+    private CameraDataCallback mCameraDataCallback;
+    private CameraMetaDataCallback mCameraMetaDataCallback;
     private OnZoomChangeListener mZoomListener;
     private FaceDetectionListener mFaceListener;
     private ErrorCallback mErrorCallback;
@@ -207,6 +211,18 @@ public class Camera {
         public static final int CAMERA_FACING_FRONT = 1;
 
         /**
+         * The facing of the camera is the same as that of the screen.
+         * @hide
+         */
+        public static final int CAMERA_SUPPORT_MODE_ZSL = 2;
+
+        /**
+         * The facing of the camera is the same as that of the screen.
+         * @hide
+         */
+        public static final int CAMERA_SUPPORT_MODE_NONZSL = 3;
+
+        /**
          * The direction that the camera faces. It should be
          * CAMERA_FACING_BACK or CAMERA_FACING_FRONT.
          */
@@ -289,6 +305,8 @@ public class Camera {
         mPreviewCallback = null;
         mPostviewCallback = null;
         mZoomListener = null;
+        mCameraDataCallback = null;
+        mCameraMetaDataCallback = null;
 
         Looper looper;
         if ((looper = Looper.myLooper()) != null) {
@@ -706,6 +724,21 @@ public class Camera {
                 }
                 return;
 
+            case CAMERA_MSG_STATS_DATA:
+                int statsdata[] = new int[257];
+                for(int i =0; i<257; i++ ) {
+                   statsdata[i] = byteToInt( (byte[])msg.obj, i*4);
+                }
+                if (mCameraDataCallback != null) {
+                     mCameraDataCallback.onCameraData(statsdata, mCamera);
+                }
+                return;
+
+            case CAMERA_MSG_META_DATA:
+                if (mCameraMetaDataCallback != null) {
+                    mCameraMetaDataCallback.onCameraMetaData((int[])msg.obj, mCamera);
+                }
+                return;
             case CAMERA_MSG_POSTVIEW_FRAME:
                 if (mPostviewCallback != null) {
                     mPostviewCallback.onPictureTaken((byte[])msg.obj, mCamera);
@@ -744,6 +777,14 @@ public class Camera {
         }
     }
 
+    private static int byteToInt(byte[] b, int offset) {
+        int value = 0;
+        for (int i = 0; i < 4; i++) {
+            int shift = (4 - 1 - i) * 8;
+            value += (b[(3-i) + offset] & 0x000000FF) << shift;
+        }
+        return value;
+    }
     private static void postEventFromNative(Object camera_ref,
                                             int what, int arg1, int arg2, Object obj)
     {
@@ -849,6 +890,15 @@ public class Camera {
     private native final void native_cancelAutoFocus();
 
     /**
+     * @hide
+     */
+
+    public final void encodeData()
+    {
+        native_encodeData();
+    }
+    private native final void native_encodeData();
+    /**
      * Callback interface used to signal the moment of actual image capture.
      *
      * @see #takePicture(ShutterCallback, PictureCallback, PictureCallback, PictureCallback)
@@ -864,6 +914,84 @@ public class Camera {
          */
         void onShutter();
     }
+    /**
+     * @hide
+     * Handles the callback for when Camera Data is available.
+     * data is read from the camera.
+     */
+    public interface CameraDataCallback {
+        /**
+         * Callback for when camera data is available.
+         *
+         * @param data   a int array of the camera data
+         * @param camera the Camera service object
+         */
+        void onCameraData(int[] data, Camera camera);
+    };
+
+    /**
+     * @hide
+     * Set camera histogram mode and registers a callback function to run.
+     *  Only valid after startPreview() has been called.
+     *
+     * @param cb the callback to run
+     */
+    public final void setHistogramMode(CameraDataCallback cb)
+    {
+        mCameraDataCallback = cb;
+        native_setHistogramMode(cb!=null);
+    }
+    private native final void native_setHistogramMode(boolean mode);
+
+    /**
+     * @hide
+     * Set camera histogram command to send data.
+     *
+     */
+    public final void sendHistogramData()
+    {
+        native_sendHistogramData();
+    }
+    private native final void native_sendHistogramData();
+
+    /**
+     * @hide
+     * Handles the callback for when Camera Meta Data is available.
+     * Meta data is read from the camera.
+     */
+    public interface CameraMetaDataCallback {
+        /**
+         * Callback for when camera meta data is available.
+         *
+         * @param data   a int array of the camera meta data
+         * @param camera the Camera service object
+         */
+        void onCameraMetaData(int[] data, Camera camera);
+    };
+
+    /**
+     * @hide
+     * Set camera face detection mode and registers a callback function to run.
+     *  Only valid after startPreview() has been called.
+     *
+     * @param cb the callback to run
+     */
+    public final void setFaceDetectionCb(CameraMetaDataCallback cb)
+    {
+        mCameraMetaDataCallback = cb;
+        native_setFaceDetectionCb(cb!=null);
+    }
+    private native final void native_setFaceDetectionCb(boolean mode);
+
+    /**
+     * @hide
+     * Set camera face detection command to send meta data.
+     */
+    public final void sendMetaData()
+    {
+        native_sendMetaData();
+    }
+    private native final void native_sendMetaData();
 
     /**
      * Callback interface used to supply image data from a photo capture.
@@ -1435,6 +1563,43 @@ public class Camera {
          */
         public int weight;
     }
+     /**
+     * @hide
+     * Handles the Touch Co-ordinate.
+     */
+	public class Coordinate {
+        /**
+         * Sets the x,y co-ordinates for a touch event
+         *
+         * @param x the x co-ordinate (pixels)
+         * @param y the y co-ordinate (pixels)
+         */
+        public Coordinate(int x, int y) {
+            xCoordinate = x;
+            yCoordinate = y;
+        }
+        /**
+         * Compares {@code obj} to this co-ordinate.
+         *
+         * @param obj the object to compare this co-ordinate with.
+         * @return {@code true} if the xCoordinate and yCoordinate of {@code obj} is the
+         *         same as those of this coordinate. {@code false} otherwise.
+         */
+        @Override
+        public boolean equals(Object obj) {
+            if (!(obj instanceof Coordinate)) {
+                return false;
+            }
+            Coordinate c = (Coordinate) obj;
+            return xCoordinate == c.xCoordinate && yCoordinate == c.yCoordinate;
+        }
+
+        /** x co-ordinate for the touch event*/
+        public int xCoordinate;
+
+        /** y co-ordinate for the touch event */
+        public int yCoordinate;
+    };
 
     /**
      * Camera service settings.
@@ -1456,9 +1621,13 @@ public class Camera {
     public class Parameters {
         // Parameter keys to communicate with the camera driver.
         private static final String KEY_PREVIEW_SIZE = "preview-size";
+	private static final String KEY_HFR_SIZE = "hfr-size";
         private static final String KEY_PREVIEW_FORMAT = "preview-format";
         private static final String KEY_PREVIEW_FRAME_RATE = "preview-frame-rate";
         private static final String KEY_PREVIEW_FPS_RANGE = "preview-fps-range";
+        private static final String KEY_PREVIEW_FRAME_RATE_MODE = "preview-frame-rate-mode";
+        private static final String KEY_PREVIEW_FRAME_RATE_AUTO_MODE = "frame-rate-auto";
+        private static final String KEY_PREVIEW_FRAME_RATE_FIXED_MODE = "frame-rate-fixed";
         private static final String KEY_PICTURE_SIZE = "picture-size";
         private static final String KEY_PICTURE_FORMAT = "picture-format";
         private static final String KEY_JPEG_THUMBNAIL_SIZE = "jpeg-thumbnail-size";
@@ -1470,14 +1639,27 @@ public class Camera {
         private static final String KEY_GPS_LATITUDE = "gps-latitude";
         private static final String KEY_GPS_LONGITUDE = "gps-longitude";
         private static final String KEY_GPS_ALTITUDE = "gps-altitude";
+        private static final String KEY_GPS_LATITUDE_REF = "gps-latitude-ref";
+        private static final String KEY_GPS_LONGITUDE_REF = "gps-longitude-ref";
+        private static final String KEY_GPS_ALTITUDE_REF = "gps-altitude-ref";
+        private static final String KEY_GPS_STATUS = "gps-status";
         private static final String KEY_GPS_TIMESTAMP = "gps-timestamp";
+        private static final String KEY_EXIF_DATETIME = "exif-datetime";
         private static final String KEY_GPS_PROCESSING_METHOD = "gps-processing-method";
         private static final String KEY_WHITE_BALANCE = "whitebalance";
         private static final String KEY_EFFECT = "effect";
+        private static final String KEY_TOUCH_AF_AEC = "touch-af-aec";
+        private static final String KEY_TOUCH_INDEX_AEC = "touch-index-aec";
+        private static final String KEY_TOUCH_INDEX_AF = "touch-index-af";
         private static final String KEY_ANTIBANDING = "antibanding";
         private static final String KEY_SCENE_MODE = "scene-mode";
+        private static final String KEY_SCENE_DETECT = "scene-detect";
         private static final String KEY_FLASH_MODE = "flash-mode";
         private static final String KEY_FOCUS_MODE = "focus-mode";
+        private static final String KEY_ISO_MODE = "iso";
+        private static final String KEY_LENSSHADE = "lensshade";
+        private static final String KEY_HISTOGRAM = "histogram";
+        private static final String KEY_SKIN_TONE_ENHANCEMENT = "skinToneEnhancement";
         private static final String KEY_FOCUS_AREAS = "focus-areas";
         private static final String KEY_MAX_NUM_FOCUS_AREAS = "max-num-focus-areas";
         private static final String KEY_FOCAL_LENGTH = "focal-length";
@@ -1493,6 +1675,7 @@ public class Camera {
         private static final String KEY_AUTO_WHITEBALANCE_LOCK_SUPPORTED = "auto-whitebalance-lock-supported";
         private static final String KEY_METERING_AREAS = "metering-areas";
         private static final String KEY_MAX_NUM_METERING_AREAS = "max-num-metering-areas";
+        private static final String KEY_AUTO_EXPOSURE = "auto-exposure";
         private static final String KEY_ZOOM = "zoom";
         private static final String KEY_MAX_ZOOM = "max-zoom";
         private static final String KEY_ZOOM_RATIOS = "zoom-ratios";
@@ -1506,8 +1689,24 @@ public class Camera {
         private static final String KEY_MAX_NUM_DETECTED_FACES_SW = "max-num-detected-faces-sw";
         private static final String KEY_RECORDING_HINT = "recording-hint";
         private static final String KEY_VIDEO_SNAPSHOT_SUPPORTED = "video-snapshot-supported";
+        private static final String KEY_FULL_VIDEO_SNAP_SUPPORTED = "full-video-snap-supported";
         private static final String KEY_VIDEO_STABILIZATION = "video-stabilization";
         private static final String KEY_VIDEO_STABILIZATION_SUPPORTED = "video-stabilization-supported";
+        private static final String KEY_SHARPNESS = "sharpness";
+        private static final String KEY_MAX_SHARPNESS = "max-sharpness";
+        private static final String KEY_CONTRAST = "contrast";
+        private static final String KEY_MAX_CONTRAST = "max-contrast";
+        private static final String KEY_SATURATION = "saturation";
+        private static final String KEY_MAX_SATURATION = "max-saturation";
+        private static final String KEY_DENOISE = "denoise";
+        private static final String KEY_CONTINUOUS_AF = "continuous-af";
+        private static final String KEY_SELECTABLE_ZONE_AF = "selectable-zone-af";
+        private static final String KEY_FACE_DETECTION = "face-detection";
+        private static final String KEY_MEMORY_COLOR_ENHANCEMENT = "mce";
+        private static final String KEY_REDEYE_REDUCTION = "redeye-reduction";
+        private static final String KEY_ZSL = "zsl";
+        private static final String KEY_CAMERA_MODE = "camera-mode";
+        private static final String KEY_VIDEO_HIGH_FRAME_RATE = "video-hfr";
 
         // Parameter key suffix for supported values.
         private static final String SUPPORTED_VALUES_SUFFIX = "-values";
@@ -1536,12 +1735,91 @@ public class Camera {
         public static final String EFFECT_BLACKBOARD = "blackboard";
         public static final String EFFECT_AQUA = "aqua";
 
+        // Values for touch af/aec settings.
+        /** @hide */
+        public static final String TOUCH_AF_AEC_OFF = "touch-off";
+        /** @hide */
+        public static final String TOUCH_AF_AEC_ON = "touch-on";
+
+        // Values for auto exposure settings.
+        /** @hide */
+        public static final String AUTO_EXPOSURE_FRAME_AVG = "frame-average";
+        /** @hide */
+        public static final String AUTO_EXPOSURE_CENTER_WEIGHTED = "center-weighted";
+        /** @hide */
+        public static final String AUTO_EXPOSURE_SPOT_METERING = "spot-metering";
         // Values for antibanding settings.
         public static final String ANTIBANDING_AUTO = "auto";
         public static final String ANTIBANDING_50HZ = "50hz";
         public static final String ANTIBANDING_60HZ = "60hz";
         public static final String ANTIBANDING_OFF = "off";
 
+        //Values for ISO settings
+        /** @hide */
+        public static final String ISO_AUTO = "auto";
+        /** @hide */
+        public static final String ISO_HJR = "ISO_HJR";
+        /** @hide */
+        public static final String ISO_100 = "ISO100";
+        /** @hide */
+        public static final String ISO_200 = "ISO200";
+        /** @hide */
+        public static final String ISO_400 = "ISO400";
+        /** @hide */
+        public static final String ISO_800 = "ISO800";
+        /** @hide */
+        public static final String ISO_1600 = "ISO1600";
+
+        //Values for Lens Shading
+
+        /** @hide */
+        public static final String LENSSHADE_ENABLE = "enable";
+        /** @hide */
+        public static final String LENSSHADE_DISABLE= "disable";
+
+        /** @hide */
+        public static final String HISTOGRAM_ENABLE = "enable";
+        /** @hide */
+        public static final String HISTOGRAM_DISABLE= "disable";
+
+        /** @hide */
+        public static final String SKIN_TONE_ENHANCEMENT_ENABLE = "enable";
+        /** @hide */
+        public static final String SKIN_TONE_ENHANCEMENT_DISABLE= "disable";
+
+        // Values for MCE settings.
+        /** @hide */
+        public static final String MCE_ENABLE = "enable";
+        /** @hide */
+        public static final String MCE_DISABLE = "disable";
+
+        // Values for ZSL settings.
+        /** @hide */
+        public static final String ZSL_ON = "on";
+        /** @hide */
+        public static final String ZSL_OFF = "off";
+
+        // Values for HDR Bracketing settings.
+        /** @hide */
+        public static final String AE_BRACKET_HDR_OFF = "Off";
+        /** @hide */
+        public static final String AE_BRACKET_HDR = "HDR";
+        /** @hide */
+        public static final String AE_BRACKET = "AE-Bracket";
+
+        // Values for HFR settings.
+        /** @hide */
+        public static final String VIDEO_HFR_OFF = "off";
+        /** @hide */
+        public static final String VIDEO_HFR_2X = "60";
+        /** @hide */
+        public static final String VIDEO_HFR_3X = "90";
+        /** @hide */
+        public static final String VIDEO_HFR_4X = "120";
+
+        /** @hide */
+        public static final String KEY_AE_BRACKET_HDR = "ae-bracket-hdr";
+
         // Values for flash mode settings.
         /**
          * Flash will not be fired.
@@ -1572,7 +1850,19 @@ public class Camera {
         public static final String FLASH_MODE_TORCH = "torch";
 
         /**
+         * Scene mode is off. (for some QCom)
+         * @hide
+         */
+        public static final String SCENE_MODE_OFF = "off";
+
+        /**
          * Scene mode is off.
+         * @hide
+         */
+        public static final String SCENE_MODE_ASD = "asd";
+
+        /**
+         * Scene mode is auto ASD.
          */
         public static final String SCENE_MODE_AUTO = "auto";
 
@@ -1647,6 +1937,16 @@ public class Camera {
          * Capture the naturally warm color of scenes lit by candles.
          */
         public static final String SCENE_MODE_CANDLELIGHT = "candlelight";
+        /** @hide */
+        public static final String SCENE_MODE_BACKLIGHT = "backlight";
+        /** @hide */
+        public static final String SCENE_MODE_FLOWERS = "flowers";
+
+        // Values for auto scene detection settings.
+        /** @hide */
+        public static final String SCENE_DETECT_OFF = "off";
+        /** @hide */
+        public static final String SCENE_DETECT_ON = "on";
 
         /**
          * Applications are looking for a barcode. Camera driver will be
@@ -1682,6 +1982,14 @@ public class Camera {
         public static final String FOCUS_MODE_FIXED = "fixed";
 
         /**
+         * Normal focus mode. Applications should call
+         * {@link #autoFocus(AutoFocusCallback)} to start the focus in this
+         * mode.
+         * @hide
+         */
+        public static final String FOCUS_MODE_NORMAL = "normal";
+
+        /**
          * Extended depth of field (EDOF). Focusing is done digitally and
          * continuously. Applications should not call {@link
          * #autoFocus(AutoFocusCallback)} in this mode.
@@ -1769,11 +2077,47 @@ public class Camera {
         // Formats for setPreviewFormat and setPictureFormat.
         private static final String PIXEL_FORMAT_YUV422SP = "yuv422sp";
         private static final String PIXEL_FORMAT_YUV420SP = "yuv420sp";
+        private static final String PIXEL_FORMAT_YUV420SP_ADRENO = "yuv420sp-adreno";
         private static final String PIXEL_FORMAT_YUV422I = "yuv422i-yuyv";
         private static final String PIXEL_FORMAT_YUV420P = "yuv420p";
         private static final String PIXEL_FORMAT_RGB565 = "rgb565";
         private static final String PIXEL_FORMAT_JPEG = "jpeg";
         private static final String PIXEL_FORMAT_BAYER_RGGB = "bayer-rggb";
+        private static final String PIXEL_FORMAT_RAW = "raw";
+        private static final String PIXEL_FORMAT_YV12 = "yv12";
+        private static final String PIXEL_FORMAT_NV12 = "nv12";
+
+        //Values for Continuous AF
+
+        /** @hide */
+        public static final String CONTINUOUS_AF_OFF = "caf-off";
+        /** @hide */
+        public static final String CONTINUOUS_AF_ON = "caf-on";
+        /** @hide */
+        public static final String DENOISE_OFF = "denoise-off";
+        /** @hide */
+        public static final String DENOISE_ON = "denoise-on";
+	// Values for Redeye Reduction settings.
+        /** @hide */
+        public static final String REDEYE_REDUCTION_ENABLE = "enable";
+        /** @hide */
+        public static final String REDEYE_REDUCTION_DISABLE = "disable";
+
+        // Values for selectable zone af settings.
+        /** @hide */
+        public static final String SELECTABLE_ZONE_AF_AUTO = "auto";
+        /** @hide */
+        public static final String SELECTABLE_ZONE_AF_SPOTMETERING = "spot-metering";
+        /** @hide */
+        public static final String SELECTABLE_ZONE_AF_CENTER_WEIGHTED = "center-weighted";
+        /** @hide */
+        public static final String SELECTABLE_ZONE_AF_FRAME_AVERAGE = "frame-average";
+
+        // Values for Face Detection settings.
+        /** @hide */
+        public static final String FACE_DETECTION_OFF = "off";
+        /** @hide */
+        public static final String FACE_DETECTION_ON = "on";
 
         private HashMap<String, String> mMap;
 
@@ -1966,6 +2310,18 @@ public class Camera {
             return splitSize(str);
         }
 
+	/**
+         * @hide
+         * Gets the supported preview sizes in high frame rate recording mode.
+         *
+         * @return a list of Size object. This method will always return a list
+         *         with at least one element.
+         */
+        public List<Size> getSupportedHfrSizes() {
+            String str = get(KEY_HFR_SIZE + SUPPORTED_VALUES_SUFFIX);
+            return splitSize(str);
+        }
+
         /**
          * <p>Gets the supported video frame sizes that can be used by
          * MediaRecorder.</p>
@@ -2418,6 +2774,16 @@ public class Camera {
         }
 
         /**
+         * @hide
+         * Sets GPS latitude reference coordinate. This will be stored in JPEG EXIF
+         * header.
+         * @param latRef GPS latitude reference coordinate.
+         */
+        public void setGpsLatitudeRef(String latRef) {
+            set(KEY_GPS_LATITUDE_REF, latRef);
+        }
+
+        /**
          * Sets GPS latitude coordinate. This will be stored in JPEG EXIF
          * header.
          *
@@ -2428,6 +2794,16 @@ public class Camera {
         }
 
         /**
+         * @hide
+         * Sets GPS longitude reference coordinate. This will be stored in JPEG EXIF
+         * header.
+         * @param lonRef GPS longitude reference coordinate.
+         */
+        public void setGpsLongitudeRef(String lonRef) {
+            set(KEY_GPS_LONGITUDE_REF, lonRef);
+        }
+
+        /**
          * Sets GPS longitude coordinate. This will be stored in JPEG EXIF
          * header.
          *
@@ -2438,6 +2814,15 @@ public class Camera {
         }
 
         /**
+         * @hide
+         * Sets GPS altitude reference. This will be stored in JPEG EXIF header.
+         * @param altRef reference GPS altitude in meters.
+         */
+        public void setGpsAltitudeRef(double altRef) {
+            set(KEY_GPS_ALTITUDE_REF, Double.toString(altRef));
+        }
+
+        /**
          * Sets GPS altitude. This will be stored in JPEG EXIF header.
          *
          * @param altitude GPS altitude in meters.
@@ -2467,12 +2852,37 @@ public class Camera {
         }
 
         /**
+         * @hide
+         * Sets system timestamp. This will be stored in JPEG EXIF header.
+         *
+         * @param dateTime current timestamp (UTC in seconds since January 1,
+         *                  1970).
+         */
+        public void setExifDateTime(String dateTime) {
+            set(KEY_EXIF_DATETIME, dateTime);
+        }
+
+        /**
+         * @hide
+         * Sets GPS Status. This will be stored in JPEG EXIF header.
+         *
+         * @param status GPS status (UTC in seconds since January 1,
+         *                  1970).
+         */
+        public void setGpsStatus(double status) {
+            set(KEY_GPS_STATUS, Double.toString(status));
+        }
+
+        /**
          * Removes GPS latitude, longitude, altitude, and timestamp from the
          * parameters.
          */
         public void removeGpsData() {
+            remove(KEY_GPS_LATITUDE_REF);
             remove(KEY_GPS_LATITUDE);
+            remove(KEY_GPS_LONGITUDE_REF);
             remove(KEY_GPS_LONGITUDE);
+            remove(KEY_GPS_ALTITUDE_REF);
             remove(KEY_GPS_ALTITUDE);
             remove(KEY_GPS_TIMESTAMP);
             remove(KEY_GPS_PROCESSING_METHOD);
@@ -2566,149 +2976,470 @@ public class Camera {
             return split(str);
         }
 
-
         /**
-         * Gets the current antibanding setting.
+         * @hide
+         * Gets the current Touch AF/AEC setting.
+         *
+         * @return one of TOUCH_AF_AEC_XXX string constant. null if Touch AF/AEC
+         *         setting is not supported.
          *
-         * @return current antibanding. null if antibanding setting is not
-         *         supported.
-         * @see #ANTIBANDING_AUTO
-         * @see #ANTIBANDING_50HZ
-         * @see #ANTIBANDING_60HZ
-         * @see #ANTIBANDING_OFF
          */
-        public String getAntibanding() {
-            return get(KEY_ANTIBANDING);
+        public String getTouchAfAec() {
+            return get(KEY_TOUCH_AF_AEC);
         }
 
         /**
-         * Sets the antibanding.
+         * @hide
+         * Sets the current TOUCH AF/AEC setting.
+         *
+         * @param value TOUCH_AF_AEC_XXX string constants.
          *
-         * @param antibanding new antibanding value.
-         * @see #getAntibanding()
          */
-        public void setAntibanding(String antibanding) {
-            set(KEY_ANTIBANDING, antibanding);
+        public void setTouchAfAec(String value) {
+            set(KEY_TOUCH_AF_AEC, value);
         }
 
-        /**
-         * Gets the supported antibanding values.
+       /**
+         * @hide
+         * Gets the supported Touch AF/AEC setting.
          *
-         * @return a list of supported antibanding values. null if antibanding
+         * @return a List of TOUCH_AF_AEC_XXX string constants. null if TOUCH AF/AEC
          *         setting is not supported.
-         * @see #getAntibanding()
+         *
          */
-        public List<String> getSupportedAntibanding() {
-            String str = get(KEY_ANTIBANDING + SUPPORTED_VALUES_SUFFIX);
+        public List<String> getSupportedTouchAfAec() {
+            String str = get(KEY_TOUCH_AF_AEC + SUPPORTED_VALUES_SUFFIX);
             return split(str);
         }
 
         /**
-         * Gets the current scene mode setting.
+         * @hide
+         * Sets the touch co-ordinate for Touch AEC.
+         *
+         * @param x  the x co-ordinate of the touch event
+         * @param y the y co-ordinate of the touch event
          *
-         * @return one of SCENE_MODE_XXX string constant. null if scene mode
-         *         setting is not supported.
-         * @see #SCENE_MODE_AUTO
-         * @see #SCENE_MODE_ACTION
-         * @see #SCENE_MODE_PORTRAIT
-         * @see #SCENE_MODE_LANDSCAPE
-         * @see #SCENE_MODE_NIGHT
-         * @see #SCENE_MODE_NIGHT_PORTRAIT
-         * @see #SCENE_MODE_THEATRE
-         * @see #SCENE_MODE_BEACH
-         * @see #SCENE_MODE_SNOW
-         * @see #SCENE_MODE_SUNSET
-         * @see #SCENE_MODE_STEADYPHOTO
-         * @see #SCENE_MODE_FIREWORKS
-         * @see #SCENE_MODE_SPORTS
-         * @see #SCENE_MODE_PARTY
-         * @see #SCENE_MODE_CANDLELIGHT
          */
-        public String getSceneMode() {
-            return get(KEY_SCENE_MODE);
+        public void setTouchIndexAec(int x, int y) {
+            String v = Integer.toString(x) + "x" + Integer.toString(y);
+            set(KEY_TOUCH_INDEX_AEC, v);
         }
 
         /**
-         * Sets the scene mode. Changing scene mode may override other
-         * parameters (such as flash mode, focus mode, white balance). For
-         * example, suppose originally flash mode is on and supported flash
-         * modes are on/off. In night scene mode, both flash mode and supported
-         * flash mode may be changed to off. After setting scene mode,
-         * applications should call getParameters to know if some parameters are
-         * changed.
+         * @hide
+         * Returns the touch co-ordinates of the touch event.
+         *
+         * @return a Index object with the x and y co-ordinated
+         *          for the touch event
          *
-         * @param value scene mode.
-         * @see #getSceneMode()
          */
-        public void setSceneMode(String value) {
-            set(KEY_SCENE_MODE, value);
+        public Coordinate getTouchIndexAec() {
+            String pair = get(KEY_TOUCH_INDEX_AEC);
+            return strToCoordinate(pair);
         }
 
         /**
-         * Gets the supported scene modes.
+         * @hide
+         * Sets the touch co-ordinate for Touch AF.
+         *
+         * @param x  the x co-ordinate of the touch event
+         * @param y the y co-ordinate of the touch event
          *
-         * @return a list of supported scene modes. null if scene mode setting
-         *         is not supported.
-         * @see #getSceneMode()
          */
-        public List<String> getSupportedSceneModes() {
-            String str = get(KEY_SCENE_MODE + SUPPORTED_VALUES_SUFFIX);
-            return split(str);
+        public void setTouchIndexAf(int x, int y) {
+            String v = Integer.toString(x) + "x" + Integer.toString(y);
+            set(KEY_TOUCH_INDEX_AF, v);
         }
 
         /**
-         * Gets the current flash mode setting.
+         * @hide
+         * Returns the touch co-ordinates of the touch event.
+         *
+         * @return a Index object with the x and y co-ordinated
+         *          for the touch event
          *
-         * @return current flash mode. null if flash mode setting is not
-         *         supported.
-         * @see #FLASH_MODE_OFF
-         * @see #FLASH_MODE_AUTO
-         * @see #FLASH_MODE_ON
-         * @see #FLASH_MODE_RED_EYE
-         * @see #FLASH_MODE_TORCH
          */
-        public String getFlashMode() {
-            return get(KEY_FLASH_MODE);
+        public Coordinate getTouchIndexAf() {
+            String pair = get(KEY_TOUCH_INDEX_AF);
+            return strToCoordinate(pair);
         }
 
         /**
-         * Sets the flash mode.
+         * @hide
+         * Get Sharpness level
          *
-         * @param value flash mode.
-         * @see #getFlashMode()
+         * @return sharpness level
          */
-        public void setFlashMode(String value) {
-            set(KEY_FLASH_MODE, value);
+        public int getSharpness(){
+            return getInt(KEY_SHARPNESS);
         }
 
         /**
-         * Gets the supported flash modes.
+         * @hide
+         * Set Sharpness Level
          *
-         * @return a list of supported flash modes. null if flash mode setting
-         *         is not supported.
-         * @see #getFlashMode()
+         * @param sharpness level
          */
-        public List<String> getSupportedFlashModes() {
-            String str = get(KEY_FLASH_MODE + SUPPORTED_VALUES_SUFFIX);
-            return split(str);
+        public void setSharpness(int sharpness){
+            if((sharpness < 0) || (sharpness > getMaxSharpness()) )
+                throw new IllegalArgumentException(
+                        "Invalid Sharpness " + sharpness);
+
+            set(KEY_SHARPNESS, String.valueOf(sharpness));
         }
 
         /**
-         * Gets the current focus mode setting.
+         * @hide
+         * Get Max Sharpness Level
          *
-         * @return current focus mode. This method will always return a non-null
-         *         value. Applications should call {@link
-         *         #autoFocus(AutoFocusCallback)} to start the focus if focus
-         *         mode is FOCUS_MODE_AUTO or FOCUS_MODE_MACRO.
-         * @see #FOCUS_MODE_AUTO
-         * @see #FOCUS_MODE_INFINITY
-         * @see #FOCUS_MODE_MACRO
-         * @see #FOCUS_MODE_FIXED
-         * @see #FOCUS_MODE_EDOF
-         * @see #FOCUS_MODE_CONTINUOUS_VIDEO
+         * @return max sharpness level
          */
-        public String getFocusMode() {
-            return get(KEY_FOCUS_MODE);
+        public int getMaxSharpness(){
+            return getInt(KEY_MAX_SHARPNESS);
+        }
+
+        /**
+         * @hide
+         * Get Contrast level
+         *
+         * @return contrast level
+         */
+        public int getContrast(){
+            return getInt(KEY_CONTRAST);
+        }
+
+        /**
+         * @hide
+         * Set Contrast Level
+         *
+         * @param contrast level
+         */
+        public void setContrast(int contrast){
+            if((contrast < 0 ) || (contrast > getMaxContrast()))
+                throw new IllegalArgumentException(
+                        "Invalid Contrast " + contrast);
+
+            set(KEY_CONTRAST, String.valueOf(contrast));
+        }
+
+        /**
+         * @hide
+         * Get Max Contrast Level
+         *
+         * @return max contrast level
+         */
+        public int getMaxContrast(){
+            return getInt(KEY_MAX_CONTRAST);
+        }
+
+        /**
+         * @hide
+         * Get Saturation level
+         *
+         * @return saturation level
+         */
+        public int getSaturation(){
+            return getInt(KEY_SATURATION);
+        }
+
+        /**
+         * @hide
+         * Set Saturation Level
+         *
+         * @param saturation level
+         */
+        public void setSaturation(int saturation){
+            if((saturation < 0 ) || (saturation > getMaxSaturation()))
+                throw new IllegalArgumentException(
+                        "Invalid Saturation " + saturation);
+
+            set(KEY_SATURATION, String.valueOf(saturation));
+        }
+
+        /**
+         * @hide
+         * Get Max Saturation Level
+         *
+         * @return max contrast level
+         */
+        public int getMaxSaturation(){
+            return getInt(KEY_MAX_SATURATION);
+        }
+
+        /**
+         * @hide
+         * Gets the current redeye reduction setting.
+         *
+         * @return one of REDEYE_REDUCTION_XXX string constant. null if redeye reduction
+         *         setting is not supported.
+         *
+         */
+        public String getRedeyeReductionMode() {
+            return get(KEY_REDEYE_REDUCTION);
+        }
+
+	/**
+         * @hide
+         * Sets the redeye reduction. Other parameters may be changed after changing
+         * redeye reduction. After setting redeye reduction,
+         * applications should call getParameters to know if some parameters are
+         * changed.
+         *
+         * @param value REDEYE_REDUCTION_XXX string constants.
+         *
+         */
+        public void setRedeyeReductionMode(String value) {
+            set(KEY_REDEYE_REDUCTION, value);
+        }
+        /**
+         * @hide
+         * Gets the supported redeye reduction modes.
+         *
+         * @return a List of REDEYE_REDUCTION_XXX string constant. null if redeye reduction
+         *         setting is not supported.
+         *
+         */
+        public List<String> getSupportedRedeyeReductionModes() {
+            String str = get(KEY_REDEYE_REDUCTION + SUPPORTED_VALUES_SUFFIX);
+            return split(str);
+        }
+        /**
+         * Gets the current antibanding setting.
+         *
+         * @return current antibanding. null if antibanding setting is not
+         *         supported.
+         * @see #ANTIBANDING_AUTO
+         * @see #ANTIBANDING_50HZ
+         * @see #ANTIBANDING_60HZ
+         * @see #ANTIBANDING_OFF
+         */
+        public String getAntibanding() {
+            return get(KEY_ANTIBANDING);
+        }
+
+        /**
+         * Sets the antibanding.
+         *
+         * @param antibanding new antibanding value.
+         * @see #getAntibanding()
+         */
+        public void setAntibanding(String antibanding) {
+            set(KEY_ANTIBANDING, antibanding);
+        }
+
+        /**
+         * Gets the supported antibanding values.
+         *
+         * @return a list of supported antibanding values. null if antibanding
+         *         setting is not supported.
+         * @see #getAntibanding()
+         */
+        public List<String> getSupportedAntibanding() {
+            String str = get(KEY_ANTIBANDING + SUPPORTED_VALUES_SUFFIX);
+            return split(str);
+        }
+
+        /**
+         * @hide
+         * Gets the frame rate mode setting.
+         *
+         * @return one of FRAME_RATE_XXX_MODE string constant. null if this
+         *         setting is not supported.
+         */
+        public String getPreviewFrameRateMode() {
+            return get(KEY_PREVIEW_FRAME_RATE_MODE);
+        }
+
+        /**
+         * @hide
+         * Sets the frame rate mode.
+         *
+         * @param value FRAME_RATE_XXX_MODE string constants.
+         */
+        public void setPreviewFrameRateMode(String value) {
+            set(KEY_PREVIEW_FRAME_RATE_MODE, value);
+        }
+
+        /**
+         * @hide
+         * Gets the supported frame rate modes.
+         *
+         * @return a List of FRAME_RATE_XXX_MODE string constant. null if this
+         *         setting is not supported.
+         */
+        public List<String> getSupportedPreviewFrameRateModes() {
+            String str = get(KEY_PREVIEW_FRAME_RATE_MODE + SUPPORTED_VALUES_SUFFIX);
+            return split(str);
+        }
+
+        /**
+         * Gets the current scene mode setting.
+         *
+         * @return one of SCENE_MODE_XXX string constant. null if scene mode
+         *         setting is not supported.
+         * @see #SCENE_MODE_AUTO
+         * @see #SCENE_MODE_ACTION
+         * @see #SCENE_MODE_PORTRAIT
+         * @see #SCENE_MODE_LANDSCAPE
+         * @see #SCENE_MODE_NIGHT
+         * @see #SCENE_MODE_NIGHT_PORTRAIT
+         * @see #SCENE_MODE_THEATRE
+         * @see #SCENE_MODE_BEACH
+         * @see #SCENE_MODE_SNOW
+         * @see #SCENE_MODE_SUNSET
+         * @see #SCENE_MODE_STEADYPHOTO
+         * @see #SCENE_MODE_FIREWORKS
+         * @see #SCENE_MODE_SPORTS
+         * @see #SCENE_MODE_PARTY
+         * @see #SCENE_MODE_CANDLELIGHT
+         */
+        public String getSceneMode() {
+            return get(KEY_SCENE_MODE);
+        }
+
+        /**
+         * Sets the scene mode. Changing scene mode may override other
+         * parameters (such as flash mode, focus mode, white balance). For
+         * example, suppose originally flash mode is on and supported flash
+         * modes are on/off. In night scene mode, both flash mode and supported
+         * flash mode may be changed to off. After setting scene mode,
+         * applications should call getParameters to know if some parameters are
+         * changed.
+         *
+         * @param value scene mode.
+         * @see #getSceneMode()
+         */
+        public void setSceneMode(String value) {
+            set(KEY_SCENE_MODE, value);
+        }
+
+        /**
+         * Gets the supported scene modes.
+         *
+         * @return a list of supported scene modes. null if scene mode setting
+         *         is not supported.
+         * @see #getSceneMode()
+         */
+        public List<String> getSupportedSceneModes() {
+            String str = get(KEY_SCENE_MODE + SUPPORTED_VALUES_SUFFIX);
+            return split(str);
+        }
+
+        /**
+         * @hide
+         * Gets the current auto scene detection setting.
+         *
+         * @return one of SCENE_DETECT_XXX string constant. null if auto scene detection
+         *         setting is not supported.
+         *
+         */
+        public String getSceneDetectMode() {
+            return get(KEY_SCENE_DETECT);
+        }
+
+        /**
+         * @hide
+         * Sets the auto scene detect. Other parameters may be changed after changing
+         * scene detect. After setting auto scene detection,
+         * applications should call getParameters to know if some parameters are
+         * changed.
+         *
+         * @param value SCENE_DETECT_XXX string constants.
+         *
+         */
+        public void setSceneDetectMode(String value) {
+            set(KEY_SCENE_DETECT, value);
+        }
+
+        /**
+         * @hide
+         * Gets the supported auto scene detection modes.
+         *
+         * @return a List of SCENE_DETECT_XXX string constant. null if scene detection
+         *         setting is not supported.
+         *
+         */
+        public List<String> getSupportedSceneDetectModes() {
+            String str = get(KEY_SCENE_DETECT + SUPPORTED_VALUES_SUFFIX);
+            return split(str);
+        }
+
+        /**
+         * Gets the current flash mode setting.
+         *
+         * @return current flash mode. null if flash mode setting is not
+         *         supported.
+         * @see #FLASH_MODE_OFF
+         * @see #FLASH_MODE_AUTO
+         * @see #FLASH_MODE_ON
+         * @see #FLASH_MODE_RED_EYE
+         * @see #FLASH_MODE_TORCH
+         */
+        public String getFlashMode() {
+            return get(KEY_FLASH_MODE);
+        }
+
+        /**
+         * @hide
+         * Gets the current hdr bracketing mode setting.
+         *
+         * @return current hdr bracketing mode.
+         * @see #KEY_AE_BRACKET_OFF
+         * @see #KEY_AE_BRACKET_HDR
+         * @see #KEY_AE_BRACKET_BRACKATING
+         */
+        public String getAEBracket() {
+            return get(KEY_AE_BRACKET_HDR);
+        }
+
+        /**
+         * Sets the flash mode.
+         *
+         * @param value flash mode.
+         * @see #getFlashMode()
+         */
+        public void setFlashMode(String value) {
+            set(KEY_FLASH_MODE, value);
+        }
+
+        /**
+         * @hide
+         * Set HDR-Bracketing Level
+         *
+         * @param value HDR-Bracketing
+         */
+        public void setAEBracket(String value){
+            set(KEY_AE_BRACKET_HDR, value);
+        }
+
+        /**
+         * Gets the supported flash modes.
+         *
+         * @return a list of supported flash modes. null if flash mode setting
+         *         is not supported.
+         * @see #getFlashMode()
+         */
+        public List<String> getSupportedFlashModes() {
+            String str = get(KEY_FLASH_MODE + SUPPORTED_VALUES_SUFFIX);
+            return split(str);
+        }
+
+        /**
+         * Gets the current focus mode setting.
+         *
+         * @return current focus mode. This method will always return a non-null
+         *         value. Applications should call {@link
+         *         #autoFocus(AutoFocusCallback)} to start the focus if focus
+         *         mode is FOCUS_MODE_AUTO or FOCUS_MODE_MACRO.
+         * @see #FOCUS_MODE_AUTO
+         * @see #FOCUS_MODE_INFINITY
+         * @see #FOCUS_MODE_MACRO
+         * @see #FOCUS_MODE_FIXED
+         * @see #FOCUS_MODE_EDOF
+         * @see #FOCUS_MODE_CONTINUOUS_VIDEO
+         */
+        public String getFocusMode() {
+            return get(KEY_FOCUS_MODE);
         }
 
         /**
@@ -3038,7 +3769,246 @@ public class Camera {
         }
 
         /**
-         * <p>Gets the distances from the camera to where an object appears to be
+         * @hide
+         * Gets the current ISO setting.
+         *
+         * @return one of ISO_XXX string constant. null if ISO
+         *         setting is not supported.
+         */
+        public String getISOValue() {
+            return get(KEY_ISO_MODE);
+        }
+
+        /**
+         * @hide
+         * Sets the ISO.
+         *
+         * @param iso ISO_XXX string constant.
+         */
+        public void setISOValue(String iso) {
+            set(KEY_ISO_MODE, iso);
+        }
+
+         /**
+         * @hide
+         * Gets the supported ISO values.
+         *
+         * @return a list of ISO_XXX string constants. null if ISO
+         *         setting is not supported.
+         */
+        public List<String> getSupportedIsoValues() {
+            String str = get(KEY_ISO_MODE + SUPPORTED_VALUES_SUFFIX);
+            return split(str);
+        }
+
+         /**
+         * @hide
+         * Gets the current LensShade Mode.
+         *
+         * @return LensShade Mode
+         */
+        public String getLensShade() {
+            return get(KEY_LENSSHADE);
+        }
+        /**
+         * @hide
+         * Sets the current LensShade Mode.
+         *
+         * @return LensShade Mode
+         */
+        public void setLensShade(String lensshade) {
+            set(KEY_LENSSHADE, lensshade);
+        }
+
+         /**
+         * @hide
+         * Gets the supported Lensshade modes.
+         *
+         * @return a List of LENS_MODE_XXX string constants. null if lens mode
+         *         setting is not supported.
+         */
+        public List<String> getSupportedLensShadeModes() {
+            String str = get(KEY_LENSSHADE + SUPPORTED_VALUES_SUFFIX);
+            return split(str);
+        }
+
+         /**
+         * @hide
+         * Gets the supported Histogram modes.
+         *
+         * @return a List of HISTOGRAM_XXX string constants. null if histogram mode
+         *         setting is not supported.
+         */
+        public List<String> getSupportedHistogramModes() {
+            String str = get(KEY_HISTOGRAM + SUPPORTED_VALUES_SUFFIX);
+            return split(str);
+        }
+
+         /**
+         * @hide
+         * Gets the supported Skin Tone Enhancement modes.
+         *
+         * @return a List of SKIN_TONE_ENHANCEMENT_XXX string constants. null if skin tone enhancement
+         *         setting is not supported.
+         */
+        public List<String> getSupportedSkinToneEnhancementModes() {
+            String str = get(KEY_SKIN_TONE_ENHANCEMENT + SUPPORTED_VALUES_SUFFIX);
+          return split(str);
+        }
+
+         /**
+         * @hide
+         * Gets the current auto exposure setting.
+         *
+         * @return one of AUTO_EXPOSURE_XXX string constant. null if auto exposure
+         *         setting is not supported.
+         */
+        public String getAutoExposure() {
+            return get(KEY_AUTO_EXPOSURE);
+        }
+
+        /**
+         * @hide
+         * Sets the current auto exposure setting.
+         *
+         * @param value AUTO_EXPOSURE_XXX string constants.
+         */
+        public void setAutoExposure(String value) {
+            set(KEY_AUTO_EXPOSURE, value);
+        }
+
+       /**
+         * @hide
+         * Gets the supported auto exposure setting.
+         *
+         * @return a List of AUTO_EXPOSURE_XXX string constants. null if auto exposure
+         *         setting is not supported.
+         */
+        public List<String> getSupportedAutoexposure() {
+            String str = get(KEY_AUTO_EXPOSURE + SUPPORTED_VALUES_SUFFIX);
+            return split(str);
+        }
+
+         /**
+         * @hide
+         * Gets the current MCE Mode.
+         *
+         * @return MCE value
+         */
+        public String getMemColorEnhance() {
+            return get(KEY_MEMORY_COLOR_ENHANCEMENT);
+        }
+
+        /**
+         * @hide
+         * Sets the current MCE Mode.
+         *
+         * @return MCE Mode
+         */
+        public void setMemColorEnhance(String mce) {
+            set(KEY_MEMORY_COLOR_ENHANCEMENT, mce);
+        }
+
+         /**
+         * @hide
+         * Gets the supported MCE modes.
+         *
+         * @return a List of MCE_ENABLE/DISABLE string constants. null if MCE mode
+         *         setting is not supported.
+         */
+        public List<String> getSupportedMemColorEnhanceModes() {
+            String str = get(KEY_MEMORY_COLOR_ENHANCEMENT + SUPPORTED_VALUES_SUFFIX);
+            return split(str);
+        }
+
+         /**
+         * @hide
+         * Gets the current ZSL Mode.
+         *
+         * @return ZSL mode value
+         */
+         public String getZSLMode() {
+            return get(KEY_ZSL);
+         }
+
+         /**
+         * @hide
+         * Sets the current ZSL Mode. ZSL mode is set as a 0th bit in KEY_CAMERA_MODE.
+         *
+         * @return null
+         */
+        public void setZSLMode(String zsl) {
+            set(KEY_ZSL, zsl);
+        }
+
+         /**
+         * @hide
+         * Gets the supported ZSL modes.
+         *
+         * @return a List of ZSL_OFF/OFF string constants. null if ZSL mode
+         * setting is not supported.
+         */
+        public List<String> getSupportedZSLModes() {
+            String str = get(KEY_ZSL + SUPPORTED_VALUES_SUFFIX);
+            return split(str);
+        }
+
+          /**
+          * @hide
+          * Gets the current Camera Mode Flag. Camera mode includes a
+          * flag(byte) which indicates different camera modes.
+          * For now support for ZSL added at bit0
+          *
+          * @return Camera Mode.
+          */
+         public String getCameraMode() {
+            return get(KEY_CAMERA_MODE);
+         }
+
+          /**
+          * @hide
+          * Sets the current Camera Mode.
+          *
+          * @return null
+          */
+         public void setCameraMode(int cameraMode) {
+            set(KEY_CAMERA_MODE, cameraMode);
+         }
+
+         /**
+         * @hide
+         * Gets the current HFR Mode.
+         *
+         * @return VIDEO_HFR_XXX string constants
+         */
+        public String getVideoHighFrameRate() {
+            return get(KEY_VIDEO_HIGH_FRAME_RATE);
+        }
+
+        /**
+         * @hide
+         * Sets the current HFR Mode.
+         *
+         * @param hfr VIDEO_HFR_XXX string constants
+         */
+        public void setVideoHighFrameRate(String hfr) {
+            set(KEY_VIDEO_HIGH_FRAME_RATE, hfr);
+        }
+
+         /**
+         * @hide
+         * Gets the supported HFR modes.
+         *
+         * @return a List of VIDEO_HFR_XXX string constants. null if hfr mode
+         *         setting is not supported.
+         */
+        public List<String> getSupportedVideoHighFrameRateModes() {
+            String str = get(KEY_VIDEO_HIGH_FRAME_RATE + SUPPORTED_VALUES_SUFFIX);
+            return split(str);
+        }
+
+        /**
+         * Gets the distances from the camera to where an object appears to be
          * in focus. The object is sharpest at the optimal focus distance. The
          * depth of field is the far focus distance minus near focus distance.</p>
          *
@@ -3131,6 +4101,28 @@ public class Camera {
         public List<Area> getFocusAreas() {
             return splitArea(get(KEY_FOCUS_AREAS));
         }
+        /**
+         * @hide
+         * Gets the current DENOISE  setting.
+         *
+         * @return one of DENOISE_XXX string constant. null if Denoise
+         *         setting is not supported.
+         *
+         */
+         public String getDenoise() {
+         return get(KEY_DENOISE);
+         }
+        /**
+         * @hide
+         * Gets the current Continuous AF setting.
+         *
+         * @return one of CONTINUOUS_AF_XXX string constant. null if continuous AF
+         *         setting is not supported.
+         *
+         */
+         public String getContinuousAf() {
+            return get(KEY_CONTINUOUS_AF);
+        }
 
         /**
          * Sets focus areas. See {@link #getFocusAreas()} for documentation.
@@ -3141,6 +4133,25 @@ public class Camera {
         public void setFocusAreas(List<Area> focusAreas) {
             set(KEY_FOCUS_AREAS, focusAreas);
         }
+        /**
+         * @hide
+         * Sets the current Denoise  mode.
+         * @param value DENOISE_XXX string constants.
+         *
+         */
+
+         public void setDenoise(String value) {
+             set(KEY_DENOISE, value);
+         }
+        /**
+         * @hide
+         * Sets the current Continuous AF mode.
+         * @param value CONTINUOUS_AF_XXX string constants.
+         *
+         */
+         public void setContinuousAf(String value) {
+            set(KEY_CONTINUOUS_AF, value);
+        }
 
         /**
          * Gets the maximum number of metering areas supported. This is the
@@ -3199,15 +4210,51 @@ public class Camera {
         }
 
         /**
+         * @hide
+         * Gets the supported Continuous AF modes.
+         *
+         * @return a List of CONTINUOUS_AF_XXX string constant. null if continuous AF
+         *         setting is not supported.
+         *
+         */
+         public List<String> getSupportedContinuousAfModes() {
+            String str = get(KEY_CONTINUOUS_AF + SUPPORTED_VALUES_SUFFIX);
+            return split(str);
+        }
+        /**
+         * @hide
+         * Gets the supported DENOISE  modes.
+         *
+         * @return a List of DENOISE_XXX string constant. null if DENOISE
+         *         setting is not supported.
+         *
+         */
+         public List<String> getSupportedDenoiseModes() {
+             String str = get(KEY_DENOISE + SUPPORTED_VALUES_SUFFIX);
+             return split(str);
+         }
+
+
+        /**
          * Sets metering areas. See {@link #getMeteringAreas()} for
          * documentation.
          *
          * @param meteringAreas the metering areas
          * @see #getMeteringAreas()
          */
-        public void setMeteringAreas(List<Area> meteringAreas) {
+         public void setMeteringAreas(List<Area> meteringAreas) {
             set(KEY_METERING_AREAS, meteringAreas);
         }
+        /**
+         * @hide
+         * Gets the current selectable zone af setting.
+         *
+         * @return one of SELECTABLE_ZONE_AF_XXX string constant. null if selectable zone af
+         *         setting is not supported.
+         */
+         public String getSelectableZoneAf() {
+            return get(KEY_SELECTABLE_ZONE_AF);
+        }
 
         /**
          * Gets the maximum number of detected faces supported. This is the
@@ -3218,9 +4265,18 @@ public class Camera {
          * @return the maximum number of detected face supported by the camera.
          * @see #startFaceDetection()
          */
-        public int getMaxNumDetectedFaces() {
+         public int getMaxNumDetectedFaces() {
             return getInt(KEY_MAX_NUM_DETECTED_FACES_HW, 0);
         }
+        /**
+         * @hide
+         * Sets the current selectable zone af setting.
+         *
+         * @param value SELECTABLE_ZONE_AF_XXX string constants.
+         */
+         public void setSelectableZoneAf(String value) {
+            set(KEY_SELECTABLE_ZONE_AF, value);
+        }
 
         /**
          * Sets recording mode hint. This tells the camera that the intent of
@@ -3245,6 +4301,18 @@ public class Camera {
         }
 
         /**
+         * @hide
+         * Gets the supported selectable zone af setting.
+         *
+         * @return a List of SELECTABLE_ZONE_AF_XXX string constants. null if selectable zone af
+         *         setting is not supported.
+         */
+        public List<String> getSupportedSelectableZoneAf() {
+            String str = get(KEY_SELECTABLE_ZONE_AF + SUPPORTED_VALUES_SUFFIX);
+            return split(str);
+        }
+
+        /**
          * Returns true if video snapshot is supported. That is, applications
          * can call {@link #takePicture(Camera.ShutterCallback,
          * Camera.PictureCallback, Camera.PictureCallback, Camera.PictureCallback)}
@@ -3272,6 +4340,27 @@ public class Camera {
             return TRUE.equals(str);
         }
 
+        /** 
+         * @hide
+         * @return true if full size video snapshot is supported. 
+         */ 
+        public boolean isFullsizeVideoSnapSupported() {
+            String str = get(KEY_FULL_VIDEO_SNAP_SUPPORTED);
+            return TRUE.equals(str);
+        }
+
+        /**
+         * @hide
+         * Gets the current face detection setting.
+         *
+         * @return one of FACE_DETECTION_XXX string constant. null if face detection
+         *         setting is not supported.
+         *
+         */
+        public String getFaceDetectionMode() {
+            return get(KEY_FACE_DETECTION);
+        }
+
         /**
          * <p>Enables and disables video stabilization. Use
          * {@link #isVideoStabilizationSupported} to determine if calling this
@@ -3297,6 +4386,17 @@ public class Camera {
         }
 
         /**
+         * Sets the auto scene detect. Other settings like Touch AF/AEC might be
+         * changed after setting face detection.
+         *
+         * @param value FACE_DETECTION_XXX string constants.
+         * @hide
+         */
+        public void setFaceDetectionMode(String value) {
+            set(KEY_FACE_DETECTION, value);
+        }
+
+        /**
          * Get the current state of video stabilization. See
          * {@link #setVideoStabilization} for details of video stabilization.
          *
@@ -3322,6 +4422,19 @@ public class Camera {
             return TRUE.equals(str);
         }
 
+        /**
+         * @hide
+         * Gets the supported face detection modes.
+         *
+         * @return a List of FACE_DETECTION_XXX string constant. null if face detection
+         *         setting is not supported.
+         *
+         */
+        public List<String> getSupportedFaceDetectionModes() {
+            String str = get(KEY_FACE_DETECTION + SUPPORTED_VALUES_SUFFIX);
+            return split(str);
+        }
+
         // Splits a comma delimited string to an ArrayList of String.
         // Return null if the passing string is null or the size is 0.
         private ArrayList<String> split(String str) {
@@ -3484,6 +4597,37 @@ public class Camera {
             return result;
         }
 
+	// Splits a comma delimited string to an ArrayList of Coordinate.
+        // Return null if the passing string is null or the Coordinate is 0.
+        private ArrayList<Coordinate> splitCoordinate(String str) {
+            if (str == null) return null;
+
+            StringTokenizer tokenizer = new StringTokenizer(str, ",");
+            ArrayList<Coordinate> coordinateList = new ArrayList<Coordinate>();
+            while (tokenizer.hasMoreElements()) {
+                Coordinate c = strToCoordinate(tokenizer.nextToken());
+                if (c != null) coordinateList.add(c);
+            }
+            if (coordinateList.size() == 0) return null;
+            return coordinateList;
+        }
+
+        // Parses a string (ex: "500x500") to Coordinate object.
+        // Return null if the passing string is null.
+        private Coordinate strToCoordinate(String str) {
+            if (str == null) return null;
+
+            int pos = str.indexOf('x');
+            if (pos != -1) {
+                String x = str.substring(0, pos);
+                String y = str.substring(pos + 1);
+                return new Coordinate(Integer.parseInt(x),
+                                Integer.parseInt(y));
+            }
+            Log.e(TAG, "Invalid Coordinate parameter string=" + str);
+            return null;
+        }
+
         private boolean same(String s1, String s2) {
             if (s1 == null && s2 == null) return true;
             if (s1 != null && s1.equals(s2)) return true;
diff --git a/core/java/android/net/DhcpInfoInternal.java b/core/java/android/net/DhcpInfoInternal.java
index fa77bc5..946c36d 100644
--- a/core/java/android/net/DhcpInfoInternal.java
+++ b/core/java/android/net/DhcpInfoInternal.java
@@ -106,7 +106,8 @@ public class DhcpInfoInternal {
         if (TextUtils.isEmpty(dns1) == false) {
             p.addDns(NetworkUtils.numericToInetAddress(dns1));
         } else {
-            Log.d(TAG, "makeLinkProperties with empty dns1!");
+            p.addDns(NetworkUtils.numericToInetAddress(serverAddress));
+            Log.d(TAG, "empty dns1, use dhcp server as dns1!");
         }
         if (TextUtils.isEmpty(dns2) == false) {
             p.addDns(NetworkUtils.numericToInetAddress(dns2));
diff --git a/core/java/android/net/MobileDataStateTracker.java b/core/java/android/net/MobileDataStateTracker.java
index 54a89ad..2ed62f9 100644
--- a/core/java/android/net/MobileDataStateTracker.java
+++ b/core/java/android/net/MobileDataStateTracker.java
@@ -330,6 +330,7 @@ public class MobileDataStateTracker implements NetworkStateTracker {
             networkTypeStr = "hsupa";
             break;
         case TelephonyManager.NETWORK_TYPE_HSPA:
+        case TelephonyManager.NETWORK_TYPE_HSPAP:
             networkTypeStr = "hspa";
             break;
         case TelephonyManager.NETWORK_TYPE_CDMA:
diff --git a/core/java/android/net/wimax/WimaxHelper.java b/core/java/android/net/wimax/WimaxHelper.java
new file mode 100644
index 0000000..f6c7a40
--- /dev/null
+++ b/core/java/android/net/wimax/WimaxHelper.java
@@ -0,0 +1,188 @@
+/*
+ * Copyright (C) 2011 The CyanogenMod Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package android.net.wimax;
+
+import dalvik.system.DexClassLoader;
+
+import android.content.Context;
+import android.content.ContextWrapper;
+import android.os.Handler;
+import android.os.IBinder;
+import android.os.ServiceManager;
+import android.util.Log;
+import android.provider.Settings;
+import java.lang.reflect.Constructor;
+import java.lang.reflect.Method;
+
+/**
+ * {@hide}
+ */
+public class WimaxHelper {
+
+    private static final String TAG = "WimaxHelper";
+
+    private static final String WIMAX_CONTROLLER_CLASSNAME = "com.htc.net.wimax.WimaxController";
+    private static final String WIMAX_MANAGER_CLASSNAME    = "android.net.fourG.wimax.Wimax4GManager";
+
+    private static DexClassLoader sWimaxClassLoader;
+    private static String sWimaxManagerClassname, sIsWimaxEnabledMethodname,
+                          sSetWimaxEnabledMethodname, sGetWimaxStateMethodname;
+
+    public static boolean isWimaxSupported(Context context) {
+        return context.getResources().getBoolean(
+                com.android.internal.R.bool.config_wimaxEnabled);
+    }
+
+    public static DexClassLoader getWimaxClassLoader(Context context) {
+        if (isWimaxSupported(context)) {
+            if (sWimaxClassLoader == null) {
+                sWimaxManagerClassname = context.getResources().getString(
+                    com.android.internal.R.string.config_wimaxManagerClassname);
+
+                // WimaxController::getWimaxState == Wimax4GManager::get4GState.
+                // However, Wimax4GManager also implements a different getWimaxState
+                // method, which returns a WimaxState object describing the connection
+                // state, not the enabled state.  Other methods are similarly renamed.
+                if (sWimaxManagerClassname.equals(WIMAX_CONTROLLER_CLASSNAME)) {
+                    sIsWimaxEnabledMethodname  = "isWimaxEnabled";
+                    sSetWimaxEnabledMethodname = "setWimaxEnabled";
+                    sGetWimaxStateMethodname   = "getWimaxState";
+                } else if (sWimaxManagerClassname.equals(WIMAX_MANAGER_CLASSNAME)) {
+                    sIsWimaxEnabledMethodname  = "is4GEnabled";
+                    sSetWimaxEnabledMethodname = "set4GEnabled";
+                    sGetWimaxStateMethodname   = "get4GState";
+                }
+
+                String wimaxJarLocation = context.getResources().getString(
+                        com.android.internal.R.string.config_wimaxServiceJarLocation);
+                String wimaxLibLocation = context.getResources().getString(
+                        com.android.internal.R.string.config_wimaxNativeLibLocation);
+                sWimaxClassLoader =  new DexClassLoader(wimaxJarLocation,
+                        new ContextWrapper(context).getCacheDir().getAbsolutePath(),
+                        wimaxLibLocation,ClassLoader.getSystemClassLoader());
+            }
+            return sWimaxClassLoader;
+        }
+        return null;
+    }
+
+    public static Object createWimaxService(Context context, Handler handler) {
+        Object controller = null;
+
+        try {
+            DexClassLoader wimaxClassLoader = getWimaxClassLoader(context);
+            if (sWimaxManagerClassname.equals(WIMAX_CONTROLLER_CLASSNAME)) {
+                // Load supersonic's and speedy's WimaxController.
+                IBinder b = ServiceManager.getService(WimaxManagerConstants.WIMAX_SERVICE);
+                if (b != null) {
+                    Class<?> klass = wimaxClassLoader.loadClass("com.htc.net.wimax.IWimaxController$Stub");
+                    if (klass != null) {
+                        Method asInterface = klass.getMethod("asInterface", IBinder.class);
+                        Object wc = asInterface.invoke(null, b);
+                        if (wc != null) {
+                            klass = wimaxClassLoader.loadClass(WIMAX_CONTROLLER_CLASSNAME);
+                            if (klass != null) {
+                                Constructor<?> ctor = klass.getDeclaredConstructors()[1];
+                                controller = ctor.newInstance(wc, handler);
+                            }
+                        }
+                    }
+                }
+            } else if (sWimaxManagerClassname.equals(WIMAX_MANAGER_CLASSNAME)) {
+                // Load crespo4g's (and epicmtd's) Wimax4GManager.
+                // Note that crespo4g's implementation grabs WIMAX_SERVICE internally, so
+                // it doesn't need to be passed in.  Other implementations (may) require
+                // WIMAX_SERVICE to be grabbed externally, so check Wimax4GManager::<init>.
+                Class<?> klass = wimaxClassLoader.loadClass(WIMAX_MANAGER_CLASSNAME);
+                if (klass != null) {
+                    Constructor<?> ctor = klass.getDeclaredConstructors()[0];
+                    controller = ctor.newInstance();
+                }
+            }
+        } catch (Exception e) {
+            Log.e(TAG, "Unable to create WimaxController instance", e);
+        }
+
+        return controller;
+    }
+
+    public static boolean isWimaxEnabled(Context context) {
+        boolean ret = false;
+        try {
+            Object wimaxService = context.getSystemService(WimaxManagerConstants.WIMAX_SERVICE);
+            Method m = wimaxService.getClass().getMethod(sIsWimaxEnabledMethodname);
+            ret = (Boolean) m.invoke(wimaxService);
+        } catch (Exception e) {
+            Log.e(TAG, "Unable to get WiMAX enabled state!", e);
+        }
+        return ret;
+    }
+
+    public static boolean setWimaxEnabled(Context context, boolean enabled) {
+        boolean ret = false;
+        try {
+            Object wimaxService = context.getSystemService(WimaxManagerConstants.WIMAX_SERVICE);
+            Method m = wimaxService.getClass().getMethod(sSetWimaxEnabledMethodname, boolean.class);
+            ret = (Boolean) m.invoke(wimaxService, enabled);
+            if (ret)
+                Settings.Secure.putInt(context.getContentResolver(),
+                        Settings.Secure.WIMAX_ON, (Boolean) enabled ? 1 : 0);
+        } catch (Exception e) {
+            Log.e(TAG, "Unable to set WiMAX state!", e);
+        }
+        return ret;
+    }
+
+    public static int getWimaxState(Context context) {
+        int ret = 0;
+        try {
+            Object wimaxService = context.getSystemService(WimaxManagerConstants.WIMAX_SERVICE);
+            Method m = wimaxService.getClass().getMethod(sGetWimaxStateMethodname);
+            ret = (Integer) m.invoke(wimaxService);
+        } catch (Exception e) {
+            Log.e(TAG, "Unable to get WiMAX state!", e);
+        }
+        return ret;
+    }
+
+    public static boolean wimaxRescan(Context context) {
+        boolean ret = false;
+        try {
+            Object wimaxService = context.getSystemService(WimaxManagerConstants.WIMAX_SERVICE);
+            Method wimaxRescan = wimaxService.getClass().getMethod("wimaxRescan");
+            if (wimaxRescan != null) {
+                wimaxRescan.invoke(wimaxService);
+                ret = true;
+            }
+        } catch (Exception e) {
+            Log.e(TAG, "Unable to perform WiMAX rescan!", e);
+        }
+        return ret;
+    }
+
+    private static Object getWimaxInfo(Context context) {
+        Object wimaxInfo = null;
+        try {
+            Object wimaxService = context.getSystemService(WimaxManagerConstants.WIMAX_SERVICE);
+            Method getConnectionInfo = wimaxService.getClass().getMethod("getConnectionInfo");
+            wimaxInfo = getConnectionInfo.invoke(wimaxService);
+        } catch (Exception e) {
+            Log.e(TAG, "Unable to get a WimaxInfo object!", e);
+        }
+        return wimaxInfo;
+    }
+}
diff --git a/core/java/android/net/wimax/WimaxManagerConstants.java b/core/java/android/net/wimax/WimaxManagerConstants.java
index b4aaf5b..adb7166 100644
--- a/core/java/android/net/wimax/WimaxManagerConstants.java
+++ b/core/java/android/net/wimax/WimaxManagerConstants.java
@@ -24,7 +24,7 @@ public class WimaxManagerConstants
      * The lookup key for an int that indicates whether Wimax is enabled,
      * disabled, enabling, disabling, or unknown.
      */
-    public static final String EXTRA_WIMAX_STATUS = "wimax_status";
+    public static final String EXTRA_4G_STATE = "4g_state";
 
     /**
      * Broadcast intent action indicating that Wimax state has been changed
@@ -48,7 +48,6 @@ public class WimaxManagerConstants
      * initializing, initialized, unknown and ready.
      */
     public static final String EXTRA_WIMAX_STATE = "WimaxState";
-    public static final String EXTRA_4G_STATE = "4g_state";
     public static final String EXTRA_WIMAX_STATE_INT = "WimaxStateInt";
     /**
      * The lookup key for an int that indicates whether state of Wimax
@@ -67,11 +66,21 @@ public class WimaxManagerConstants
     public static final int NET_4G_STATE_DISABLED = 1;
 
     /**
+     * Indicatates Wimax is disabling.
+     */
+    public static final int NET_4G_STATE_DISABLING = 0;
+
+    /**
      * Indicatates Wimax is enabled.
      */
     public static final int NET_4G_STATE_ENABLED = 3;
 
     /**
+     * Indicatates Wimax is enabling.
+     */
+    public static final int NET_4G_STATE_ENABLING = 2;
+
+    /**
      * Indicatates Wimax status is known.
      */
     public static final int NET_4G_STATE_UNKNOWN = 4;
@@ -101,4 +110,9 @@ public class WimaxManagerConstants
      */
     public static final int WIMAX_STATE_DISCONNECTED = 9;
 
+    /**
+     * Constants for HTC/SQN WiMAX implementation
+     */
+    public static final String WIMAX_ENABLED_CHANGED_ACTION = "com.htc.net.wimax.WIMAX_ENABLED_CHANGED";
+    public static final String CURRENT_WIMAX_ENABLED_STATE  = "curWimaxEnabledState";
 }
diff --git a/core/java/android/nfc/Tag.java b/core/java/android/nfc/Tag.java
old mode 100644
new mode 100755
index a73067a..e58b3ef
--- a/core/java/android/nfc/Tag.java
+++ b/core/java/android/nfc/Tag.java
@@ -26,6 +26,8 @@ import android.nfc.tech.NfcA;
 import android.nfc.tech.NfcB;
 import android.nfc.tech.NfcF;
 import android.nfc.tech.NfcV;
+import android.nfc.tech.IsoPcdA;
+import android.nfc.tech.IsoPcdB;
 import android.nfc.tech.TagTechnology;
 import android.os.Bundle;
 import android.os.Parcel;
@@ -184,6 +186,12 @@ public final class Tag implements Parcelable {
                 case TagTechnology.NFC_V:
                     strings[i] = NfcV.class.getName();
                     break;
+                case TagTechnology.ISO_PCD_A:
+                    strings[i] = IsoPcdA.class.getName();
+                    break;
+                case TagTechnology.ISO_PCD_B:
+                    strings[i] = IsoPcdB.class.getName();
+                    break;
                 default:
                     throw new IllegalArgumentException("Unknown tech type " + techList[i]);
             }
diff --git a/core/java/android/nfc/tech/IsoPcdA.java b/core/java/android/nfc/tech/IsoPcdA.java
new file mode 100755
index 0000000..6018ceb
--- /dev/null
+++ b/core/java/android/nfc/tech/IsoPcdA.java
@@ -0,0 +1,101 @@
+/*
+ * Copyright (C) 2011 The Android Open Source Project
+ *
+ *   HOST CARD EMULATION PATCH 0.01
+ *   Author:  doug yeager (doug@simplytapp.com)
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package android.nfc.tech;
+
+import android.nfc.ErrorCodes;
+import android.nfc.Tag;
+import android.os.Bundle;
+import android.os.RemoteException;
+import android.util.Log;
+
+import java.io.IOException;
+
+/**
+ * @hide
+ * Provides access to ISO-PCD type A (ISO 14443-4) properties and I/O operations on a {@link Tag}.
+ *
+ * <p>Acquire an {@link IsoPcdA} object using {@link #get}.
+ * <p>The primary ISO-PCD type A I/O operation is {@link #transceive}. Applications must
+ * implement their own protocol stack on top of {@link #transceive}.
+ *
+ * <p class="note"><strong>Note:</strong> Methods that perform I/O operations
+ * require the {@link android.Manifest.permission#NFC} permission.
+ */
+public final class IsoPcdA extends BasicTagTechnology {
+
+    /**
+     * Get an instance of {@link IsoPcdA} for the given tag.
+     * <p>Does not cause any RF activity and does not block.
+     * <p>Returns null if {@link IsoPcdA} was not enumerated in {@link Tag#getTechList}.
+     * This indicates the tag does not support ISO-PCD type A.
+     *
+     * @param tag an ISO-PCD type A compatible PCD
+     * @return ISO-PCD type A object
+     */
+    public static IsoPcdA get(Tag tag) {
+        if (!tag.hasTech(TagTechnology.ISO_PCD_A)) return null;
+        try {
+            return new IsoPcdA(tag);
+        } catch (RemoteException e) {
+            return null;
+        }
+    }
+
+    /** @hide */
+    public IsoPcdA(Tag tag)
+            throws RemoteException {
+        super(tag, TagTechnology.ISO_PCD_A);
+        Bundle extras = tag.getTechExtras(TagTechnology.ISO_PCD_A);
+    }
+
+    /**
+     * Send raw ISO-PCD type A data to the PCD and receive the response.
+     *
+     * <p>Applications must only send the INF payload, and not the start of frame and
+     * end of frame indicators. Applications do not need to fragment the payload, it
+     * will be automatically fragmented and defragmented by {@link #transceive} if
+     * it exceeds FSD/FSC limits.
+     *
+     * <p>Use {@link #getMaxTransceiveLength} to retrieve the maximum number of bytes
+     * that can be sent with {@link #transceive}.
+     *
+     * <p>This is an I/O operation and will block until complete. It must
+     * not be called from the main application thread. A blocked call will be canceled with
+     * {@link IOException} if {@link #close} is called from another thread.
+     *
+     * <p class="note">Requires the {@link android.Manifest.permission#NFC} permission.
+     *
+     * @param data  - on the first call to transceive after PCD activation, the data sent to the method will be ignored
+     * @return response bytes received, will not be null
+     * @throws TagLostException if the tag leaves the field
+     * @throws IOException if there is an I/O failure, or this operation is canceled
+     */
+    public byte[] transceive(byte[] data) throws IOException {
+        return transceive(data, true);
+    }
+
+    /**
+     * Return the maximum number of bytes that can be sent with {@link #transceive}.
+     * @return the maximum number of bytes that can be sent with {@link #transceive}.
+     */
+    public int getMaxTransceiveLength() {
+        return getMaxTransceiveLengthInternal();
+    }
+}
diff --git a/core/java/android/nfc/tech/IsoPcdB.java b/core/java/android/nfc/tech/IsoPcdB.java
new file mode 100755
index 0000000..e3334b1
--- /dev/null
+++ b/core/java/android/nfc/tech/IsoPcdB.java
@@ -0,0 +1,101 @@
+/*
+ * Copyright (C) 2010 The Android Open Source Project
+ *
+ *   HOST CARD EMULATION PATCH 0.01
+ *   Author:  doug yeager (doug@simplytapp.com)
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package android.nfc.tech;
+
+import android.nfc.ErrorCodes;
+import android.nfc.Tag;
+import android.os.Bundle;
+import android.os.RemoteException;
+import android.util.Log;
+
+import java.io.IOException;
+
+/**
+ * @hide
+ * Provides access to ISO-PCD type B (ISO 14443-4) properties and I/O operations on a {@link Tag}.
+ *
+ * <p>Acquire an {@link IsoPcdB} object using {@link #get}.
+ * <p>The primary ISO-PCD type B I/O operation is {@link #transceive}. Applications must
+ * implement their own protocol stack on top of {@link #transceive}.
+ *
+ * <p class="note"><strong>Note:</strong> Methods that perform I/O operations
+ * require the {@link android.Manifest.permission#NFC} permission.
+ */
+public final class IsoPcdB extends BasicTagTechnology {
+
+    /**
+     * Get an instance of {@link IsoPcdB} for the given tag.
+     * <p>Does not cause any RF activity and does not block.
+     * <p>Returns null if {@link IsoPcdB} was not enumerated in {@link Tag#getTechList}.
+     * This indicates the tag does not support ISO-PCD type B.
+     *
+     * @param tag an ISO-PCD type B compatible PCD
+     * @return ISO-PCD type B object
+     */
+    public static IsoPcdB get(Tag tag) {
+        if (!tag.hasTech(TagTechnology.ISO_PCD_B)) return null;
+        try {
+            return new IsoPcdB(tag);
+        } catch (RemoteException e) {
+            return null;
+        }
+    }
+
+    /** @hide */
+    public IsoPcdB(Tag tag)
+            throws RemoteException {
+        super(tag, TagTechnology.ISO_PCD_B);
+        Bundle extras = tag.getTechExtras(TagTechnology.ISO_PCD_B);
+    }
+
+    /**
+     * Send raw ISO-PCD type B data to the PCD and receive the response.
+     *
+     * <p>Applications must only send the INF payload, and not the start of frame and
+     * end of frame indicators. Applications do not need to fragment the payload, it
+     * will be automatically fragmented and defragmented by {@link #transceive} if
+     * it exceeds FSD/FSC limits.
+     *
+     * <p>Use {@link #getMaxTransceiveLength} to retrieve the maximum number of bytes
+     * that can be sent with {@link #transceive}.
+     *
+     * <p>This is an I/O operation and will block until complete. It must
+     * not be called from the main application thread. A blocked call will be canceled with
+     * {@link IOException} if {@link #close} is called from another thread.
+     *
+     * <p class="note">Requires the {@link android.Manifest.permission#NFC} permission.
+     *
+     * @param data - on the first call to transceive after PCD activation, the data sent to the method will be ignored
+     * @return response bytes received, will not be null
+     * @throws TagLostException if the tag leaves the field
+     * @throws IOException if there is an I/O failure, or this operation is canceled
+     */
+    public byte[] transceive(byte[] data) throws IOException {
+        return transceive(data, true);
+    }
+
+    /**
+     * Return the maximum number of bytes that can be sent with {@link #transceive}.
+     * @return the maximum number of bytes that can be sent with {@link #transceive}.
+     */
+    public int getMaxTransceiveLength() {
+        return getMaxTransceiveLengthInternal();
+    }
+}
diff --git a/core/java/android/nfc/tech/TagTechnology.java b/core/java/android/nfc/tech/TagTechnology.java
old mode 100644
new mode 100755
index be5cbd2..ab2611d
--- a/core/java/android/nfc/tech/TagTechnology.java
+++ b/core/java/android/nfc/tech/TagTechnology.java
@@ -148,6 +148,24 @@ public interface TagTechnology extends Closeable {
     public static final int MIFARE_ULTRALIGHT = 9;
 
     /**
+     * This technology is an instance of {@link IsoPcdA}.
+     * <p>Support for this technology type is optional. If a stack doesn't support this technology
+     * type tags using it must still be discovered and present the lower level radio interface
+     * technologies in use.
+     * @hide
+     */
+    public static final int ISO_PCD_A = 10;
+
+    /**
+     * This technology is an instance of {@link IsoPcdB}.
+     * <p>Support for this technology type is optional. If a stack doesn't support this technology
+     * type tags using it must still be discovered and present the lower level radio interface
+     * technologies in use.
+     * @hide
+     */
+    public static final int ISO_PCD_B = 11;
+
+    /**
      * Get the {@link Tag} object backing this {@link TagTechnology} object.
      * @return the {@link Tag} backing this {@link TagTechnology} object.
      */
diff --git a/core/java/android/os/BatteryManager.java b/core/java/android/os/BatteryManager.java
index c62715b..79b01a1 100644
--- a/core/java/android/os/BatteryManager.java
+++ b/core/java/android/os/BatteryManager.java
@@ -26,6 +26,12 @@ public class BatteryManager {
      * integer containing the current status constant.
      */
     public static final String EXTRA_STATUS = "status";
+
+    /**
+     * Integer containing the current status constant for the dock battery.
+     * @hide
+     */
+    public static final String EXTRA_DOCK_STATUS = "dock_status";
     
     /**
      * Extra for {@link android.content.Intent#ACTION_BATTERY_CHANGED}:
@@ -45,6 +51,18 @@ public class BatteryManager {
      * {@link #EXTRA_SCALE}.
      */
     public static final String EXTRA_LEVEL = "level";
+
+    /**
+     * Integer field containing the current dock battery level.
+     * @hide
+     */
+    public static final String EXTRA_DOCK_LEVEL = "dock_level";
+
+    /**
+     * Boolean field containing the current dock battery AC status.
+     * @hide
+     */
+    public static final String EXTRA_DOCK_AC_ONLINE = "dock_ac_online";
     
     /**
      * Extra for {@link android.content.Intent#ACTION_BATTERY_CHANGED}:
@@ -109,6 +127,21 @@ public class BatteryManager {
     public static final int BATTERY_HEALTH_UNSPECIFIED_FAILURE = 6;
     public static final int BATTERY_HEALTH_COLD = 7;
 
+    /** @hide */
+    public static final int DOCK_STATE_UNKNOWN = 0;
+
+    /** @hide */
+    public static final int DOCK_STATE_UNDOCKED = 1;
+
+    /** @hide */
+    public static final int DOCK_STATE_CHARGING = 2;
+
+    /** @hide */
+    public static final int DOCK_STATE_DOCKED = 3;
+
+    /** @hide */
+    public static final int DOCK_STATE_DISCHARGING = 4;
+
     // values of the "plugged" field in the ACTION_BATTERY_CHANGED intent.
     // These must be powers of 2.
     /** Power source is an AC charger. */
diff --git a/core/java/android/os/Environment.java b/core/java/android/os/Environment.java
index 11f9445..8adbbe6 100644
--- a/core/java/android/os/Environment.java
+++ b/core/java/android/os/Environment.java
@@ -416,11 +416,18 @@ public class Environment {
      * <p>See {@link #getExternalStorageDirectory()} for more information.
      */
     public static String getExternalStorageState() {
+        return getExternalStorageState(getExternalStorageDirectory().toString());
+    }
+
+    /**
+     * Gets the current state of the specified "external" storage device.
+     * @hide
+     */
+    public static String getExternalStorageState(String path) {
         try {
             IMountService mountService = IMountService.Stub.asInterface(ServiceManager
                     .getService("mount"));
-            return mountService.getVolumeState(getExternalStorageDirectory()
-                    .toString());
+            return mountService.getVolumeState(path);
         } catch (Exception rex) {
             return Environment.MEDIA_REMOVED;
         }
diff --git a/core/java/android/os/IHDMIService.aidl b/core/java/android/os/IHDMIService.aidl
new file mode 100644
index 0000000..12d9fe5
--- /dev/null
+++ b/core/java/android/os/IHDMIService.aidl
@@ -0,0 +1,32 @@
+/*
+**
+** Copyright 2007, The Android Open Source Project
+** Copyright (c) 2010, Code Aurora Forum. All rights reserved.
+**
+** Licensed under the Apache License, Version 2.0 (the "License");
+** you may not use this file except in compliance with the License.
+** You may obtain a copy of the License at
+**
+**     http://www.apache.org/licenses/LICENSE-2.0
+**
+** Unless required by applicable law or agreed to in writing, software
+** distributed under the License is distributed on an "AS IS" BASIS,
+** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+** See the License for the specific language governing permissions and
+** limitations under the License.
+*/
+
+package android.os;
+
+/**
+ * @hide
+ */
+
+interface IHDMIService
+{
+    boolean isHDMIConnected();
+
+    void setHDMIOutput(boolean enableHDMI);
+    void setActionsafeWidthRatio(float asWidthRatio);
+    void setActionsafeHeightRatio(float asHeightRatio);
+}
diff --git a/core/java/android/os/IPowerManager.aidl b/core/java/android/os/IPowerManager.aidl
index 9a53d76..8911590 100644
--- a/core/java/android/os/IPowerManager.aidl
+++ b/core/java/android/os/IPowerManager.aidl
@@ -45,4 +45,11 @@ interface IPowerManager
     // sets the brightness of the backlights (screen, keyboard, button) 0-255
     void setBacklightBrightness(int brightness);
     void setAttentionLight(boolean on, int color);
+
+    // custom backlight things
+    int getLightSensorValue();
+    int getRawLightSensorValue();
+    int getLightSensorScreenBrightness();
+    int getLightSensorButtonBrightness();
+    int getLightSensorKeyboardBrightness();
 }
diff --git a/core/java/android/os/Power.java b/core/java/android/os/Power.java
index 5a79215..9f03ff9 100644
--- a/core/java/android/os/Power.java
+++ b/core/java/android/os/Power.java
@@ -1,5 +1,6 @@
 /*
  * Copyright (C) 2007 The Android Open Source Project
+ * Copyright (c) 2010-2011, Code Aurora Forum. All rights reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -104,4 +105,12 @@ public class Power
     }
 
     private static native void rebootNative(String reason) throws IOException ;
+
+    /**
+     * Activate/DeActivate Unstable Memory block
+     *
+     * @param on Whether you want Activate(true) or DeActive(False)
+     * @hide
+     */
+    public static native int SetUnstableMemoryState(boolean on);
 }
diff --git a/core/java/android/os/SystemProperties.java b/core/java/android/os/SystemProperties.java
index 619bf8d..0a70825 100644
--- a/core/java/android/os/SystemProperties.java
+++ b/core/java/android/os/SystemProperties.java
@@ -1,5 +1,6 @@
 /*
  * Copyright (C) 2006 The Android Open Source Project
+ * This code has been modified.  Portions copyright (C) 2010, T-Mobile USA, Inc.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -28,6 +29,14 @@ public class SystemProperties
     public static final int PROP_NAME_MAX = 31;
     public static final int PROP_VALUE_MAX = 91;
 
+    // OMAP4 and OMAP3's OMAP_COMPAT
+    public static final boolean OMAP_ENHANCEMENT = native_get_boolean("com.ti.omap_enhancement", false);
+    public static final boolean OMAP_COMPAT = native_get_boolean("com.ti.omap_compat", false);
+
+    // QCOM Hardware
+    public static final boolean QCOM_HARDWARE = native_get_boolean("com.qc.hardware", false);
+    public static final boolean QCOM_HDMI_OUT = native_get_boolean("com.qc.hdmi_out", false);
+
     private static native String native_get(String key);
     private static native String native_get(String key, String def);
     private static native int native_get_int(String key, int def);
@@ -124,4 +133,49 @@ public class SystemProperties
         }
         native_set(key, val);
     }
+
+    /**
+     * Get the value for the given key.
+     * @return def string if the key isn't found
+     */
+    public static String getLongString(String key, String def) {
+        if (key.length() + 1 > PROP_NAME_MAX) {
+            throw new IllegalArgumentException("key.length > " + PROP_NAME_MAX);
+        }
+        int chunks = getInt(key + '0', 0);
+        if (chunks == 0) {
+            return def;
+        }
+        StringBuffer sb = new StringBuffer();
+        for (int i = 1; i <= chunks; i++) {
+            sb.append(native_get(key + Integer.toString(i)));
+        }
+        return sb.toString();
+    }
+
+    /**
+     * Set the value for the given key.
+     * @throws IllegalArgumentException if the key exceeds 32 characters
+     */
+    public static void setLongString(String key, String val) {
+        if (key.length() + 1 > PROP_NAME_MAX) {
+            throw new IllegalArgumentException("key.length > " + PROP_NAME_MAX);
+        }
+        int chunks = 0;
+        if (val != null && val.length() > 0) {
+            chunks = 1 + val.length() / (PROP_VALUE_MAX + 1);
+        }
+        native_set(key + '0', Integer.toString(chunks));
+        if (chunks > 0) {
+            for (int i = 1, start = 0; i <= chunks; i++) {
+                int end = start + PROP_VALUE_MAX;
+                if (end > val.length()) {
+                    end = val.length();
+                }
+                native_set(key + Integer.toString(i), val.substring(start, end));
+                start = end;
+            }
+        }
+    }
+
 }
diff --git a/core/java/android/preference/ListPreferenceMultiSelect.java b/core/java/android/preference/ListPreferenceMultiSelect.java
new file mode 100644
index 0000000..a8c711b
--- /dev/null
+++ b/core/java/android/preference/ListPreferenceMultiSelect.java
@@ -0,0 +1,131 @@
+/*
+ * Copyright (C) 2011 The CyanogenMod Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package android.preference;
+
+import android.app.AlertDialog.Builder;
+import android.content.Context;
+import android.content.DialogInterface;
+import android.text.TextUtils;
+import android.util.AttributeSet;
+
+/**
+ * @hide
+ */
+public class ListPreferenceMultiSelect extends ListPreference {
+
+    private static final String SEPARATOR = "OV=I=XseparatorX=I=VO";
+
+    private boolean[] mClickedDialogEntryIndices;
+
+    private String mSummary;
+
+    public ListPreferenceMultiSelect(Context context) {
+        super(context);
+    }
+
+    public ListPreferenceMultiSelect(Context context, AttributeSet attrs) {
+        super(context, attrs);
+    }
+
+    @Override
+    protected void onPrepareDialogBuilder(Builder builder) {
+        CharSequence[] entries = getEntries();
+        CharSequence[] entryValues = getEntryValues();
+
+        if (entries == null || entryValues == null || entries.length != entryValues.length) {
+            throw new IllegalStateException(
+                    this.getClass().getSimpleName()
+                            + " requires an entries array and an entryValues array which are both the same length");
+        }
+
+        mClickedDialogEntryIndices = new boolean[entryValues.length];
+        restoreCheckedEntries();
+        builder.setMultiChoiceItems(entries, mClickedDialogEntryIndices, new DialogInterface.OnMultiChoiceClickListener() {
+            @Override
+            public void onClick(DialogInterface dialog, int which, boolean isChecked) {
+                mClickedDialogEntryIndices[which] = isChecked;
+            }
+        });
+    }
+
+    public static String[] parseStoredValue(CharSequence val) {
+        if (TextUtils.isEmpty(val)) {
+            return null;
+        } else {
+            return val.toString().split(SEPARATOR);
+        }
+    }
+
+    private void restoreCheckedEntries() {
+        CharSequence[] entryValues = getEntryValues();
+
+        String[] vals = parseStoredValue(getValue());
+        if (vals != null) {
+            for (String val : vals) {
+                for (int i = 0; i < entryValues.length; i++) {
+                    CharSequence entry = entryValues[i];
+                    if (entry.equals(val)) {
+                        mClickedDialogEntryIndices[i] = true;
+                        break;
+                    }
+                }
+            }
+        }
+    }
+
+    @Override
+    protected void onDialogClosed(boolean positiveResult) {
+        CharSequence[] entryValues = getEntryValues();
+
+        if (positiveResult && entryValues != null) {
+            StringBuilder value = new StringBuilder();
+            for (int i = 0; i < entryValues.length; i++) {
+                if (mClickedDialogEntryIndices[i]) {
+                    if (value.length() > 0) {
+                        value.append(SEPARATOR);
+                    }
+                    value.append(entryValues[i]);
+                }
+            }
+
+            String val = value.toString();
+            if (callChangeListener(val)) {
+                setValue(val);
+            }
+        }
+    }
+
+    @Override
+    public CharSequence getSummary() {
+        final CharSequence entry = getEntry();
+        if (mSummary == null) {
+            return super.getSummary();
+        } else {
+            return mSummary;
+        }
+    }
+
+    @Override
+    public void setSummary(CharSequence summary) {
+        super.setSummary(summary);
+        if (summary == null && mSummary != null) {
+            mSummary = null;
+        } else if (summary != null && !summary.equals(mSummary)) {
+            mSummary = summary.toString();
+        }
+    }
+}
diff --git a/core/java/android/preference/PreferenceActivity.java b/core/java/android/preference/PreferenceActivity.java
index 1029161..f31d18e 100644
--- a/core/java/android/preference/PreferenceActivity.java
+++ b/core/java/android/preference/PreferenceActivity.java
@@ -143,6 +143,10 @@ public abstract class PreferenceActivity extends ListActivity implements
      */
     public static final String EXTRA_SHOW_FRAGMENT_TITLE = ":android:show_fragment_title";
 
+    // fix for title text for startPreferencePanel in a single pane mode
+    /** @hide */
+    public static final String EXTRA_SHOW_FRAGMENT_TITLE_TEXT = ":android:show_fragment_title_text";
+
     /**
      * When starting this activity and using {@link #EXTRA_SHOW_FRAGMENT},
      * this extra can also be specify to supply the short title to be shown for
@@ -151,6 +155,11 @@ public abstract class PreferenceActivity extends ListActivity implements
     public static final String EXTRA_SHOW_FRAGMENT_SHORT_TITLE
             = ":android:show_fragment_short_title";
 
+    // fix for short title text for startPreferencePanel in a single pane mode
+    /** @hide */
+    public static final String EXTRA_SHOW_FRAGMENT_SHORT_TITLE_TEXT
+            = ":android:show_fragment_short_title_text";
+
     /**
      * When starting this activity, the invoking Intent can contain this extra
      * boolean that the header list should not be displayed.  This is most often
@@ -535,6 +544,13 @@ public abstract class PreferenceActivity extends ListActivity implements
                     CharSequence initialShortTitleStr = initialShortTitle != 0
                             ? getText(initialShortTitle) : null;
                     showBreadCrumbs(initialTitleStr, initialShortTitleStr);
+                } else {
+                    CharSequence initialTitleStr = getIntent().getStringExtra(EXTRA_SHOW_FRAGMENT_TITLE_TEXT);
+                    if ( initialTitleStr != null ) {
+                        CharSequence initialShortTitleStr
+                                = getIntent().getStringExtra(EXTRA_SHOW_FRAGMENT_SHORT_TITLE_TEXT);
+                        showBreadCrumbs(initialTitleStr, initialShortTitleStr);
+                    }
                 }
 
             } else {
@@ -568,6 +584,13 @@ public abstract class PreferenceActivity extends ListActivity implements
                 CharSequence initialShortTitleStr = initialShortTitle != 0
                         ? getText(initialShortTitle) : null;
                 showBreadCrumbs(initialTitleStr, initialShortTitleStr);
+            } else {
+                CharSequence initialTitleStr = getIntent().getStringExtra(EXTRA_SHOW_FRAGMENT_TITLE_TEXT);
+                if ( initialTitleStr != null ) {
+                    CharSequence initialShortTitleStr
+                            = getIntent().getStringExtra(EXTRA_SHOW_FRAGMENT_SHORT_TITLE_TEXT);
+                    showBreadCrumbs(initialTitleStr, initialShortTitleStr);
+                }
             }
         } else if (mHeaders.size() > 0) {
             setListAdapter(new HeaderAdapter(this, mHeaders));
@@ -1011,7 +1034,21 @@ public abstract class PreferenceActivity extends ListActivity implements
         intent.putExtra(EXTRA_NO_HEADERS, true);
         return intent;
     }
-    
+
+    // fix for title text for startPreferencePanel in a single pane mode
+    /** @hide */
+    public Intent onBuildStartFragmentIntent(String fragmentName, Bundle args,
+            CharSequence titleText, CharSequence shortTitleText) {
+        Intent intent = new Intent(Intent.ACTION_MAIN);
+        intent.setClass(this, getClass());
+        intent.putExtra(EXTRA_SHOW_FRAGMENT, fragmentName);
+        intent.putExtra(EXTRA_SHOW_FRAGMENT_ARGUMENTS, args);
+        intent.putExtra(EXTRA_SHOW_FRAGMENT_TITLE_TEXT, titleText);
+        intent.putExtra(EXTRA_SHOW_FRAGMENT_SHORT_TITLE_TEXT, shortTitleText);
+        intent.putExtra(EXTRA_NO_HEADERS, true);
+        return intent;
+    }
+
     /**
      * Like {@link #startWithFragment(String, Bundle, Fragment, int, int, int)}
      * but uses a 0 titleRes.
@@ -1048,6 +1085,18 @@ public abstract class PreferenceActivity extends ListActivity implements
         }
     }
 
+    // fix for title text for startPreferencePanel in a single pane mode
+    /** @hide */
+    public void startWithFragment(String fragmentName, Bundle args, Fragment resultTo,
+            int resultRequestCode, CharSequence titleText, CharSequence shortTitleText) {
+        Intent intent = onBuildStartFragmentIntent(fragmentName, args, titleText, shortTitleText);
+        if (resultTo == null) {
+            startActivity(intent);
+        } else {
+            resultTo.startActivityForResult(intent, resultRequestCode);
+        }
+    }
+
     /**
      * Change the base title of the bread crumbs for the current preferences.
      * This will normally be called for you.  See
@@ -1238,7 +1287,12 @@ public abstract class PreferenceActivity extends ListActivity implements
     public void startPreferencePanel(String fragmentClass, Bundle args, int titleRes,
             CharSequence titleText, Fragment resultTo, int resultRequestCode) {
         if (mSinglePane) {
-            startWithFragment(fragmentClass, args, resultTo, resultRequestCode, titleRes, 0);
+            // fix for title text for startPreferencePanel in a single pane mode
+            if (titleRes == 0 && titleText != null) {
+                startWithFragment(fragmentClass, args, resultTo, resultRequestCode, titleText, null);
+            } else {
+                startWithFragment(fragmentClass, args, resultTo, resultRequestCode, titleRes, 0);
+            }
         } else {
             Fragment f = Fragment.instantiate(this, fragmentClass, args);
             if (resultTo != null) {
diff --git a/core/java/android/preference/VolumePreference.java b/core/java/android/preference/VolumePreference.java
index fe5e76c..e0491d0 100644
--- a/core/java/android/preference/VolumePreference.java
+++ b/core/java/android/preference/VolumePreference.java
@@ -146,6 +146,11 @@ public class VolumePreference extends SeekBarDialogPreference implements
         }
     }
 
+    /** @hide */
+    protected boolean onVolumeChange(SeekBarVolumizer volumizer, int value) {
+        return true;
+    }
+
     @Override
     protected Parcelable onSaveInstanceState() {
         final Parcelable superState = super.onSaveInstanceState();
@@ -307,10 +312,14 @@ public class VolumePreference extends SeekBarDialogPreference implements
         }
 
         void postSetVolume(int progress) {
-            // Do the volume changing separately to give responsive UI
-            mLastProgress = progress;
-            mHandler.removeCallbacks(this);
-            mHandler.post(this);
+            if (onVolumeChange(this, progress)) {
+                // Do the volume changing separately to give responsive UI
+                mLastProgress = progress;
+                mHandler.removeCallbacks(this);
+                mHandler.post(this);
+            } else {
+                mSeekBar.setProgress(mLastProgress);
+            }
         }
 
         public void onStartTrackingTouch(SeekBar seekBar) {
diff --git a/core/java/android/provider/Settings.java b/core/java/android/provider/Settings.java
index d7fab37..4c4a6d5 100644
--- a/core/java/android/provider/Settings.java
+++ b/core/java/android/provider/Settings.java
@@ -55,6 +55,14 @@ public final class Settings {
 
     // Intent actions for Settings
 
+
+   /**
+    * Intent actions for Settings
+    *
+    * @hide
+    */
+    public static final String SETTINGS_CHANGED = "android.settings.SETTINGS_CHANGED_ACTION";
+
     /**
      * Activity Action: Show system settings.
      * <p>
@@ -1391,6 +1399,148 @@ public final class Settings {
         public static final int SCREEN_BRIGHTNESS_MODE_AUTOMATIC = 1;
 
         /**
+         * Indicates that custom light sensor settings has changed.
+         * The value is random and changes reloads light settings.
+         *
+         * @hide
+         */
+        public static final String LIGHTS_CHANGED = "lights_changed";
+
+        /**
+         * Whether custom light sensor levels & values are enabled. The value is
+         * boolean (1 or 0).
+         *
+         * @hide
+         */
+        public static final String LIGHT_SENSOR_CUSTOM = "light_sensor_custom";
+
+        /**
+         * Screen dim value to use if LIGHT_SENSOR_CUSTOM is set. The value is int.
+         * Default is android.os.BRIGHTNESS_DIM.
+         *
+         * @hide
+         */
+        public static final String LIGHT_SCREEN_DIM = "light_screen_dim";
+
+        /**
+         * Custom light sensor levels. The value is a comma separated int array
+         * with length N.
+         * Example: "100,300,3000".
+         *
+         * @hide
+         */
+        public static final String LIGHT_SENSOR_LEVELS = "light_sensor_levels";
+
+        /**
+         * Custom light sensor lcd values. The value is a comma separated int array
+         * with length N+1.
+         * Example: "10,50,100,255".
+         *
+         * @hide
+         */
+        public static final String LIGHT_SENSOR_LCD_VALUES = "light_sensor_lcd_values";
+
+        /**
+         * Custom light sensor lcd values. The value is a comma separated int array
+         * with length N+1.
+         * Example: "10,50,100,255".
+         *
+         * @hide
+         */
+        public static final String LIGHT_SENSOR_BUTTON_VALUES = "light_sensor_button_values";
+
+        /**
+         * Custom light sensor lcd values. The value is a comma separated int array
+         * with length N+1.
+         * Example: "10,50,100,255".
+         *
+         * @hide
+         */
+        public static final String LIGHT_SENSOR_KEYBOARD_VALUES = "light_sensor_keyboard_values";
+
+        /**
+         * Whether light sensor is allowed to decrease when calculating automatic
+         * backlight. The value is boolean (1 or 0).
+         *
+         * @hide
+         */
+        public static final String LIGHT_DECREASE = "light_decrease";
+
+        /**
+         * Light sensor hysteresis for decreasing backlight. The value is
+         * int (0-99) representing % (0-0.99 as float). Example:
+         *
+         * Levels     Output
+         * 0 - 100    50
+         * 100 - 200  100
+         * 200 - Inf  255
+         *
+         * Current sensor value is 150 which gives light value 100. Hysteresis is 50.
+         * Current level lower bound is 100 and previous lower bound is 0.
+         * Sensor value must drop below 100-(100-0)*(50/100)=50 for output to become 50
+         * (corresponding to the 0 - 100 level).
+         * @hide
+         */
+        public static final String LIGHT_HYSTERESIS = "light_hysteresis";
+
+        /**
+         * Whether light sensor used when calculating automatic backlight should
+         * be filtered through an moving average filter.
+         * The value is boolean (1 or 0).
+         *
+         * @hide
+         */
+        public static final String LIGHT_FILTER = "light_filter";
+
+        /**
+         * Window length of filter used when calculating automatic backlight.
+         * One minute means that the average sensor value last minute is used.
+         * The value is integer (milliseconds)
+         *
+         * @hide
+         */
+        public static final String LIGHT_FILTER_WINDOW = "light_filter_window";
+
+        /**
+         * Reset threshold of filter used when calculating automatic backlight.
+         * Sudden large jumps in sensor value resets the filter. This is used
+         * to make the filter respond quickly to large enough changes in input
+         * while still filtering small changes. Example:
+         *
+         * Current filter value (average) is 100 and sensor value is changing to
+         * 10, 150, 100, 30, 50. The filter is continously taking the average of
+         * the samples. Now the user goes outside and the value jumps over 1000.
+         * The difference between current average and new sample is larger than
+         * the reset threshold and filter is reset. It begins calculating a new
+         * average on samples around 1000 (say, 800, 1200, 1000, 1100 etc.)
+         *
+         * The value is integer (lux)
+         *
+         * @hide
+         */
+        public static final String LIGHT_FILTER_RESET = "light_filter_reset";
+
+        /**
+         * Sample interval of filter used when calculating automatic backlight.
+         * The value is integer (milliseconds)
+         *
+         * @hide
+         */
+        public static final String LIGHT_FILTER_INTERVAL = "light_filter_interval";
+
+        /**
+         * Whether to enable the electron beam animation when turning screen on
+         *
+         * @hide */
+        public static final String ELECTRON_BEAM_ANIMATION_ON = "electron_beam_animation_on";
+
+        /**
+         * Whether to enable the electron beam animation when turning screen off
+         *
+         * @hide */
+        public static final String ELECTRON_BEAM_ANIMATION_OFF = "electron_beam_animation_off";
+
+        /**
          * Control whether the process CPU usage meter should be shown.
          */
         public static final String SHOW_PROCESSES = "show_processes";
@@ -1405,6 +1555,22 @@ public final class Settings {
 
 
         /**
+         * Volume Overlay Mode, This is behaviour of the volume overlay panel
+         * Defaults to 0 - which is simple
+         * @hide
+         */
+        public static final String MODE_VOLUME_OVERLAY = "mode_volume_overlay";
+
+        /** @hide */
+        public static final int VOLUME_OVERLAY_SINGLE = 0;
+        /** @hide */
+        public static final int VOLUME_OVERLAY_EXPANDABLE = 1;
+        /** @hide */
+        public static final int VOLUME_OVERLAY_EXPANDED = 2;
+        /** @hide */
+        public static final int VOLUME_OVERLAY_NONE = 3;
+
+        /**
          * Ringer mode. This is used internally, changing this value will not
          * change the ringer mode. See AudioManager.
          */
@@ -1473,6 +1639,12 @@ public final class Settings {
         public static final String VOLUME_BLUETOOTH_SCO = "volume_bluetooth_sco";
 
         /**
+         * Whether to prevent loud volume levels when headset is first plugged in.
+         * @hide
+         */
+        public static final String SAFE_HEADSET_VOLUME_RESTORE = "safe_headset_volume_restore";
+
+        /**
          * Whether the notifications should use the ring volume (value of 1) or a separate
          * notification volume (value of 0). In most cases, users will have this enabled so the
          * notification and ringer volumes will be the same. However, power users can disable this
@@ -1489,6 +1661,24 @@ public final class Settings {
             "notifications_use_ring_volume";
 
         /**
+         * Whether the phone ringtone should be played in an increasing manner
+         * @hide
+         */
+        public static final String INCREASING_RING = "increasing_ring";
+
+        /**
+         * Minimum volume index for increasing ring volume
+         * @hide
+         */
+        public static final String INCREASING_RING_MIN_VOLUME = "increasing_ring_min_vol";
+
+        /**
+         * Time (in ms) between ringtone volume increases
+         * @hide
+         */
+        public static final String INCREASING_RING_INTERVAL = "increasing_ring_interval";
+
+        /**
          * Whether silent mode should allow vibration feedback. This is used
          * internally in AudioService and the Sound settings activity to
          * coordinate decoupling of vibrate and silent modes. This setting
@@ -1667,6 +1857,19 @@ public final class Settings {
         public static final String ACCELEROMETER_ROTATION = "accelerometer_rotation";
 
         /**
+         * Control the type of rotation which can be performed using the accelerometer
+         * if ACCELEROMETER_ROTATION is enabled.
+         * Value is a bitwise combination of
+         * 1 = 0 degrees (portrait)
+         * 2 = 90 degrees (left)
+         * 4 = 180 degrees (inverted portrait)
+         * 8 = 270 degrees (right)
+         * Setting to 0 is effectively orientation lock
+         * @hide
+         */
+        public static final String ACCELEROMETER_ROTATION_ANGLES = "accelerometer_rotation_angles";
+
+        /**
          * Default screen rotation when no other policy applies.
          * When {@link #ACCELEROMETER_ROTATION} is zero and no on-screen Activity expresses a
          * preference, this rotation value will be used. Must be one of the
@@ -1727,6 +1930,13 @@ public final class Settings {
         public static final String TTY_MODE = "tty_mode";
 
         /**
+         * Whether noise suppression is enabled. The value is
+         * boolean (1 or 0).
+         * @hide
+         */
+        public static final String NOISE_SUPPRESSION = "noise_suppression";
+
+        /**
          * Whether the sounds effects (key clicks, lid open ...) are enabled. The value is
          * boolean (1 or 0).
          */
@@ -1753,6 +1963,109 @@ public final class Settings {
         public static final String NOTIFICATION_LIGHT_PULSE = "notification_light_pulse";
 
         /**
+         * What color to use for the notification LED by default
+         * @hide
+         */
+        public static final String NOTIFICATION_LIGHT_PULSE_DEFAULT_COLOR = "notification_light_pulse_default_color";
+
+        /**
+         * How long to flash the notification LED by default
+         * @hide
+         */
+        public static final String NOTIFICATION_LIGHT_PULSE_DEFAULT_LED_ON = "notification_light_pulse_default_led_on";
+
+        /**
+         * How long to wait between flashes for the notification LED by default
+         * @hide
+         */
+        public static final String NOTIFICATION_LIGHT_PULSE_DEFAULT_LED_OFF = "notification_light_pulse_default_led_off";
+
+        /**
+         * What color to use for the missed call notification LED
+         * @hide
+         */
+        public static final String NOTIFICATION_LIGHT_PULSE_CALL_COLOR = "notification_light_pulse_call_color";
+
+        /**
+         * How long to flash the missed call notification LED
+         * @hide
+         */
+        public static final String NOTIFICATION_LIGHT_PULSE_CALL_LED_ON = "notification_light_pulse_call_led_on";
+
+        /**
+         * How long to wait between flashes for the missed call notification LED
+         * @hide
+         */
+        public static final String NOTIFICATION_LIGHT_PULSE_CALL_LED_OFF = "notification_light_pulse_call_led_off";
+
+        /**
+         * What color to use for the voicemail notification LED
+         * @hide
+         */
+        public static final String NOTIFICATION_LIGHT_PULSE_VMAIL_COLOR = "notification_light_pulse_vmail_color";
+
+        /**
+         * How long to flash the voicemail notification LED
+         * @hide
+         */
+        public static final String NOTIFICATION_LIGHT_PULSE_VMAIL_LED_ON = "notification_light_pulse_vmail_led_on";
+
+        /**
+         * How long to wait between flashes for the voicemail notification LED
+         * @hide
+         */
+        public static final String NOTIFICATION_LIGHT_PULSE_VMAIL_LED_OFF = "notification_light_pulse_vmail_led_off";
+
+        /**
+         * Whether to use the custom LED values for the notification pulse LED.
+         * @hide
+         */
+        public static final String NOTIFICATION_LIGHT_PULSE_CUSTOM_ENABLE = "notification_light_pulse_custom_enable";
+
+        /**
+         * Which custom LED values to use for the notification pulse LED.
+         * @hide
+         */
+        public static final String NOTIFICATION_LIGHT_PULSE_CUSTOM_VALUES = "notification_light_pulse_custom_values";
+
+        /**
+         * Whether the battery light should be enabled (if hardware supports it)
+         * The value is boolean (1 or 0).
+         * @hide
+         */
+        public static final String BATTERY_LIGHT_ENABLED = "battery_light_enabled";
+
+        /**
+         * Whether the battery LED should repeatedly flash when the battery is low
+         * on charge. The value is boolean (1 or 0).
+         * @hide
+         */
+        public static final String BATTERY_LIGHT_PULSE = "battery_light_pulse";
+
+        /**
+         * What color to use for the battery LED while charging - low
+         * @hide
+         */
+        public static final String BATTERY_LIGHT_LOW_COLOR = "battery_light_low_color";
+
+        /**
+         * What color to use for the battery LED while charging - medium
+         * @hide
+         */
+        public static final String BATTERY_LIGHT_MEDIUM_COLOR = "battery_light_medium_color";
+
+        /**
+         * What color to use for the battery LED while charging - full
+         * @hide
+         */
+        public static final String BATTERY_LIGHT_FULL_COLOR = "battery_light_full_color";
+
+        /** Sprint MWI Quirk: Show message wait indicator notifications
+         * @hide
+         */
+        public static final String ENABLE_MWI_NOTIFICATION = "enable_mwi_notification";
+
+        /**
          * Show pointer location on screen?
          * 0 = no
          * 1 = yes
@@ -1761,6 +2074,14 @@ public final class Settings {
         public static final String POINTER_LOCATION = "pointer_location";
 
         /**
+         * Show icon when stylus is used?
+         * 0 = no
+         * 1 = yes
+         * @hide
+         */
+        public static final String STYLUS_ICON_ENABLED = "stylus_icon_enabled";
+
+        /**
          * Show touch positions on screen?
          * 0 = no
          * 1 = yes
@@ -1769,6 +2090,13 @@ public final class Settings {
         public static final String SHOW_TOUCHES = "show_touches";
 
         /**
+         * The keylayout that will be used by EventHub instead of the default
+         * one.
+	 * @hide
+         */
+        public static final String KEYLAYOUT_OVERRIDES = "keylayout";
+
+        /**
          * Log raw orientation data from {@link WindowOrientationListener} for use with the
          * orientationplot.py tool.
          * 0 = no
@@ -1785,6 +2113,12 @@ public final class Settings {
         public static final String POWER_SOUNDS_ENABLED = "power_sounds_enabled";
 
         /**
+         * Whether to route USB Audio when docked.
+         * @hide
+         */
+        public static final String DOCK_USB_AUDIO_ENABLED = "dock_usb_audio_enabled";
+
+        /**
          * Whether to play a sound for dock events.
          * @hide
          */
@@ -1874,6 +2208,11 @@ public final class Settings {
         public static final String SIP_ASK_ME_EACH_TIME = "SIP_ASK_ME_EACH_TIME";
 
         /**
+         * Torch state (flashlight)
+         * @hide
+         */
+        public static final String TORCH_STATE = "torch_state";
+        /**
          * Pointer speed setting.
          * This is an integer value in a range between -7 and +7, so there are 15 possible values.
          *   -7 = slowest
@@ -1884,6 +2223,368 @@ public final class Settings {
         public static final String POINTER_SPEED = "pointer_speed";
 
         /**
+         * Use the Notification Power Widget? (Who wouldn't!)
+         *
+         * @hide
+         */
+        public static final String EXPANDED_VIEW_WIDGET = "expanded_view_widget";
+
+        /**
+         * Whether to hide the notification screen after clicking on a widget
+         * button
+         *
+         * @hide
+         */
+        public static final String EXPANDED_HIDE_ONCHANGE = "expanded_hide_onchange";
+
+        /**
+         * Hide scroll bar in power widget
+         *
+         * @hide
+         */
+        public static final String EXPANDED_HIDE_SCROLLBAR = "expanded_hide_scrollbar";
+
+        /**
+         * Hide indicator in status bar widget
+         *
+         * @hide
+         */
+        public static final String EXPANDED_HIDE_INDICATOR = "expanded_hide_indicator";
+
+        /**
+         * Haptic feedback in power widget
+         *
+         * @hide
+         */
+        public static final String EXPANDED_HAPTIC_FEEDBACK = "expanded_haptic_feedback";
+
+        /**
+         * Notification Indicator Color
+         *
+         * @hide
+         */
+        public static final String EXPANDED_VIEW_WIDGET_COLOR = "expanded_widget_color";
+
+        /**
+         * Widget Buttons to Use
+         *
+         * @hide
+         */
+        public static final String WIDGET_BUTTONS = "expanded_widget_buttons";
+
+        /**
+         * Widget Buttons to Use - Tablet
+         *
+         * @hide
+         */
+        public static final String WIDGET_BUTTONS_TABLET = "expanded_widget_buttons_tablet";
+
+        /**
+         * Navigation controls to Use
+         *
+         * @hide
+         */
+        public static final String NAV_BUTTONS = "nav_buttons";
+
+        /**
+        * Notification Power Widget - Custom Brightness Mode
+        * @hide
+        */
+        public static final String EXPANDED_BRIGHTNESS_MODE = "expanded_brightness_mode";
+
+        /**
+        * Notification Power Widget - Custom Network Mode
+        * @hide
+        */
+        public static final String EXPANDED_NETWORK_MODE = "expanded_network_mode";
+
+        /**
+         * Notification Power Widget - Custom LTE Toggle
+         * 1 - lte on, 0 - lte off
+         * @hide
+         */
+        public static final String LTE_MODE = "lte_mode";
+
+        /**
+        * Notification Power Widget - Custom Screen Timeout
+        * @hide
+        */
+        public static final String EXPANDED_SCREENTIMEOUT_MODE = "expanded_screentimeout_mode";
+
+        /**
+        * Notification Power Widget - Custom Ring Mode
+        * @hide
+        */
+        public static final String EXPANDED_RING_MODE = "expanded_ring_mode";
+
+        /**
+        * Notification Power Widget - Custom Torch Mode
+        * @hide
+        */
+        public static final String EXPANDED_FLASH_MODE = "expanded_flash_mode";
+
+        /**
+        * AutoHide CombinedBar on tablets.
+        * @hide
+        */
+        public static final String COMBINED_BAR_AUTO_HIDE = "combined_bar_auto_hide";
+
+        /**
+         * Display style of AM/PM next to clock in status bar
+         * 0: Normal display (Eclair stock)
+         * 1: Small display (Froyo stock)
+         * 2: No display (Gingerbread/ICS stock)
+         * default: 2
+         * @hide
+         */
+        public static final String STATUS_BAR_AM_PM = "status_bar_am_pm";
+
+        /**
+         * Display style of the status bar battery information
+         * 0: Display the stock battery information
+         * 1: Display cm battery percentage implementation / dont show stock icon
+         * 2: Hide the battery information
+         * default: 0
+         * @hide
+         */
+        public static final String STATUS_BAR_BATTERY = "status_bar_battery";
+
+        /**
+         * Whether to show the clock in status bar
+         * of the stock battery icon
+         * 0: don't show the clock
+         * 1: show the clock
+         * default: 1
+         * @hide
+         */
+        public static final String STATUS_BAR_CLOCK = "status_bar_clock";
+
+        /**
+         * Whether to show the signal text or signal bars.
+         * default: 0
+         * 0: show signal bars
+         * 1: show signal text numbers
+         * 2: show signal text numbers w/small dBm appended
+         * @hide
+         */
+        public static final String STATUS_BAR_SIGNAL_TEXT = "status_bar_signal";
+
+         /**
+         * Whether to control brightness from status bar
+         *
+         * @hide
+         */
+        public static final String STATUS_BAR_BRIGHTNESS_CONTROL = "status_bar_brightness_control";
+
+        /**
+         * Whether to show the IME switcher in the status bar
+         * @hide
+         */
+        public static final String STATUS_BAR_IME_SWITCHER = "status_bar_ime_switcher";
+
+        /**
+         * Whether to use a separate delay for "slide to unlock" and security
+         * lock
+         * @hide
+         */
+        public static final String SCREEN_LOCK_SLIDE_DELAY_TOGGLE = "screen_lock_slide_delay_toggle";
+
+        /**
+         * How many ms to delay before enabling the "slide to unlock" screen
+         * lock when the screen goes off due to timeout
+         * @hide
+         */
+        public static final String SCREEN_LOCK_SLIDE_TIMEOUT_DELAY = "screen_lock_slide_timeout_delay";
+
+        /**
+         * How many ms to delay before enabling the "slide to unlock" screen
+         * lock when the screen is turned off by the user
+         * @hide
+         */
+        public static final String SCREEN_LOCK_SLIDE_SCREENOFF_DELAY = "screen_lock_slide_screenoff_delay";
+
+        /**
+         * Whether to use the custom quick unlock screen control
+         * @hide
+         */
+        public static final String LOCKSCREEN_QUICK_UNLOCK_CONTROL = "lockscreen_quick_unlock_control";
+
+        /**
+         * Stores values for custom lockscreen targets
+         * @hide
+         */
+        public static final String LOCKSCREEN_TARGETS = "lockscreen_targets";
+
+        /**
+         * Boolean value whether to link ringtone and notification volumes
+         * 
+         * @hide
+         */
+        public static final String VOLUME_LINK_NOTIFICATION = "volume_link_notification";
+
+        /**
+         * Whether to unlock the menu key.  The value is boolean (1 or 0).
+         * @hide
+         */
+        public static final String MENU_UNLOCK_SCREEN = "menu_unlock_screen";
+
+        /**
+         * Whether to wake the screen with the volume keys, the value is boolean.
+         * @hide
+         */
+        public static final String VOLUME_WAKE_SCREEN = "volume_wake_screen";
+
+        /**
+         * Whether or not volume button music controls should be enabled to seek media tracks
+         * @hide
+         */
+        public static final String VOLBTN_MUSIC_CONTROLS = "volbtn_music_controls";
+
+        /**
+         * Whether national data roaming should be used.
+         * @hide
+         */
+        public static final String MVNO_ROAMING = "mvno_roaming";
+
+        /**
+         * Whether to enable quiet hours.
+         * @hide
+         */
+        public static final String QUIET_HOURS_ENABLED = "quiet_hours_enabled";
+
+        /**
+         * Sets when quiet hours starts. This is stored in minutes from the start of the day.
+         * @hide
+         */
+        public static final String QUIET_HOURS_START = "quiet_hours_start";
+
+        /**
+         * Sets when quiet hours end. This is stored in minutes from the start of the day.
+         * @hide
+         */
+        public static final String QUIET_HOURS_END = "quiet_hours_end";
+
+        /**
+         * Whether to remove the sound from outgoing notifications during quiet hours.
+         * @hide
+         */
+        public static final String QUIET_HOURS_MUTE = "quiet_hours_mute";
+
+        /**
+         * Whether to disable haptic feedback during quiet hours.
+         * @hide
+         */
+        public static final String QUIET_HOURS_HAPTIC = "quiet_hours_haptic";
+
+        /**
+         * Whether to remove the vibration from outgoing notifications during quiet hours.
+         * @hide
+         */
+        public static final String QUIET_HOURS_STILL = "quiet_hours_still";
+
+        /**
+         * Whether to attempt to dim the LED color during quiet hours.
+         * @hide
+         */
+        public static final String QUIET_HOURS_DIM = "quiet_hours_dim";
+
+        /**
+         * Sets the lockscreen background style
+         * @hide
+         */
+        public static final String LOCKSCREEN_BACKGROUND = "lockscreen_background";
+
+        /**
+         * Show the weather on the lock screen
+         * @hide
+         */
+        public static final String LOCKSCREEN_WEATHER = "lockscreen_weather";
+
+        /**
+         * Show the current weather location on the lock screen
+         * @hide
+         */
+        public static final String WEATHER_SHOW_LOCATION = "weather_show_location";
+
+        /**
+         * Show the current weather location on the lock screen
+         * @hide
+         */
+        public static final String WEATHER_SHOW_TIMESTAMP = "weather_show_timestamp";
+
+        /**
+         * Use the custom/manually configured weather location
+         * @hide
+         */
+        public static final String WEATHER_USE_CUSTOM_LOCATION = "weather_use_custom_location";
+
+        /**
+         * Stores the custom/manually configured weather location
+         * @hide
+         */
+        public static final String WEATHER_CUSTOM_LOCATION = "weather_custom_location";
+
+        /**
+         * Stores the weather update frequency
+         * @hide
+         */
+        public static final String WEATHER_UPDATE_INTERVAL = "weather_update_interval";
+
+        /**
+         * Use Metric measurements (celcius, km/h) for weather data
+         * @hide
+         */
+        public static final String WEATHER_USE_METRIC = "weather_use_metric";
+
+        /**
+         * Invert low/high temperature display
+         * @hide
+         */
+        public static final String WEATHER_INVERT_LOWHIGH = "weather_invert_lowhigh";
+
+        /**
+         * Whether to show the next calendar event
+         * @hide
+         */
+        public static final String LOCKSCREEN_CALENDAR = "lockscreen_calendar";
+
+        /**
+         * Whether to show the next calendar event's location
+         * @hide
+         */
+        public static final String LOCKSCREEN_CALENDAR_SHOW_LOCATION = "lockscreen_calendar_show_location";
+
+        /**
+         * Whether to show the next calendar event's description
+         * @hide
+         */
+        public static final String LOCKSCREEN_CALENDAR_SHOW_DESCRIPTION = "lockscreen_calendar_show_description";
+
+        /**
+         * Which calendars to look for events
+         * @hide
+         */
+        public static final String LOCKSCREEN_CALENDARS = "lockscreen_calendars";
+
+        /**
+         * How far in the future to look for events
+         * @hide
+         */
+        public static final String LOCKSCREEN_CALENDAR_LOOKAHEAD = "lockscreen_calendar_lookahead";
+
+        /**
+         * Whether to find only events with reminders
+         * @hide
+         */
+        public static final String LOCKSCREEN_CALENDAR_REMINDERS_ONLY = "lockscreen_calendar_reminders_only";
+
+        /**
+         * Show the pending notification counts as overlays on the status bar
+         * @hide
+         */
+        public static final String STATUS_BAR_NOTIF_COUNT = "status_bar_notif_count";
+
+        /**
          * Settings to backup. This is here so that it's in the same place as the settings
          * keys and easy to update.
          *
@@ -1942,6 +2643,7 @@ public final class Settings {
             CALL_AUTO_RETRY,
             HEARING_AID,
             TTY_MODE,
+            NOISE_SUPPRESSION,
             SOUND_EFFECTS_ENABLED,
             HAPTIC_FEEDBACK_ENABLED,
             POWER_SOUNDS_ENABLED,
@@ -1949,9 +2651,19 @@ public final class Settings {
             LOCKSCREEN_SOUNDS_ENABLED,
             SHOW_WEB_SUGGESTIONS,
             NOTIFICATION_LIGHT_PULSE,
+            NOTIFICATION_LIGHT_PULSE_DEFAULT_COLOR,
+            NOTIFICATION_LIGHT_PULSE_DEFAULT_LED_ON,
+            NOTIFICATION_LIGHT_PULSE_DEFAULT_LED_OFF,
             SIP_CALL_OPTIONS,
             SIP_RECEIVE_CALLS,
             POINTER_SPEED,
+            QUIET_HOURS_ENABLED,
+            QUIET_HOURS_START,
+            QUIET_HOURS_END,
+            QUIET_HOURS_MUTE,
+            QUIET_HOURS_STILL,
+            QUIET_HOURS_DIM,
+            KEYLAYOUT_OVERRIDES,
         };
 
         // Settings moved to Settings.Secure
@@ -2453,6 +3165,18 @@ public final class Settings {
         public static final String ADB_ENABLED = "adb_enabled";
 
         /**
+         * The TCP/IP port to run ADB on, or -1 for USB
+         * @hide
+         */
+        public static final String ADB_PORT = "adb_port";
+
+        /**
+         * The hostname for this device
+         * @hide
+         */
+        public static final String DEVICE_HOSTNAME = "device_hostname";
+
+        /**
          * Setting to allow mock locations and location provider status to be injected into the
          * LocationManager service for testing purposes during application development.  These
          * locations and status values  override actual location and status information generated
@@ -2643,6 +3367,14 @@ public final class Settings {
             "lock_screen_owner_info_enabled";
 
         /**
+         * Whether the unsecure widget screen will be shown before a secure
+         * lock screen
+         * @hide
+         */
+        public static final String LOCK_BEFORE_UNLOCK =
+            "lock_before_unlock";
+
+        /**
          * The saved value for WindowManagerService.setForcedDisplaySize().
          * Two integers separated by a comma.  If unset, then use the real display size.
          * @hide
@@ -2656,6 +3388,11 @@ public final class Settings {
         public static final String ASSISTED_GPS_ENABLED = "assisted_gps_enabled";
 
         /**
+         * External GPS source/device
+         * @hide
+         */
+        public static final String EXTERNAL_GPS_BT_DEVICE = "0";
+        /**
          * The Logging ID (a unique 64-bit value) as a hex string.
          * Used as a pseudonymous identifier for logging.
          * @deprecated This identifier is poorly initialized and has
@@ -2694,6 +3431,12 @@ public final class Settings {
          */
         public static final String TETHER_DUN_APN = "tether_dun_apn";
 
+        /** DHCP lease time for tethering in seconds {@hide} */
+        public static final String TETHER_LEASE_TIME = "tether_lease_time";
+
+        /** Default value for TETHER_LEASE_TIME {@hide} */
+        public static final int TETHER_LEASE_TIME_DEFAULT = -1;
+
         /**
          * No longer supported.
          */
@@ -3169,6 +3912,12 @@ public final class Settings {
             "wifi_mobile_data_transition_wakelock_timeout_ms";
 
         /**
+         * Whether the Wimax should be on.  Only the WiMAX service should touch this.
+         * @hide
+         */
+        public static final String WIMAX_ON = "wimax_on";
+
+        /**
          * Whether background data usage is allowed by the user. See
          * ConnectivityManager for more info.
          */
@@ -3856,6 +4605,12 @@ public final class Settings {
         public static final String ANR_SHOW_BACKGROUND = "anr_show_background";
 
         /**
+         * Whether to allow killing of the foreground app by long-pressing the Back button
+         * @hide
+         */
+        public static final String KILL_APP_LONGPRESS_BACK = "kill_app_longpress_back";
+
+        /**
          * The {@link ComponentName} string of the service to be used as the voice recognition
          * service.
          *
diff --git a/core/java/android/server/BluetoothA2dpService.java b/core/java/android/server/BluetoothA2dpService.java
index c4cb3a5..ddc022d 100644
--- a/core/java/android/server/BluetoothA2dpService.java
+++ b/core/java/android/server/BluetoothA2dpService.java
@@ -66,6 +66,36 @@ public class BluetoothA2dpService extends IBluetoothA2dp.Stub {
     private int   mTargetA2dpState;
     private BluetoothDevice mPlayingA2dpDevice;
 
+    /* AVRCP1.3 Metadata variables */
+    private String mTrackName = DEFAULT_METADATA_STRING;
+    private String mArtistName = DEFAULT_METADATA_STRING;
+    private String mAlbumName = DEFAULT_METADATA_STRING;
+    private String mMediaNumber = DEFAULT_METADATA_NUMBER;
+    private String mMediaCount = DEFAULT_METADATA_NUMBER;
+    private String mDuration = DEFAULT_METADATA_NUMBER;
+    private int mPlayStatus = (int)Integer.valueOf(DEFAULT_METADATA_NUMBER);
+    private long mPosition = (long)Long.valueOf(DEFAULT_METADATA_NUMBER);
+
+    /* AVRCP1.3 Events */
+    private final static int EVENT_PLAYSTATUS_CHANGED = 0x1;
+    private final static int EVENT_TRACK_CHANGED = 0x2;
+
+    /*AVRCP 1.3 Music App Intents */
+    private static final String PLAYSTATE_CHANGED = "com.android.music.playstatechanged";
+    private static final String META_CHANGED = "com.android.music.metachanged";
+
+    private final static String DEFAULT_METADATA_STRING = "Unknown";
+    private final static String DEFAULT_METADATA_NUMBER = "0";
+
+    /* AVRCP 1.3 PlayStatus */
+    private final static int STATUS_STOPPED = 0X00;
+    private final static int STATUS_PLAYING = 0X01;
+    private final static int STATUS_PAUSED = 0X02;
+    private final static int STATUS_FWD_SEEK = 0X03;
+    private final static int STATUS_REV_SEEK = 0X04;
+    private final static int STATUS_ERROR = 0XFF;
+
+
     private final BroadcastReceiver mReceiver = new BroadcastReceiver() {
         @Override
         public void onReceive(Context context, Intent intent) {
@@ -109,10 +139,122 @@ public class BluetoothA2dpService extends IBluetoothA2dp.Stub {
                         }
                     }
                 }
+            } else if (action.equals(META_CHANGED)) {
+                mTrackName = intent.getStringExtra("track");
+                mArtistName = intent.getStringExtra("artist");
+                mAlbumName = intent.getStringExtra("album");
+                if (mTrackName == null)
+                    mTrackName = DEFAULT_METADATA_STRING;
+                if (mArtistName == null)
+                    mArtistName = DEFAULT_METADATA_STRING;
+                if (mAlbumName == null)
+                    mAlbumName = DEFAULT_METADATA_STRING;
+                long extra = intent.getLongExtra("id", 0);
+                if (extra < 0)
+                    extra = 0;
+                mMediaNumber = String.valueOf(extra);
+                extra = intent.getLongExtra("ListSize", 0);;
+                if (extra < 0)
+                    extra = 0;
+                mMediaCount = String.valueOf(extra);
+                extra = intent.getLongExtra("duration", 0);
+                if (extra < 0)
+                    extra = 0;
+                mDuration = String.valueOf(extra);
+                extra = intent.getLongExtra("position", 0);
+                if (extra < 0)
+                    extra = 0;
+                mPosition = extra;
+                if(DBG) {
+                    Log.d(TAG, "Meta data info is trackname: "+ mTrackName+" artist: "+mArtistName);
+                    Log.d(TAG, "mMediaNumber: "+mMediaNumber+" mediaCount "+mMediaCount);
+                    Log.d(TAG, "mPostion "+ mPosition+" album: "+mAlbumName+ "duration "+mDuration);
+                }
+                for (String path: getConnectedSinksPaths()) {
+                    sendMetaData(path);
+                    sendEvent(path, EVENT_TRACK_CHANGED, Long.valueOf(mMediaNumber));
+                }
+            } else if (action.equals(PLAYSTATE_CHANGED)) {
+                String currentTrackName = intent.getStringExtra("track");
+                if ((currentTrackName != null) && (!currentTrackName.equals(mTrackName))) {
+                    mTrackName = currentTrackName;
+                    mArtistName = intent.getStringExtra("artist");
+                    mAlbumName = intent.getStringExtra("album");
+                    if (mTrackName == null)
+                        mTrackName = DEFAULT_METADATA_STRING;
+                    if (mArtistName == null)
+                        mArtistName = DEFAULT_METADATA_STRING;
+                    if (mAlbumName == null)
+                        mAlbumName = DEFAULT_METADATA_STRING;
+                    long extra = intent.getLongExtra("id", 0);
+                    if (extra < 0)
+                        extra = 0;
+                    mMediaNumber = String.valueOf(extra);
+                    extra = intent.getLongExtra("ListSize", 0);;
+                    if (extra < 0)
+                        extra = 0;
+                    mMediaCount = String.valueOf(extra);
+                    extra = intent.getLongExtra("duration", 0);
+                    if (extra < 0)
+                        extra = 0;
+                    mDuration = String.valueOf(extra);
+                    extra = intent.getLongExtra("position", 0);
+                    if (extra < 0)
+                        extra = 0;
+                    mPosition = extra;
+                    for (String path: getConnectedSinksPaths())
+                        sendMetaData(path);
+                }
+                boolean playStatus = intent.getBooleanExtra("playing", false);
+                mPosition = intent.getLongExtra("position", 0);
+                if (mPosition < 0)
+                    mPosition = 0;
+                mPlayStatus = convertedPlayStatus(playStatus, mPosition);
+                if(DBG) Log.d(TAG, "PlayState changed "+ mPlayStatus);
+                for (String path: getConnectedSinksPaths()) {
+                    sendEvent(path, EVENT_PLAYSTATUS_CHANGED, (long)mPlayStatus);
+                }
             }
         }
     };
 
+    private synchronized int convertedPlayStatus(boolean playing, long position) {
+        if (playing == false && position == 0)
+            return STATUS_STOPPED;
+        if (playing == false)
+            return STATUS_PAUSED;
+        if (playing == true)
+            return STATUS_PLAYING;
+        return STATUS_ERROR;
+    }
+
+    private synchronized void sendMetaData(String path) {
+        if(DBG) {
+            Log.d(TAG, "sendMetaData "+ path);
+            Log.d(TAG, "Meta data info is trackname: "+ mTrackName+" artist: "+mArtistName);
+            Log.d(TAG, "mMediaNumber: "+mMediaNumber+" mediaCount "+mMediaCount);
+            Log.d(TAG, "mPostion "+ mPosition+" album: "+mAlbumName+ "duration "+mDuration);
+        }
+        sendMetaDataNative(path);
+    }
+
+    private synchronized void sendEvent(String path, int eventId, long data) {
+        if(DBG) Log.d(TAG, "sendEvent "+path+ " data "+ data);
+        sendEventNative(path, eventId, data);
+    }
+
+    private synchronized void sendPlayStatus(String path) {
+        if(DBG) Log.d(TAG, "sendPlayStatus"+ path);
+        sendPlayStatusNative(path, (int)Integer.valueOf(mDuration), (int)mPosition, mPlayStatus);
+    }
+
+    private void onGetPlayStatusRequest() {
+        if(DBG) Log.d(TAG, "onGetPlayStatusRequest");
+        for (String path: getConnectedSinksPaths()) {
+            sendPlayStatus(path);
+        }
+    }
+
     private boolean isPhoneDocked(BluetoothDevice device) {
         // This works only because these broadcast intents are "sticky"
         Intent i = mContext.registerReceiver(null, new IntentFilter(Intent.ACTION_DOCK_EVENT));
@@ -148,6 +290,8 @@ public class BluetoothA2dpService extends IBluetoothA2dp.Stub {
         mIntentFilter.addAction(BluetoothDevice.ACTION_ACL_CONNECTED);
         mIntentFilter.addAction(BluetoothDevice.ACTION_ACL_DISCONNECTED);
         mIntentFilter.addAction(AudioManager.VOLUME_CHANGED_ACTION);
+        mIntentFilter.addAction(PLAYSTATE_CHANGED);
+        mIntentFilter.addAction(META_CHANGED);
         mContext.registerReceiver(mReceiver, mIntentFilter);
 
         mAudioDevices = new HashMap<BluetoothDevice, Integer>();
@@ -397,6 +541,16 @@ public class BluetoothA2dpService extends IBluetoothA2dp.Stub {
         return state;
     }
 
+    public synchronized List<String> getConnectedSinksPaths() {
+        mContext.enforceCallingOrSelfPermission(BLUETOOTH_PERM, "Need BLUETOOTH permission");
+        List<BluetoothDevice> btDevices = getConnectedDevices();
+        ArrayList<String> paths = new ArrayList<String>();
+        for(BluetoothDevice device:btDevices) {
+            paths.add(mBluetoothService.getObjectPathFromAddress(device.getAddress()));
+        }
+        return paths;
+    }
+
     public synchronized List<BluetoothDevice> getConnectedDevices() {
         mContext.enforceCallingOrSelfPermission(BLUETOOTH_PERM, "Need BLUETOOTH permission");
         List<BluetoothDevice> sinks = getDevicesMatchingConnectionStates(
@@ -526,6 +680,13 @@ public class BluetoothA2dpService extends IBluetoothA2dp.Stub {
             mBluetoothService.sendConnectionStateChange(device, BluetoothProfile.A2DP, state,
                                                         prevState);
         }
+        if (prevState == BluetoothA2dp.STATE_CONNECTING &&
+             state == BluetoothA2dp.STATE_CONNECTED) {
+            for (String path: getConnectedSinksPaths()) {
+                sendMetaData(path);
+                sendEvent(path, EVENT_PLAYSTATUS_CHANGED, (long)mPlayStatus);
+            }
+        }
     }
 
     private void handleSinkPlayingStateChange(BluetoothDevice device, int state, int prevState) {
@@ -609,4 +770,8 @@ public class BluetoothA2dpService extends IBluetoothA2dp.Stub {
     private synchronized native Object []getSinkPropertiesNative(String path);
     private synchronized native boolean avrcpVolumeUpNative(String path);
     private synchronized native boolean avrcpVolumeDownNative(String path);
+    private synchronized native boolean sendMetaDataNative(String path);
+    private synchronized native boolean sendEventNative(String path, int eventId, long data);
+    private synchronized native boolean sendPlayStatusNative(String path, int duration,
+                                                             int position, int playStatus);
 }
diff --git a/core/java/android/server/BluetoothService.java b/core/java/android/server/BluetoothService.java
index fecc8f9..d1283ba 100755
--- a/core/java/android/server/BluetoothService.java
+++ b/core/java/android/server/BluetoothService.java
@@ -136,7 +136,8 @@ public class BluetoothService extends IBluetooth.Stub {
     private static final ParcelUuid[] RFCOMM_UUIDS = {
             BluetoothUuid.Handsfree,
             BluetoothUuid.HSP,
-            BluetoothUuid.ObexObjectPush };
+            BluetoothUuid.ObexObjectPush,
+            BluetoothUuid.MessageNotificationServer };
 
     private final BluetoothAdapterProperties mAdapterProperties;
     private final BluetoothDeviceProperties mDeviceProperties;
@@ -557,6 +558,7 @@ public class BluetoothService extends IBluetooth.Stub {
         // Add the default records
         uuids.add(BluetoothUuid.HSP_AG);
         uuids.add(BluetoothUuid.ObexObjectPush);
+        uuids.add(BluetoothUuid.MessageAccessServer);
 
         if (mContext.getResources().
                 getBoolean(com.android.internal.R.bool.config_voice_capable)) {
diff --git a/core/java/android/text/method/QwertyKeyListener.java b/core/java/android/text/method/QwertyKeyListener.java
index 4c82b81..8c37daa 100644
--- a/core/java/android/text/method/QwertyKeyListener.java
+++ b/core/java/android/text/method/QwertyKeyListener.java
@@ -129,6 +129,12 @@ public class QwertyKeyListener extends BaseKeyListener {
             return true;
         }
 
+	if (i == KeyCharacterMap.DOT_WWW_INPUT || i == KeyCharacterMap.DOT_COM_INPUT) {
+            content.replace(selStart, selEnd, selStart == 0 ? "www." : ".com");
+            adjustMetaAfterKeypress(content);
+            return true;
+        }
+
         if (i == KeyCharacterMap.HEX_INPUT) {
             int start;
 
@@ -423,78 +429,75 @@ public class QwertyKeyListener extends BaseKeyListener {
                         Spannable.SPAN_EXCLUSIVE_EXCLUSIVE);
     }
 
-    private static SparseArray<String> PICKER_SETS =
-                        new SparseArray<String>();
+    private static SparseArray<Integer> SYM_PICKER_RES_ID =
+                        new SparseArray<Integer>();
+
     static {
-        PICKER_SETS.put('A', "\u00C0\u00C1\u00C2\u00C4\u00C6\u00C3\u00C5\u0104\u0100");
-        PICKER_SETS.put('C', "\u00C7\u0106\u010C");
-        PICKER_SETS.put('D', "\u010E");
-        PICKER_SETS.put('E', "\u00C8\u00C9\u00CA\u00CB\u0118\u011A\u0112");
-        PICKER_SETS.put('G', "\u011E");
-        PICKER_SETS.put('L', "\u0141");
-        PICKER_SETS.put('I', "\u00CC\u00CD\u00CE\u00CF\u012A\u0130");
-        PICKER_SETS.put('N', "\u00D1\u0143\u0147");
-        PICKER_SETS.put('O', "\u00D8\u0152\u00D5\u00D2\u00D3\u00D4\u00D6\u014C");
-        PICKER_SETS.put('R', "\u0158");
-        PICKER_SETS.put('S', "\u015A\u0160\u015E");
-        PICKER_SETS.put('T', "\u0164");
-        PICKER_SETS.put('U', "\u00D9\u00DA\u00DB\u00DC\u016E\u016A");
-        PICKER_SETS.put('Y', "\u00DD\u0178");
-        PICKER_SETS.put('Z', "\u0179\u017B\u017D");
-        PICKER_SETS.put('a', "\u00E0\u00E1\u00E2\u00E4\u00E6\u00E3\u00E5\u0105\u0101");
-        PICKER_SETS.put('c', "\u00E7\u0107\u010D");
-        PICKER_SETS.put('d', "\u010F");
-        PICKER_SETS.put('e', "\u00E8\u00E9\u00EA\u00EB\u0119\u011B\u0113");
-        PICKER_SETS.put('g', "\u011F");
-        PICKER_SETS.put('i', "\u00EC\u00ED\u00EE\u00EF\u012B\u0131");
-        PICKER_SETS.put('l', "\u0142");
-        PICKER_SETS.put('n', "\u00F1\u0144\u0148");
-        PICKER_SETS.put('o', "\u00F8\u0153\u00F5\u00F2\u00F3\u00F4\u00F6\u014D");
-        PICKER_SETS.put('r', "\u0159");
-        PICKER_SETS.put('s', "\u00A7\u00DF\u015B\u0161\u015F");
-        PICKER_SETS.put('t', "\u0165");
-        PICKER_SETS.put('u', "\u00F9\u00FA\u00FB\u00FC\u016F\u016B");
-        PICKER_SETS.put('y', "\u00FD\u00FF");
-        PICKER_SETS.put('z', "\u017A\u017C\u017E");
-        PICKER_SETS.put(KeyCharacterMap.PICKER_DIALOG_INPUT,
-                             "\u2026\u00A5\u2022\u00AE\u00A9\u00B1[]{}\\|");
-        PICKER_SETS.put('/', "\\");
-
-        // From packages/inputmethods/LatinIME/res/xml/kbd_symbols.xml
-
-        PICKER_SETS.put('1', "\u00b9\u00bd\u2153\u00bc\u215b");
-        PICKER_SETS.put('2', "\u00b2\u2154");
-        PICKER_SETS.put('3', "\u00b3\u00be\u215c");
-        PICKER_SETS.put('4', "\u2074");
-        PICKER_SETS.put('5', "\u215d");
-        PICKER_SETS.put('7', "\u215e");
-        PICKER_SETS.put('0', "\u207f\u2205");
-        PICKER_SETS.put('$', "\u00a2\u00a3\u20ac\u00a5\u20a3\u20a4\u20b1");
-        PICKER_SETS.put('%', "\u2030");
-        PICKER_SETS.put('*', "\u2020\u2021");
-        PICKER_SETS.put('-', "\u2013\u2014");
-        PICKER_SETS.put('+', "\u00b1");
-        PICKER_SETS.put('(', "[{<");
-        PICKER_SETS.put(')', "]}>");
-        PICKER_SETS.put('!', "\u00a1");
-        PICKER_SETS.put('"', "\u201c\u201d\u00ab\u00bb\u02dd");
-        PICKER_SETS.put('?', "\u00bf");
-        PICKER_SETS.put(',', "\u201a\u201e");
-
-        // From packages/inputmethods/LatinIME/res/xml/kbd_symbols_shift.xml
-
-        PICKER_SETS.put('=', "\u2260\u2248\u221e");
-        PICKER_SETS.put('<', "\u2264\u00ab\u2039");
-        PICKER_SETS.put('>', "\u2265\u00bb\u203a");
+        SYM_PICKER_RES_ID.put('A', com.android.internal.R.string.symbol_picker_A);
+        SYM_PICKER_RES_ID.put('C', com.android.internal.R.string.symbol_picker_C);
+        SYM_PICKER_RES_ID.put('D', com.android.internal.R.string.symbol_picker_D);
+        SYM_PICKER_RES_ID.put('E', com.android.internal.R.string.symbol_picker_E);
+        SYM_PICKER_RES_ID.put('G', com.android.internal.R.string.symbol_picker_G);
+        SYM_PICKER_RES_ID.put('L', com.android.internal.R.string.symbol_picker_L);
+        SYM_PICKER_RES_ID.put('I', com.android.internal.R.string.symbol_picker_I);
+        SYM_PICKER_RES_ID.put('N', com.android.internal.R.string.symbol_picker_N);
+        SYM_PICKER_RES_ID.put('O', com.android.internal.R.string.symbol_picker_O);
+        SYM_PICKER_RES_ID.put('R', com.android.internal.R.string.symbol_picker_R);
+        SYM_PICKER_RES_ID.put('S', com.android.internal.R.string.symbol_picker_S);
+        SYM_PICKER_RES_ID.put('T', com.android.internal.R.string.symbol_picker_T);
+        SYM_PICKER_RES_ID.put('U', com.android.internal.R.string.symbol_picker_U);
+        SYM_PICKER_RES_ID.put('Y', com.android.internal.R.string.symbol_picker_Y);
+        SYM_PICKER_RES_ID.put('Z', com.android.internal.R.string.symbol_picker_Z);
+        SYM_PICKER_RES_ID.put('a', com.android.internal.R.string.symbol_picker_a);
+        SYM_PICKER_RES_ID.put('c', com.android.internal.R.string.symbol_picker_c);
+        SYM_PICKER_RES_ID.put('d', com.android.internal.R.string.symbol_picker_d);
+        SYM_PICKER_RES_ID.put('e', com.android.internal.R.string.symbol_picker_e);
+        SYM_PICKER_RES_ID.put('g', com.android.internal.R.string.symbol_picker_g);
+        SYM_PICKER_RES_ID.put('i', com.android.internal.R.string.symbol_picker_i);
+        SYM_PICKER_RES_ID.put('l', com.android.internal.R.string.symbol_picker_l);
+        SYM_PICKER_RES_ID.put('n', com.android.internal.R.string.symbol_picker_n);
+        SYM_PICKER_RES_ID.put('o', com.android.internal.R.string.symbol_picker_o);
+        SYM_PICKER_RES_ID.put('r', com.android.internal.R.string.symbol_picker_r);
+        SYM_PICKER_RES_ID.put('s', com.android.internal.R.string.symbol_picker_s);
+        SYM_PICKER_RES_ID.put('t', com.android.internal.R.string.symbol_picker_t);
+        SYM_PICKER_RES_ID.put('u', com.android.internal.R.string.symbol_picker_u);
+        SYM_PICKER_RES_ID.put('y', com.android.internal.R.string.symbol_picker_y);
+        SYM_PICKER_RES_ID.put('z', com.android.internal.R.string.symbol_picker_z);
+        SYM_PICKER_RES_ID.put('1', com.android.internal.R.string.symbol_picker_1);
+        SYM_PICKER_RES_ID.put('2', com.android.internal.R.string.symbol_picker_2);
+        SYM_PICKER_RES_ID.put('3', com.android.internal.R.string.symbol_picker_3);
+        SYM_PICKER_RES_ID.put('4', com.android.internal.R.string.symbol_picker_4);
+        SYM_PICKER_RES_ID.put('5', com.android.internal.R.string.symbol_picker_5);
+        SYM_PICKER_RES_ID.put('7', com.android.internal.R.string.symbol_picker_7);
+        SYM_PICKER_RES_ID.put('0', com.android.internal.R.string.symbol_picker_0);
+        SYM_PICKER_RES_ID.put(KeyCharacterMap.PICKER_DIALOG_INPUT,com.android.internal.R.string.symbol_picker_sym);
+        SYM_PICKER_RES_ID.put('/', com.android.internal.R.string.symbol_picker_slash);
+        SYM_PICKER_RES_ID.put('$', com.android.internal.R.string.symbol_picker_dollar);
+        SYM_PICKER_RES_ID.put('%', com.android.internal.R.string.symbol_picker_percent);
+        SYM_PICKER_RES_ID.put('*', com.android.internal.R.string.symbol_picker_star);
+        SYM_PICKER_RES_ID.put('-', com.android.internal.R.string.symbol_picker_minus);
+        SYM_PICKER_RES_ID.put('+', com.android.internal.R.string.symbol_picker_plus);
+        SYM_PICKER_RES_ID.put('(', com.android.internal.R.string.symbol_picker_opening_parenthesis);
+        SYM_PICKER_RES_ID.put(')', com.android.internal.R.string.symbol_picker_closing_parenthesis);
+        SYM_PICKER_RES_ID.put('!', com.android.internal.R.string.symbol_picker_exclamation);
+        SYM_PICKER_RES_ID.put('"', com.android.internal.R.string.symbol_picker_quote);
+        SYM_PICKER_RES_ID.put('?', com.android.internal.R.string.symbol_picker_question);
+        SYM_PICKER_RES_ID.put(',', com.android.internal.R.string.symbol_picker_comma);
+        SYM_PICKER_RES_ID.put('=', com.android.internal.R.string.symbol_picker_equal);
+        SYM_PICKER_RES_ID.put('<', com.android.internal.R.string.symbol_picker_lt);
+        SYM_PICKER_RES_ID.put('>', com.android.internal.R.string.symbol_picker_gt);
     };
 
     private boolean showCharacterPicker(View view, Editable content, char c,
                                         boolean insert, int count) {
-        String set = PICKER_SETS.get(c);
-        if (set == null) {
+        Integer resId = SYM_PICKER_RES_ID.get(c);
+
+        if (resId == null) {
             return false;
         }
 
+        String set = view.getContext().getString(resId);
+
         if (count == 1) {
             new CharacterPickerDialog(view.getContext(),
                                       view, content, set, insert).show();
diff --git a/core/java/android/view/GLES20Canvas.java b/core/java/android/view/GLES20Canvas.java
index 4ca299f..3a6183a 100644
--- a/core/java/android/view/GLES20Canvas.java
+++ b/core/java/android/view/GLES20Canvas.java
@@ -254,9 +254,25 @@ class GLES20Canvas extends HardwareCanvas {
         }
     }
 
+    @Override
+    void startTileRendering(Rect dirty) {
+        if (dirty != null) {
+            nStartTileRendering(mRenderer, dirty.left, dirty.top, dirty.right, dirty.bottom);
+        } else {
+            nStartTileRendering(mRenderer, 0, 0, 0, 0);
+        }
+    }
+
+    @Override
+    void endTileRendering() {
+            nEndTileRendering(mRenderer);
+    }
+
     private static native void nPrepare(int renderer, boolean opaque);
     private static native void nPrepareDirty(int renderer, int left, int top, int right, int bottom,
             boolean opaque);
+    private static native void nStartTileRendering(int renderer, int left, int top, int right, int bottom);
+    private static native void nEndTileRendering(int renderer);
 
     @Override
     void onPostDraw() {
diff --git a/core/java/android/view/HardwareCanvas.java b/core/java/android/view/HardwareCanvas.java
index 23b3abc..1a6c7b6 100644
--- a/core/java/android/view/HardwareCanvas.java
+++ b/core/java/android/view/HardwareCanvas.java
@@ -43,6 +43,8 @@ public abstract class HardwareCanvas extends Canvas {
      * @param dirty The dirty rectangle to update, can be null.
      */
     abstract void onPreDraw(Rect dirty);
+    abstract void startTileRendering(Rect dirty);
+    abstract void endTileRendering();
 
     /**
      * Invoked after all drawing operation have been performed.
diff --git a/core/java/android/view/HardwareRenderer.java b/core/java/android/view/HardwareRenderer.java
index 71f3cf5..a95b22c 100644
--- a/core/java/android/view/HardwareRenderer.java
+++ b/core/java/android/view/HardwareRenderer.java
@@ -74,9 +74,18 @@ public abstract class HardwareRenderer {
     static final String RENDER_DIRTY_REGIONS_PROPERTY = "hwui.render_dirty_regions";
     
     /**
+     * System property used to enable or disable tile rendering
+     *
+     * Possible values:
+     * "true", to enable tile rendering
+     * "false", to disable tile rendering
+     */
+    static final String TILE_RENDERING_PROPERTY = "debug.enabletr";
+
+    /**
      * System property used to enable or disable vsync.
      * The default value of this property is assumed to be false.
-     * 
+     *
      * Possible values:
      * "true", to disable vsync
      * "false", to enable vsync
@@ -433,14 +442,22 @@ public abstract class HardwareRenderer {
 
         static boolean sDirtyRegions;
         static final boolean sDirtyRegionsRequested;
+        static boolean sTileRendering;
         static {
             String dirtyProperty = SystemProperties.get(RENDER_DIRTY_REGIONS_PROPERTY, "true");
+            String trProperty = SystemProperties.get(TILE_RENDERING_PROPERTY, "false");
             //noinspection PointlessBooleanExpression,ConstantConditions
-            sDirtyRegions = RENDER_DIRTY_REGIONS && "true".equalsIgnoreCase(dirtyProperty);
+            //enable dirty regions if tile-rendering enabled or dirty regions property enabled
+            sTileRendering = "true".equalsIgnoreCase(trProperty);
+            sDirtyRegions = RENDER_DIRTY_REGIONS &&
+                            ("true".equalsIgnoreCase(dirtyProperty) ||
+                             sTileRendering);
             sDirtyRegionsRequested = sDirtyRegions;
         }
 
         boolean mDirtyRegionsEnabled;
+        boolean mUpdateDirtyRegions;
+
         final boolean mVsyncDisabled;
 
         final int mGlVersion;
@@ -675,6 +692,12 @@ public abstract class HardwareRenderer {
             
             initCaches();
 
+            enableDirtyRegions();
+
+            return mEglContext.getGL();
+        }
+
+        private void enableDirtyRegions() {
             // If mDirtyRegions is set, this means we have an EGL configuration
             // with EGL_SWAP_BEHAVIOR_PRESERVED_BIT set
             if (sDirtyRegions) {
@@ -690,8 +713,6 @@ public abstract class HardwareRenderer {
                 // configuration (see RENDER_DIRTY_REGIONS)
                 mDirtyRegionsEnabled = GLES20Canvas.isBackBufferPreserved();
             }
-
-            return mEglContext.getGL();
         }
 
         abstract void initCaches();
@@ -745,6 +766,9 @@ public abstract class HardwareRenderer {
                 if (!createSurface(holder)) {
                     return;
                 }
+
+                mUpdateDirtyRegions = true;
+
                 if (mCanvas != null) {
                     setEnabled(true);
                 }
@@ -799,6 +823,12 @@ public abstract class HardwareRenderer {
             return mGl != null && mCanvas != null;
         }        
         
+        void startTileRendering(Rect dirty) {
+        }
+
+        void endTileRendering() {
+        }
+
         void onPreDraw(Rect dirty) {
         }
 
@@ -826,6 +856,9 @@ public abstract class HardwareRenderer {
                         dirty = null;
                     }
 
+                    if (sTileRendering)
+                        startTileRendering(dirty);
+
                     onPreDraw(dirty);
 
                     HardwareCanvas canvas = mCanvas;
@@ -871,6 +904,8 @@ public abstract class HardwareRenderer {
                     }
 
                     onPostDraw();
+                    if (sTileRendering)
+                        endTileRendering();
 
                     attachInfo.mIgnoreDirtyState = false;
 
@@ -906,6 +941,12 @@ public abstract class HardwareRenderer {
                     fallback(true);
                     return SURFACE_STATE_ERROR;
                 } else {
+                    if (SystemProperties.QCOM_HARDWARE ) {
+                        if (mUpdateDirtyRegions) {
+                            enableDirtyRegions();
+                            mUpdateDirtyRegions = false;
+                        }
+                     }
                     return SURFACE_STATE_UPDATED;
                 }
             }
@@ -1014,6 +1055,16 @@ public abstract class HardwareRenderer {
         }
 
         @Override
+        void startTileRendering(Rect dirty) {
+            mGlCanvas.startTileRendering(dirty);
+        }
+
+        @Override
+        void endTileRendering() {
+            mGlCanvas.endTileRendering();
+        }
+
+        @Override
         void destroy(boolean full) {
             try {
                 super.destroy(full);
diff --git a/core/java/android/view/KeyCharacterMap.java b/core/java/android/view/KeyCharacterMap.java
index 575af3b..4e4116d 100644
--- a/core/java/android/view/KeyCharacterMap.java
+++ b/core/java/android/view/KeyCharacterMap.java
@@ -120,6 +120,18 @@ public class KeyCharacterMap {
     public static final char PICKER_DIALOG_INPUT = '\uEF01';
 
     /**
+     * Private use character denoting a .com suffix
+     * @hide
+     */
+    public static final char DOT_COM_INPUT = '\uEF03';
+
+    /**
+     * Private use character denoting a www. prefix
+     * @hide
+     */
+    public static final char DOT_WWW_INPUT = '\uEF04';
+
+    /**
      * Modifier keys may be chorded with character keys.
      *
      * @see {#link #getModifierBehavior()} for more details.
diff --git a/core/java/android/view/KeyEvent.java b/core/java/android/view/KeyEvent.java
index f53e42c..0d15d66 100755
--- a/core/java/android/view/KeyEvent.java
+++ b/core/java/android/view/KeyEvent.java
@@ -592,7 +592,53 @@ public class KeyEvent extends InputEvent implements Parcelable {
      * Used to launch a calculator application. */
     public static final int KEYCODE_CALCULATOR      = 210;
 
-    private static final int LAST_KEYCODE           = KEYCODE_CALCULATOR;
+    /** Please note all remaining keycodes need to be
+     * hidden from the api */
+
+    /** @hide */
+    public static final int KEYCODE_TOGGLE_WIFI     = 211;
+    /** @hide */
+    public static final int KEYCODE_TOGGLE_BT       = 212;
+    /** @hide */
+    public static final int KEYCODE_TOGGLE_TOUCHPAD = 213;
+    /** @hide */
+    public static final int KEYCODE_BRIGHTNESS_DOWN = 214;
+    /** @hide */
+    public static final int KEYCODE_BRIGHTNESS_UP   = 215;
+    /** @hide */
+    public static final int KEYCODE_BRIGHTNESS_AUTO = 216;
+    /** @hide */
+    public static final int KEYCODE_SCREENSHOT      = 217;
+    /** @hide */
+    /** FUNC_1 through USER5 to support keypad mapping */
+    /** @hide */
+    public static final int KEYCODE_FUNC_1          = 218;
+    /** @hide */
+    public static final int KEYCODE_FUNC_2          = 219;
+    /** @hide */
+    public static final int KEYCODE_FUNC_3          = 220;
+    /** @hide */
+    public static final int KEYCODE_FUNC_4          = 221;
+    /** @hide */
+    public static final int KEYCODE_FUNC_5          = 222;
+    /** @hide */
+    public static final int KEYCODE_FUNC_6          = 223;
+    /** @hide */
+    public static final int KEYCODE_FUNC_7          = 224;
+    /** @hide */
+    public static final int KEYCODE_FUNC_8          = 225;
+    /** @hide */
+    public static final int KEYCODE_USER1           = 226;
+    /** @hide */
+    public static final int KEYCODE_USER2           = 227;
+    /** @hide */
+    public static final int KEYCODE_USER3           = 228;
+    /** @hide */
+    public static final int KEYCODE_USER4           = 229;
+    /** @hide */
+    public static final int KEYCODE_USER5           = 230;
+
+    private static final int LAST_KEYCODE           = KEYCODE_USER5;
 
     // NOTE: If you add a new keycode here you must also add it to:
     //  isSystem()
@@ -825,6 +871,46 @@ public class KeyEvent extends InputEvent implements Parcelable {
         names.append(KEYCODE_CALENDAR, "KEYCODE_CALENDAR");
         names.append(KEYCODE_MUSIC, "KEYCODE_MUSIC");
         names.append(KEYCODE_CALCULATOR, "KEYCODE_CALCULATOR");
+	/** @hide */
+        names.append(KEYCODE_TOGGLE_WIFI, "KEYCODE_TOGGLE_WIFI");
+	/** @hide */
+        names.append(KEYCODE_TOGGLE_BT, "KEYCODE_TOGGLE_BT");
+	/** @hide */
+        names.append(KEYCODE_TOGGLE_TOUCHPAD, "KEYCODE_TOGGLE_TOUCHPAD");
+	/** @hide */
+        names.append(KEYCODE_BRIGHTNESS_DOWN, "KEYCODE_BRIGHTNESS_DOWN");
+	/** @hide */
+        names.append(KEYCODE_BRIGHTNESS_UP, "KEYCODE_BRIGHTNESS_UP");
+	/** @hide */
+        names.append(KEYCODE_BRIGHTNESS_AUTO, "KEYCODE_BRIGHTNESS_AUTO");
+	/** @hide */
+        names.append(KEYCODE_SCREENSHOT, "KEYCODE_SCREENSHOT");
+	/** @hide */
+        names.append(KEYCODE_SCREENSHOT, "KEYCODE_FUNC_1");
+	/** @hide */
+        names.append(KEYCODE_SCREENSHOT, "KEYCODE_FUNC_2");
+	/** @hide */
+        names.append(KEYCODE_SCREENSHOT, "KEYCODE_FUNC_3");
+	/** @hide */
+        names.append(KEYCODE_SCREENSHOT, "KEYCODE_FUNC_4");
+	/** @hide */
+        names.append(KEYCODE_SCREENSHOT, "KEYCODE_FUNC_5");
+	/** @hide */
+        names.append(KEYCODE_SCREENSHOT, "KEYCODE_FUNC_6");
+	/** @hide */
+        names.append(KEYCODE_SCREENSHOT, "KEYCODE_FUNC_7");
+	/** @hide */
+        names.append(KEYCODE_SCREENSHOT, "KEYCODE_FUNC_8");
+	/** @hide */
+        names.append(KEYCODE_SCREENSHOT, "KEYCODE_USER1");
+	/** @hide */
+        names.append(KEYCODE_SCREENSHOT, "KEYCODE_USER2");
+	/** @hide */
+        names.append(KEYCODE_SCREENSHOT, "KEYCODE_USER3");
+	/** @hide */
+        names.append(KEYCODE_SCREENSHOT, "KEYCODE_USER4");
+	/** @hide */
+        names.append(KEYCODE_SCREENSHOT, "KEYCODE_USER5");
     };
 
     // Symbolic names of all metakeys in bit order from least significant to most significant.
diff --git a/core/java/android/view/Surface.java b/core/java/android/view/Surface.java
index edaa262..3471677 100644
--- a/core/java/android/view/Surface.java
+++ b/core/java/android/view/Surface.java
@@ -76,6 +76,18 @@ public class Surface implements Parcelable {
         return lockCanvasNative(dirty);
     }
 
+    /**
+     * @hide
+     */
+    public void setStereoscopic3DFormat(int format) {
+        setStereoscopic3DFormatNative(format);
+    }
+
+    /**
+     * @hide
+     */
+    private native void setStereoscopic3DFormatNative(int format);
+
     /** unlock the surface and asks a page flip */
     public native   void unlockCanvasAndPost(Canvas canvas);
 
diff --git a/core/java/android/view/SurfaceHolder.java b/core/java/android/view/SurfaceHolder.java
index 2a16725..0b05282 100644
--- a/core/java/android/view/SurfaceHolder.java
+++ b/core/java/android/view/SurfaceHolder.java
@@ -46,6 +46,27 @@ public interface SurfaceHolder {
     public static final int SURFACE_TYPE_PUSH_BUFFERS = 3;
 
     /**
+     * Stereoscopic Side-by-Side Half 3D format
+     * @hide
+     */
+    public static final int STEREOSCOPIC_3D_FORMAT_SIDE_BY_SIDE_HALF_L_R = 0x10000;
+    /**
+     * Stereoscopic Top Bottom 3D format
+     * @hide
+     */
+    public static final int STEREOSCOPIC_3D_FORMAT_TOP_BOTTOM   = 0x20000;
+    /**
+     * Stereoscopic Interleaved 3D format
+     * @hide
+     */
+    public static final int STEREOSCOPIC_3D_FORMAT_INTERLEAVED  = 0x40000;
+    /**
+     * Stereoscopic Side-by-Side Full 3D format
+     * @hide
+     */
+    public static final int STEREOSCOPIC_3D_FORMAT_SIDE_BY_SIDE_R_L = 0x80000;
+
+    /**
      * Exception that is thrown from {@link #lockCanvas} when called on a Surface
      * whose type is SURFACE_TYPE_PUSH_BUFFERS.
      */
diff --git a/core/java/android/view/SurfaceView.java b/core/java/android/view/SurfaceView.java
index 6726c56..0573094 100644
--- a/core/java/android/view/SurfaceView.java
+++ b/core/java/android/view/SurfaceView.java
@@ -692,7 +692,16 @@ public class SurfaceView extends View {
         }
 
         public void setFormat(int format) {
-
+            switch (format) {
+                case STEREOSCOPIC_3D_FORMAT_SIDE_BY_SIDE_HALF_L_R:
+                case STEREOSCOPIC_3D_FORMAT_SIDE_BY_SIDE_R_L:
+                case STEREOSCOPIC_3D_FORMAT_TOP_BOTTOM:
+                case STEREOSCOPIC_3D_FORMAT_INTERLEAVED:
+                    mSurface.setStereoscopic3DFormat(format);
+                    return;
+                default:
+                    break;
+            }
             // for backward compatibility reason, OPAQUE always
             // means 565 for SurfaceView
             if (format == PixelFormat.OPAQUE)
diff --git a/core/java/android/view/VolumePanel.java b/core/java/android/view/VolumePanel.java
index 48fe0df..45eb3bb 100644
--- a/core/java/android/view/VolumePanel.java
+++ b/core/java/android/view/VolumePanel.java
@@ -92,12 +92,16 @@ public class VolumePanel extends Handler implements OnSeekBarChangeListener, Vie
     private static final int MSG_TIMEOUT = 5;
     private static final int MSG_RINGER_MODE_CHANGED = 6;
 
+    public static final String ACTION_VOLUME_OVERLAY_CHANGED
+        = "android.intent.action.VOLUME_OVERLAY_CHANGED";
+
     protected Context mContext;
     private AudioManager mAudioManager;
     protected AudioService mAudioService;
     private boolean mRingIsSilent;
     private boolean mShowCombinedVolumes;
     private boolean mVoiceCapable;
+    private int mCurrentOverlayStyle = -1;
 
     /** Dialog containing all the sliders */
     private final Dialog mDialog;
@@ -128,7 +132,7 @@ public class VolumePanel extends Handler implements OnSeekBarChangeListener, Vie
                 R.string.volume_icon_description_ringer,
                 R.drawable.ic_audio_ring_notif,
                 R.drawable.ic_audio_ring_notif_mute,
-                false),
+                true),
         VoiceStream(AudioManager.STREAM_VOICE_CALL,
                 R.string.volume_icon_description_incall,
                 R.drawable.ic_audio_phone,
@@ -138,7 +142,7 @@ public class VolumePanel extends Handler implements OnSeekBarChangeListener, Vie
                 R.string.volume_alarm,
                 R.drawable.ic_audio_alarm,
                 R.drawable.ic_audio_alarm_mute,
-                false),
+                true),
         MediaStream(AudioManager.STREAM_MUSIC,
                 R.string.volume_icon_description_media,
                 R.drawable.ic_audio_vol,
@@ -154,7 +158,7 @@ public class VolumePanel extends Handler implements OnSeekBarChangeListener, Vie
         int descRes;
         int iconRes;
         int iconMuteRes;
-        // RING, VOICE_CALL & BLUETOOTH_SCO are hidden unless explicitly requested
+        // VOICE_CALL & BLUETOOTH_SCO are hidden unless explicitly requested
         boolean show;
 
         StreamResources(int streamType, int descRes, int iconRes, int iconMuteRes, boolean show) {
@@ -194,7 +198,6 @@ public class VolumePanel extends Handler implements OnSeekBarChangeListener, Vie
         mContext = context;
         mAudioManager = (AudioManager) context.getSystemService(Context.AUDIO_SERVICE);
         mAudioService = volumeService;
-
         LayoutInflater inflater = (LayoutInflater) context
                 .getSystemService(Context.LAYOUT_INFLATER_SERVICE);
         View view = mView = inflater.inflate(R.layout.volume_adjust, null);
@@ -245,21 +248,27 @@ public class VolumePanel extends Handler implements OnSeekBarChangeListener, Vie
         mVibrator = new Vibrator();
 
         mVoiceCapable = context.getResources().getBoolean(R.bool.config_voice_capable);
-        mShowCombinedVolumes = !mVoiceCapable;
-        // If we don't want to show multiple volumes, hide the settings button and divider
-        if (!mShowCombinedVolumes) {
-            mMoreButton.setVisibility(View.GONE);
-            mDivider.setVisibility(View.GONE);
-        } else {
-            mMoreButton.setOnClickListener(this);
+
+        // get the users preference
+        int choosenStyle = Settings.System.getInt(context.getContentResolver(),Settings.System.MODE_VOLUME_OVERLAY, -1);
+        // by default -1 is expected - deal with choosing the right default
+        if (choosenStyle == -1) {
+            if (mVoiceCapable) {
+                choosenStyle = Settings.System.VOLUME_OVERLAY_SINGLE;
+            } else {
+                choosenStyle = Settings.System.VOLUME_OVERLAY_EXPANDABLE;
+            }
         }
+        changeOverlayStyle(choosenStyle);
+        mMoreButton.setOnClickListener(this);
 
-        listenToRingerMode();
+        listenToRingerModeAndConfigChanges();
     }
 
-    private void listenToRingerMode() {
+    private void listenToRingerModeAndConfigChanges() {
         final IntentFilter filter = new IntentFilter();
         filter.addAction(AudioManager.RINGER_MODE_CHANGED_ACTION);
+        filter.addAction(ACTION_VOLUME_OVERLAY_CHANGED);
         mContext.registerReceiver(new BroadcastReceiver() {
 
             public void onReceive(Context context, Intent intent) {
@@ -268,11 +277,48 @@ public class VolumePanel extends Handler implements OnSeekBarChangeListener, Vie
                 if (AudioManager.RINGER_MODE_CHANGED_ACTION.equals(action)) {
                     removeMessages(MSG_RINGER_MODE_CHANGED);
                     sendMessage(obtainMessage(MSG_RINGER_MODE_CHANGED));
+                } else if (ACTION_VOLUME_OVERLAY_CHANGED.equals(action)) {
+                    int state = (Integer) intent.getExtra("state");
+                    changeOverlayStyle(state);
                 }
             }
         }, filter);
     }
 
+    private void changeOverlayStyle(int newStyle) {
+        Log.i("VolumePanel", "changeOverlayStyle : " + newStyle);
+        // Don't change to the same style
+        if (newStyle == mCurrentOverlayStyle) return;
+        switch (newStyle) {
+            case Settings.System.VOLUME_OVERLAY_SINGLE :
+                mMoreButton.setVisibility(View.GONE);
+                mDivider.setVisibility(View.GONE);
+                mShowCombinedVolumes = false;
+                mCurrentOverlayStyle = Settings.System.VOLUME_OVERLAY_SINGLE;
+                break;
+            case Settings.System.VOLUME_OVERLAY_EXPANDABLE :
+                mMoreButton.setVisibility(View.VISIBLE);
+                mDivider.setVisibility(View.VISIBLE);
+                mShowCombinedVolumes = true;
+                mCurrentOverlayStyle = Settings.System.VOLUME_OVERLAY_EXPANDABLE;
+                break;
+            case Settings.System.VOLUME_OVERLAY_EXPANDED :
+                mMoreButton.setVisibility(View.GONE);
+                mDivider.setVisibility(View.GONE);
+                mShowCombinedVolumes = true;
+                if (mCurrentOverlayStyle == Settings.System.VOLUME_OVERLAY_NONE) {
+                    addOtherVolumes();
+                    expand();
+                }
+                mCurrentOverlayStyle = Settings.System.VOLUME_OVERLAY_EXPANDED;
+                break;
+            case Settings.System.VOLUME_OVERLAY_NONE :
+                mShowCombinedVolumes = false;
+                mCurrentOverlayStyle = Settings.System.VOLUME_OVERLAY_NONE;
+                break;
+        }
+    }
+
     private boolean isMuted(int streamType) {
         return mAudioManager.isStreamMute(streamType);
     }
@@ -285,9 +331,6 @@ public class VolumePanel extends Handler implements OnSeekBarChangeListener, Vie
         for (int i = 0; i < STREAMS.length; i++) {
             StreamResources streamRes = STREAMS[i];
             int streamType = streamRes.streamType;
-            if (mVoiceCapable && streamRes == StreamResources.NotificationStream) {
-                streamRes = StreamResources.RingerStream;
-            }
             StreamControl sc = new StreamControl();
             sc.streamType = streamType;
             sc.group = (ViewGroup) inflater.inflate(R.layout.volume_adjust_item, null);
@@ -298,6 +341,7 @@ public class VolumePanel extends Handler implements OnSeekBarChangeListener, Vie
             sc.iconRes = streamRes.iconRes;
             sc.iconMuteRes = streamRes.iconMuteRes;
             sc.icon.setImageResource(sc.iconRes);
+            sc.icon.setOnClickListener(this);
             sc.seekbarView = (SeekBar) sc.group.findViewById(R.id.seekbar);
             int plusOne = (streamType == AudioSystem.STREAM_BLUETOOTH_SCO ||
                     streamType == AudioSystem.STREAM_VOICE_CALL) ? 1 : 0;
@@ -321,19 +365,21 @@ public class VolumePanel extends Handler implements OnSeekBarChangeListener, Vie
             active.group.setVisibility(View.VISIBLE);
             updateSlider(active);
         }
-
         addOtherVolumes();
     }
 
     private void addOtherVolumes() {
         if (!mShowCombinedVolumes) return;
-
         for (int i = 0; i < STREAMS.length; i++) {
             // Skip the phone specific ones and the active one
             final int streamType = STREAMS[i].streamType;
             if (!STREAMS[i].show || streamType == mActiveStreamType) {
                 continue;
             }
+            // Skip ring volume for non-phone devices
+            if (!mVoiceCapable && streamType == AudioManager.STREAM_RING) {
+                continue;
+            }
             StreamControl sc = mStreamControls.get(streamType);
             mSliderGroup.addView(sc.group);
             updateSlider(sc);
@@ -357,11 +403,24 @@ public class VolumePanel extends Handler implements OnSeekBarChangeListener, Vie
 
     private void expand() {
         final int count = mSliderGroup.getChildCount();
+
+        for (int i = 0; i < count; i++) {
+            if (mSliderGroup.getChildAt(i).getVisibility() != View.VISIBLE) {
+                mSliderGroup.getChildAt(i).setVisibility(View.VISIBLE);
+            }
+        }
+        mMoreButton.setVisibility(View.GONE);
+        mDivider.setVisibility(View.GONE);
+    }
+
+    private void hideSlider(int mActiveStreamType) {
+        final int count = mSliderGroup.getChildCount();
         for (int i = 0; i < count; i++) {
-            mSliderGroup.getChildAt(i).setVisibility(View.VISIBLE);
+            StreamControl sc = (StreamControl) mSliderGroup.getChildAt(i).getTag();
+            if (mActiveStreamType == sc.streamType) {
+                mSliderGroup.getChildAt(i).setVisibility(View.GONE);
+            }
         }
-        mMoreButton.setVisibility(View.INVISIBLE);
-        mDivider.setVisibility(View.INVISIBLE);
     }
 
     private void collapse() {
@@ -400,7 +459,14 @@ public class VolumePanel extends Handler implements OnSeekBarChangeListener, Vie
         if (LOGD) Log.d(TAG, "onVolumeChanged(streamType: " + streamType + ", flags: " + flags + ")");
 
         if ((flags & AudioManager.FLAG_SHOW_UI) != 0) {
-            if (mActiveStreamType == -1) {
+            // If the activePanel is none - or - the one we are updating is not the current active panel
+            // then it is likely that the audio stream being updated has been swapped by an app
+            // we need to reorder the sliders to bring the new active one to the front
+            if (mActiveStreamType == -1 || streamType != mActiveStreamType) {
+                if (streamType != mActiveStreamType && 
+                       mCurrentOverlayStyle == Settings.System.VOLUME_OVERLAY_EXPANDABLE) {
+                    hideSlider(mActiveStreamType);
+                }
                 reorderSliders(streamType);
             }
             onShowVolumeChanged(streamType, flags);
@@ -436,13 +502,11 @@ public class VolumePanel extends Handler implements OnSeekBarChangeListener, Vie
         }
 
         // get max volume for progress bar
-
         int max = mAudioService.getStreamMaxVolume(streamType);
 
         switch (streamType) {
 
             case AudioManager.STREAM_RING: {
-//                setRingerIcon();
                 Uri ringuri = RingtoneManager.getActualDefaultRingtoneUri(
                         mContext, RingtoneManager.TYPE_RINGTONE);
                 if (ringuri == null) {
@@ -506,15 +570,29 @@ public class VolumePanel extends Handler implements OnSeekBarChangeListener, Vie
                 sc.seekbarView.setMax(max);
             }
             sc.seekbarView.setProgress(index);
+            // If adjusting Ring volume and preference is to link it to Notification
+            if (streamType == AudioManager.STREAM_RING &&
+                    System.getInt(mContext.getContentResolver(),System.VOLUME_LINK_NOTIFICATION, 1) == 1) {
+                StreamControl notifySc = mStreamControls.get(AudioManager.STREAM_NOTIFICATION);
+                if (index > notifySc.seekbarView.getMax()) {
+                    notifySc.seekbarView.setProgress(notifySc.seekbarView.getMax());
+                } else {
+                    notifySc.seekbarView.setProgress(index);
+                }
+            }
+
         }
 
-        if (!mDialog.isShowing()) {
-            mAudioManager.forceVolumeControlStream(streamType);
-            mDialog.setContentView(mView);
+        // Only Show if style needs it
+        if (!mDialog.isShowing() && mCurrentOverlayStyle != Settings.System.VOLUME_OVERLAY_NONE) {
             // Showing dialog - use collapsed state
-            if (mShowCombinedVolumes) {
+            if (mShowCombinedVolumes && mCurrentOverlayStyle != Settings.System.VOLUME_OVERLAY_EXPANDED) {
                 collapse();
             }
+            // If just changed the style and we need to expand
+            if (mCurrentOverlayStyle == Settings.System.VOLUME_OVERLAY_EXPANDED) {
+                expand();
+            }
             mDialog.show();
         }
 
@@ -666,13 +744,34 @@ public class VolumePanel extends Handler implements OnSeekBarChangeListener, Vie
         sendMessage(obtainMessage(MSG_TIMEOUT));
     }
 
-    public void onProgressChanged(SeekBar seekBar, int progress,
-            boolean fromUser) {
+    public void onProgressChanged(SeekBar seekBar, int progress, boolean fromUser) {
         final Object tag = seekBar.getTag();
         if (fromUser && tag instanceof StreamControl) {
             StreamControl sc = (StreamControl) tag;
             if (mAudioManager.getStreamVolume(sc.streamType) != progress) {
                 mAudioManager.setStreamVolume(sc.streamType, progress, 0);
+                // if audio is linked then adjust other one if change made by user
+                if (fromUser && System.getInt(mContext.getContentResolver(),System.VOLUME_LINK_NOTIFICATION, 1) == 1) {
+                    if (sc.streamType == AudioManager.STREAM_RING) {
+                        StreamControl notifySc = mStreamControls.get(AudioManager.STREAM_NOTIFICATION);
+                        if (notifySc != null) {
+                            if (progress > notifySc.seekbarView.getMax()) {
+                                notifySc.seekbarView.setProgress(notifySc.seekbarView.getMax());
+                            } else {
+                                notifySc.seekbarView.setProgress(progress);
+                            }
+                        }
+                    } else if (sc.streamType == AudioManager.STREAM_NOTIFICATION) {
+                        StreamControl phoneSc = mStreamControls.get(AudioManager.STREAM_RING);
+                        if (phoneSc != null) {
+                            if (progress > phoneSc.seekbarView.getMax()) {
+                                phoneSc.seekbarView.setProgress(phoneSc.seekbarView.getMax());
+                            } else {
+                                phoneSc.seekbarView.setProgress(progress);
+                            }
+                        }
+                    }
+                }
             }
         }
         resetTimeout();
@@ -687,6 +786,12 @@ public class VolumePanel extends Handler implements OnSeekBarChangeListener, Vie
     public void onClick(View v) {
         if (v == mMoreButton) {
             expand();
+        } else if (v instanceof ImageView) {
+            Intent volumeSettings = new Intent(android.provider.Settings.ACTION_SOUND_SETTINGS);
+            volumeSettings.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_RESET_TASK_IF_NEEDED);
+            forceTimeout();
+            mContext.startActivity(volumeSettings);
+            return;
         }
         resetTimeout();
     }
diff --git a/core/java/android/view/Window.java b/core/java/android/view/Window.java
index a99ac03..d289d11 100644
--- a/core/java/android/view/Window.java
+++ b/core/java/android/view/Window.java
@@ -741,6 +741,9 @@ public abstract class Window {
      * @param mask Which of the window flag bits to modify.
      */
     public void setFlags(int flags, int mask) {
+        if ((flags & mask & WindowManager.LayoutParams.PREVENT_POWER_KEY) != 0){
+            mContext.enforceCallingOrSelfPermission("android.permission.PREVENT_POWER_KEY", "No permission to prevent power key");
+        }
         final WindowManager.LayoutParams attrs = getAttributes();
         attrs.flags = (attrs.flags&~mask) | (flags&mask);
         if ((mask&WindowManager.LayoutParams.FLAG_NEEDS_MENU_KEY) != 0) {
@@ -780,6 +783,9 @@ public abstract class Window {
      *          current values.
      */
     public void setAttributes(WindowManager.LayoutParams a) {
+        if ((a.flags & WindowManager.LayoutParams.PREVENT_POWER_KEY) != 0){
+            mContext.enforceCallingOrSelfPermission("android.permission.PREVENT_POWER_KEY", "No permission to prevent power key");
+        }
         mWindowAttributes.copyFrom(a);
         if (mCallback != null) {
             mCallback.onWindowAttributesChanged(mWindowAttributes);
diff --git a/core/java/android/view/WindowManager.java b/core/java/android/view/WindowManager.java
index c0eb65b..42460d5 100644
--- a/core/java/android/view/WindowManager.java
+++ b/core/java/android/view/WindowManager.java
@@ -699,6 +699,10 @@ public interface WindowManager extends ViewManager {
          * {@hide} */
         public static final int FLAG_SYSTEM_ERROR = 0x40000000;
 
+        /** Window flag: Overrides default power key behavior
+         * {@hide} */
+        public static final int PREVENT_POWER_KEY = 0x80000000;
+
         /**
          * Various behavioral options/flags.  Default is none.
          * 
diff --git a/core/java/android/view/inputmethod/InputMethodManager.java b/core/java/android/view/inputmethod/InputMethodManager.java
index ce36046..047716f 100644
--- a/core/java/android/view/inputmethod/InputMethodManager.java
+++ b/core/java/android/view/inputmethod/InputMethodManager.java
@@ -1482,14 +1482,16 @@ public final class InputMethodManager {
                 return;
             }
     
-            if (key.getAction() == KeyEvent.ACTION_DOWN
-                    && key.getKeyCode() == KeyEvent.KEYCODE_SYM) {
-                showInputMethodPicker();
-                try {
-                    callback.finishedEvent(seq, true);
-                } catch (RemoteException e) {
+            if (context.getResources().getBoolean(com.android.internal.R.bool.config_symKeyShowsImePicker)) {
+                if (key.getAction() == KeyEvent.ACTION_DOWN
+                        && key.getKeyCode() == KeyEvent.KEYCODE_SYM) {
+                    showInputMethodPicker();
+                    try {
+                        callback.finishedEvent(seq, true);
+                    } catch (RemoteException e) {
+                    }
+                    return;
                 }
-                return;
             }
             try {
                 if (DEBUG) Log.v(TAG, "DISPATCH KEY: " + mCurMethod);
diff --git a/core/java/android/webkit/BrowserFrame.java b/core/java/android/webkit/BrowserFrame.java
index 66fca80..a810cf6 100644
--- a/core/java/android/webkit/BrowserFrame.java
+++ b/core/java/android/webkit/BrowserFrame.java
@@ -869,6 +869,7 @@ class BrowserFrame extends Handler {
         loader.setCacheMode(headers.containsKey("If-Modified-Since")
                 || headers.containsKey("If-None-Match") ? 
                         WebSettings.LOAD_NO_CACHE : cacheMode);
+        loader.executeLoad();
         // Set referrer to current URL?
         return !synchronous ? loadListener : null;
     }
diff --git a/core/java/android/webkit/WebSettings.java b/core/java/android/webkit/WebSettings.java
index f947f95..2ac66c0 100644
--- a/core/java/android/webkit/WebSettings.java
+++ b/core/java/android/webkit/WebSettings.java
@@ -22,6 +22,7 @@ import android.content.pm.PackageManager;
 import android.os.Build;
 import android.os.Handler;
 import android.os.Message;
+import android.os.SystemProperties;
 import android.util.DisplayMetrics;
 import android.util.EventLog;
 
@@ -509,6 +510,9 @@ public class WebSettings {
             buffer.append(" Build/");
             buffer.append(id);
         }
+        final String cmversion = SystemProperties.get("ro.cm.version");
+        if (cmversion != null && cmversion.length() > 0)
+            buffer.append("; CyanogenMod-" + cmversion.replaceAll("(.+?)-.*","$1"));
         String mobile = mContext.getResources().getText(
             com.android.internal.R.string.web_user_agent_target_content).toString();
         final String base = mContext.getResources().getText(
diff --git a/core/java/android/webkit/WebView.java b/core/java/android/webkit/WebView.java
index 24eebd7..18e7e93 100644
--- a/core/java/android/webkit/WebView.java
+++ b/core/java/android/webkit/WebView.java
@@ -1,5 +1,6 @@
 /*
  * Copyright (C) 2006 The Android Open Source Project
+ * Copyright (c) 2011-2012, Code Aurora Forum. All rights reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -743,9 +744,10 @@ public class WebView extends AbsoluteLayout
     static final int ENTER_FULLSCREEN_VIDEO             = 137;
     static final int UPDATE_SELECTION                   = 138;
     static final int UPDATE_ZOOM_DENSITY                = 139;
+    static final int RESUME_RENDER_PRIORITY             = 140;
 
     private static final int FIRST_PACKAGE_MSG_ID = SCROLL_TO_MSG_ID;
-    private static final int LAST_PACKAGE_MSG_ID = SET_TOUCH_HIGHLIGHT_RECTS;
+    private static final int LAST_PACKAGE_MSG_ID = RESUME_RENDER_PRIORITY;
 
     static final String[] HandlerPrivateDebugString = {
         "REMEMBER_PASSWORD", //              = 1;
@@ -3647,7 +3649,9 @@ public class WebView extends AbsoluteLayout
                 abortAnimation();
                 nativeSetIsScrolling(false);
                 if (!mBlockWebkitViewMessages) {
-                    WebViewCore.resumePriority();
+                    WebViewCore.resumePriority(2000);
+                    WebSettings webSettings = getSettings();
+                    webSettings.setRenderPriority(WebSettings.RenderPriority.NORMAL);
                     if (!mSelectingText) {
                         WebViewCore.resumeUpdatePicture(mWebViewCore);
                     }
@@ -5593,7 +5597,9 @@ public class WebView extends AbsoluteLayout
             // called by mSelectCallback.onDestroyActionMode
             mSelectCallback.finish();
             mSelectCallback = null;
-            WebViewCore.resumePriority();
+            WebViewCore.resumePriority(0);
+            WebSettings webSettings = getSettings();
+            webSettings.setRenderPriority(WebSettings.RenderPriority.NORMAL);
             WebViewCore.resumeUpdatePicture(mWebViewCore);
             invalidate(); // redraw without selection
             mAutoScrollX = 0;
@@ -6498,6 +6504,8 @@ public class WebView extends AbsoluteLayout
                                 // we will not rewrite drag code here, but we
                                 // will try fling if it applies.
                                 WebViewCore.reducePriority();
+                                WebSettings webSettings = getSettings();
+                                webSettings.setRenderPriority(WebSettings.RenderPriority.HIGH);
                                 // to get better performance, pause updating the
                                 // picture
                                 WebViewCore.pauseUpdatePicture(mWebViewCore);
@@ -6568,7 +6576,9 @@ public class WebView extends AbsoluteLayout
                         // device as we almost certain will get a MOVE. But this
                         // is possible on emulator.
                         mLastVelocity = 0;
-                        WebViewCore.resumePriority();
+                        WebViewCore.resumePriority(0);
+                        WebSettings webSettings = getSettings();
+                        webSettings.setRenderPriority(WebSettings.RenderPriority.NORMAL);
                         if (!mSelectingText) {
                             WebViewCore.resumeUpdatePicture(mWebViewCore);
                         }
@@ -6620,6 +6630,9 @@ public class WebView extends AbsoluteLayout
     }
 
     void handleMultiTouchInWebView(MotionEvent ev) {
+        WebViewCore.reducePriority();
+        WebSettings webSettings = getSettings();
+        webSettings.setRenderPriority(WebSettings.RenderPriority.HIGH);
         if (DebugFlags.WEB_VIEW) {
             Log.v(LOGTAG, "multi-touch: " + ev + " at " + ev.getEventTime()
                 + " mTouchMode=" + mTouchMode
@@ -6720,6 +6733,8 @@ public class WebView extends AbsoluteLayout
 
     private void startDrag() {
         WebViewCore.reducePriority();
+        WebSettings webSettings = getSettings();
+        webSettings.setRenderPriority(WebSettings.RenderPriority.HIGH);
         // to get better performance, pause updating the picture
         WebViewCore.pauseUpdatePicture(mWebViewCore);
         nativeSetIsScrolling(true);
@@ -6795,7 +6810,9 @@ public class WebView extends AbsoluteLayout
     private void stopTouch() {
         if (mScroller.isFinished() && !mSelectingText
                 && (mTouchMode == TOUCH_DRAG_MODE || mTouchMode == TOUCH_DRAG_LAYER_MODE)) {
-            WebViewCore.resumePriority();
+            WebViewCore.resumePriority(0);
+            WebSettings webSettings = getSettings();
+            webSettings.setRenderPriority(WebSettings.RenderPriority.NORMAL);
             WebViewCore.resumeUpdatePicture(mWebViewCore);
             nativeSetIsScrolling(false);
         }
@@ -6825,7 +6842,9 @@ public class WebView extends AbsoluteLayout
 
         if ((mTouchMode == TOUCH_DRAG_MODE
                 || mTouchMode == TOUCH_DRAG_LAYER_MODE) && !mSelectingText) {
-            WebViewCore.resumePriority();
+            WebViewCore.resumePriority(0);
+            WebSettings webSettings = getSettings();
+            webSettings.setRenderPriority(WebSettings.RenderPriority.NORMAL);
             WebViewCore.resumeUpdatePicture(mWebViewCore);
             nativeSetIsScrolling(false);
         }
@@ -7236,7 +7255,9 @@ public class WebView extends AbsoluteLayout
             }
         }
         if ((maxX == 0 && vy == 0) || (maxY == 0 && vx == 0)) {
-            WebViewCore.resumePriority();
+            WebViewCore.resumePriority(0);
+            WebSettings webSettings = getSettings();
+            webSettings.setRenderPriority(WebSettings.RenderPriority.NORMAL);
             if (!mSelectingText) {
                 WebViewCore.resumeUpdatePicture(mWebViewCore);
             }
@@ -8283,7 +8304,9 @@ public class WebView extends AbsoluteLayout
                                         computeMaxScrollX(), 0,
                                         computeMaxScrollY());
                                 invalidate();
-                                WebViewCore.resumePriority();
+                                WebViewCore.resumePriority(0);
+                                WebSettings webSettings = getSettings();
+                                webSettings.setRenderPriority(WebSettings.RenderPriority.NORMAL);
                                 WebViewCore.resumeUpdatePicture(mWebViewCore);
                             }
                             mDeferTouchMode = TOUCH_DONE_MODE;
@@ -8776,6 +8799,10 @@ public class WebView extends AbsoluteLayout
                     nativeSelectAt(msg.arg1, msg.arg2);
                     break;
 
+                case RESUME_RENDER_PRIORITY:
+                    WebSettings webSettings = getSettings();
+                    webSettings.setRenderPriority(WebSettings.RenderPriority.NORMAL);
+
                 default:
                     super.handleMessage(msg);
                     break;
diff --git a/core/java/android/webkit/WebViewCore.java b/core/java/android/webkit/WebViewCore.java
index 2d15afb..1730227 100644
--- a/core/java/android/webkit/WebViewCore.java
+++ b/core/java/android/webkit/WebViewCore.java
@@ -1,5 +1,6 @@
 /*
  * Copyright (C) 2007 The Android Open Source Project
+ * Copyright (c) 2012, Code Aurora Forum. All rights reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -30,6 +31,7 @@ import android.os.Handler;
 import android.os.Looper;
 import android.os.Message;
 import android.os.Process;
+import android.os.SystemProperties;
 import android.provider.MediaStore;
 import android.util.Log;
 import android.util.SparseBooleanArray;
@@ -46,8 +48,11 @@ import java.util.ArrayList;
 import java.util.Collection;
 import java.util.Map;
 import java.util.Set;
+import java.util.Vector;
+import org.json.*;
 
 import junit.framework.Assert;
+import org.codeaurora.Performance;
 
 /**
  * @hide
@@ -72,6 +77,8 @@ public final class WebViewCore {
      * WebViewCore always executes in the same thread as the native webkit.
      */
 
+    private static int mResumeTimerDuration = 2000;
+
     // The WebView that corresponds to this WebViewCore.
     private WebView mWebView;
     // Proxy for handling callbacks from native code
@@ -205,6 +212,13 @@ public final class WebViewCore {
         sWebCoreHandler.sendMessage(init);
     }
 
+    private void sendPriorityMessageToWebView()
+    {
+        if (mWebView != null)
+            mWebView.mPrivateHandler.sendMessageAtFrontOfQueue(
+                mWebView.mPrivateHandler.obtainMessage(WebView.RESUME_RENDER_PRIORITY));
+    }
+
     /* Initialize private data within the WebCore thread.
      */
     private void initialize() {
@@ -559,6 +573,7 @@ public final class WebViewCore {
             int anchorY, boolean ignoreHeight);
 
     private native int nativeGetContentMinPrefWidth();
+    private native static int nativeGetTextureGeneratorThreadID();
 
     // Start: functions that deal with text editing
     private native void nativeReplaceTextfieldText(
@@ -671,6 +686,10 @@ public final class WebViewCore {
         private static final int INITIALIZE = 0;
         private static final int REDUCE_PRIORITY = 1;
         private static final int RESUME_PRIORITY = 2;
+        private static Performance mPerf = new Performance();
+        private static final int MIN_FREQ_DURING_SCROLLING = 10;
+        private WebViewCore core = null;
+        private int tid = 0;
 
         public void run() {
             Looper.prepare();
@@ -681,20 +700,62 @@ public final class WebViewCore {
                     public void handleMessage(Message msg) {
                         switch (msg.what) {
                             case INITIALIZE:
-                                WebViewCore core = (WebViewCore) msg.obj;
+                                core = (WebViewCore) msg.obj;
                                 core.initialize();
                                 break;
 
                             case REDUCE_PRIORITY:
-                                // 3 is an adjustable number.
+                                sWebCoreHandler.removeMessages(WebCoreThread.RESUME_PRIORITY);
+                                tid = nativeGetTextureGeneratorThreadID();
+                                if (tid > 0) {
+                                    try {
+                                        Process.setThreadPriority(tid,Process.THREAD_PRIORITY_FOREGROUND);
+                                    } catch (IllegalArgumentException ex){
+                                        Log.e(LOGTAG, "Thread does not exist");
+                                    }
+                                }
+                                    // 10 is an adjustable number.
                                 Process.setThreadPriority(
-                                        Process.THREAD_PRIORITY_DEFAULT + 3 *
+                                        Process.THREAD_PRIORITY_DEFAULT + 10 *
                                         Process.THREAD_PRIORITY_LESS_FAVORABLE);
+
+                                sWebCoreHandler.sendMessageDelayed(Message.obtain(null,
+                                    WebCoreThread.RESUME_PRIORITY), mResumeTimerDuration);
+
+                                if (SystemProperties.QCOM_HARDWARE ) {
+                                    /* Disable power collapse and setup the min frequency */
+                                    /* 0 means disabling power collapse */
+                                    mPerf.cpuSetOptions(Performance.CPUOPT_CPU0_PWRCLSP,0);
+                                    mPerf.cpuSetOptions(Performance.CPUOPT_CPU0_FREQMIN,MIN_FREQ_DURING_SCROLLING);
+                                }
+
                                 break;
 
                             case RESUME_PRIORITY:
+
+                                tid = nativeGetTextureGeneratorThreadID();
+                                if (tid > 0) {
+                                    try {
+                                        Process.setThreadPriority(tid,Process.THREAD_PRIORITY_DEFAULT);
+                                    } catch (IllegalArgumentException ex) {
+                                        Log.e(LOGTAG, "Thread does not exist");
+                                    }
+                                }
                                 Process.setThreadPriority(
                                         Process.THREAD_PRIORITY_DEFAULT);
+
+                                if (core != null)
+                                {
+                                    core.sendPriorityMessageToWebView();
+                                }
+
+                                if (SystemProperties.QCOM_HARDWARE ) {
+                                    /* Enable power collapse and reset the min frequency */
+                                    /* 1 means enabling power collapse */
+                                    mPerf.cpuSetOptions(Performance.CPUOPT_CPU0_PWRCLSP,1);
+                                    mPerf.cpuSetOptions(Performance.CPUOPT_CPU0_FREQMIN,0);
+                                }
+
                                 break;
 
                             case EventHub.ADD_PACKAGE_NAME:
@@ -2086,12 +2147,20 @@ public final class WebViewCore {
                 .obtainMessage(WebCoreThread.REDUCE_PRIORITY));
     }
 
-    static void resumePriority() {
+    static void resumePriority(int delay) {
         // remove the pending REDUCE_PRIORITY and RESUME_PRIORITY messages
         sWebCoreHandler.removeMessages(WebCoreThread.REDUCE_PRIORITY);
         sWebCoreHandler.removeMessages(WebCoreThread.RESUME_PRIORITY);
-        sWebCoreHandler.sendMessageAtFrontOfQueue(sWebCoreHandler
+        if (delay > 0)
+        {
+            sWebCoreHandler.sendMessageDelayed(sWebCoreHandler
+                .obtainMessage(WebCoreThread.RESUME_PRIORITY), delay);
+        }
+        else
+        {
+            sWebCoreHandler.sendMessageAtFrontOfQueue(sWebCoreHandler
                 .obtainMessage(WebCoreThread.RESUME_PRIORITY));
+        }
     }
 
     static void sendStaticMessage(int messageType, Object argument) {
diff --git a/core/java/android/webkit/ZoomManager.java b/core/java/android/webkit/ZoomManager.java
index 14bdc42..d4c0910 100644
--- a/core/java/android/webkit/ZoomManager.java
+++ b/core/java/android/webkit/ZoomManager.java
@@ -1,5 +1,6 @@
 /*
  * Copyright (C) 2010 The Android Open Source Project
+ * Copyright (c) 2011-2012, Code Aurora Forum. All rights reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -628,6 +629,8 @@ class ZoomManager {
         if (!isDoubleTapEnabled()) {
             return;
         }
+        WebViewCore.reducePriority();
+        settings.setRenderPriority(WebSettings.RenderPriority.HIGH);
 
         setZoomCenter(lastTouchX, lastTouchY);
         mAnchorX = mWebView.viewToContentX((int) lastTouchX + mWebView.getScrollX());
diff --git a/core/java/android/widget/AbsListView.java b/core/java/android/widget/AbsListView.java
index 38bb2e1..4167812 100644
--- a/core/java/android/widget/AbsListView.java
+++ b/core/java/android/widget/AbsListView.java
@@ -567,6 +567,7 @@ public abstract class AbsListView extends AdapterView<ListAdapter> implements Te
     private Runnable mClearScrollingCache;
     private int mMinimumVelocity;
     private int mMaximumVelocity;
+    private int mDecacheThreshold;
     private float mVelocityScale = 1.0f;
 
     final boolean[] mIsScrap = new boolean[1];
@@ -786,6 +787,7 @@ public abstract class AbsListView extends AdapterView<ListAdapter> implements Te
         mTouchSlop = configuration.getScaledTouchSlop();
         mMinimumVelocity = configuration.getScaledMinimumFlingVelocity();
         mMaximumVelocity = configuration.getScaledMaximumFlingVelocity();
+        mDecacheThreshold = mMaximumVelocity / 2;
         mOverscrollDistance = configuration.getScaledOverscrollDistance();
         mOverflingDistance = configuration.getScaledOverflingDistance();
 
@@ -3650,7 +3652,7 @@ public abstract class AbsListView extends AdapterView<ListAdapter> implements Te
                     // Keep the fling alive a little longer
                     postDelayed(this, FLYWHEEL_TIMEOUT);
                 } else {
-                    endFling();
+                    endFling(false); // Don't disable the scrolling cache right after it was enabled
                     mTouchMode = TOUCH_MODE_SCROLL;
                     reportScrollStateChange(OnScrollListener.SCROLL_STATE_TOUCH_SCROLL);
                 }
@@ -3664,6 +3666,11 @@ public abstract class AbsListView extends AdapterView<ListAdapter> implements Te
         }
 
         void start(int initialVelocity) {
+            if (Math.abs(initialVelocity) > mDecacheThreshold) {
+                // For long flings, scrolling cache causes stutter, so don't use it
+                clearScrollingCache();
+            }
+
             int initialY = initialVelocity < 0 ? Integer.MAX_VALUE : 0;
             mLastFlingY = initialY;
             mScroller.fling(0, initialY, 0, initialVelocity,
@@ -3733,13 +3740,18 @@ public abstract class AbsListView extends AdapterView<ListAdapter> implements Te
         }
 
         void endFling() {
+            endFling(true);
+        }
+
+        void endFling(boolean clearCache) {
             mTouchMode = TOUCH_MODE_REST;
 
             removeCallbacks(this);
             removeCallbacks(mCheckFlywheel);
 
             reportScrollStateChange(OnScrollListener.SCROLL_STATE_IDLE);
-            clearScrollingCache();
+            if (clearCache)
+                clearScrollingCache();
             mScroller.abortAnimation();
 
             if (mFlingStrictSpan != null) {
diff --git a/core/java/android/widget/SearchView.java b/core/java/android/widget/SearchView.java
index 9d2ff2e..3e7cb77 100644
--- a/core/java/android/widget/SearchView.java
+++ b/core/java/android/widget/SearchView.java
@@ -1432,6 +1432,9 @@ public class SearchView extends LinearLayout implements CollapsibleActionView {
         // because the voice search activity will always need to insert "QUERY" into
         // it anyway.
         Bundle queryExtras = new Bundle();
+        if(this.mAppSearchData != null) {
+            queryExtras.putParcelable(SearchManager.APP_DATA, this.mAppSearchData);
+        }
 
         // Now build the intent to launch the voice search.  Add all necessary
         // extras to launch the voice recognizer, and then all the necessary extras
diff --git a/core/java/android/widget/VideoView.java b/core/java/android/widget/VideoView.java
index 8e438ff..10496fe 100644
--- a/core/java/android/widget/VideoView.java
+++ b/core/java/android/widget/VideoView.java
@@ -574,6 +574,8 @@ public class VideoView extends SurfaceView implements MediaPlayerControl {
     }
 
     public void suspend() {
+        mSeekWhenPrepared = getCurrentPosition( );
+        Log.v(TAG, "suspend( ) - will resume at " + mSeekWhenPrepared);
         release(false);
     }
 
diff --git a/core/java/com/android/internal/app/IAssetRedirectionManager.aidl b/core/java/com/android/internal/app/IAssetRedirectionManager.aidl
new file mode 100644
index 0000000..8b47f0b
--- /dev/null
+++ b/core/java/com/android/internal/app/IAssetRedirectionManager.aidl
@@ -0,0 +1,42 @@
+/*
+ * Copyright (C) 2011, T-Mobile USA, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.internal.app;
+
+import android.content.res.PackageRedirectionMap;
+
+/**
+ * Interface used to interact with the AssetRedirectionManagerService.
+ */
+interface IAssetRedirectionManager {
+    /**
+     * Access the package redirection map for the supplied package name given a
+     * particular theme.
+     */
+    PackageRedirectionMap getPackageRedirectionMap(in String themePackageName,
+            String themeId, in String targetPackageName);
+
+    /**
+     * Clear all redirection maps for the given theme.
+     */
+    void clearRedirectionMapsByTheme(in String themePackageName,
+            in String themeId);
+
+    /**
+     * Clear all redirection maps for the given target package.
+     */
+    void clearPackageRedirectionMap(in String targetPackageName);
+}
diff --git a/core/java/com/android/internal/app/ShutdownThread.java b/core/java/com/android/internal/app/ShutdownThread.java
index 77d0c97..e063409 100644
--- a/core/java/com/android/internal/app/ShutdownThread.java
+++ b/core/java/com/android/internal/app/ShutdownThread.java
@@ -43,6 +43,12 @@ import android.os.storage.IMountShutdownObserver;
 import com.android.internal.telephony.ITelephony;
 import android.util.Log;
 import android.view.WindowManager;
+import android.view.KeyEvent;
+
+import java.io.FileInputStream;
+import java.io.FileOutputStream;
+import java.io.PrintWriter;
+import java.io.OutputStreamWriter;
 
 public final class ShutdownThread extends Thread {
     // constants
@@ -65,6 +71,10 @@ public final class ShutdownThread extends Thread {
 
     // Provides shutdown assurance in case the system_server is killed
     public static final String SHUTDOWN_ACTION_PROPERTY = "sys.shutdown.requested";
+    public static final String RADIO_SHUTDOWN_PROPERTY = "sys.radio.shutdown";
+
+    private static final String SYSFS_MSM_EFS_SYNC_COMPLETE = "/sys/devices/platform/rs300000a7.65536/sync_sts";
+    private static final String SYSFS_MDM_EFS_SYNC_COMPLETE = "/sys/devices/platform/rs300100a7.65536/sync_sts";
 
     // static instance of this thread
     private static final ShutdownThread sInstance = new ShutdownThread();
@@ -107,19 +117,61 @@ public final class ShutdownThread extends Thread {
         Log.d(TAG, "Notifying thread to start shutdown longPressBehavior=" + longPressBehavior);
 
         if (confirm) {
-            final CloseDialogReceiver closer = new CloseDialogReceiver(context);
-            final AlertDialog dialog = new AlertDialog.Builder(context)
-                    .setTitle(com.android.internal.R.string.power_off)
-                    .setMessage(resourceId)
-                    .setPositiveButton(com.android.internal.R.string.yes, new DialogInterface.OnClickListener() {
-                        public void onClick(DialogInterface dialog, int which) {
-                            beginShutdownSequence(context);
-                        }
-                    })
-                    .setNegativeButton(com.android.internal.R.string.no, null)
-                    .create();
-            closer.dialog = dialog;
-            dialog.setOnDismissListener(closer);
+            final AlertDialog dialog;
+            // Set different dialog message based on whether or not we're rebooting
+            if (mReboot) {
+                dialog = new AlertDialog.Builder(context)
+                        .setIconAttribute(android.R.attr.alertDialogIcon)
+                        .setTitle(com.android.internal.R.string.reboot_system)
+                        .setSingleChoiceItems(com.android.internal.R.array.shutdown_reboot_options, 0, new DialogInterface.OnClickListener() {
+                            public void onClick(DialogInterface dialog, int which) {
+                                if (which < 0)
+                                    return;
+
+                                String actions[] = context.getResources().getStringArray(com.android.internal.R.array.shutdown_reboot_actions);
+
+                                if (actions != null && which < actions.length)
+                                    mRebootReason = actions[which];
+                            }
+                        })
+                        .setPositiveButton(com.android.internal.R.string.yes, new DialogInterface.OnClickListener() {
+                            public void onClick(DialogInterface dialog, int which) {
+                                mReboot = true;
+                                beginShutdownSequence(context);
+                            }
+                        })
+                        .setNegativeButton(com.android.internal.R.string.no, new DialogInterface.OnClickListener() {
+                            public void onClick(DialogInterface dialog, int which) {
+                                mReboot = false;
+                                dialog.cancel();
+                            }
+                        })
+                        .create();
+                        dialog.setOnKeyListener(new DialogInterface.OnKeyListener() {
+                            public boolean onKey (DialogInterface dialog, int keyCode, KeyEvent event) {
+                                if (keyCode == KeyEvent.KEYCODE_BACK) {
+                                    mReboot = false;
+                                    dialog.cancel();
+                                }
+                                return true;
+                            }
+                        });
+                // Initialize to the first reason
+                String actions[] = context.getResources().getStringArray(com.android.internal.R.array.shutdown_reboot_actions);
+                mRebootReason = actions[0];
+            } else {
+                dialog = new AlertDialog.Builder(context)
+                        .setIconAttribute(android.R.attr.alertDialogIcon)
+                        .setTitle(com.android.internal.R.string.power_off)
+                        .setMessage(com.android.internal.R.string.shutdown_confirm)
+                        .setPositiveButton(com.android.internal.R.string.yes, new DialogInterface.OnClickListener() {
+                            public void onClick(DialogInterface dialog, int which) {
+                                beginShutdownSequence(context);
+                            }
+                        })
+                        .setNegativeButton(com.android.internal.R.string.no, null)
+                        .create();
+            }
             dialog.getWindow().setType(WindowManager.LayoutParams.TYPE_KEYGUARD_DIALOG);
             dialog.show();
         } else {
@@ -175,8 +227,13 @@ public final class ShutdownThread extends Thread {
         // throw up an indeterminate system dialog to indicate radio is
         // shutting down.
         ProgressDialog pd = new ProgressDialog(context);
-        pd.setTitle(context.getText(com.android.internal.R.string.power_off));
-        pd.setMessage(context.getText(com.android.internal.R.string.shutdown_progress));
+        if (mReboot) {
+            pd.setTitle(context.getText(com.android.internal.R.string.reboot_system));
+            pd.setMessage(context.getText(com.android.internal.R.string.reboot_progress));
+        } else {
+            pd.setTitle(context.getText(com.android.internal.R.string.power_off));
+            pd.setMessage(context.getText(com.android.internal.R.string.shutdown_progress));
+        }
         pd.setIndeterminate(true);
         pd.setCancelable(false);
         pd.getWindow().setType(WindowManager.LayoutParams.TYPE_KEYGUARD_DIALOG);
@@ -232,6 +289,7 @@ public final class ShutdownThread extends Thread {
     public void run() {
         boolean bluetoothOff;
         boolean radioOff;
+        boolean msmEfsSyncDone = false, mdmEfsSyncDone = false;
 
         BroadcastReceiver br = new BroadcastReceiver() {
             @Override public void onReceive(Context context, Intent intent) {
@@ -316,6 +374,48 @@ public final class ShutdownThread extends Thread {
             radioOff = true;
         }
 
+        SystemProperties.set(RADIO_SHUTDOWN_PROPERTY, "true");
+
+        if (SystemProperties.QCOM_HARDWARE) {
+            Log.i(TAG, "Waiting for radio file system sync to complete ...");
+
+            // Wait a max of 8 seconds
+            for (int i = 0; i < MAX_NUM_PHONE_STATE_READS; i++) {
+                if (!msmEfsSyncDone) {
+                    try {
+                        FileInputStream fis = new FileInputStream(SYSFS_MSM_EFS_SYNC_COMPLETE);
+                        int result = fis.read();
+                        fis.close();
+                        if (result == '1') {
+                            msmEfsSyncDone = true;
+                        }
+                    } catch (Exception ex) {
+                        Log.e(TAG, "Exception during msmEfsSyncDone", ex);
+                        msmEfsSyncDone = true;
+                    }
+                }
+                if (!mdmEfsSyncDone) {
+                    try {
+                        FileInputStream fis = new FileInputStream(SYSFS_MDM_EFS_SYNC_COMPLETE);
+                        int result = fis.read();
+                        fis.close();
+                        if (result == '1') {
+                            mdmEfsSyncDone = true;
+                        }
+                    } catch (Exception ex) {
+                        Log.e(TAG, "Exception during mdmEfsSyncDone", ex);
+                        mdmEfsSyncDone = true;
+                    }
+                }
+                if (msmEfsSyncDone && mdmEfsSyncDone) {
+                    Log.i(TAG, "Radio file system sync complete.");
+                    break;
+                }
+                Log.i(TAG, "Radio file system sync incomplete - retry.");
+                SystemClock.sleep(PHONE_STATE_POLL_SLEEP_MSEC);
+            }
+        }
+
         Log.i(TAG, "Waiting for Bluetooth and Radio...");
         
         // Wait a max of 32 seconds for clean shutdown
diff --git a/core/java/com/android/internal/app/ThemeUtils.java b/core/java/com/android/internal/app/ThemeUtils.java
new file mode 100644
index 0000000..4265fd5
--- /dev/null
+++ b/core/java/com/android/internal/app/ThemeUtils.java
@@ -0,0 +1,56 @@
+/*
+ * Copyright (C) 2012 The CyanogenMod Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.internal.app;
+
+import android.content.Context;
+import android.content.BroadcastReceiver;
+import android.content.IntentFilter;
+import android.content.pm.PackageManager;
+import android.util.Log;
+
+/**
+ * @hide
+ */
+
+public class ThemeUtils {
+    private static final String TAG = "ThemeUtils";
+    private static final String DATA_TYPE_TMOBILE_STYLE = "vnd.tmobile.cursor.item/style";
+    private static final String DATA_TYPE_TMOBILE_THEME = "vnd.tmobile.cursor.item/theme";
+    private static final String ACTION_TMOBILE_THEME_CHANGED = "com.tmobile.intent.action.THEME_CHANGED";
+
+    public static Context createUiContext(final Context context) {
+        try {
+            return context.createPackageContext("com.android.systemui", Context.CONTEXT_RESTRICTED);
+        } catch (PackageManager.NameNotFoundException e) {
+        }
+
+        return null;
+    }
+
+    public static void registerThemeChangeReceiver(final Context context, final BroadcastReceiver receiver) {
+        IntentFilter filter = new IntentFilter(ACTION_TMOBILE_THEME_CHANGED);
+        try {
+            filter.addDataType(DATA_TYPE_TMOBILE_THEME);
+            filter.addDataType(DATA_TYPE_TMOBILE_STYLE);
+        } catch (IntentFilter.MalformedMimeTypeException e) {
+            Log.e(TAG, "Could not add MIME types to filter", e);
+        }
+
+        context.registerReceiver(receiver, filter);
+    }
+}
+
diff --git a/core/java/com/android/internal/os/DeviceKeyHandler.java b/core/java/com/android/internal/os/DeviceKeyHandler.java
new file mode 100644
index 0000000..f4bdf2c
--- /dev/null
+++ b/core/java/com/android/internal/os/DeviceKeyHandler.java
@@ -0,0 +1,21 @@
+/*
+ * Copyright (C) 2012 The CyanogenMod Project Licensed under the Apache License,
+ * Version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at
+ * http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law
+ * or agreed to in writing, software distributed under the License is
+ * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied. See the License for the specific language
+ * governing permissions and limitations under the License.
+ */
+
+package com.android.internal.os;
+
+import android.view.KeyEvent;
+
+public interface DeviceKeyHandler {
+    public static final int KEYEVENT_CAUGHT = -1;
+    public static final int KEYEVENT_UNCAUGHT = 0;
+
+    public int handleKeyEvent(KeyEvent event);
+}
diff --git a/core/java/com/android/internal/os/ProcessStats.java b/core/java/com/android/internal/os/ProcessStats.java
index e0e9a29..8ca07a3 100644
--- a/core/java/com/android/internal/os/ProcessStats.java
+++ b/core/java/com/android/internal/os/ProcessStats.java
@@ -154,7 +154,7 @@ public class ProcessStats {
 
     private boolean mFirst = true;
 
-    private byte[] mBuffer = new byte[256];
+    private byte[] mBuffer = new byte[512];
 
     /**
      * The time in microseconds that the CPU has been running at each speed.
@@ -699,7 +699,9 @@ public class ProcessStats {
 
         long sampleTime = mCurrentSampleTime - mLastSampleTime;
         long sampleRealTime = mCurrentSampleRealTime - mLastSampleRealTime;
-        long percAwake = (sampleTime*100) / sampleRealTime;
+        long percAwake = ((sampleRealTime > 0)
+            ? (sampleTime*100) / sampleRealTime
+            : 100);
         if (percAwake != 100) {
             pw.print(" with ");
             pw.print(percAwake);
diff --git a/core/java/com/android/internal/os/ZygoteInit.java b/core/java/com/android/internal/os/ZygoteInit.java
index 9c45dc6..7e80095 100644
--- a/core/java/com/android/internal/os/ZygoteInit.java
+++ b/core/java/com/android/internal/os/ZygoteInit.java
@@ -66,7 +66,10 @@ public class ZygoteInit {
     private static final int LOG_BOOT_PROGRESS_PRELOAD_END = 3030;
 
     /** when preloading, GC after allocating this many bytes */
-    private static final int PRELOAD_GC_THRESHOLD = 50000;
+    private static final String heapgrowthlimit =
+                    SystemProperties.get("dalvik.vm.heapgrowthlimit", "16m");
+    private static final int PRELOAD_GC_THRESHOLD = Integer.parseInt(
+                    heapgrowthlimit.substring(0, heapgrowthlimit.length()-1))*1024*1024/2;
 
     public static final String USAGE_STRING =
             " <\"start-system-server\"|\"\" for startSystemServer>";
@@ -97,7 +100,7 @@ public class ZygoteInit {
     private static final String PRELOADED_CLASSES = "preloaded-classes";
 
     /** Controls whether we should preload resources during zygote init. */
-    private static final boolean PRELOAD_RESOURCES = true;
+    private static final boolean PRELOAD_RESOURCES = false;
 
     /**
      * Invokes a static "main(argv[]) method on class "className".
@@ -357,6 +360,8 @@ public class ZygoteInit {
                 N = preloadColorStateLists(runtime, ar);
                 Log.i(TAG, "...preloaded " + N + " resources in "
                         + (SystemClock.uptimeMillis()-startTime) + "ms.");
+            } else {
+                Log.i(TAG, "Preload resources disabled, skipped.");
             }
             mResources.finishPreloading();
         } catch (RuntimeException e) {
diff --git a/core/java/com/android/internal/util/weather/HttpRetriever.java b/core/java/com/android/internal/util/weather/HttpRetriever.java
new file mode 100644
index 0000000..a3417a0
--- /dev/null
+++ b/core/java/com/android/internal/util/weather/HttpRetriever.java
@@ -0,0 +1,152 @@
+/******************************************************************************
+ * Class       : HttpConnectHelper.java                                                           *
+ * Main Weather activity, in this demo apps i use API from yahoo, you can     *
+ * use other weather web service which you prefer                             *
+ *                                                                            *
+ * Version     : v1.0                                                         *
+ * Date        : May 09, 2011                                                 *
+ * Copyright (c)-2011 DatNQ some right reserved                               *
+ * You can distribute, modify or what ever you want but WITHOUT ANY WARRANTY  *
+ * Be honest by keep credit of this file                                      *
+ *                                                                            *
+ * If you have any concern, feel free to contact with me via email, i will    *
+ * check email in free time                                                   * 
+ * Email: nguyendatnq@gmail.com                                               *
+ * ---------------------------------------------------------------------------*
+ * Modification Logs:                                                         *
+ *   KEYCHANGE  DATE          AUTHOR   DESCRIPTION                            *
+ * ---------------------------------------------------------------------------*
+ *    -------   May 09, 2011  DatNQ    Create new                             *
+ ******************************************************************************/
+
+/**
+ * Modification into Android-internal HttpRetreiver.java
+ * Copyright (C) 2012 The AOKP Project
+ */
+
+
+package com.android.internal.util.weather;
+
+import org.apache.http.HttpEntity;
+import org.apache.http.HttpResponse;
+import org.apache.http.client.methods.HttpGet;
+import org.apache.http.impl.client.DefaultHttpClient;
+import org.apache.http.util.EntityUtils;
+
+import java.io.BufferedReader;
+import java.io.ByteArrayInputStream;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.InputStreamReader;
+import java.net.HttpURLConnection;
+import java.net.URL;
+
+import javax.xml.parsers.DocumentBuilder;
+import javax.xml.parsers.DocumentBuilderFactory;
+
+import org.w3c.dom.Document;
+
+import android.util.Log;
+
+public class HttpRetriever {
+
+    private final String TAG = getClass().getSimpleName();
+    private DefaultHttpClient client = new DefaultHttpClient();
+    private HttpURLConnection httpConnection;
+
+    public String retrieve(String url) {
+        HttpGet get = new HttpGet(url);
+        try {
+            HttpResponse getResponse = client.execute(get);
+            HttpEntity getResponseEntity = getResponse.getEntity();
+            if (getResponseEntity != null) {
+                String response = EntityUtils.toString(getResponseEntity);
+                return response;
+            }
+        } catch (IOException e) {
+            e.printStackTrace();
+        }
+        return null;
+    }
+
+    private void requestConnectServer(String strURL) throws IOException {
+        httpConnection = (HttpURLConnection) new URL(strURL).openConnection();
+        httpConnection.connect();
+
+        if (httpConnection.getResponseCode() != HttpURLConnection.HTTP_OK) {
+            Log.e(TAG, "Something wrong with connection");
+            httpConnection.disconnect();
+            throw new IOException("Error in connection: " + httpConnection.getResponseCode());
+        }
+    }
+
+    private void requestDisconnect() {
+        if (httpConnection != null) {
+            httpConnection.disconnect();
+        }
+    }
+
+    public Document getDocumentFromURL(String strURL) throws IOException {
+        if (strURL == null) {
+            Log.e(TAG, "Invalid input URL");
+            return null;
+        }
+
+        // Connect to server, get data and close
+        requestConnectServer(strURL);
+        String strDocContent = getDataFromConnection();
+        requestDisconnect();
+
+        if (strDocContent == null) {
+            Log.e(TAG, "Cannot get XML content");
+            return null;
+        }
+
+        int strContentSize = strDocContent.length();
+        StringBuffer strBuff = new StringBuffer();
+        strBuff.setLength(strContentSize + 1);
+        strBuff.append(strDocContent);
+        ByteArrayInputStream is = new ByteArrayInputStream(strDocContent.getBytes());
+
+        DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();
+        DocumentBuilder db;
+        Document docData = null;
+
+        try {
+            db = dbf.newDocumentBuilder();
+            docData = db.parse(is);
+        } catch (Exception e) {
+            Log.e(TAG, "Parser data error");
+            return null;
+        }
+        return docData;
+    }
+
+    private String getDataFromConnection() throws IOException {
+        if (httpConnection == null) {
+            Log.e(TAG, "Connection is null");
+            return null;
+        }
+
+        String strValue = null;
+        InputStream inputStream = httpConnection.getInputStream();
+        if (inputStream == null) {
+            Log.e(TAG, "Input stream error");
+            return null;
+        }
+
+        StringBuffer strBuf = new StringBuffer();
+        BufferedReader buffReader = new BufferedReader(new InputStreamReader(inputStream));
+        String strLine = "";
+
+        while ((strLine = buffReader.readLine()) != null) {
+            strBuf.append(strLine + "\n");
+            strValue += strLine + "\n";
+        }
+
+        // Release resource to system
+        buffReader.close();
+        inputStream.close();
+        return strBuf.toString();
+    }
+}
diff --git a/core/java/com/android/internal/util/weather/WeatherInfo.java b/core/java/com/android/internal/util/weather/WeatherInfo.java
new file mode 100644
index 0000000..2b65785
--- /dev/null
+++ b/core/java/com/android/internal/util/weather/WeatherInfo.java
@@ -0,0 +1,115 @@
+/*
+ * Copyright (C) 2012 The AOKP Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.internal.util.weather;
+
+import android.content.Context;
+import com.android.internal.R;
+
+public class WeatherInfo {
+
+    public static final String NODATA = "-";
+
+    public String city, forecast_date, condition, condition_code, temp, temp_unit,
+        humidity, wind, wind_dir, speed_unit, low, high;
+    public long last_sync;
+
+    public WeatherInfo() {
+        this.city = NODATA;
+        this.forecast_date = NODATA;
+        this.condition = NODATA;
+        this.condition_code = NODATA;
+        this.temp = NODATA;
+        this.temp_unit = NODATA;
+        this.humidity = NODATA;
+        this.wind = NODATA;
+        this.wind_dir = NODATA;
+        this.speed_unit = NODATA;
+        this.low = NODATA;
+        this.high = NODATA;
+        this.last_sync = 0;
+    }
+
+    public WeatherInfo(Context context, String city, String fdate, String condition, String condition_code,
+            String temp, String temp_unit, String humidity,
+            String wind, String wind_dir, String speed_unit,
+            String low, String high, long last_sync) {
+        this.city = city;
+        this.forecast_date = fdate;
+        this.condition = condition;
+        this.condition_code = condition_code;
+        this.humidity = humidity + "%";
+        this.wind = calcDirection(context, wind_dir) + " " + trimSpeed(wind) + speed_unit;
+        this.speed_unit = speed_unit;
+        this.last_sync = last_sync;
+        // Only the current temperature gets the temp_unit added.
+        this.temp_unit = temp_unit;
+        this.temp = temp + "°" + temp_unit;
+        this.low = low + "°";
+        this.high = high + "°";
+    }
+
+    /**
+     * find the optimal weather string (helper function for translation)
+     *
+     * @param conditionCode condition code from Yahoo (this is the main
+     *            identifier which will be used to find a matching translation
+     *            in the project's resources
+     * @param providedString
+     * @return either the defaultString (which should be Yahoo's weather
+     *         condition text), or the translated version from resources
+     */
+    public static String getTranslatedConditionString(Context context, int conditionCode,
+            String providedString) {
+        int resID = context.getResources().getIdentifier("weather_" + conditionCode, "string",
+                context.getPackageName());
+        return (resID != 0) ? context.getResources().getString(resID) : providedString;
+    }
+
+    private String calcDirection(Context context, String degrees) {
+        try {
+            int deg = Integer.parseInt(degrees);
+            if (deg >= 338 || deg <= 22)
+                return context.getResources().getString(R.string.weather_N);
+            else if (deg < 68)
+                return context.getResources().getString(R.string.weather_NE);
+            else if (deg < 113)
+                return context.getResources().getString(R.string.weather_E);
+            else if (deg < 158)
+                return context.getResources().getString(R.string.weather_SE);
+            else if (deg < 203)
+                return context.getResources().getString(R.string.weather_S);
+            else if (deg < 248)
+                return context.getResources().getString(R.string.weather_SW);
+            else if (deg < 293)
+                return context.getResources().getString(R.string.weather_W);
+            else if (deg < 338)
+                return context.getResources().getString(R.string.weather_NW);
+            else
+                return "";
+        } catch (NumberFormatException e) {
+            return "";
+        }
+    }
+
+    private String trimSpeed(String speed) {
+        try {
+            return String.valueOf(Math.round(Float.parseFloat(speed)));
+        } catch (NumberFormatException e) {
+            return "";
+        }
+    }
+}
diff --git a/core/java/com/android/internal/util/weather/WeatherXmlParser.java b/core/java/com/android/internal/util/weather/WeatherXmlParser.java
new file mode 100644
index 0000000..a2986fc
--- /dev/null
+++ b/core/java/com/android/internal/util/weather/WeatherXmlParser.java
@@ -0,0 +1,177 @@
+/******************************************************************************
+ * Class       : YahooWeatherHelper.java                                                                  *
+ * Parser helper for Yahoo                                                    *
+ *                                                                            *
+ * Version     : v1.0                                                         *
+ * Date        : May 06, 2011                                                 *
+ * Copyright (c)-2011 DatNQ some right reserved                               *
+ * You can distribute, modify or what ever you want but WITHOUT ANY WARRANTY  *
+ * Be honest by keep credit of this file                                      *
+ *                                                                            *
+ * If you have any concern, feel free to contact with me via email, i will    *
+ * check email in free time                                                   * 
+ * Email: nguyendatnq@gmail.com                                               *
+ * ---------------------------------------------------------------------------*
+ * Modification Logs:                                                         *
+ *   KEYCHANGE  DATE          AUTHOR   DESCRIPTION                            *
+ * ---------------------------------------------------------------------------*
+ *    -------   May 06, 2011  DatNQ    Create new                             *
+ ******************************************************************************/
+/*
+ * Modification into Android-internal WeatherXmlParser.java
+ * Copyright (C) 2012 The AOKP Project
+ */
+
+package com.android.internal.util.weather;
+
+import java.io.StringReader;
+
+import javax.xml.parsers.DocumentBuilder;
+import javax.xml.parsers.DocumentBuilderFactory;
+
+import org.w3c.dom.Document;
+import org.w3c.dom.Element;
+import org.w3c.dom.NamedNodeMap;
+import org.w3c.dom.Node;
+import org.w3c.dom.NodeList;
+import org.xml.sax.InputSource;
+
+import android.content.Context;
+import android.util.Log;
+
+public class WeatherXmlParser {
+
+    protected static final String TAG = "WeatherXmlParser";
+
+    /** Yahoo attributes */
+    private static final String PARAM_YAHOO_LOCATION = "yweather:location";
+    private static final String PARAM_YAHOO_UNIT = "yweather:units";
+    private static final String PARAM_YAHOO_ATMOSPHERE = "yweather:atmosphere";
+    private static final String PARAM_YAHOO_CONDITION = "yweather:condition";
+    private static final String PARAM_YAHOO_WIND = "yweather:wind";
+    private static final String PARAM_YAHOO_FORECAST = "yweather:forecast";
+
+    private static final String ATT_YAHOO_CITY = "city";
+    private static final String ATT_YAHOO_TEMP = "temp";
+    private static final String ATT_YAHOO_CODE = "code";
+    private static final String ATT_YAHOO_TEMP_UNIT = "temperature";
+    private static final String ATT_YAHOO_HUMIDITY = "humidity";
+    private static final String ATT_YAHOO_TEXT = "text";
+    private static final String ATT_YAHOO_DATE = "date";
+    private static final String ATT_YAHOO_SPEED = "speed";
+    private static final String ATT_YAHOO_DIRECTION = "direction";
+    private static final String ATT_YAHOO_TODAY_HIGH = "high";
+    private static final String ATT_YAHOO_TODAY_LOW = "low";
+
+    private Context mContext;
+
+    public WeatherXmlParser(Context context) {
+        mContext = context;
+    }
+
+    public WeatherInfo parseWeatherResponse(Document docWeather) {
+        if (docWeather == null) {
+            Log.e(TAG, "Invalid doc weather");
+            return null;
+        }
+
+        String strCity = null;
+        String strDate = null;
+        String strCondition = null;
+        String strCondition_code = null;
+        String strTemp = null;
+        String strTempUnit = null;
+        String strHumidity = null;
+        String strWindSpeed = null;
+        String strWindDir = null;
+        String strSpeedUnit = null;
+        String strHigh = null;
+        String strLow = null;
+
+        try {
+            Element root = docWeather.getDocumentElement();
+            root.normalize();
+
+            NamedNodeMap locationNode = root.getElementsByTagName(PARAM_YAHOO_LOCATION).item(0)
+                    .getAttributes();
+            if (locationNode != null) {
+                strCity = locationNode.getNamedItem(ATT_YAHOO_CITY).getNodeValue();
+            }
+
+            NamedNodeMap unitNode = root.getElementsByTagName(PARAM_YAHOO_UNIT).item(0)
+                    .getAttributes();
+
+            if (locationNode != null) {
+                strTempUnit = unitNode.getNamedItem(ATT_YAHOO_TEMP_UNIT).getNodeValue();
+                strSpeedUnit = unitNode.getNamedItem(ATT_YAHOO_SPEED).getNodeValue();
+            }
+
+            NamedNodeMap atmosNode = root.getElementsByTagName(PARAM_YAHOO_ATMOSPHERE).item(0)
+                    .getAttributes();
+            if (atmosNode != null) {
+                strHumidity = atmosNode.getNamedItem(ATT_YAHOO_HUMIDITY).getNodeValue();
+            }
+
+            NamedNodeMap conditionNode = root.getElementsByTagName(PARAM_YAHOO_CONDITION).item(0)
+                    .getAttributes();
+            if (conditionNode != null) {
+                strCondition = conditionNode.getNamedItem(ATT_YAHOO_TEXT).getNodeValue();
+                strCondition_code = conditionNode.getNamedItem(ATT_YAHOO_CODE).getNodeValue();
+                strCondition = WeatherInfo.getTranslatedConditionString(mContext, Integer.parseInt(strCondition_code), strCondition);
+                strTemp = conditionNode.getNamedItem(ATT_YAHOO_TEMP).getNodeValue();
+                strDate = conditionNode.getNamedItem(ATT_YAHOO_DATE).getNodeValue();
+            }
+
+            NamedNodeMap temNode = root.getElementsByTagName(PARAM_YAHOO_WIND).item(0)
+                    .getAttributes();
+            if (temNode != null) {
+                strWindSpeed = temNode.getNamedItem(ATT_YAHOO_SPEED).getNodeValue();
+                strWindDir = temNode.getNamedItem(ATT_YAHOO_DIRECTION).getNodeValue();
+            }
+
+            NamedNodeMap fcNode = root.getElementsByTagName(PARAM_YAHOO_FORECAST).item(0).getAttributes();
+            if (fcNode != null) {
+                strHigh = fcNode.getNamedItem(ATT_YAHOO_TODAY_HIGH).getNodeValue();
+                strLow = fcNode.getNamedItem(ATT_YAHOO_TODAY_LOW).getNodeValue();
+            }
+        } catch (Exception e) {
+            Log.e(TAG, "Something wrong with parser data: " + e.toString());
+            return null;
+        }
+
+        /* Weather info */
+        WeatherInfo yahooWeatherInfo = new WeatherInfo(mContext, strCity, strDate, strCondition, strCondition_code, strTemp,
+                strTempUnit, strHumidity, strWindSpeed, strWindDir, strSpeedUnit, strLow, strHigh, System.currentTimeMillis());
+
+        Log.d(TAG, "Weather updated for " + strCity + ": " + strDate + ", " + strCondition + "(" + strCondition_code
+                + "), " + strTemp + strTempUnit + ", " + strHumidity + "% humidity, "  + ", wind: " + strWindDir + " at "
+                + strWindSpeed + strSpeedUnit + ", low: " + strLow  + strTempUnit + " high: " + strHigh + strTempUnit);
+
+        return yahooWeatherInfo;
+    }
+
+    public String parsePlaceFinderResponse(String response) {
+        try {
+
+            DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();
+            DocumentBuilder db = dbf.newDocumentBuilder();
+            Document doc = db.parse(new InputSource(new StringReader(response)));
+
+            NodeList resultNodes = doc.getElementsByTagName("Result");
+
+            Node resultNode = resultNodes.item(0);
+            NodeList attrsList = resultNode.getChildNodes();
+
+            for (int i = 0; i < attrsList.getLength(); i++) {
+                Node node = attrsList.item(i);
+                Node firstChild = node.getFirstChild();
+                if ("woeid".equalsIgnoreCase(node.getNodeName()) && firstChild != null) {
+                    return firstChild.getNodeValue();
+                }
+            }
+        } catch (Exception e) {
+            Log.e(TAG, e.toString());
+        }
+        return null;
+    }
+}
diff --git a/core/java/com/android/internal/util/weather/YahooPlaceFinder.java b/core/java/com/android/internal/util/weather/YahooPlaceFinder.java
new file mode 100644
index 0000000..fb8efe4
--- /dev/null
+++ b/core/java/com/android/internal/util/weather/YahooPlaceFinder.java
@@ -0,0 +1,41 @@
+/*
+ * Copyright (C) 2012 The AOKP Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.internal.util.weather;
+
+import android.content.Context;
+
+public class YahooPlaceFinder {
+
+    private static final String YAHOO_API_BASE_REV_URL = "http://where.yahooapis.com/geocode?appid=jYkTZp64&q=%1$s,+%2$s&gflags=R";
+    private static final String YAHOO_API_BASE_URL = "http://where.yahooapis.com/geocode?appid=jYkTZp64&q=%1$s";
+
+    public static String reverseGeoCode(Context c, double latitude, double longitude) {
+
+        String url = String.format(YAHOO_API_BASE_REV_URL, String.valueOf(latitude),
+                String.valueOf(longitude));
+        String response = new HttpRetriever().retrieve(url);
+        return new WeatherXmlParser(c).parsePlaceFinderResponse(response);
+
+    }
+
+    public static String GeoCode(Context c, String location) {
+        String url = String.format(YAHOO_API_BASE_URL, location).replace(' ', '+');
+        String response = new HttpRetriever().retrieve(url);
+        return new WeatherXmlParser(c).parsePlaceFinderResponse(response);
+    }
+
+}
diff --git a/core/java/com/android/internal/view/menu/ActionMenuPresenter.java b/core/java/com/android/internal/view/menu/ActionMenuPresenter.java
index 530809b..97911dd 100644
--- a/core/java/com/android/internal/view/menu/ActionMenuPresenter.java
+++ b/core/java/com/android/internal/view/menu/ActionMenuPresenter.java
@@ -277,7 +277,7 @@ public class ActionMenuPresenter extends BaseMenuPresenter
      */
     public boolean showOverflowMenu() {
         if (mReserveOverflow && !isOverflowMenuShowing() && mMenu != null && mMenuView != null &&
-                mPostedOpenRunnable == null) {
+                mPostedOpenRunnable == null && !mMenu.getNonActionItems().isEmpty()) {
             OverflowPopup popup = new OverflowPopup(mContext, mMenu, mOverflowButton, true);
             mPostedOpenRunnable = new OpenOverflowRunnable(popup);
             // Post this for later; we might still need a layout for the anchor to be right.
diff --git a/core/java/com/android/internal/widget/LockPatternUtils.java b/core/java/com/android/internal/widget/LockPatternUtils.java
index 905a171..14e965e 100644
--- a/core/java/com/android/internal/widget/LockPatternUtils.java
+++ b/core/java/com/android/internal/widget/LockPatternUtils.java
@@ -1,5 +1,6 @@
 /*
  * Copyright (C) 2007 The Android Open Source Project
+ * Copyright (C) 2012 The CyanogenMod Project (Calendar)
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -25,16 +26,21 @@ import android.content.ContentResolver;
 import android.content.Context;
 import android.content.Intent;
 import android.content.pm.PackageManager;
+import android.database.Cursor;
+import android.net.Uri;
 import android.os.FileObserver;
 import android.os.IBinder;
 import android.os.RemoteException;
 import android.os.ServiceManager;
 import android.os.SystemClock;
 import android.os.storage.IMountService;
+import android.provider.CalendarContract;
 import android.provider.Settings;
 import android.security.KeyStore;
 import android.telephony.TelephonyManager;
 import android.text.TextUtils;
+import android.text.format.DateFormat;
+import android.text.format.Time;
 import android.util.Log;
 import android.view.View;
 import android.widget.Button;
@@ -46,8 +52,11 @@ import java.io.RandomAccessFile;
 import java.security.MessageDigest;
 import java.security.NoSuchAlgorithmException;
 import java.security.SecureRandom;
+import java.text.SimpleDateFormat;
 import java.util.Arrays;
+import java.util.Date;
 import java.util.List;
+import java.util.TimeZone;
 import java.util.concurrent.atomic.AtomicBoolean;
 
 /**
@@ -991,6 +1000,166 @@ public class LockPatternUtils {
         return nextAlarm;
     }
 
+    /**
+     * @return A formatted string of the next calendar event with a reminder
+     * (for showing on the lock screen), or null if there is no next event
+     * within a certain look-ahead time.
+     */
+    public String[] getNextCalendarAlarm(long lookahead, String[] calendars,
+            boolean remindersOnly) {
+        long now = System.currentTimeMillis();
+        long later = now + lookahead;
+
+        StringBuilder where = new StringBuilder();
+        if (remindersOnly) {
+            where.append(CalendarContract.Events.HAS_ALARM + "=1");
+        }
+        if (calendars != null && calendars.length > 0) {
+            if (remindersOnly) {
+                where.append(" AND ");
+            }
+            where.append(CalendarContract.Events.CALENDAR_ID + " in (");
+            for (int i = 0; i < calendars.length; i++) {
+                where.append(calendars[i]);
+                if (i != calendars.length - 1) {
+                    where.append(",");
+                }
+            }
+            where.append(") ");
+        }
+
+        // Projection array
+        String[] projection = new String[] {
+            CalendarContract.Events.TITLE,
+            CalendarContract.Instances.BEGIN,
+            CalendarContract.Events.DESCRIPTION,
+            CalendarContract.Events.EVENT_LOCATION,
+            CalendarContract.Events.ALL_DAY
+        };
+
+        // The indices for the projection array
+        int TITLE_INDEX = 0;
+        int BEGIN_TIME_INDEX = 1;
+        int DESCRIPTION_INDEX = 2;
+        int LOCATION_INDEX = 3;
+        int ALL_DAY_INDEX = 4;
+
+        Uri uri = Uri.withAppendedPath(CalendarContract.Instances.CONTENT_URI,
+                String.format("%d/%d", now, later));
+        String[] nextCalendarAlarm = new String[2];
+        Cursor cursor = null;
+
+        try {
+            cursor = mContentResolver.query(uri, projection,
+                    where.toString(), null, "begin ASC");
+
+            if (cursor != null && cursor.moveToFirst()) {
+
+                String title = cursor.getString(TITLE_INDEX);
+                long begin = cursor.getLong(BEGIN_TIME_INDEX);
+                String description = cursor.getString(DESCRIPTION_INDEX);
+                String location = cursor.getString(LOCATION_INDEX);
+                boolean allDay = cursor.getInt(ALL_DAY_INDEX) != 0;
+
+                // Check the next event in the case of all day event. As UTC is used for all day
+                // events, the next event may be the one that actually starts sooner
+                if (allDay && !cursor.isLast()) {
+                    cursor.moveToNext();
+                    long nextBegin = cursor.getLong(BEGIN_TIME_INDEX);
+                    if (nextBegin < begin + TimeZone.getDefault().getOffset(begin)) {
+                        title = cursor.getString(TITLE_INDEX);
+                        begin = nextBegin;
+                        description = cursor.getString(DESCRIPTION_INDEX);
+                        location = cursor.getString(LOCATION_INDEX);
+                        allDay = cursor.getInt(ALL_DAY_INDEX) != 0;
+                    }
+                }
+
+                // Set the event title as the first array item
+                nextCalendarAlarm[0] = title.toString();
+
+                // Start building the event details string
+                // Starting with the date
+                Date start = new Date(begin);
+                StringBuilder sb = new StringBuilder();
+
+                if (allDay) {
+                    SimpleDateFormat sdf = new SimpleDateFormat(
+                            mContext.getString(R.string.abbrev_wday_month_day_no_year));
+                    // Calendar stores all-day events in UTC -- setting the time zone ensures
+                    // the correct date is shown.
+                    sdf.setTimeZone(TimeZone.getTimeZone(Time.TIMEZONE_UTC));
+                    sb.append(sdf.format(start));
+                } else {
+                    sb.append(DateFormat.format("E", start));
+                    sb.append(" ");
+                    sb.append(DateFormat.getTimeFormat(mContext).format(start));
+                }
+
+                // Add the event location if it should be shown
+                int showLocation = Settings.System.getInt(mContext.getContentResolver(),
+                            Settings.System.LOCKSCREEN_CALENDAR_SHOW_LOCATION, 0);
+                if (showLocation != 0 && !TextUtils.isEmpty(location)) {
+                    switch(showLocation) {
+                        case 1:
+                            // Show first line
+                            int end = location.indexOf('\n');
+                            if(end == -1) {
+                                sb.append(": " + location);
+                            } else {
+                                sb.append(": " + location.substring(0, end));
+                            }
+                            break;
+                        case 2:
+                            // Show all
+                            sb.append(": " + location);
+                            break;
+                    }
+                }
+
+                // Add the event description if it should be shown
+                int showDescription = Settings.System.getInt(mContext.getContentResolver(),
+                            Settings.System.LOCKSCREEN_CALENDAR_SHOW_DESCRIPTION, 0);
+                if (showDescription != 0 && !TextUtils.isEmpty(description)) {
+
+                    // Show the appropriate separator
+                    if (showLocation == 0) {
+                        sb.append(": ");
+                    } else {
+                        sb.append(" - ");
+                    }
+
+                    switch(showDescription) {
+                        case 1:
+                            // Show first line
+                            int end = description.indexOf('\n');
+                            if(end == -1) {
+                                sb.append(description);
+                            } else {
+                                sb.append(description.substring(0, end));
+                            }
+                            break;
+                        case 2:
+                            // Show all
+                            sb.append(description);
+                            break;
+                    }
+                }
+
+                // Set the time, location and description as the second array item
+                nextCalendarAlarm[1] = sb.toString();
+            }
+        } catch (Exception e) {
+            // Do nothing
+        } finally {
+            if (cursor != null) {
+                cursor.close();
+            }
+        }
+
+        return nextCalendarAlarm;
+    }
+
     private boolean getBoolean(String secureSettingKey, boolean defaultValue) {
         return 1 ==
                 android.provider.Settings.Secure.getInt(mContentResolver, secureSettingKey,
@@ -1103,4 +1272,13 @@ public class LockPatternUtils {
         return getBoolean(LOCKSCREEN_POWER_BUTTON_INSTANTLY_LOCKS, true);
     }
 
+    /**
+     * @hide
+     * Set the lock-before-unlock option (show widgets before the secure
+     * unlock screen). See config_enableLockBeforeUnlockScreen
+     */
+    public void setLockBeforeUnlock(boolean enabled) {
+        setBoolean(Settings.Secure.LOCK_BEFORE_UNLOCK, enabled);
+    }
+
 }
diff --git a/core/java/com/android/internal/widget/LockPatternView.java b/core/java/com/android/internal/widget/LockPatternView.java
index 0d9cf9a..5f756db 100644
--- a/core/java/com/android/internal/widget/LockPatternView.java
+++ b/core/java/com/android/internal/widget/LockPatternView.java
@@ -64,6 +64,7 @@ public class LockPatternView extends View {
 
     private Paint mPaint = new Paint();
     private Paint mPathPaint = new Paint();
+    private Paint mMsgPaint = new Paint();
 
     // TODO: make this common with PhoneWindow
     static final int STATUS_BAR_HEIGHT = 25;
@@ -115,6 +116,8 @@ public class LockPatternView extends View {
     private Bitmap mBitmapCircleGreen;
     private Bitmap mBitmapCircleRed;
 
+    private String mIncorrectPatternMsg;
+
     private Bitmap mBitmapArrowGreenUp;
     private Bitmap mBitmapArrowRedUp;
 
@@ -267,6 +270,12 @@ public class LockPatternView extends View {
         mPathPaint.setStrokeJoin(Paint.Join.ROUND);
         mPathPaint.setStrokeCap(Paint.Cap.ROUND);
 
+        mMsgPaint.setAntiAlias(true);
+        mMsgPaint.setDither(true);
+        mMsgPaint.setColor(Color.RED);   // TODO this should be from the style
+        mMsgPaint.setTextAlign(Paint.Align.CENTER);
+
+
         // lot's of bitmaps!
         mBitmapBtnDefault = getBitmapFor(R.drawable.btn_code_lock_default_holo);
         mBitmapBtnTouched = getBitmapFor(R.drawable.btn_code_lock_touched_holo);
@@ -286,6 +295,8 @@ public class LockPatternView extends View {
             mBitmapHeight = Math.max(mBitmapHeight, bitmap.getHeight());
         }
 
+        // incorrect pattern message
+        mIncorrectPatternMsg = context.getResources().getString(R.string.lockscreen_pattern_wrong);
     }
 
     private Bitmap getBitmapFor(int resId) {
@@ -452,6 +463,9 @@ public class LockPatternView extends View {
 
         final int height = h - mPaddingTop - mPaddingBottom;
         mSquareHeight = height / 3.0f;
+
+        // Try to set a message size relative to square size
+        mMsgPaint.setTextSize(mSquareHeight / 6);
     }
 
     private int resolveMeasured(int measureSpec, int desired)
@@ -930,11 +944,17 @@ public class LockPatternView extends View {
             }
         }
 
+        // If lock pattern is in stealth mode and the pattern was wrong
+        // show a text advising of the pattern failure
+        float msgLeftX = paddingLeft + squareWidth + (squareWidth / 2);
+        float msgTopY = paddingTop + (squareHeight * 2);
+        drawMsg(canvas, (int) msgLeftX, (int) msgTopY);
+
         // TODO: the path should be created and cached every time we hit-detect a cell
         // only the last segment of the path should be computed here
         // draw the path of the pattern (unless the user is in progress, and
         // we are in stealth mode)
-        final boolean drawPath = (!mInStealthMode || mPatternDisplayMode == DisplayMode.Wrong);
+        final boolean drawPath = !mInStealthMode;
 
         // draw the arrows associated with the path (unless the user is in progress, and
         // we are in stealth mode)
@@ -1038,7 +1058,7 @@ public class LockPatternView extends View {
         Bitmap outerCircle;
         Bitmap innerCircle;
 
-        if (!partOfPattern || (mInStealthMode && mPatternDisplayMode != DisplayMode.Wrong)) {
+        if (!partOfPattern || (mInStealthMode)) {
             // unselected circle
             outerCircle = mBitmapCircleDefault;
             innerCircle = mBitmapBtnDefault;
@@ -1081,6 +1101,17 @@ public class LockPatternView extends View {
         canvas.drawBitmap(innerCircle, mCircleMatrix, mPaint);
     }
 
+    /**
+     * @param canvas
+     * @param leftX
+     * @param topY
+     */
+    private void drawMsg(Canvas canvas, int leftX, int topY) {
+        if (mInStealthMode && mPatternDisplayMode == DisplayMode.Wrong) {
+            canvas.drawText(mIncorrectPatternMsg, leftX, topY, mMsgPaint);
+        }
+    }
+
     @Override
     protected Parcelable onSaveInstanceState() {
         Parcelable superState = super.onSaveInstanceState();
diff --git a/core/java/com/android/internal/widget/multiwaveview/MultiWaveView.java b/core/java/com/android/internal/widget/multiwaveview/MultiWaveView.java
index ebd355a..12000b0 100644
--- a/core/java/com/android/internal/widget/multiwaveview/MultiWaveView.java
+++ b/core/java/com/android/internal/widget/multiwaveview/MultiWaveView.java
@@ -81,6 +81,46 @@ public class MultiWaveView extends View {
     private static final float TAP_RADIUS_SCALE_ACCESSIBILITY_ENABLED = 1.3f;
     private TimeInterpolator mChevronAnimationInterpolator = Ease.Quad.easeOut;
 
+    /**
+     * @hide
+     */
+    public final static String ICON_RESOURCE = "icon_resource";
+
+    /**
+     * @hide
+     */
+    public final static String ICON_PACKAGE = "icon_package";
+
+    /**
+     * @hide
+     */
+    public final static String ICON_FILE = "icon_file";
+
+    /**
+     * Number of customizable lockscreen targets for tablets
+     * @hide
+     */
+    public final static int MAX_TABLET_TARGETS = 7;
+
+    /**
+     * Number of customizable lockscreen targets for phones
+     * @hide
+     */
+    public final static int MAX_PHONE_TARGETS = 4;
+
+    /**
+     * Empty target used to reference unused lockscreen targets
+     * @hide
+     */
+    public final static String EMPTY_TARGET = "empty";
+
+    /**
+     * Default stock configuration for lockscreen targets
+     * @hide
+     */
+    public final static String DEFAULT_TARGETS = "empty|empty|empty|#Intent;action=android.intent.action.MAIN;" +
+            "category=android.intent.category.LAUNCHER;component=com.android.camera/.Camera;S.icon_resource=ic_lockscreen_camera_normal;end";
+
     private ArrayList<TargetDrawable> mTargetDrawables = new ArrayList<TargetDrawable>();
     private ArrayList<TargetDrawable> mChevronDrawables = new ArrayList<TargetDrawable>();
     private ArrayList<Tweener> mChevronAnimations = new ArrayList<Tweener>();
@@ -107,6 +147,7 @@ public class MultiWaveView extends View {
     private float mSnapMargin = 0.0f;
     private boolean mDragging;
     private int mNewTargetResources;
+    private ArrayList<TargetDrawable> mNewTargetDrawables;
 
     private AnimatorListener mResetListener = new AnimatorListenerAdapter() {
         public void onAnimationEnd(Animator animator) {
@@ -135,6 +176,10 @@ public class MultiWaveView extends View {
                 internalSetTargetResources(mNewTargetResources);
                 mNewTargetResources = 0;
                 hideTargets(false);
+            } else if (mNewTargetDrawables != null) {
+                internalSetTargetResources(mNewTargetDrawables);
+                mNewTargetDrawables = null;
+                hideTargets(false);
             }
             mAnimatingTargets = false;
         }
@@ -542,6 +587,21 @@ public class MultiWaveView extends View {
         }
     }
 
+    public void setTargetResources(ArrayList<TargetDrawable> drawList) {
+        if (mAnimatingTargets) {
+            // postpone this change until we return to the initial state
+            mNewTargetDrawables = drawList;
+        } else {
+            internalSetTargetResources(drawList);
+        }
+    }
+
+    private void internalSetTargetResources(ArrayList<TargetDrawable> drawList) {
+        mTargetResourceId = 0;
+        mTargetDrawables = drawList;
+        updateTargetPositions();
+    }
+
     public int getTargetResourceId() {
         return mTargetResourceId;
     }
@@ -927,7 +987,7 @@ public class MultiWaveView extends View {
     }
 
     private String getTargetDescription(int index) {
-        if (mTargetDescriptions == null || mTargetDescriptions.isEmpty()) {
+        if (mTargetDescriptions == null || mTargetDescriptions.isEmpty() || index >= mTargetDescriptions.size()) {
             mTargetDescriptions = loadDescriptions(mTargetDescriptionsResourceId);
             if (mTargetDrawables.size() != mTargetDescriptions.size()) {
                 Log.w(TAG, "The number of target drawables must be"
@@ -939,7 +999,7 @@ public class MultiWaveView extends View {
     }
 
     private String getDirectionDescription(int index) {
-        if (mDirectionDescriptions == null || mDirectionDescriptions.isEmpty()) {
+        if (mDirectionDescriptions == null || mDirectionDescriptions.isEmpty() || index >= mDirectionDescriptions.size()) {
             mDirectionDescriptions = loadDescriptions(mDirectionDescriptionsResourceId);
             if (mTargetDrawables.size() != mDirectionDescriptions.size()) {
                 Log.w(TAG, "The number of target drawables must be"
diff --git a/core/java/com/android/internal/widget/multiwaveview/TargetDrawable.java b/core/java/com/android/internal/widget/multiwaveview/TargetDrawable.java
index aa9fa45..03f078f 100644
--- a/core/java/com/android/internal/widget/multiwaveview/TargetDrawable.java
+++ b/core/java/com/android/internal/widget/multiwaveview/TargetDrawable.java
@@ -28,9 +28,9 @@ public class TargetDrawable {
     private static final boolean DEBUG = false;
 
     public static final int[] STATE_ACTIVE =
-            { android.R.attr.state_enabled, android.R.attr.state_active };
+            { android.R.attr.state_enabled, android.R.attr.state_active, -android.R.attr.state_focused };
     public static final int[] STATE_INACTIVE =
-            { android.R.attr.state_enabled, -android.R.attr.state_active };
+            { android.R.attr.state_enabled, -android.R.attr.state_active, -android.R.attr.state_focused };
     public static final int[] STATE_FOCUSED =
             { android.R.attr.state_enabled, android.R.attr.state_focused };
 
diff --git a/core/java/org/codeaurora/Performance.java b/core/java/org/codeaurora/Performance.java
new file mode 100644
index 0000000..bbdbb80
--- /dev/null
+++ b/core/java/org/codeaurora/Performance.java
@@ -0,0 +1,63 @@
+/*
+ * Copyright (c) 2011-2012, Code Aurora Forum. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *    * Redistributions of source code must retain the above copyright
+ *      notice, this list of conditions and the following disclaimer.
+ *    * Redistributions in binary form must reproduce the above copyright
+ *      notice, this list of conditions and the following disclaimer in the
+ *      documentation and/or other materials provided with the distribution.
+ *    * Neither the name of Code Aurora nor
+ *      the names of its contributors may be used to endorse or promote
+ *      products derived from this software without specific prior written
+ *      permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NON-INFRINGEMENT ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+ * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
+ * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
+ * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+package org.codeaurora;
+
+import android.util.Log;
+
+public class Performance
+{
+    private static final String TAG = "Perf";
+
+    /** &hide */
+    public Performance() {
+        //Log.d(TAG, "Perf module initialized");
+    }
+
+    /** &hide */
+    protected void finalize() {
+        native_deinit();
+    }
+
+    /** &hide */
+    public void cpuBoost(int ntasks) {
+        native_cpu_boost(ntasks);
+    }
+
+    /** @hide */ public static final int CPUOPT_CPU0_PWRCLSP = 1;
+    /** @hide */ public static final int CPUOPT_CPU0_FREQMIN = 2;
+
+    /** &hide */
+    public int cpuSetOptions(int reqType, int reqValue) {
+        return native_cpu_setoptions(reqType, reqValue);
+    }
+
+    private native void native_cpu_boost(int ntasks);
+    private native int  native_cpu_setoptions(int reqtype, int reqvalue);
+    private native void native_deinit();
+}
diff --git a/core/jni/Android.mk b/core/jni/Android.mk
old mode 100644
new mode 100755
index 71c5d26..3853973
--- a/core/jni/Android.mk
+++ b/core/jni/Android.mk
@@ -86,6 +86,7 @@ LOCAL_SRC_FILES:= \
 	android_util_Process.cpp \
 	android_util_StringBlock.cpp \
 	android_util_XmlBlock.cpp \
+	android_util_PackageRedirectionMap.cpp \
 	android/graphics/AutoDecodeCancel.cpp \
 	android/graphics/Bitmap.cpp \
 	android/graphics/BitmapFactory.cpp \
@@ -155,7 +156,11 @@ LOCAL_SRC_FILES:= \
 	android_app_backup_FullBackup.cpp \
 	android_content_res_ObbScanner.cpp \
 	android_content_res_Configuration.cpp \
-    android_animation_PropertyValuesHolder.cpp
+        android_animation_PropertyValuesHolder.cpp
+
+ifeq ($(BOARD_USES_QCOM_HARDWARE),true)
+	LOCAL_SRC_FILES += org_codeaurora_Performance.cpp
+endif
 
 LOCAL_C_INCLUDES += \
 	$(JNI_H_INCLUDE) \
@@ -222,6 +227,13 @@ ifeq ($(USE_OPENGL_RENDERER),true)
 	LOCAL_SHARED_LIBRARIES += libhwui
 endif
 
+ifeq ($(BOARD_USES_QCOM_HARDWARE),true)
+ifeq ($(USE_OPENGL_RENDERER),true)
+LOCAL_SHARED_LIBRARIES += libtilerenderer
+endif
+LOCAL_C_INCLUDES += hardware/qcom/display/libtilerenderer
+endif
+
 ifeq ($(BOARD_HAVE_BLUETOOTH),true)
 LOCAL_C_INCLUDES += \
 	external/dbus \
@@ -244,6 +256,10 @@ endif
 
 LOCAL_MODULE:= libandroid_runtime
 
+ifneq ($(BOARD_MOBILEDATA_INTERFACE_NAME),)
+	LOCAL_CFLAGS += -DMOBILE_IFACE_NAME='$(BOARD_MOBILEDATA_INTERFACE_NAME)'
+endif
+
 include $(BUILD_SHARED_LIBRARY)
 
 include $(call all-makefiles-under,$(LOCAL_PATH))
diff --git a/core/jni/AndroidRuntime.cpp b/core/jni/AndroidRuntime.cpp
index c00e6c9..5fa3172 100644
--- a/core/jni/AndroidRuntime.cpp
+++ b/core/jni/AndroidRuntime.cpp
@@ -177,6 +177,10 @@ extern int register_android_content_res_ObbScanner(JNIEnv* env);
 extern int register_android_content_res_Configuration(JNIEnv* env);
 extern int register_android_animation_PropertyValuesHolder(JNIEnv *env);
 extern int register_com_android_internal_content_NativeLibraryHelper(JNIEnv *env);
+extern int register_android_content_res_PackageRedirectionMap(JNIEnv* env);
+#ifdef QCOM_HARDWARE
+extern int register_org_codeaurora_Performance(JNIEnv *env);
+#endif
 
 static AndroidRuntime* gCurRuntime = NULL;
 
@@ -1203,6 +1207,11 @@ static const RegJNIRec gRegJNI[] = {
 
     REG_JNI(register_android_animation_PropertyValuesHolder),
     REG_JNI(register_com_android_internal_content_NativeLibraryHelper),
+
+    REG_JNI(register_android_content_res_PackageRedirectionMap),
+#ifdef QCOM_HARDWARE
+    REG_JNI(register_org_codeaurora_Performance),
+#endif
 };
 
 /*
diff --git a/core/jni/android_bluetooth_HeadsetBase.cpp b/core/jni/android_bluetooth_HeadsetBase.cpp
index 5b21c56..bb49ebd 100644
--- a/core/jni/android_bluetooth_HeadsetBase.cpp
+++ b/core/jni/android_bluetooth_HeadsetBase.cpp
@@ -96,6 +96,22 @@ static int send_line(int fd, const char* line) {
     return 0;
 }
 
+static int send_chars(int fd, const char* line) {
+    int nw;
+    int len = strlen(line);
+    int llen = len + 1;
+    char *buffer = (char *)calloc(llen, sizeof(char));
+
+    snprintf(buffer, llen, "%s", line);
+
+    if (write_error_check(fd, buffer, llen - 1)) {
+        free(buffer);
+        return -1;
+    }
+    free(buffer);
+    return 0;
+}
+
 static void mask_eighth_bit(char *line)
 {
    for (;;line++) {
@@ -165,18 +181,97 @@ again:
 
     *bufit = NULL;
 
-    // According to ITU V.250 section 5.1, IA5 7 bit chars are used, 
+    // According to ITU V.250 section 5.1, IA5 7 bit chars are used,
     //   the eighth bit or higher bits are ignored if they exists
     // We mask out only eighth bit, no higher bit, since we do char
     // string here, not wide char.
     // We added this processing due to 2 real world problems.
     // 1 BMW 2005 E46 which sends binary junk
-    // 2 Audi 2010 A3, dial command use 0xAD (soft-hyphen) as number 
+    // 2 Audi 2010 A3, dial command use 0xAD (soft-hyphen) as number
     //   formater, which was rejected by the AT handler
     mask_eighth_bit(buf);
 
     return buf;
 }
+
+// specialized version of get_line that terminates on ESC(abort) or Ctrl-Z
+
+static const char* get_PDUline(int fd, char *buf, int len, int timeout_ms,
+                            int *err) {
+    char *bufit=buf;
+    int fd_flags = fcntl(fd, F_GETFL, 0);
+    struct pollfd pfd;
+
+again:
+    *bufit = 0;
+    pfd.fd = fd;
+    pfd.events = POLLIN;
+    *err = errno = 0;
+    int ret = poll(&pfd, 1, timeout_ms);
+    if (ret < 0) {
+        LOGE("poll() error\n");
+        *err = errno;
+        return NULL;
+    }
+    if (ret == 0) {
+        return NULL;
+    }
+
+    if (pfd.revents & (POLLHUP | POLLERR | POLLNVAL)) {
+        LOGW("RFCOMM poll() returned  success (%d), "
+             "but with an unexpected revents bitmask: %#x\n", ret, pfd.revents);
+        errno = EIO;
+        *err = errno;
+        return NULL;
+    }
+
+    while ((int)(bufit - buf) < (len - 1))
+    {
+        errno = 0;
+        int rc = read(fd, bufit, 1);
+
+        if (!rc)
+            break;
+
+        if (rc < 0) {
+            if (errno == EBUSY) {
+                LOGI("read() error %s (%d): repeating read()...",
+                     strerror(errno), errno);
+                goto again;
+            }
+            *err = errno;
+            LOGE("read() error %s (%d)", strerror(errno), errno);
+            return NULL;
+        }
+
+        if (*bufit == '\x1b') { // ESC  - cause a string containing only ESC to be returned
+            *buf = '\x1b';
+            bufit = buf+1;
+            break;
+        }
+
+        if (*bufit=='\x1a') { // ctrl-z
+            break;
+        }
+
+        bufit++;
+    }
+
+    *bufit = NULL;
+
+    // According to ITU V.250 section 5.1, IA5 7 bit chars are used,
+    //   the eighth bit or higher bits are ignored if they exists
+    // We mask out only eighth bit, no higher bit, since we do char
+    // string here, not wide char.
+    // We added this processing due to 2 real world problems.
+    // 1 BMW 2005 E46 which sends binary junk
+    // 2 Audi 2010 A3, dial command use 0xAD (soft-hyphen) as number
+    //   formater, which was rejected by the AT handler
+    mask_eighth_bit(buf);
+
+    return buf;
+}
+
 #endif
 
 static void classInitNative(JNIEnv* env, jclass clazz) {
@@ -513,6 +608,21 @@ static jboolean sendURCNative(JNIEnv *env, jobject obj, jstring urc) {
     return JNI_FALSE;
 }
 
+static jboolean sendURCNativeChars(JNIEnv *env, jobject obj, jstring urc) {
+#ifdef HAVE_BLUETOOTH
+    native_data_t *nat = get_native_data(env, obj);
+    if (nat->rfcomm_connected) {
+        const char *c_urc = env->GetStringUTFChars(urc, NULL);
+        jboolean ret = send_chars(nat->rfcomm_sock, c_urc) == 0 ? JNI_TRUE : JNI_FALSE;
+        if (ret == JNI_TRUE) pretty_log_urc(c_urc);
+        env->ReleaseStringUTFChars(urc, c_urc);
+        return ret;
+    }
+#endif
+    return JNI_FALSE;
+}
+
+
 static jstring readNative(JNIEnv *env, jobject obj, jint timeout_ms) {
 #ifdef HAVE_BLUETOOTH
     {
@@ -532,6 +642,25 @@ static jstring readNative(JNIEnv *env, jobject obj, jint timeout_ms) {
 #endif
 }
 
+static jstring readNativePDUStream(JNIEnv *env, jobject obj, jint timeout_ms) {
+#ifdef HAVE_BLUETOOTH
+    {
+        native_data_t *nat = get_native_data(env, obj);
+        if (nat->rfcomm_connected) {
+            char buf[256];
+            const char *ret = get_PDUline(nat->rfcomm_sock,
+                                       buf, sizeof(buf),
+                                       timeout_ms,
+                                       &nat->last_read_err);
+            return ret ? env->NewStringUTF(ret) : NULL;
+        }
+        return NULL;
+    }
+#else
+    return NULL;
+#endif
+}
+
 static jint getLastReadStatusNative(JNIEnv *env, jobject obj) {
 #ifdef HAVE_BLUETOOTH
     {
@@ -555,7 +684,9 @@ static JNINativeMethod sMethods[] = {
     {"waitForAsyncConnectNative", "(I)I", (void *)waitForAsyncConnectNative},
     {"disconnectNative", "()V", (void *)disconnectNative},
     {"sendURCNative", "(Ljava/lang/String;)Z", (void *)sendURCNative},
+    {"sendURCNativeChars", "(Ljava/lang/String;)Z", (void *)sendURCNativeChars},
     {"readNative", "(I)Ljava/lang/String;", (void *)readNative},
+    {"readNativePDUStream", "(I)Ljava/lang/String;", (void *)readNativePDUStream},
     {"getLastReadStatusNative", "()I", (void *)getLastReadStatusNative},
 };
 
diff --git a/core/jni/android_database_SQLiteDatabase.cpp b/core/jni/android_database_SQLiteDatabase.cpp
index e0c900e..fea7763 100644
--- a/core/jni/android_database_SQLiteDatabase.cpp
+++ b/core/jni/android_database_SQLiteDatabase.cpp
@@ -35,6 +35,7 @@
 #include <ctype.h>
 
 #include <stdio.h>
+#include <libgen.h>
 #include <sys/types.h>
 #include <sys/socket.h>
 #include <netinet/in.h>
@@ -98,6 +99,35 @@ static void registerLoggingFunc(const char *path) {
     loggingFuncSet = true;
 }
 
+static int use_wal_mode (char const *path8)
+{
+    char *temp = basename(path8);
+    int i;
+    const char *wal_dbs[] = {
+         "database_test.db","contacts2.db","calendar.db",\
+         "telephony.db","launcher.db","user_dict.db",\
+         "downloads.db", "mmssms.db", "internal.db", \
+         "EmailProvider.db","alarms.db","EmailProviderBody.db",\
+         "btopp.db","picasa.db",\
+         "webviewCache.db","browser.db", NULL};
+
+    const char *wal_dbs_nosync[] = {
+         "webview.db", "quadrant.db", \
+         "MyDatabase.db", NULL};
+
+    for (i = 0 ; wal_dbs[i]!= NULL ; i++) {
+        if(strcmp(temp, wal_dbs[i]) == 0)
+            return 1;
+    }
+
+    for (i = 0 ; wal_dbs_nosync[i]!= NULL ; i++) {
+        if(strcmp(temp, wal_dbs_nosync[i]) == 0)
+            return 2;
+    }
+
+    return 0;
+}
+
 /* public native void dbopen(String path, int flags, String locale); */
 static void dbopen(JNIEnv* env, jobject object, jstring pathString, jint flags)
 {
@@ -106,6 +136,8 @@ static void dbopen(JNIEnv* env, jobject object, jstring pathString, jint flags)
     sqlite3_stmt * statement = NULL;
     char const * path8 = env->GetStringUTFChars(pathString, NULL);
     int sqliteFlags;
+    // Error code handling for SQLite exec
+    char* zErrMsg = NULL;
 
     // register the logging func on sqlite. needs to be done BEFORE any sqlite3 func is called.
     registerLoggingFunc(path8);
@@ -126,6 +158,41 @@ static void dbopen(JNIEnv* env, jobject object, jstring pathString, jint flags)
         goto done;
     }
 
+    // WAL is a new rollback method available in SQLite v3.7+. WAL speeds up writes to
+    // SQLite databases. WAL cannot be used with Read Only databases or databases opened
+    // in read only mode.
+
+    // Check if DB can use WAL mode; Open in WAL mode for non-ReadOnly DBs
+    if(!(flags & OPEN_READONLY) && (use_wal_mode(path8))) {
+        // Configure databases to run in WAL mode.
+        err = sqlite3_exec(handle,"PRAGMA journal_mode = WAL;",
+                           NULL, NULL,&zErrMsg);
+        if (SQLITE_OK != err) {
+           LOGE("sqlite3_exec - Failed to set WAL mode for [%s] \n", path8);
+           err = sqlite3_exec(handle,"PRAGMA journal_mode = DELETE;",
+                           NULL, NULL,&zErrMsg);
+           if(SQLITE_OK != err) {
+               LOGE("sqlite3_exec - Failed to set DELETE mode for [%s] \n", path8);
+               throw_sqlite3_exception(env, handle);
+               goto done;
+           }
+        }
+        else {
+            // Set autocheckpoint = 100 pages
+            err = sqlite3_wal_autocheckpoint(handle,
+                                             100);
+            if (SQLITE_OK != err) {
+               LOGE("sqlite3_exec to set WAL autocheckpoint failed\n");
+               throw_sqlite3_exception(env, handle);
+               goto done;
+            } else if (use_wal_mode(path8) == 2) {
+                /* Try to disable fsyncs. We don't care if it fails */
+                sqlite3_exec(handle,"PRAGMA synchronous = OFF;",
+                           NULL, NULL,&zErrMsg);
+            }
+        }
+    }
+
     // The soft heap limit prevents the page cache allocations from growing
     // beyond the given limit, no matter what the max page cache sizes are
     // set to. The limit does not, as of 3.5.0, affect any other allocations.
diff --git a/core/jni/android_hardware_Camera.cpp b/core/jni/android_hardware_Camera.cpp
index fe60381..c8dd098 100644
--- a/core/jni/android_hardware_Camera.cpp
+++ b/core/jni/android_hardware_Camera.cpp
@@ -601,6 +601,42 @@ static void android_hardware_Camera_setHasPreviewCallback(JNIEnv *env, jobject t
     context->setCallbackMode(env, installed, manualBuffer);
 }
 
+ static void android_hardware_Camera_sendHistogramData(JNIEnv *env, jobject thiz)
+ {
+#ifdef QCOM_HARDWARE
+   LOGV("setHistogramMode: mode:" );
+   JNICameraContext* context;
+   status_t rc;
+   sp<Camera> camera = get_native_camera(env, thiz, &context);
+   if (camera == 0) return;
+
+   rc = camera->sendCommand(CAMERA_CMD_HISTOGRAM_SEND_DATA, 0, 0);
+
+   if (rc != NO_ERROR) {
+      jniThrowException(env, "java/lang/RuntimeException", "set histogram mode failed");
+     }
+#endif
+ }
+ static void android_hardware_Camera_setHistogramMode(JNIEnv *env, jobject thiz, jboolean mode)
+ {
+#ifdef QCOM_HARDWARE
+   LOGV("sendHistogramData: mode:%d", (int)mode);
+   JNICameraContext* context;
+   status_t rc;
+   sp<Camera> camera = get_native_camera(env, thiz, &context);
+   if (camera == 0) return;
+
+   if(mode == true)
+      rc = camera->sendCommand(CAMERA_CMD_HISTOGRAM_ON, 0, 0);
+   else
+      rc = camera->sendCommand(CAMERA_CMD_HISTOGRAM_OFF, 0, 0);
+
+   if (rc != NO_ERROR) {
+      jniThrowException(env, "java/lang/RuntimeException", "set histogram mode failed");
+     }
+#endif
+ }
+
 static void android_hardware_Camera_addCallbackBuffer(JNIEnv *env, jobject thiz, jbyteArray bytes, int msgType) {
     LOGV("addCallbackBuffer: 0x%x", msgType);
 
@@ -840,6 +876,12 @@ static JNINativeMethod camMethods[] = {
   { "native_takePicture",
     "(I)V",
     (void *)android_hardware_Camera_takePicture },
+  { "native_setHistogramMode",
+    "(Z)V",
+    (void *)android_hardware_Camera_setHistogramMode },
+  { "native_sendHistogramData",
+    "()V",
+    (void *)android_hardware_Camera_sendHistogramData },
   { "native_setParameters",
     "(Ljava/lang/String;)V",
     (void *)android_hardware_Camera_setParameters },
diff --git a/core/jni/android_net_TrafficStats.cpp b/core/jni/android_net_TrafficStats.cpp
index 7a61432..1e3cf6d 100644
--- a/core/jni/android_net_TrafficStats.cpp
+++ b/core/jni/android_net_TrafficStats.cpp
@@ -64,6 +64,9 @@ static jlong readNumber(char const* filename) {
 }
 
 static const char* mobile_iface_list[] = {
+#ifdef MOBILE_IFACE_NAME
+    MOBILE_IFACE_NAME,
+#endif
     "rmnet0",
     "rmnet1",
     "rmnet2",
diff --git a/core/jni/android_net_wifi_Wifi.cpp b/core/jni/android_net_wifi_Wifi.cpp
index 84c636b..62e574b 100644
--- a/core/jni/android_net_wifi_Wifi.cpp
+++ b/core/jni/android_net_wifi_Wifi.cpp
@@ -119,6 +119,21 @@ static jboolean android_net_wifi_unloadDriver(JNIEnv* env, jobject)
     return (jboolean)(::wifi_unload_driver() == 0);
 }
 
+static jboolean android_net_wifi_isHotspotDriverLoaded(JNIEnv* env, jobject)
+{
+    return (jboolean)(::is_wifi_hotspot_driver_loaded() == 1);
+}
+
+static jboolean android_net_wifi_loadHotspotDriver(JNIEnv* env, jobject)
+{
+    return (jboolean)(::wifi_load_hotspot_driver() == 0);
+}
+
+static jboolean android_net_wifi_unloadHotspotDriver(JNIEnv* env, jobject)
+{
+    return (jboolean)(::wifi_unload_hotspot_driver() == 0);
+}
+
 static jboolean android_net_wifi_startSupplicant(JNIEnv* env, jobject)
 {
     return (jboolean)(::wifi_start_supplicant() == 0);
@@ -561,6 +576,9 @@ static JNINativeMethod gWifiMethods[] = {
     { "loadDriver", "()Z",  (void *)android_net_wifi_loadDriver },
     { "isDriverLoaded", "()Z",  (void *)android_net_wifi_isDriverLoaded},
     { "unloadDriver", "()Z",  (void *)android_net_wifi_unloadDriver },
+    { "loadHotspotDriver", "()Z",  (void *)android_net_wifi_loadHotspotDriver },
+    { "isHotspotDriverLoaded", "()Z",  (void *)android_net_wifi_isHotspotDriverLoaded},
+    { "unloadHotspotDriver", "()Z",  (void *)android_net_wifi_unloadHotspotDriver },
     { "startSupplicant", "()Z",  (void *)android_net_wifi_startSupplicant },
     { "startP2pSupplicant", "()Z",  (void *)android_net_wifi_startP2pSupplicant },
     { "stopSupplicant", "()Z", (void*) android_net_wifi_stopSupplicant },
diff --git a/core/jni/android_os_Power.cpp b/core/jni/android_os_Power.cpp
index dc16990..9aaf673 100644
--- a/core/jni/android_os_Power.cpp
+++ b/core/jni/android_os_Power.cpp
@@ -1,6 +1,7 @@
 /* //device/libs/android_runtime/android_os_Power.cpp
 **
 ** Copyright 2006, The Android Open Source Project
+** Copyright (c) 2010-2011, Code Aurora Forum. All rights reserved.
 **
 ** Licensed under the Apache License, Version 2.0 (the "License");
 ** you may not use this file except in compliance with the License.
@@ -85,6 +86,14 @@ static void android_os_Power_reboot(JNIEnv *env, jobject clazz, jstring reason)
     jniThrowIOException(env, errno);
 }
 
+#ifdef QCOM_HARDWARE
+static int
+SetUnstableMemoryState(JNIEnv *env, jobject clazz, jboolean on)
+{
+    return set_unstable_memory_state(on);
+}
+#endif
+
 static JNINativeMethod method_table[] = {
     { "acquireWakeLock", "(ILjava/lang/String;)V", (void*)acquireWakeLock },
     { "releaseWakeLock", "(Ljava/lang/String;)V", (void*)releaseWakeLock },
@@ -92,6 +101,9 @@ static JNINativeMethod method_table[] = {
     { "setScreenState", "(Z)I", (void*)setScreenState },
     { "shutdown", "()V", (void*)android_os_Power_shutdown },
     { "rebootNative", "(Ljava/lang/String;)V", (void*)android_os_Power_reboot },
+#ifdef QCOM_HARDWARE
+    { "SetUnstableMemoryState",  "(Z)I", (void*)SetUnstableMemoryState},
+#endif
 };
 
 int register_android_os_Power(JNIEnv *env)
diff --git a/core/jni/android_server_BluetoothA2dpService.cpp b/core/jni/android_server_BluetoothA2dpService.cpp
index 1851ad6..51d25c0 100644
--- a/core/jni/android_server_BluetoothA2dpService.cpp
+++ b/core/jni/android_server_BluetoothA2dpService.cpp
@@ -39,6 +39,13 @@ namespace android {
 #ifdef HAVE_BLUETOOTH
 static jmethodID method_onSinkPropertyChanged;
 static jmethodID method_onConnectSinkResult;
+static jmethodID method_onGetPlayStatusRequest;
+static jfieldID field_mTrackName;
+static jfieldID field_mArtistName;
+static jfieldID field_mAlbumName;
+static jfieldID field_mMediaNumber;
+static jfieldID field_mMediaCount;
+static jfieldID field_mDuration;
 
 typedef struct {
     JavaVM *vm;
@@ -49,6 +56,7 @@ typedef struct {
 
 static native_data_t *nat = NULL;  // global native data
 static void onConnectSinkResult(DBusMessage *msg, void *user, void *n);
+static void onStatusReply(DBusMessage *msg, void *user, void *n);
 
 static Properties sink_properties[] = {
         {"State", DBUS_TYPE_STRING},
@@ -216,6 +224,92 @@ static jboolean avrcpVolumeUpNative(JNIEnv *env, jobject object,
     return JNI_FALSE;
 }
 
+static jboolean sendMetaDataNative(JNIEnv *env, jobject obj,
+                                     jstring path) {
+#ifdef HAVE_BLUETOOTH
+    LOGV(__FUNCTION__);
+    if (nat) {
+        jstring title, artist, album, media_number, total_media_count, playing_time;
+        const char *c_title, *c_artist, *c_album, *c_media_number;
+        const char *c_total_media_count, *c_playing_time;
+        const char *c_path = env->GetStringUTFChars(path, NULL);
+        title = (jstring) env->GetObjectField(obj, field_mTrackName);
+        artist = (jstring) env->GetObjectField(obj, field_mArtistName);
+        album = (jstring) env->GetObjectField(obj, field_mAlbumName);
+        media_number = (jstring) env->GetObjectField(obj, field_mMediaNumber);
+        total_media_count = (jstring) env->GetObjectField(obj, field_mMediaCount);
+        playing_time = (jstring) env->GetObjectField(obj, field_mDuration);
+
+        c_title = env->GetStringUTFChars(title, NULL);
+        c_artist = env->GetStringUTFChars(artist, NULL);
+        c_album = env->GetStringUTFChars(album, NULL);
+        c_media_number = env->GetStringUTFChars(media_number, NULL);
+        c_total_media_count = env->GetStringUTFChars(total_media_count, NULL);
+        c_playing_time = env->GetStringUTFChars(playing_time, NULL);
+
+        bool ret = dbus_func_args_async(env, nat->conn, -1, onStatusReply, NULL, nat,
+                           c_path, "org.bluez.Control", "UpdateMetaData",
+                           DBUS_TYPE_STRING, &c_title,
+                           DBUS_TYPE_STRING, &c_artist,
+                           DBUS_TYPE_STRING, &c_album,
+                           DBUS_TYPE_STRING, &c_media_number,
+                           DBUS_TYPE_STRING, &c_total_media_count,
+                           DBUS_TYPE_STRING, &c_playing_time,
+                           DBUS_TYPE_INVALID);
+
+        env->ReleaseStringUTFChars(path, c_path);
+        env->ReleaseStringUTFChars(title, c_title);
+        env->ReleaseStringUTFChars(artist, c_artist);
+        env->ReleaseStringUTFChars(album, c_album);
+        env->ReleaseStringUTFChars(media_number, c_media_number);
+        env->ReleaseStringUTFChars(total_media_count, c_total_media_count);
+        env->ReleaseStringUTFChars(playing_time, c_playing_time);
+
+        return ret ? JNI_TRUE : JNI_FALSE;
+    }
+#endif
+    return JNI_FALSE;
+}
+
+
+static jboolean sendPlayStatusNative(JNIEnv *env, jobject object, jstring path,
+                                        jint duration, jint position, jint play_status) {
+#ifdef HAVE_BLUETOOTH
+    LOGV(__FUNCTION__);
+    if (nat) {
+        const char *c_path = env->GetStringUTFChars(path, NULL);
+        bool ret = dbus_func_args_async(env, nat->conn, -1, onStatusReply, NULL, nat,
+                           c_path, "org.bluez.Control", "UpdatePlayStatus",
+                           DBUS_TYPE_UINT32, &duration,
+                           DBUS_TYPE_UINT32, &position,
+                           DBUS_TYPE_UINT32, &play_status,
+                           DBUS_TYPE_INVALID);
+        env->ReleaseStringUTFChars(path, c_path);
+        return ret ? JNI_TRUE : JNI_FALSE;
+    }
+#endif
+    return JNI_FALSE;
+}
+
+static jboolean sendEventNative(JNIEnv *env, jobject object,
+                                     jstring path, jint event_id, jlong data) {
+#ifdef HAVE_BLUETOOTH
+    LOGV(__FUNCTION__);
+    if (nat) {
+        const char *c_path = env->GetStringUTFChars(path, NULL);
+
+        bool ret = dbus_func_args_async(env, nat->conn, -1, onStatusReply, NULL, nat,
+                           c_path, "org.bluez.Control", "UpdateNotification",
+                           DBUS_TYPE_UINT16, &event_id,
+                           DBUS_TYPE_UINT64, &data,
+                           DBUS_TYPE_INVALID);
+        env->ReleaseStringUTFChars(path, c_path);
+        return ret ? JNI_TRUE : JNI_FALSE;
+    }
+#endif
+    return JNI_FALSE;
+}
+
 static jboolean avrcpVolumeDownNative(JNIEnv *env, jobject object,
                                      jstring path) {
 #ifdef HAVE_BLUETOOTH
@@ -264,7 +358,12 @@ DBusHandlerResult a2dp_event_filter(DBusMessage *msg, JNIEnv *env) {
         env->DeleteLocalRef(path);
         result = DBUS_HANDLER_RESULT_HANDLED;
         return result;
-    } else {
+    } else if (dbus_message_is_signal(msg, "org.bluez.Control",
+                                      "GetPlayStatus")) {
+        env->CallVoidMethod(nat->me, method_onGetPlayStatusRequest);
+        result = DBUS_HANDLER_RESULT_HANDLED;
+        return result;
+    }else {
         LOGV("... ignored");
     }
     if (env->ExceptionCheck()) {
@@ -304,6 +403,17 @@ void onConnectSinkResult(DBusMessage *msg, void *user, void *n) {
     free(user);
 }
 
+void onStatusReply(DBusMessage *msg, void *user, void *n) {
+    LOGV(__FUNCTION__);
+
+    native_data_t *nat = (native_data_t *)n;
+    DBusError err;
+    dbus_error_init(&err);
+    if (dbus_set_error_from_message(&err, msg)) {
+        LOG_AND_FREE_DBUS_ERROR(&err);
+    }
+}
+
 
 #endif
 
@@ -321,6 +431,9 @@ static JNINativeMethod sMethods[] = {
                                     (void *)getSinkPropertiesNative},
     {"avrcpVolumeUpNative", "(Ljava/lang/String;)Z", (void*)avrcpVolumeUpNative},
     {"avrcpVolumeDownNative", "(Ljava/lang/String;)Z", (void*)avrcpVolumeDownNative},
+    {"sendMetaDataNative", "(Ljava/lang/String;)Z", (void*)sendMetaDataNative},
+    {"sendEventNative", "(Ljava/lang/String;IJ)Z", (void*)sendEventNative},
+    {"sendPlayStatusNative", "(Ljava/lang/String;III)Z", (void*)sendPlayStatusNative},
 };
 
 int register_android_server_BluetoothA2dpService(JNIEnv *env) {
@@ -335,6 +448,14 @@ int register_android_server_BluetoothA2dpService(JNIEnv *env) {
                                           "(Ljava/lang/String;[Ljava/lang/String;)V");
     method_onConnectSinkResult = env->GetMethodID(clazz, "onConnectSinkResult",
                                                          "(Ljava/lang/String;Z)V");
+    method_onGetPlayStatusRequest = env->GetMethodID(clazz, "onGetPlayStatusRequest",
+                                          "()V");
+    field_mTrackName = env->GetFieldID(clazz, "mTrackName", "Ljava/lang/String;");
+    field_mArtistName = env->GetFieldID(clazz, "mArtistName", "Ljava/lang/String;");
+    field_mAlbumName = env->GetFieldID(clazz, "mAlbumName", "Ljava/lang/String;");
+    field_mMediaNumber = env->GetFieldID(clazz, "mMediaNumber", "Ljava/lang/String;");
+    field_mMediaCount = env->GetFieldID(clazz, "mMediaCount", "Ljava/lang/String;");
+    field_mDuration = env->GetFieldID(clazz, "mDuration", "Ljava/lang/String;");
 #endif
 
     return AndroidRuntime::registerNativeMethods(env,
diff --git a/core/jni/android_server_BluetoothEventLoop.cpp b/core/jni/android_server_BluetoothEventLoop.cpp
index e8933fe..192e1e3 100644
--- a/core/jni/android_server_BluetoothEventLoop.cpp
+++ b/core/jni/android_server_BluetoothEventLoop.cpp
@@ -288,6 +288,13 @@ static jboolean setUpEventLoop(native_data_t *nat) {
             LOG_AND_FREE_DBUS_ERROR(&err);
             return JNI_FALSE;
         }
+        dbus_bus_add_match(nat->conn,
+                "type='signal',interface='"BLUEZ_DBUS_BASE_IFC".Control'",
+                &err);
+        if (dbus_error_is_set(&err)) {
+            LOG_AND_FREE_DBUS_ERROR(&err);
+            return JNI_FALSE;
+        }
 
         dbus_bus_add_match(nat->conn,
                 "type='signal',interface='"BLUEZ_DBUS_BASE_IFC".HealthDevice'",
@@ -455,6 +462,12 @@ static void tearDownEventLoop(native_data_t *nat) {
             LOG_AND_FREE_DBUS_ERROR(&err);
         }
         dbus_bus_remove_match(nat->conn,
+                "type='signal',interface='"BLUEZ_DBUS_BASE_IFC".Control'",
+                &err);
+        if (dbus_error_is_set(&err)) {
+            LOG_AND_FREE_DBUS_ERROR(&err);
+        }
+        dbus_bus_remove_match(nat->conn,
                 "type='signal',interface='"BLUEZ_DBUS_BASE_IFC".Device'",
                 &err);
         if (dbus_error_is_set(&err)) {
diff --git a/core/jni/android_util_AssetManager.cpp b/core/jni/android_util_AssetManager.cpp
index 4f8f1af..1a8f3e7 100644
--- a/core/jni/android_util_AssetManager.cpp
+++ b/core/jni/android_util_AssetManager.cpp
@@ -1,6 +1,7 @@
 /* //device/libs/android_runtime/android_util_AssetManager.cpp
 **
 ** Copyright 2006, The Android Open Source Project
+** This code has been modified.  Portions copyright (C) 2010, T-Mobile USA, Inc.
 **
 ** Licensed under the Apache License, Version 2.0 (the "License");
 ** you may not use this file except in compliance with the License.
@@ -34,9 +35,13 @@
 #include <utils/Asset.h>
 #include <utils/AssetManager.h>
 #include <utils/ResourceTypes.h>
+#include <utils/PackageRedirectionMap.h>
+#include <utils/ZipFile.h>
 
 #include <stdio.h>
 
+#define REDIRECT_NOISY(x) //x
+
 namespace android {
 
 // ----------------------------------------------------------------------------
@@ -691,17 +696,23 @@ static jint android_content_AssetManager_loadResourceValue(JNIEnv* env, jobject
     }
     const ResTable& res(am->getResources());
 
+    uint32_t ref = res.lookupRedirectionMap(ident);
+    if (ref == 0) {
+        ref = ident;
+    } else {
+        REDIRECT_NOISY(LOGW("PERFORMED REDIRECT OF ident=0x%08x FOR ref=0x%08x\n", ident, ref));
+    }
+
     Res_value value;
     ResTable_config config;
     uint32_t typeSpecFlags;
-    ssize_t block = res.getResource(ident, &value, false, density, &typeSpecFlags, &config);
+    ssize_t block = res.getResource(ref, &value, false, density, &typeSpecFlags, &config);
 #if THROW_ON_BAD_ID
     if (block == BAD_INDEX) {
         jniThrowException(env, "java/lang/IllegalStateException", "Bad resource!");
         return 0;
     }
 #endif
-    uint32_t ref = ident;
     if (resolve) {
         block = res.resolveReference(&value, block, &ref);
 #if THROW_ON_BAD_ID
@@ -952,6 +963,20 @@ static jboolean android_content_AssetManager_applyStyle(JNIEnv* env, jobject cla
     // Now lock down the resource object and start pulling stuff from it.
     res.lock();
 
+    // Apply theme redirections to the referenced styles.
+    if (defStyleRes != 0) {
+        uint32_t ref = res.lookupRedirectionMap(defStyleRes);
+        if (ref != 0) {
+            defStyleRes = ref;
+        }
+    }
+    if (style != 0) {
+        uint32_t ref = res.lookupRedirectionMap(style);
+        if (ref != 0) {
+            style = ref;
+        }
+    }
+
     // Retrieve the default style bag, if requested.
     const ResTable::bag_entry* defStyleEnt = NULL;
     uint32_t defStyleTypeSetFlags = 0;
@@ -1076,6 +1101,31 @@ static jboolean android_content_AssetManager_applyStyle(JNIEnv* env, jobject cla
             block = kXmlBlock;
         }
 
+        // One final test for a resource redirection from the applied theme.
+        if (resid != 0) {
+            uint32_t redirect = res.lookupRedirectionMap(resid);
+            if (redirect != 0) {
+                REDIRECT_NOISY(LOGW("deep REDIRECT 0x%08x => 0x%08x\n", resid, redirect));
+                ssize_t newBlock = res.getResource(redirect, &value, true, config.density, &typeSetFlags, &config);
+                if (newBlock >= 0) {
+                    newBlock = res.resolveReference(&value, newBlock, &redirect, &typeSetFlags, &config);
+#if THROW_ON_BAD_ID
+                    if (newBlock == BAD_INDEX) {
+                        jniThrowException(env, "java/lang/IllegalStateException", "Bad resource!");
+                        return JNI_FALSE;
+                    }
+#endif
+                    if (newBlock >= 0) {
+                        block = newBlock;
+                        resid = redirect;
+                    }
+                }
+                if (resid != redirect) {
+                    LOGW("deep redirect failure from 0x%08x => 0x%08x, defStyleAttr=0x%08x, defStyleRes=0x%08x, style=0x%08x\n", resid, redirect, defStyleAttr, defStyleRes, style);
+                }
+            }
+        }
+
         DEBUG_STYLES(LOGI("Attribute 0x%08x: type=0x%x, data=0x%08x",
                 curIdent, value.dataType, value.data));
 
@@ -1333,6 +1383,31 @@ static jint android_content_AssetManager_retrieveArray(JNIEnv* env, jobject claz
             value.dataType = Res_value::TYPE_NULL;
         }
 
+        // One final test for a resource redirection from the applied theme.
+        if (resid != 0) {
+            uint32_t redirect = res.lookupRedirectionMap(resid);
+            if (redirect != 0) {
+                REDIRECT_NOISY(LOGW("array REDIRECT 0x%08x => 0x%08x\n", resid, redirect));
+                ssize_t newBlock = res.getResource(redirect, &value, true, config.density, &typeSetFlags, &config);
+                if (newBlock >= 0) {
+                    newBlock = res.resolveReference(&value, newBlock, &redirect, &typeSetFlags, &config);
+#if THROW_ON_BAD_ID
+                    if (newBlock == BAD_INDEX) {
+                        jniThrowException(env, "java/lang/IllegalStateException", "Bad resource!");
+                        return JNI_FALSE;
+                    }
+#endif
+                    if (newBlock >= 0) {
+                        block = newBlock;
+                        resid = redirect;
+                    }
+                }
+                if (resid != redirect) {
+                    LOGW("array redirect failure from 0x%08x => 0x%08x, array id=0x%08x", resid, redirect, id);
+                }
+            }
+        }
+
         //printf("Attribute 0x%08x: final type=0x%x, data=0x%08x\n", curIdent, value.dataType, value.data);
 
         // Write the final value back to Java.
@@ -1561,6 +1636,84 @@ static jintArray android_content_AssetManager_getArrayIntResource(JNIEnv* env, j
     return array;
 }
 
+static jint android_content_AssetManager_splitThemePackage(JNIEnv* env, jobject clazz,
+		jstring srcFileName, jstring dstFileName, jobjectArray drmProtectedAssetNames)
+{
+    AssetManager* am = assetManagerForJavaObject(env, clazz);
+    if (am == NULL) {
+        return -1;
+    }
+
+    LOGV("splitThemePackage in %p (Java object %p)\n", am, clazz);
+
+    if (srcFileName == NULL || dstFileName == NULL) {
+        jniThrowException(env, "java/lang/NullPointerException", srcFileName == NULL ? "srcFileName" : "dstFileName");
+        return -2;
+    }
+
+    jsize size = env->GetArrayLength(drmProtectedAssetNames);
+    if (size == 0) {
+        jniThrowException(env, "java/lang/IllegalArgumentException", "drmProtectedAssetNames");
+        return -3;
+    }
+
+    const char* srcFileName8 = env->GetStringUTFChars(srcFileName, NULL);
+    ZipFile* srcZip = new ZipFile;
+    status_t err = srcZip->open(srcFileName8, ZipFile::kOpenReadWrite);
+    if (err != NO_ERROR) {
+        LOGV("error opening zip file %s\n", srcFileName8);
+        delete srcZip;
+        env->ReleaseStringUTFChars(srcFileName, srcFileName8);
+        return -4;
+    }
+
+    const char* dstFileName8 = env->GetStringUTFChars(dstFileName, NULL);
+    ZipFile* dstZip = new ZipFile;
+    err = dstZip->open(dstFileName8, ZipFile::kOpenReadWrite | ZipFile::kOpenTruncate | ZipFile::kOpenCreate);
+
+    if (err != NO_ERROR) {
+        LOGV("error opening zip file %s\n", dstFileName8);
+        delete srcZip;
+        delete dstZip;
+        env->ReleaseStringUTFChars(srcFileName, srcFileName8);
+        env->ReleaseStringUTFChars(dstFileName, dstFileName8);
+        return -5;
+    }
+
+    int result = 0;
+    for (int i = 0; i < size; i++) {
+        jstring javaString = (jstring)env->GetObjectArrayElement(drmProtectedAssetNames, i);
+        const char* drmProtectedAssetFileName8 = env->GetStringUTFChars(javaString, NULL);
+        ZipEntry *assetEntry = srcZip->getEntryByName(drmProtectedAssetFileName8);
+        if (assetEntry == NULL) {
+            result = 1;
+            LOGV("Invalid asset entry %s\n", drmProtectedAssetFileName8);
+        } else {
+            status_t loc_result = dstZip->add(srcZip, assetEntry, 0, NULL);
+            if (loc_result != NO_ERROR) {
+                LOGV("error copying zip entry %s\n", drmProtectedAssetFileName8);
+                result = result | 2;
+            } else {
+                loc_result = srcZip->remove(assetEntry);
+                if (loc_result != NO_ERROR) {
+                    LOGV("error removing zip entry %s\n", drmProtectedAssetFileName8);
+                    result = result | 4;
+                }
+            }
+        }
+        env->ReleaseStringUTFChars(javaString, drmProtectedAssetFileName8);
+    }
+    srcZip->flush();
+    dstZip->flush();
+
+    delete srcZip;
+    delete dstZip;
+    env->ReleaseStringUTFChars(srcFileName, srcFileName8);
+    env->ReleaseStringUTFChars(dstFileName, dstFileName8);
+
+    return (jint)result;
+}
+
 static void android_content_AssetManager_init(JNIEnv* env, jobject clazz)
 {
     AssetManager* am = new AssetManager();
@@ -1607,6 +1760,173 @@ static jint android_content_AssetManager_getGlobalAssetManagerCount(JNIEnv* env,
     return AssetManager::getGlobalCount();
 }
 
+static jint android_content_AssetManager_getBasePackageCount(JNIEnv* env, jobject clazz)
+{
+    AssetManager* am = assetManagerForJavaObject(env, clazz);
+    if (am == NULL) {
+        return JNI_FALSE;
+    }
+
+    return am->getResources().getBasePackageCount();
+}
+
+static jstring android_content_AssetManager_getBasePackageName(JNIEnv* env, jobject clazz, jint index)
+{
+    AssetManager* am = assetManagerForJavaObject(env, clazz);
+    if (am == NULL) {
+        return JNI_FALSE;
+    }
+
+    String16 packageName(am->getResources().getBasePackageName(index));
+    return env->NewString((const jchar*)packageName.string(), packageName.size());
+}
+
+static jint android_content_AssetManager_getBasePackageId(JNIEnv* env, jobject clazz, jint index)
+{
+    AssetManager* am = assetManagerForJavaObject(env, clazz);
+    if (am == NULL) {
+        return JNI_FALSE;
+    }
+
+    return am->getResources().getBasePackageId(index);
+}
+
+static void android_content_AssetManager_addRedirectionsNative(JNIEnv* env, jobject clazz,
+            PackageRedirectionMap* resMap)
+{
+    AssetManager* am = assetManagerForJavaObject(env, clazz);
+    if (am == NULL) {
+        return;
+    }
+
+    am->addRedirections(resMap);
+}
+
+static void android_content_AssetManager_clearRedirectionsNative(JNIEnv* env, jobject clazz)
+{
+    AssetManager* am = assetManagerForJavaObject(env, clazz);
+    if (am == NULL) {
+        return;
+    }
+
+    am->clearRedirections();
+}
+
+static jboolean android_content_AssetManager_generateStyleRedirections(JNIEnv* env, jobject clazz,
+        PackageRedirectionMap* resMap, jint sourceStyle, jint destStyle)
+{
+    AssetManager* am = assetManagerForJavaObject(env, clazz);
+    if (am == NULL) {
+        return JNI_FALSE;
+    }
+
+    const ResTable& res(am->getResources());
+
+    res.lock();
+
+    // Load up a bag for the user-supplied theme.
+    const ResTable::bag_entry* themeEnt = NULL;
+    ssize_t N = res.getBagLocked(destStyle, &themeEnt);
+    const ResTable::bag_entry* endThemeEnt = themeEnt + (N >= 0 ? N : 0);
+
+    // ...and a bag for the framework default.
+    const ResTable::bag_entry* frameworkEnt = NULL;
+    N = res.getBagLocked(sourceStyle, &frameworkEnt);
+    const ResTable::bag_entry* endFrameworkEnt = frameworkEnt + (N >= 0 ? N : 0);
+
+    // Add the source => dest style redirection first.
+    jboolean ret = JNI_FALSE;
+    if (themeEnt < endThemeEnt && frameworkEnt < endFrameworkEnt) {
+        resMap->addRedirection(sourceStyle, destStyle);
+        ret = JNI_TRUE;
+    }
+
+    // Now compare them and infer resource redirections for attributes that
+    // remap to different styles.  This works by essentially lining up all the
+    // sorted attributes from each theme and detected TYPE_REFERENCE entries
+    // that point to different resources.  When we find such a mismatch, we'll
+    // create a resource redirection from the original framework resource ID to
+    // the one in the theme.  This lets us do things like automatically find
+    // redirections for @android:style/Widget.Button by looking at how the
+    // theme overrides the android:attr/buttonStyle attribute.
+    REDIRECT_NOISY(LOGW("delta between 0x%08x and 0x%08x:\n", sourceStyle, destStyle));
+    for (; frameworkEnt < endFrameworkEnt; frameworkEnt++) {
+        if (frameworkEnt->map.value.dataType != Res_value::TYPE_REFERENCE) {
+            continue;
+        }
+
+        uint32_t curIdent = frameworkEnt->map.name.ident;
+
+        // Walk along the theme entry looking for a match.
+        while (themeEnt < endThemeEnt && curIdent > themeEnt->map.name.ident) {
+            themeEnt++;
+        }
+        // Match found, compare the references.
+        if (themeEnt < endThemeEnt && curIdent == themeEnt->map.name.ident) {
+            if (themeEnt->map.value.data != frameworkEnt->map.value.data) {
+                uint32_t fromIdent = frameworkEnt->map.value.data;
+                uint32_t toIdent = themeEnt->map.value.data;
+                REDIRECT_NOISY(LOGW("   generated mapping from 0x%08x => 0x%08x (by attr 0x%08x)\n",
+                        fromIdent, toIdent, curIdent));
+                resMap->addRedirection(fromIdent, toIdent);
+            }
+            themeEnt++;
+        }
+
+        // Exhausted the theme, bail early.
+        if (themeEnt >= endThemeEnt) {
+            break;
+        }
+    }
+
+    res.unlock();
+
+    return ret;
+}
+
+static jboolean android_content_AssetManager_detachThemePath(JNIEnv* env, jobject clazz,
+            jstring packageName, jint cookie)
+{
+    if (packageName == NULL) {
+        jniThrowException(env, "java/lang/NullPointerException", "packageName");
+        return JNI_FALSE;
+    }
+
+    AssetManager* am = assetManagerForJavaObject(env, clazz);
+    if (am == NULL) {
+        return JNI_FALSE;
+    }
+
+    const char* name8 = env->GetStringUTFChars(packageName, NULL);
+    bool res = am->detachThemePath(String8(name8), (void *)cookie);
+    env->ReleaseStringUTFChars(packageName, name8);
+
+    return res;
+}
+
+static jint android_content_AssetManager_attachThemePath(
+            JNIEnv* env, jobject clazz, jstring path)
+{
+    if (path == NULL) {
+        jniThrowException(env, "java/lang/NullPointerException", "path");
+        return JNI_FALSE;
+    }
+
+    AssetManager* am = assetManagerForJavaObject(env, clazz);
+    if (am == NULL) {
+        return JNI_FALSE;
+    }
+
+    const char* path8 = env->GetStringUTFChars(path, NULL);
+
+    void* cookie;
+    bool res = am->attachThemePath(String8(path8), &cookie);
+
+    env->ReleaseStringUTFChars(path, path8);
+
+    return (res) ? (jint)cookie : 0;
+}
+
 // ----------------------------------------------------------------------------
 
 /*
@@ -1716,6 +2036,28 @@ static JNINativeMethod gAssetManagerMethods[] = {
         (void*) android_content_AssetManager_getAssetAllocations },
     { "getGlobalAssetManagerCount", "()I",
         (void*) android_content_AssetManager_getGlobalAssetCount },
+
+    // Split theme package apk into two.
+    { "splitThemePackage","(Ljava/lang/String;Ljava/lang/String;[Ljava/lang/String;)I",
+        (void*) android_content_AssetManager_splitThemePackage },
+
+    // Dynamic theme package support.
+    { "detachThemePath", "(Ljava/lang/String;I)Z",
+        (void*) android_content_AssetManager_detachThemePath },
+    { "attachThemePath",   "(Ljava/lang/String;)I",
+        (void*) android_content_AssetManager_attachThemePath },
+    { "getBasePackageCount", "()I",
+        (void*) android_content_AssetManager_getBasePackageCount },
+    { "getBasePackageName", "(I)Ljava/lang/String;",
+        (void*) android_content_AssetManager_getBasePackageName },
+    { "getBasePackageId", "(I)I",
+        (void*) android_content_AssetManager_getBasePackageId },
+    { "addRedirectionsNative", "(I)V",
+        (void*) android_content_AssetManager_addRedirectionsNative },
+    { "clearRedirectionsNative", "()V",
+        (void*) android_content_AssetManager_clearRedirectionsNative },
+    { "generateStyleRedirections", "(III)Z",
+        (void*) android_content_AssetManager_generateStyleRedirections },
 };
 
 int register_android_content_AssetManager(JNIEnv* env)
diff --git a/core/jni/android_util_PackageRedirectionMap.cpp b/core/jni/android_util_PackageRedirectionMap.cpp
new file mode 100644
index 0000000..2391edb
--- /dev/null
+++ b/core/jni/android_util_PackageRedirectionMap.cpp
@@ -0,0 +1,176 @@
+/*
+ * Copyright (C) 2011, T-Mobile USA, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include <utils/PackageRedirectionMap.h>
+
+#include "jni.h"
+#include "JNIHelp.h"
+#include <utils/misc.h>
+#include <android_runtime/AndroidRuntime.h>
+
+#include "android_util_Binder.h"
+#include <binder/Parcel.h>
+
+#include <utils/ResourceTypes.h>
+
+#include <stdio.h>
+
+namespace android {
+
+// ----------------------------------------------------------------------------
+
+static PackageRedirectionMap* PackageRedirectionMap_constructor(JNIEnv* env, jobject clazz)
+{
+    return new PackageRedirectionMap;
+}
+
+static void PackageRedirectionMap_destructor(JNIEnv* env, jobject clazz,
+        PackageRedirectionMap* resMap)
+{
+    delete resMap;
+}
+
+static PackageRedirectionMap* PackageRedirectionMap_createFromParcel(JNIEnv* env, jobject clazz,
+        jobject parcel)
+{
+    if (parcel == NULL) {
+        return NULL;
+    }
+
+    Parcel* p = parcelForJavaObject(env, parcel);
+    PackageRedirectionMap* resMap = new PackageRedirectionMap;
+
+    int32_t entryCount = p->readInt32();
+    while (entryCount-- > 0) {
+        uint32_t fromIdent = (uint32_t)p->readInt32();
+        uint32_t toIdent = (uint32_t)p->readInt32();
+        resMap->addRedirection(fromIdent, toIdent);
+    }
+
+    return resMap;
+}
+
+static jboolean PackageRedirectionMap_writeToParcel(JNIEnv* env, jobject clazz,
+        PackageRedirectionMap* resMap, jobject parcel)
+{
+    if (parcel == NULL) {
+        return JNI_FALSE;
+    }
+
+    Parcel* p = parcelForJavaObject(env, parcel);
+
+    int package = resMap->getPackage();
+    size_t nTypes = resMap->getNumberOfTypes();
+    size_t entryCount = 0;
+    for (size_t type=0; type<nTypes; type++) {
+        entryCount += resMap->getNumberOfUsedEntries(type);
+    }
+    p->writeInt32(entryCount);
+    for (size_t type=0; type<nTypes; type++) {
+        size_t nEntries = resMap->getNumberOfEntries(type);
+        for (size_t entry=0; entry<nEntries; entry++) {
+            uint32_t toIdent = resMap->getEntry(type, entry);
+            if (toIdent != 0) {
+                uint32_t fromIdent = Res_MAKEID(package-1, type, entry);
+                p->writeInt32(fromIdent);
+                p->writeInt32(toIdent);
+            }
+        }
+    }
+
+    return JNI_TRUE;
+}
+
+static void PackageRedirectionMap_addRedirection(JNIEnv* env, jobject clazz,
+        PackageRedirectionMap* resMap, jint fromIdent, jint toIdent)
+{
+    resMap->addRedirection(fromIdent, toIdent);
+}
+
+static jint PackageRedirectionMap_getPackageId(JNIEnv* env, jobject clazz,
+        PackageRedirectionMap* resMap)
+{
+    return resMap->getPackage();
+}
+
+static jint PackageRedirectionMap_lookupRedirection(JNIEnv* env, jobject clazz,
+        PackageRedirectionMap* resMap, jint fromIdent)
+{
+    return resMap->lookupRedirection(fromIdent);
+}
+
+static jintArray PackageRedirectionMap_getRedirectionKeys(JNIEnv* env, jobject clazz,
+        PackageRedirectionMap* resMap)
+{
+    int package = resMap->getPackage();
+    size_t nTypes = resMap->getNumberOfTypes();
+    size_t entryCount = 0;
+    for (size_t type=0; type<nTypes; type++) {
+        size_t usedEntries = resMap->getNumberOfUsedEntries(type);
+        entryCount += usedEntries;
+    }
+    jintArray array = env->NewIntArray(entryCount);
+    if (array == NULL) {
+        jniThrowException(env, "java/lang/OutOfMemoryError", "");
+        return NULL;
+    }
+    jsize index = 0;
+    for (size_t type=0; type<nTypes; type++) {
+        size_t nEntries = resMap->getNumberOfEntries(type);
+        for (size_t entry=0; entry<nEntries; entry++) {
+            uint32_t toIdent = resMap->getEntry(type, entry);
+            if (toIdent != 0) {
+                jint fromIdent = (jint)Res_MAKEID(package-1, type, entry);
+                env->SetIntArrayRegion(array, index++, 1, &fromIdent);
+            }
+        }
+    }
+    return array;
+}
+
+// ----------------------------------------------------------------------------
+
+/*
+ * JNI registration.
+ */
+static JNINativeMethod gPackageRedirectionMapMethods[] = {
+    { "nativeConstructor",      "()I",
+        (void*) PackageRedirectionMap_constructor },
+    { "nativeDestructor",       "(I)V",
+        (void*) PackageRedirectionMap_destructor },
+    { "nativeCreateFromParcel", "(Landroid/os/Parcel;)I",
+        (void*) PackageRedirectionMap_createFromParcel },
+    { "nativeWriteToParcel", "(ILandroid/os/Parcel;)Z",
+        (void*) PackageRedirectionMap_writeToParcel },
+    { "nativeAddRedirection", "(III)V",
+        (void*) PackageRedirectionMap_addRedirection },
+    { "nativeGetPackageId", "(I)I",
+        (void*) PackageRedirectionMap_getPackageId },
+    { "nativeLookupRedirection", "(II)I",
+        (void*) PackageRedirectionMap_lookupRedirection },
+    { "nativeGetRedirectionKeys", "(I)[I",
+        (void*) PackageRedirectionMap_getRedirectionKeys },
+};
+
+int register_android_content_res_PackageRedirectionMap(JNIEnv* env)
+{
+    return AndroidRuntime::registerNativeMethods(env,
+            "android/content/res/PackageRedirectionMap",
+            gPackageRedirectionMapMethods,
+            NELEM(gPackageRedirectionMapMethods));
+}
+
+}; // namespace android
diff --git a/core/jni/android_view_GLES20Canvas.cpp b/core/jni/android_view_GLES20Canvas.cpp
index 426f4f7..eb3a87a 100644
--- a/core/jni/android_view_GLES20Canvas.cpp
+++ b/core/jni/android_view_GLES20Canvas.cpp
@@ -44,6 +44,10 @@
 #include <SkiaColorFilter.h>
 #include <Rect.h>
 
+#ifdef QCOM_HARDWARE
+#include <tilerenderer.h>
+#endif
+
 #include <TextLayout.h>
 
 namespace android {
@@ -176,6 +180,18 @@ static void android_view_GLES20Canvas_prepare(JNIEnv* env, jobject clazz,
     renderer->prepare(opaque);
 }
 
+#ifdef QCOM_HARDWARE
+static void android_view_GLES20Canvas_startTileRendering(JNIEnv* env, jobject clazz,
+        OpenGLRenderer* renderer, jint left, jint top, jint right, jint bottom) {
+    TileRenderer::getInstance().startTileRendering(renderer, left, top, right, bottom);
+}
+
+static void android_view_GLES20Canvas_endTileRendering(JNIEnv* env, jobject clazz,
+        OpenGLRenderer* renderer) {
+    TileRenderer::getInstance().endTileRendering(renderer);
+}
+#endif
+
 static void android_view_GLES20Canvas_prepareDirty(JNIEnv* env, jobject clazz,
         OpenGLRenderer* renderer, jint left, jint top, jint right, jint bottom,
         jboolean opaque) {
@@ -613,7 +629,7 @@ static void android_view_GLES20Canvas_resetDisplayListRenderer(JNIEnv* env,
 
 static void android_view_GLES20Canvas_destroyDisplayList(JNIEnv* env,
         jobject clazz, DisplayList* displayList) {
-    delete displayList;
+    DisplayList::destroyDisplayListDeferred(displayList);
 }
 
 static bool android_view_GLES20Canvas_drawDisplayList(JNIEnv* env,
@@ -785,6 +801,10 @@ static JNINativeMethod gMethods[] = {
     { "nSetViewport",       "(III)V",          (void*) android_view_GLES20Canvas_setViewport },
     { "nPrepare",           "(IZ)V",           (void*) android_view_GLES20Canvas_prepare },
     { "nPrepareDirty",      "(IIIIIZ)V",       (void*) android_view_GLES20Canvas_prepareDirty },
+#ifdef QCOM_HARDWARE
+    { "nStartTileRendering","(IIIII)V",        (void*) android_view_GLES20Canvas_startTileRendering},
+    { "nEndTileRendering",  "(I)V",            (void*) android_view_GLES20Canvas_endTileRendering},
+#endif
     { "nFinish",            "(I)V",            (void*) android_view_GLES20Canvas_finish },
 
     { "nCallDrawGLFunction", "(II)Z",
diff --git a/core/jni/android_view_Surface.cpp b/core/jni/android_view_Surface.cpp
index bba4b47..3a7b918 100644
--- a/core/jni/android_view_Surface.cpp
+++ b/core/jni/android_view_Surface.cpp
@@ -610,6 +610,20 @@ static void Surface_setSize(
     }
 }
 
+#ifdef QCOM_HARDWARE
+static void Surface_setStereoscopic3DFormat(JNIEnv* env, jobject clazz, jint f)
+{
+    const sp<Surface>& surface(getSurface(env, clazz));
+    if (!Surface::isValid(surface))
+        return;
+
+    status_t err = surface->setStereoscopic3DFormat(f);
+    if (err<0 && err!=NO_INIT) {
+        doThrowIAE(env);
+    }
+}
+#endif
+
 static void Surface_hide(
         JNIEnv* env, jobject clazz)
 {
diff --git a/core/jni/org_codeaurora_Performance.cpp b/core/jni/org_codeaurora_Performance.cpp
new file mode 100644
index 0000000..496972a
--- /dev/null
+++ b/core/jni/org_codeaurora_Performance.cpp
@@ -0,0 +1,162 @@
+/*
+ * Copyright (c) 2011-2012, Code Aurora Forum. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *    * Redistributions of source code must retain the above copyright
+ *      notice, this list of conditions and the following disclaimer.
+ *    * Redistributions in binary form must reproduce the above copyright
+ *      notice, this list of conditions and the following disclaimer in the
+ *      documentation and/or other materials provided with the distribution.
+ *    * Neither the name of Code Aurora nor
+ *      the names of its contributors may be used to endorse or promote
+ *      products derived from this software without specific prior written
+ *      permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NON-INFRINGEMENT ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+ * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
+ * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
+ * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#define LOG_TAG "ANDR-PERF-JNI"
+
+#include "jni.h"
+#include "JNIHelp.h"
+#include <android_runtime/AndroidRuntime.h>
+
+#include <dlfcn.h>
+#include <limits.h>
+#include <string.h>
+
+#include <cutils/properties.h>
+#include <utils/Log.h>
+
+#define LIBRARY_PATH_PREFIX	"/system/lib/"
+
+namespace android
+{
+
+// ----------------------------------------------------------------------------
+
+static void (*cpu_boost)(int)           = NULL;
+static int  (*cpu_setoptions)(int, int) = NULL;
+static void *dlhandle                   = NULL;
+
+// ----------------------------------------------------------------------------
+
+static void
+org_codeaurora_performance_native_init()
+{
+    const char *rc;
+    void (*init)(void);
+    char buf[PROPERTY_VALUE_MAX];
+    int len;
+
+    /* Retrieve name of vendor extension library */
+    if (property_get("ro.vendor.extension_library", buf, NULL) <= 0) {
+        return;
+    }
+
+    /* Sanity check - ensure */
+    buf[PROPERTY_VALUE_MAX-1] = '\0';
+    if ((strncmp(buf, LIBRARY_PATH_PREFIX, sizeof(LIBRARY_PATH_PREFIX) - 1) != 0)
+        ||
+        (strstr(buf, "..") != NULL)) {
+        return;
+    }
+
+    dlhandle = dlopen(buf, RTLD_NOW | RTLD_LOCAL);
+    if (dlhandle == NULL) {
+        return;
+    }
+
+    dlerror();
+
+    cpu_boost = (void (*) (int))dlsym(dlhandle, "perf_cpu_boost");
+    if ((rc = dlerror()) != NULL) {
+        goto cleanup;
+    }
+    cpu_setoptions = (int (*) (int, int))dlsym(dlhandle, "perf_cpu_setoptions");
+    if ((rc = dlerror()) != NULL) {
+        goto cleanup;
+    }
+    init = (void (*) ())dlsym(dlhandle, "libqc_opt_init");
+    if ((rc = dlerror()) != NULL) {
+        goto cleanup;
+    }
+    (*init)();
+    return;
+
+cleanup:
+    cpu_boost      = NULL;
+    cpu_setoptions = NULL;
+    if (dlhandle) {
+        dlclose(dlhandle);
+        dlhandle = NULL;
+    }
+}
+
+static void
+org_codeaurora_performance_native_deinit(JNIEnv *env, jobject clazz)
+{
+    void (*deinit)(void);
+
+    if (dlhandle) {
+        cpu_boost      = NULL;
+        cpu_setoptions = NULL;
+
+        deinit = (void (*) ())dlsym(dlhandle, "libqc_opt_deinit");
+        if (deinit) {
+            (*deinit)();
+        }
+
+        dlclose(dlhandle);
+        dlhandle       = NULL;
+    }
+}
+
+static void
+org_codeaurora_performance_native_cpu_boost(JNIEnv *env, jobject clazz, jint ntasks)
+{
+    if (cpu_boost) {
+        (*cpu_boost)(ntasks);
+    }
+}
+
+static jint
+org_codeaurora_performance_native_cpu_setoptions(JNIEnv *env, jobject clazz,
+                                                 jint reqtype, jint reqvalue)
+{
+    if (cpu_setoptions) {
+        return (*cpu_setoptions)(reqtype, reqvalue);
+    }
+    return 0;
+}
+
+
+// ----------------------------------------------------------------------------
+
+static JNINativeMethod gMethods[] = {
+    {"native_cpu_boost",      "(I)V",                  (void *)org_codeaurora_performance_native_cpu_boost},
+    {"native_cpu_setoptions", "(II)I",                 (int *)org_codeaurora_performance_native_cpu_setoptions},
+    {"native_deinit",         "()V",                   (void *)org_codeaurora_performance_native_deinit},
+};
+
+
+int register_org_codeaurora_Performance(JNIEnv *env)
+{
+    org_codeaurora_performance_native_init();
+
+    return AndroidRuntime::registerNativeMethods(env,
+            "org/codeaurora/Performance", gMethods, NELEM(gMethods));
+}
+
+}   // namespace android
diff --git a/core/res/AndroidManifest.xml b/core/res/AndroidManifest.xml
index 97658a1..973c5c8 100644
--- a/core/res/AndroidManifest.xml
+++ b/core/res/AndroidManifest.xml
@@ -18,6 +18,7 @@
 */
 -->
 <manifest xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:pluto="http://www.w3.org/2001/pluto.html"
     package="android" coreApp="true" android:sharedUserId="android.uid.system"
     android:sharedUserLabel="@string/android_system_label">
 
@@ -120,7 +121,7 @@
     <protected-broadcast android:name="android.nfc.action.TRANSACTION_DETECTED" />
     <protected-broadcast android:name="android.intent.action.CLEAR_DNS_CACHE" />
     <protected-broadcast android:name="android.intent.action.PROXY_CHANGE" />
-
+    <protected-broadcast android:name="android.intent.action.NAVBAR_EDIT" />
 
     <!-- ====================================== -->
     <!-- Permissions for things that cost money -->
@@ -541,6 +542,14 @@
         android:label="@string/permlab_camera"
         android:description="@string/permdesc_camera" />
 
+    <!-- Allows an application to override the power key action 
+         @hide -->
+    <permission android:name="android.permission.PREVENT_POWER_KEY"
+        android:permissionGroup="android.permission-group.HARDWARE_CONTROLS"
+        android:protectionLevel="dangerous"
+        android:label="@string/permlab_preventpower"
+        android:description="@string/permdesc_preventpower" />
+
     <!-- Allows access to the vibrator -->
     <permission android:name="android.permission.VIBRATE"
         android:permissionGroup="android.permission-group.HARDWARE_CONTROLS"
@@ -548,6 +557,22 @@
         android:label="@string/permlab_vibrate"
         android:description="@string/permdesc_vibrate" />
 
+    <!-- Allows access to the FM Radio receiver
+        @hide Pending API council approval -->
+    <permission android:name="com.stericsson.permission.FM_RADIO_RECEIVER"
+        android:permissionGroup="android.permission-group.HARDWARE_CONTROLS"
+        android:protectionLevel="normal"
+        android:label="@string/permlab_fm_radio_receiver"
+        android:description="@string/permdesc_fm_radio_receiver" />
+
+    <!-- Allows access to the FM Radio transmitter
+         @hide Pending API council approval -->
+    <permission android:name="com.stericsson.permission.FM_RADIO_TRANSMITTER"
+        android:permissionGroup="android.permission-group.HARDWARE_CONTROLS"
+        android:protectionLevel="dangerous"
+        android:label="@string/permlab_fm_radio_transmitter"
+        android:description="@string/permdesc_fm_radio_transmitter" />
+
     <!-- Allows access to the flashlight -->
     <permission android:name="android.permission.FLASHLIGHT"
         android:permissionGroup="android.permission-group.HARDWARE_CONTROLS"
@@ -1630,6 +1655,18 @@
             </intent-filter>
         </receiver>
 
+        <receiver android:name="com.android.server.AppsLaunchFailureReceiver" >
+            <intent-filter>
+                <action android:name="com.tmobile.intent.action.APP_LAUNCH_FAILURE" />
+                <action android:name="com.tmobile.intent.action.APP_LAUNCH_FAILURE_RESET" />
+                <action android:name="android.intent.action.PACKAGE_ADDED" />
+                <action android:name="android.intent.action.PACKAGE_REMOVED" />
+                <action android:name="com.tmobile.intent.action.THEME_PACKAGE_UPDATED" />
+                <category android:name="com.tmobile.intent.category.THEME_PACKAGE_INSTALL_STATE_CHANGE" />
+                <data android:scheme="package" />
+            </intent-filter>
+        </receiver>
+
         <service android:name="com.android.internal.os.storage.ExternalStorageFormatter"
             android:permission="android.permission.MASTER_CLEAR"
             android:exported="true" />
diff --git a/core/res/res/drawable-hdpi/ic_lock_idle_calendar.png b/core/res/res/drawable-hdpi/ic_lock_idle_calendar.png
new file mode 100644
index 0000000..05b68b1
Binary files /dev/null and b/core/res/res/drawable-hdpi/ic_lock_idle_calendar.png differ
diff --git a/core/res/res/drawable-hdpi/ic_lock_profile.png b/core/res/res/drawable-hdpi/ic_lock_profile.png
new file mode 100644
index 0000000..7fc4cec
Binary files /dev/null and b/core/res/res/drawable-hdpi/ic_lock_profile.png differ
diff --git a/core/res/res/drawable-hdpi/ic_lock_reboot.png b/core/res/res/drawable-hdpi/ic_lock_reboot.png
new file mode 100644
index 0000000..ca00936
Binary files /dev/null and b/core/res/res/drawable-hdpi/ic_lock_reboot.png differ
diff --git a/core/res/res/drawable-hdpi/ic_lock_screenshot.png b/core/res/res/drawable-hdpi/ic_lock_screenshot.png
new file mode 100644
index 0000000..5ef76f7
Binary files /dev/null and b/core/res/res/drawable-hdpi/ic_lock_screenshot.png differ
diff --git a/core/res/res/drawable-hdpi/ic_lockscreen_alarm_activated.png b/core/res/res/drawable-hdpi/ic_lockscreen_alarm_activated.png
new file mode 100644
index 0000000..7fc4e3f
Binary files /dev/null and b/core/res/res/drawable-hdpi/ic_lockscreen_alarm_activated.png differ
diff --git a/core/res/res/drawable-hdpi/ic_lockscreen_alarm_normal.png b/core/res/res/drawable-hdpi/ic_lockscreen_alarm_normal.png
new file mode 100644
index 0000000..af87580
Binary files /dev/null and b/core/res/res/drawable-hdpi/ic_lockscreen_alarm_normal.png differ
diff --git a/core/res/res/drawable-hdpi/ic_lockscreen_browser_activated.png b/core/res/res/drawable-hdpi/ic_lockscreen_browser_activated.png
new file mode 100644
index 0000000..99cc744
Binary files /dev/null and b/core/res/res/drawable-hdpi/ic_lockscreen_browser_activated.png differ
diff --git a/core/res/res/drawable-hdpi/ic_lockscreen_browser_normal.png b/core/res/res/drawable-hdpi/ic_lockscreen_browser_normal.png
new file mode 100644
index 0000000..e666013
Binary files /dev/null and b/core/res/res/drawable-hdpi/ic_lockscreen_browser_normal.png differ
diff --git a/core/res/res/drawable-hdpi/ic_lockscreen_calendar_activated.png b/core/res/res/drawable-hdpi/ic_lockscreen_calendar_activated.png
new file mode 100644
index 0000000..f4972e7
Binary files /dev/null and b/core/res/res/drawable-hdpi/ic_lockscreen_calendar_activated.png differ
diff --git a/core/res/res/drawable-hdpi/ic_lockscreen_calendar_normal.png b/core/res/res/drawable-hdpi/ic_lockscreen_calendar_normal.png
new file mode 100644
index 0000000..9a5c37e
Binary files /dev/null and b/core/res/res/drawable-hdpi/ic_lockscreen_calendar_normal.png differ
diff --git a/core/res/res/drawable-hdpi/ic_lockscreen_camera_activated.png b/core/res/res/drawable-hdpi/ic_lockscreen_camera_activated.png
index 19c8eb2..1e77930 100644
Binary files a/core/res/res/drawable-hdpi/ic_lockscreen_camera_activated.png and b/core/res/res/drawable-hdpi/ic_lockscreen_camera_activated.png differ
diff --git a/core/res/res/drawable-hdpi/ic_lockscreen_camera_normal.png b/core/res/res/drawable-hdpi/ic_lockscreen_camera_normal.png
index c79a245..c1a6047 100644
Binary files a/core/res/res/drawable-hdpi/ic_lockscreen_camera_normal.png and b/core/res/res/drawable-hdpi/ic_lockscreen_camera_normal.png differ
diff --git a/core/res/res/drawable-hdpi/ic_lockscreen_email_activated.png b/core/res/res/drawable-hdpi/ic_lockscreen_email_activated.png
new file mode 100644
index 0000000..37d1334
Binary files /dev/null and b/core/res/res/drawable-hdpi/ic_lockscreen_email_activated.png differ
diff --git a/core/res/res/drawable-hdpi/ic_lockscreen_email_normal.png b/core/res/res/drawable-hdpi/ic_lockscreen_email_normal.png
new file mode 100644
index 0000000..480b4dc
Binary files /dev/null and b/core/res/res/drawable-hdpi/ic_lockscreen_email_normal.png differ
diff --git a/core/res/res/drawable-hdpi/ic_lockscreen_facebook_activated.png b/core/res/res/drawable-hdpi/ic_lockscreen_facebook_activated.png
new file mode 100644
index 0000000..493dbdb
Binary files /dev/null and b/core/res/res/drawable-hdpi/ic_lockscreen_facebook_activated.png differ
diff --git a/core/res/res/drawable-hdpi/ic_lockscreen_facebook_normal.png b/core/res/res/drawable-hdpi/ic_lockscreen_facebook_normal.png
new file mode 100644
index 0000000..d9f0c0b
Binary files /dev/null and b/core/res/res/drawable-hdpi/ic_lockscreen_facebook_normal.png differ
diff --git a/core/res/res/drawable-hdpi/ic_lockscreen_gallery_activated.png b/core/res/res/drawable-hdpi/ic_lockscreen_gallery_activated.png
new file mode 100644
index 0000000..e465737
Binary files /dev/null and b/core/res/res/drawable-hdpi/ic_lockscreen_gallery_activated.png differ
diff --git a/core/res/res/drawable-hdpi/ic_lockscreen_gallery_normal.png b/core/res/res/drawable-hdpi/ic_lockscreen_gallery_normal.png
new file mode 100644
index 0000000..b0113a4
Binary files /dev/null and b/core/res/res/drawable-hdpi/ic_lockscreen_gallery_normal.png differ
diff --git a/core/res/res/drawable-hdpi/ic_lockscreen_gplus_activated.png b/core/res/res/drawable-hdpi/ic_lockscreen_gplus_activated.png
new file mode 100644
index 0000000..a526ab7
Binary files /dev/null and b/core/res/res/drawable-hdpi/ic_lockscreen_gplus_activated.png differ
diff --git a/core/res/res/drawable-hdpi/ic_lockscreen_gplus_normal.png b/core/res/res/drawable-hdpi/ic_lockscreen_gplus_normal.png
new file mode 100644
index 0000000..8187db4
Binary files /dev/null and b/core/res/res/drawable-hdpi/ic_lockscreen_gplus_normal.png differ
diff --git a/core/res/res/drawable-hdpi/ic_lockscreen_gtalk_activated.png b/core/res/res/drawable-hdpi/ic_lockscreen_gtalk_activated.png
new file mode 100644
index 0000000..263195d
Binary files /dev/null and b/core/res/res/drawable-hdpi/ic_lockscreen_gtalk_activated.png differ
diff --git a/core/res/res/drawable-hdpi/ic_lockscreen_gtalk_normal.png b/core/res/res/drawable-hdpi/ic_lockscreen_gtalk_normal.png
new file mode 100644
index 0000000..375ed81
Binary files /dev/null and b/core/res/res/drawable-hdpi/ic_lockscreen_gtalk_normal.png differ
diff --git a/core/res/res/drawable-hdpi/ic_lockscreen_lock_pressed.png b/core/res/res/drawable-hdpi/ic_lockscreen_lock_pressed.png
index 0bbf62f..1e2d3ca 100644
Binary files a/core/res/res/drawable-hdpi/ic_lockscreen_lock_pressed.png and b/core/res/res/drawable-hdpi/ic_lockscreen_lock_pressed.png differ
diff --git a/core/res/res/drawable-hdpi/ic_lockscreen_maps_activated.png b/core/res/res/drawable-hdpi/ic_lockscreen_maps_activated.png
new file mode 100644
index 0000000..bba9404
Binary files /dev/null and b/core/res/res/drawable-hdpi/ic_lockscreen_maps_activated.png differ
diff --git a/core/res/res/drawable-hdpi/ic_lockscreen_maps_normal.png b/core/res/res/drawable-hdpi/ic_lockscreen_maps_normal.png
new file mode 100644
index 0000000..de61277
Binary files /dev/null and b/core/res/res/drawable-hdpi/ic_lockscreen_maps_normal.png differ
diff --git a/core/res/res/drawable-hdpi/ic_lockscreen_movie_activated.png b/core/res/res/drawable-hdpi/ic_lockscreen_movie_activated.png
new file mode 100644
index 0000000..68597ef
Binary files /dev/null and b/core/res/res/drawable-hdpi/ic_lockscreen_movie_activated.png differ
diff --git a/core/res/res/drawable-hdpi/ic_lockscreen_movie_normal.png b/core/res/res/drawable-hdpi/ic_lockscreen_movie_normal.png
new file mode 100644
index 0000000..7165666
Binary files /dev/null and b/core/res/res/drawable-hdpi/ic_lockscreen_movie_normal.png differ
diff --git a/core/res/res/drawable-hdpi/ic_lockscreen_music_activated.png b/core/res/res/drawable-hdpi/ic_lockscreen_music_activated.png
new file mode 100644
index 0000000..7ced86b
Binary files /dev/null and b/core/res/res/drawable-hdpi/ic_lockscreen_music_activated.png differ
diff --git a/core/res/res/drawable-hdpi/ic_lockscreen_music_normal.png b/core/res/res/drawable-hdpi/ic_lockscreen_music_normal.png
new file mode 100644
index 0000000..c9c3dcb
Binary files /dev/null and b/core/res/res/drawable-hdpi/ic_lockscreen_music_normal.png differ
diff --git a/core/res/res/drawable-hdpi/ic_lockscreen_nav_activated.png b/core/res/res/drawable-hdpi/ic_lockscreen_nav_activated.png
new file mode 100644
index 0000000..0dead7c
Binary files /dev/null and b/core/res/res/drawable-hdpi/ic_lockscreen_nav_activated.png differ
diff --git a/core/res/res/drawable-hdpi/ic_lockscreen_nav_normal.png b/core/res/res/drawable-hdpi/ic_lockscreen_nav_normal.png
new file mode 100644
index 0000000..8284c01
Binary files /dev/null and b/core/res/res/drawable-hdpi/ic_lockscreen_nav_normal.png differ
diff --git a/core/res/res/drawable-hdpi/ic_lockscreen_phone_activated.png b/core/res/res/drawable-hdpi/ic_lockscreen_phone_activated.png
new file mode 100644
index 0000000..fecc774
Binary files /dev/null and b/core/res/res/drawable-hdpi/ic_lockscreen_phone_activated.png differ
diff --git a/core/res/res/drawable-hdpi/ic_lockscreen_phone_normal.png b/core/res/res/drawable-hdpi/ic_lockscreen_phone_normal.png
new file mode 100644
index 0000000..48fe685
Binary files /dev/null and b/core/res/res/drawable-hdpi/ic_lockscreen_phone_normal.png differ
diff --git a/core/res/res/drawable-hdpi/ic_lockscreen_podcast_activated.png b/core/res/res/drawable-hdpi/ic_lockscreen_podcast_activated.png
new file mode 100644
index 0000000..4884988
Binary files /dev/null and b/core/res/res/drawable-hdpi/ic_lockscreen_podcast_activated.png differ
diff --git a/core/res/res/drawable-hdpi/ic_lockscreen_podcast_normal.png b/core/res/res/drawable-hdpi/ic_lockscreen_podcast_normal.png
new file mode 100644
index 0000000..fa1acab
Binary files /dev/null and b/core/res/res/drawable-hdpi/ic_lockscreen_podcast_normal.png differ
diff --git a/core/res/res/drawable-hdpi/ic_lockscreen_rss_activated.png b/core/res/res/drawable-hdpi/ic_lockscreen_rss_activated.png
new file mode 100644
index 0000000..aba39d5
Binary files /dev/null and b/core/res/res/drawable-hdpi/ic_lockscreen_rss_activated.png differ
diff --git a/core/res/res/drawable-hdpi/ic_lockscreen_rss_normal.png b/core/res/res/drawable-hdpi/ic_lockscreen_rss_normal.png
new file mode 100644
index 0000000..ff6e0de
Binary files /dev/null and b/core/res/res/drawable-hdpi/ic_lockscreen_rss_normal.png differ
diff --git a/core/res/res/drawable-hdpi/ic_lockscreen_sms_activated.png b/core/res/res/drawable-hdpi/ic_lockscreen_sms_activated.png
new file mode 100644
index 0000000..e58b50b
Binary files /dev/null and b/core/res/res/drawable-hdpi/ic_lockscreen_sms_activated.png differ
diff --git a/core/res/res/drawable-hdpi/ic_lockscreen_sms_normal.png b/core/res/res/drawable-hdpi/ic_lockscreen_sms_normal.png
new file mode 100644
index 0000000..0711a52
Binary files /dev/null and b/core/res/res/drawable-hdpi/ic_lockscreen_sms_normal.png differ
diff --git a/core/res/res/drawable-hdpi/ic_lockscreen_target_activated.png b/core/res/res/drawable-hdpi/ic_lockscreen_target_activated.png
new file mode 100644
index 0000000..c5810bf
Binary files /dev/null and b/core/res/res/drawable-hdpi/ic_lockscreen_target_activated.png differ
diff --git a/core/res/res/drawable-hdpi/ic_lockscreen_text_activated.png b/core/res/res/drawable-hdpi/ic_lockscreen_text_activated.png
deleted file mode 100644
index 0ebff0b..0000000
Binary files a/core/res/res/drawable-hdpi/ic_lockscreen_text_activated.png and /dev/null differ
diff --git a/core/res/res/drawable-hdpi/ic_lockscreen_text_focusde.png b/core/res/res/drawable-hdpi/ic_lockscreen_text_focusde.png
deleted file mode 100644
index 5f1b881..0000000
Binary files a/core/res/res/drawable-hdpi/ic_lockscreen_text_focusde.png and /dev/null differ
diff --git a/core/res/res/drawable-hdpi/ic_lockscreen_text_normal.png b/core/res/res/drawable-hdpi/ic_lockscreen_text_normal.png
deleted file mode 100644
index bf73a26..0000000
Binary files a/core/res/res/drawable-hdpi/ic_lockscreen_text_normal.png and /dev/null differ
diff --git a/core/res/res/drawable-hdpi/ic_lockscreen_twitter_activated.png b/core/res/res/drawable-hdpi/ic_lockscreen_twitter_activated.png
new file mode 100644
index 0000000..376e678
Binary files /dev/null and b/core/res/res/drawable-hdpi/ic_lockscreen_twitter_activated.png differ
diff --git a/core/res/res/drawable-hdpi/ic_lockscreen_twitter_normal.png b/core/res/res/drawable-hdpi/ic_lockscreen_twitter_normal.png
new file mode 100644
index 0000000..341fb77
Binary files /dev/null and b/core/res/res/drawable-hdpi/ic_lockscreen_twitter_normal.png differ
diff --git a/core/res/res/drawable-hdpi/stat_sys_tether_bluetooth.png b/core/res/res/drawable-hdpi/stat_sys_tether_bluetooth.png
index 9451174..ab5208e 100644
Binary files a/core/res/res/drawable-hdpi/stat_sys_tether_bluetooth.png and b/core/res/res/drawable-hdpi/stat_sys_tether_bluetooth.png differ
diff --git a/core/res/res/drawable-hdpi/stat_sys_tether_usb.png b/core/res/res/drawable-hdpi/stat_sys_tether_usb.png
index cae1bd1..b40f8d9 100644
Binary files a/core/res/res/drawable-hdpi/stat_sys_tether_usb.png and b/core/res/res/drawable-hdpi/stat_sys_tether_usb.png differ
diff --git a/core/res/res/drawable-hdpi/stat_sys_tether_wifi.png b/core/res/res/drawable-hdpi/stat_sys_tether_wifi.png
index 7d4df50..86c3df3 100644
Binary files a/core/res/res/drawable-hdpi/stat_sys_tether_wifi.png and b/core/res/res/drawable-hdpi/stat_sys_tether_wifi.png differ
diff --git a/core/res/res/drawable-hdpi/weather_0.png b/core/res/res/drawable-hdpi/weather_0.png
new file mode 100644
index 0000000..9e539b6
Binary files /dev/null and b/core/res/res/drawable-hdpi/weather_0.png differ
diff --git a/core/res/res/drawable-hdpi/weather_1.png b/core/res/res/drawable-hdpi/weather_1.png
new file mode 100644
index 0000000..9e539b6
Binary files /dev/null and b/core/res/res/drawable-hdpi/weather_1.png differ
diff --git a/core/res/res/drawable-hdpi/weather_10.png b/core/res/res/drawable-hdpi/weather_10.png
new file mode 100644
index 0000000..daf991e
Binary files /dev/null and b/core/res/res/drawable-hdpi/weather_10.png differ
diff --git a/core/res/res/drawable-hdpi/weather_11.png b/core/res/res/drawable-hdpi/weather_11.png
new file mode 100644
index 0000000..91a74a5
Binary files /dev/null and b/core/res/res/drawable-hdpi/weather_11.png differ
diff --git a/core/res/res/drawable-hdpi/weather_12.png b/core/res/res/drawable-hdpi/weather_12.png
new file mode 100644
index 0000000..91a74a5
Binary files /dev/null and b/core/res/res/drawable-hdpi/weather_12.png differ
diff --git a/core/res/res/drawable-hdpi/weather_13.png b/core/res/res/drawable-hdpi/weather_13.png
new file mode 100644
index 0000000..b2f41a5
Binary files /dev/null and b/core/res/res/drawable-hdpi/weather_13.png differ
diff --git a/core/res/res/drawable-hdpi/weather_14.png b/core/res/res/drawable-hdpi/weather_14.png
new file mode 100644
index 0000000..b2f41a5
Binary files /dev/null and b/core/res/res/drawable-hdpi/weather_14.png differ
diff --git a/core/res/res/drawable-hdpi/weather_15.png b/core/res/res/drawable-hdpi/weather_15.png
new file mode 100644
index 0000000..2e92b35
Binary files /dev/null and b/core/res/res/drawable-hdpi/weather_15.png differ
diff --git a/core/res/res/drawable-hdpi/weather_16.png b/core/res/res/drawable-hdpi/weather_16.png
new file mode 100644
index 0000000..bf4564c
Binary files /dev/null and b/core/res/res/drawable-hdpi/weather_16.png differ
diff --git a/core/res/res/drawable-hdpi/weather_17.png b/core/res/res/drawable-hdpi/weather_17.png
new file mode 100644
index 0000000..f7948c1
Binary files /dev/null and b/core/res/res/drawable-hdpi/weather_17.png differ
diff --git a/core/res/res/drawable-hdpi/weather_18.png b/core/res/res/drawable-hdpi/weather_18.png
new file mode 100644
index 0000000..802a80f
Binary files /dev/null and b/core/res/res/drawable-hdpi/weather_18.png differ
diff --git a/core/res/res/drawable-hdpi/weather_19.png b/core/res/res/drawable-hdpi/weather_19.png
new file mode 100644
index 0000000..b67ba5e
Binary files /dev/null and b/core/res/res/drawable-hdpi/weather_19.png differ
diff --git a/core/res/res/drawable-hdpi/weather_2.png b/core/res/res/drawable-hdpi/weather_2.png
new file mode 100644
index 0000000..9e539b6
Binary files /dev/null and b/core/res/res/drawable-hdpi/weather_2.png differ
diff --git a/core/res/res/drawable-hdpi/weather_20.png b/core/res/res/drawable-hdpi/weather_20.png
new file mode 100644
index 0000000..fd40f33
Binary files /dev/null and b/core/res/res/drawable-hdpi/weather_20.png differ
diff --git a/core/res/res/drawable-hdpi/weather_21.png b/core/res/res/drawable-hdpi/weather_21.png
new file mode 100644
index 0000000..8349b21
Binary files /dev/null and b/core/res/res/drawable-hdpi/weather_21.png differ
diff --git a/core/res/res/drawable-hdpi/weather_22.png b/core/res/res/drawable-hdpi/weather_22.png
new file mode 100644
index 0000000..b67ba5e
Binary files /dev/null and b/core/res/res/drawable-hdpi/weather_22.png differ
diff --git a/core/res/res/drawable-hdpi/weather_23.png b/core/res/res/drawable-hdpi/weather_23.png
new file mode 100644
index 0000000..ca015be
Binary files /dev/null and b/core/res/res/drawable-hdpi/weather_23.png differ
diff --git a/core/res/res/drawable-hdpi/weather_24.png b/core/res/res/drawable-hdpi/weather_24.png
new file mode 100644
index 0000000..ca015be
Binary files /dev/null and b/core/res/res/drawable-hdpi/weather_24.png differ
diff --git a/core/res/res/drawable-hdpi/weather_25.png b/core/res/res/drawable-hdpi/weather_25.png
new file mode 100644
index 0000000..32cb0d8
Binary files /dev/null and b/core/res/res/drawable-hdpi/weather_25.png differ
diff --git a/core/res/res/drawable-hdpi/weather_26.png b/core/res/res/drawable-hdpi/weather_26.png
new file mode 100644
index 0000000..ce9761a
Binary files /dev/null and b/core/res/res/drawable-hdpi/weather_26.png differ
diff --git a/core/res/res/drawable-hdpi/weather_27.png b/core/res/res/drawable-hdpi/weather_27.png
new file mode 100644
index 0000000..67433a7
Binary files /dev/null and b/core/res/res/drawable-hdpi/weather_27.png differ
diff --git a/core/res/res/drawable-hdpi/weather_28.png b/core/res/res/drawable-hdpi/weather_28.png
new file mode 100644
index 0000000..43f3df8
Binary files /dev/null and b/core/res/res/drawable-hdpi/weather_28.png differ
diff --git a/core/res/res/drawable-hdpi/weather_29.png b/core/res/res/drawable-hdpi/weather_29.png
new file mode 100644
index 0000000..67433a7
Binary files /dev/null and b/core/res/res/drawable-hdpi/weather_29.png differ
diff --git a/core/res/res/drawable-hdpi/weather_3.png b/core/res/res/drawable-hdpi/weather_3.png
new file mode 100644
index 0000000..708a2e6
Binary files /dev/null and b/core/res/res/drawable-hdpi/weather_3.png differ
diff --git a/core/res/res/drawable-hdpi/weather_30.png b/core/res/res/drawable-hdpi/weather_30.png
new file mode 100644
index 0000000..43f3df8
Binary files /dev/null and b/core/res/res/drawable-hdpi/weather_30.png differ
diff --git a/core/res/res/drawable-hdpi/weather_31.png b/core/res/res/drawable-hdpi/weather_31.png
new file mode 100644
index 0000000..d545d77
Binary files /dev/null and b/core/res/res/drawable-hdpi/weather_31.png differ
diff --git a/core/res/res/drawable-hdpi/weather_32.png b/core/res/res/drawable-hdpi/weather_32.png
new file mode 100644
index 0000000..c55e4b3
Binary files /dev/null and b/core/res/res/drawable-hdpi/weather_32.png differ
diff --git a/core/res/res/drawable-hdpi/weather_33.png b/core/res/res/drawable-hdpi/weather_33.png
new file mode 100644
index 0000000..d545d77
Binary files /dev/null and b/core/res/res/drawable-hdpi/weather_33.png differ
diff --git a/core/res/res/drawable-hdpi/weather_34.png b/core/res/res/drawable-hdpi/weather_34.png
new file mode 100644
index 0000000..c55e4b3
Binary files /dev/null and b/core/res/res/drawable-hdpi/weather_34.png differ
diff --git a/core/res/res/drawable-hdpi/weather_35.png b/core/res/res/drawable-hdpi/weather_35.png
new file mode 100644
index 0000000..3cd1b81
Binary files /dev/null and b/core/res/res/drawable-hdpi/weather_35.png differ
diff --git a/core/res/res/drawable-hdpi/weather_36.png b/core/res/res/drawable-hdpi/weather_36.png
new file mode 100644
index 0000000..06cb774
Binary files /dev/null and b/core/res/res/drawable-hdpi/weather_36.png differ
diff --git a/core/res/res/drawable-hdpi/weather_37.png b/core/res/res/drawable-hdpi/weather_37.png
new file mode 100644
index 0000000..8b2c4d1
Binary files /dev/null and b/core/res/res/drawable-hdpi/weather_37.png differ
diff --git a/core/res/res/drawable-hdpi/weather_38.png b/core/res/res/drawable-hdpi/weather_38.png
new file mode 100644
index 0000000..f0509ef
Binary files /dev/null and b/core/res/res/drawable-hdpi/weather_38.png differ
diff --git a/core/res/res/drawable-hdpi/weather_39.png b/core/res/res/drawable-hdpi/weather_39.png
new file mode 100644
index 0000000..8b2c4d1
Binary files /dev/null and b/core/res/res/drawable-hdpi/weather_39.png differ
diff --git a/core/res/res/drawable-hdpi/weather_4.png b/core/res/res/drawable-hdpi/weather_4.png
new file mode 100644
index 0000000..708a2e6
Binary files /dev/null and b/core/res/res/drawable-hdpi/weather_4.png differ
diff --git a/core/res/res/drawable-hdpi/weather_40.png b/core/res/res/drawable-hdpi/weather_40.png
new file mode 100644
index 0000000..fb3c06d
Binary files /dev/null and b/core/res/res/drawable-hdpi/weather_40.png differ
diff --git a/core/res/res/drawable-hdpi/weather_41.png b/core/res/res/drawable-hdpi/weather_41.png
new file mode 100644
index 0000000..bf4564c
Binary files /dev/null and b/core/res/res/drawable-hdpi/weather_41.png differ
diff --git a/core/res/res/drawable-hdpi/weather_42.png b/core/res/res/drawable-hdpi/weather_42.png
new file mode 100644
index 0000000..7b81366
Binary files /dev/null and b/core/res/res/drawable-hdpi/weather_42.png differ
diff --git a/core/res/res/drawable-hdpi/weather_43.png b/core/res/res/drawable-hdpi/weather_43.png
new file mode 100644
index 0000000..bf4564c
Binary files /dev/null and b/core/res/res/drawable-hdpi/weather_43.png differ
diff --git a/core/res/res/drawable-hdpi/weather_44.png b/core/res/res/drawable-hdpi/weather_44.png
new file mode 100644
index 0000000..67433a7
Binary files /dev/null and b/core/res/res/drawable-hdpi/weather_44.png differ
diff --git a/core/res/res/drawable-hdpi/weather_45.png b/core/res/res/drawable-hdpi/weather_45.png
new file mode 100644
index 0000000..708a2e6
Binary files /dev/null and b/core/res/res/drawable-hdpi/weather_45.png differ
diff --git a/core/res/res/drawable-hdpi/weather_46.png b/core/res/res/drawable-hdpi/weather_46.png
new file mode 100644
index 0000000..b2f41a5
Binary files /dev/null and b/core/res/res/drawable-hdpi/weather_46.png differ
diff --git a/core/res/res/drawable-hdpi/weather_47.png b/core/res/res/drawable-hdpi/weather_47.png
new file mode 100644
index 0000000..f0509ef
Binary files /dev/null and b/core/res/res/drawable-hdpi/weather_47.png differ
diff --git a/core/res/res/drawable-hdpi/weather_5.png b/core/res/res/drawable-hdpi/weather_5.png
new file mode 100644
index 0000000..802a80f
Binary files /dev/null and b/core/res/res/drawable-hdpi/weather_5.png differ
diff --git a/core/res/res/drawable-hdpi/weather_6.png b/core/res/res/drawable-hdpi/weather_6.png
new file mode 100644
index 0000000..802a80f
Binary files /dev/null and b/core/res/res/drawable-hdpi/weather_6.png differ
diff --git a/core/res/res/drawable-hdpi/weather_7.png b/core/res/res/drawable-hdpi/weather_7.png
new file mode 100644
index 0000000..802a80f
Binary files /dev/null and b/core/res/res/drawable-hdpi/weather_7.png differ
diff --git a/core/res/res/drawable-hdpi/weather_8.png b/core/res/res/drawable-hdpi/weather_8.png
new file mode 100644
index 0000000..e36a680
Binary files /dev/null and b/core/res/res/drawable-hdpi/weather_8.png differ
diff --git a/core/res/res/drawable-hdpi/weather_9.png b/core/res/res/drawable-hdpi/weather_9.png
new file mode 100644
index 0000000..7651b3e
Binary files /dev/null and b/core/res/res/drawable-hdpi/weather_9.png differ
diff --git a/core/res/res/drawable-hdpi/weather_na.png b/core/res/res/drawable-hdpi/weather_na.png
new file mode 100644
index 0000000..4a43283
Binary files /dev/null and b/core/res/res/drawable-hdpi/weather_na.png differ
diff --git a/core/res/res/drawable-ldpi/ic_lock_reboot.png b/core/res/res/drawable-ldpi/ic_lock_reboot.png
new file mode 100644
index 0000000..b96d099
Binary files /dev/null and b/core/res/res/drawable-ldpi/ic_lock_reboot.png differ
diff --git a/core/res/res/drawable-ldpi/ic_lock_screenshot.png b/core/res/res/drawable-ldpi/ic_lock_screenshot.png
new file mode 100644
index 0000000..60e91ef
Binary files /dev/null and b/core/res/res/drawable-ldpi/ic_lock_screenshot.png differ
diff --git a/core/res/res/drawable-ldpi/stat_sys_adb.png b/core/res/res/drawable-ldpi/stat_sys_adb.png
index 86b945b..7cf15b9 100644
Binary files a/core/res/res/drawable-ldpi/stat_sys_adb.png and b/core/res/res/drawable-ldpi/stat_sys_adb.png differ
diff --git a/core/res/res/drawable-mdpi/ic_lock_idle_calendar.png b/core/res/res/drawable-mdpi/ic_lock_idle_calendar.png
new file mode 100644
index 0000000..2834c8f
Binary files /dev/null and b/core/res/res/drawable-mdpi/ic_lock_idle_calendar.png differ
diff --git a/core/res/res/drawable-mdpi/ic_lock_profile.png b/core/res/res/drawable-mdpi/ic_lock_profile.png
new file mode 100644
index 0000000..d47ba16
Binary files /dev/null and b/core/res/res/drawable-mdpi/ic_lock_profile.png differ
diff --git a/core/res/res/drawable-mdpi/ic_lock_reboot.png b/core/res/res/drawable-mdpi/ic_lock_reboot.png
new file mode 100644
index 0000000..2b125b9
Binary files /dev/null and b/core/res/res/drawable-mdpi/ic_lock_reboot.png differ
diff --git a/core/res/res/drawable-mdpi/ic_lock_screenshot.png b/core/res/res/drawable-mdpi/ic_lock_screenshot.png
new file mode 100644
index 0000000..9996e72
Binary files /dev/null and b/core/res/res/drawable-mdpi/ic_lock_screenshot.png differ
diff --git a/core/res/res/drawable-mdpi/ic_lockscreen_alarm_activated.png b/core/res/res/drawable-mdpi/ic_lockscreen_alarm_activated.png
new file mode 100644
index 0000000..3e6bf27
Binary files /dev/null and b/core/res/res/drawable-mdpi/ic_lockscreen_alarm_activated.png differ
diff --git a/core/res/res/drawable-mdpi/ic_lockscreen_alarm_normal.png b/core/res/res/drawable-mdpi/ic_lockscreen_alarm_normal.png
new file mode 100644
index 0000000..e7cd0fe
Binary files /dev/null and b/core/res/res/drawable-mdpi/ic_lockscreen_alarm_normal.png differ
diff --git a/core/res/res/drawable-mdpi/ic_lockscreen_browser_activated.png b/core/res/res/drawable-mdpi/ic_lockscreen_browser_activated.png
new file mode 100644
index 0000000..12898f5
Binary files /dev/null and b/core/res/res/drawable-mdpi/ic_lockscreen_browser_activated.png differ
diff --git a/core/res/res/drawable-mdpi/ic_lockscreen_browser_normal.png b/core/res/res/drawable-mdpi/ic_lockscreen_browser_normal.png
new file mode 100644
index 0000000..e857ecd
Binary files /dev/null and b/core/res/res/drawable-mdpi/ic_lockscreen_browser_normal.png differ
diff --git a/core/res/res/drawable-mdpi/ic_lockscreen_calendar_activated.png b/core/res/res/drawable-mdpi/ic_lockscreen_calendar_activated.png
new file mode 100644
index 0000000..19ec569
Binary files /dev/null and b/core/res/res/drawable-mdpi/ic_lockscreen_calendar_activated.png differ
diff --git a/core/res/res/drawable-mdpi/ic_lockscreen_calendar_normal.png b/core/res/res/drawable-mdpi/ic_lockscreen_calendar_normal.png
new file mode 100644
index 0000000..d1f274c
Binary files /dev/null and b/core/res/res/drawable-mdpi/ic_lockscreen_calendar_normal.png differ
diff --git a/core/res/res/drawable-mdpi/ic_lockscreen_camera_activated.png b/core/res/res/drawable-mdpi/ic_lockscreen_camera_activated.png
index 862f33b..69f254e 100644
Binary files a/core/res/res/drawable-mdpi/ic_lockscreen_camera_activated.png and b/core/res/res/drawable-mdpi/ic_lockscreen_camera_activated.png differ
diff --git a/core/res/res/drawable-mdpi/ic_lockscreen_camera_normal.png b/core/res/res/drawable-mdpi/ic_lockscreen_camera_normal.png
index 30df0a3..bc179d1 100644
Binary files a/core/res/res/drawable-mdpi/ic_lockscreen_camera_normal.png and b/core/res/res/drawable-mdpi/ic_lockscreen_camera_normal.png differ
diff --git a/core/res/res/drawable-mdpi/ic_lockscreen_email_activated.png b/core/res/res/drawable-mdpi/ic_lockscreen_email_activated.png
new file mode 100644
index 0000000..116e8af
Binary files /dev/null and b/core/res/res/drawable-mdpi/ic_lockscreen_email_activated.png differ
diff --git a/core/res/res/drawable-mdpi/ic_lockscreen_email_normal.png b/core/res/res/drawable-mdpi/ic_lockscreen_email_normal.png
new file mode 100644
index 0000000..1f466e6
Binary files /dev/null and b/core/res/res/drawable-mdpi/ic_lockscreen_email_normal.png differ
diff --git a/core/res/res/drawable-mdpi/ic_lockscreen_facebook_activated.png b/core/res/res/drawable-mdpi/ic_lockscreen_facebook_activated.png
new file mode 100644
index 0000000..9437476
Binary files /dev/null and b/core/res/res/drawable-mdpi/ic_lockscreen_facebook_activated.png differ
diff --git a/core/res/res/drawable-mdpi/ic_lockscreen_facebook_normal.png b/core/res/res/drawable-mdpi/ic_lockscreen_facebook_normal.png
new file mode 100644
index 0000000..c8100f4
Binary files /dev/null and b/core/res/res/drawable-mdpi/ic_lockscreen_facebook_normal.png differ
diff --git a/core/res/res/drawable-mdpi/ic_lockscreen_gallery_activated.png b/core/res/res/drawable-mdpi/ic_lockscreen_gallery_activated.png
new file mode 100644
index 0000000..f443923
Binary files /dev/null and b/core/res/res/drawable-mdpi/ic_lockscreen_gallery_activated.png differ
diff --git a/core/res/res/drawable-mdpi/ic_lockscreen_gallery_normal.png b/core/res/res/drawable-mdpi/ic_lockscreen_gallery_normal.png
new file mode 100644
index 0000000..151db41
Binary files /dev/null and b/core/res/res/drawable-mdpi/ic_lockscreen_gallery_normal.png differ
diff --git a/core/res/res/drawable-mdpi/ic_lockscreen_gplus_activated.png b/core/res/res/drawable-mdpi/ic_lockscreen_gplus_activated.png
new file mode 100644
index 0000000..9b0c0cc
Binary files /dev/null and b/core/res/res/drawable-mdpi/ic_lockscreen_gplus_activated.png differ
diff --git a/core/res/res/drawable-mdpi/ic_lockscreen_gplus_normal.png b/core/res/res/drawable-mdpi/ic_lockscreen_gplus_normal.png
new file mode 100644
index 0000000..acc280e
Binary files /dev/null and b/core/res/res/drawable-mdpi/ic_lockscreen_gplus_normal.png differ
diff --git a/core/res/res/drawable-mdpi/ic_lockscreen_gtalk_activated.png b/core/res/res/drawable-mdpi/ic_lockscreen_gtalk_activated.png
new file mode 100644
index 0000000..62b71d6
Binary files /dev/null and b/core/res/res/drawable-mdpi/ic_lockscreen_gtalk_activated.png differ
diff --git a/core/res/res/drawable-mdpi/ic_lockscreen_gtalk_normal.png b/core/res/res/drawable-mdpi/ic_lockscreen_gtalk_normal.png
new file mode 100644
index 0000000..86df9fb
Binary files /dev/null and b/core/res/res/drawable-mdpi/ic_lockscreen_gtalk_normal.png differ
diff --git a/core/res/res/drawable-mdpi/ic_lockscreen_lock_pressed.png b/core/res/res/drawable-mdpi/ic_lockscreen_lock_pressed.png
index aab2f6b..d9f5e04 100644
Binary files a/core/res/res/drawable-mdpi/ic_lockscreen_lock_pressed.png and b/core/res/res/drawable-mdpi/ic_lockscreen_lock_pressed.png differ
diff --git a/core/res/res/drawable-mdpi/ic_lockscreen_maps_activated.png b/core/res/res/drawable-mdpi/ic_lockscreen_maps_activated.png
new file mode 100644
index 0000000..1d86e3f
Binary files /dev/null and b/core/res/res/drawable-mdpi/ic_lockscreen_maps_activated.png differ
diff --git a/core/res/res/drawable-mdpi/ic_lockscreen_maps_normal.png b/core/res/res/drawable-mdpi/ic_lockscreen_maps_normal.png
new file mode 100644
index 0000000..3387fb4
Binary files /dev/null and b/core/res/res/drawable-mdpi/ic_lockscreen_maps_normal.png differ
diff --git a/core/res/res/drawable-mdpi/ic_lockscreen_movie_activated.png b/core/res/res/drawable-mdpi/ic_lockscreen_movie_activated.png
new file mode 100644
index 0000000..242fa51
Binary files /dev/null and b/core/res/res/drawable-mdpi/ic_lockscreen_movie_activated.png differ
diff --git a/core/res/res/drawable-mdpi/ic_lockscreen_movie_normal.png b/core/res/res/drawable-mdpi/ic_lockscreen_movie_normal.png
new file mode 100644
index 0000000..ae4d9b4
Binary files /dev/null and b/core/res/res/drawable-mdpi/ic_lockscreen_movie_normal.png differ
diff --git a/core/res/res/drawable-mdpi/ic_lockscreen_music_activated.png b/core/res/res/drawable-mdpi/ic_lockscreen_music_activated.png
new file mode 100644
index 0000000..5f3ab91
Binary files /dev/null and b/core/res/res/drawable-mdpi/ic_lockscreen_music_activated.png differ
diff --git a/core/res/res/drawable-mdpi/ic_lockscreen_music_normal.png b/core/res/res/drawable-mdpi/ic_lockscreen_music_normal.png
new file mode 100644
index 0000000..39faf74
Binary files /dev/null and b/core/res/res/drawable-mdpi/ic_lockscreen_music_normal.png differ
diff --git a/core/res/res/drawable-mdpi/ic_lockscreen_nav_activated.png b/core/res/res/drawable-mdpi/ic_lockscreen_nav_activated.png
new file mode 100644
index 0000000..300e885
Binary files /dev/null and b/core/res/res/drawable-mdpi/ic_lockscreen_nav_activated.png differ
diff --git a/core/res/res/drawable-mdpi/ic_lockscreen_nav_normal.png b/core/res/res/drawable-mdpi/ic_lockscreen_nav_normal.png
new file mode 100644
index 0000000..04e5bab
Binary files /dev/null and b/core/res/res/drawable-mdpi/ic_lockscreen_nav_normal.png differ
diff --git a/core/res/res/drawable-mdpi/ic_lockscreen_phone_activated.png b/core/res/res/drawable-mdpi/ic_lockscreen_phone_activated.png
new file mode 100644
index 0000000..1cb40ba
Binary files /dev/null and b/core/res/res/drawable-mdpi/ic_lockscreen_phone_activated.png differ
diff --git a/core/res/res/drawable-mdpi/ic_lockscreen_phone_normal.png b/core/res/res/drawable-mdpi/ic_lockscreen_phone_normal.png
new file mode 100644
index 0000000..4f7a2bb
Binary files /dev/null and b/core/res/res/drawable-mdpi/ic_lockscreen_phone_normal.png differ
diff --git a/core/res/res/drawable-mdpi/ic_lockscreen_podcast_activated.png b/core/res/res/drawable-mdpi/ic_lockscreen_podcast_activated.png
new file mode 100644
index 0000000..714bdc3
Binary files /dev/null and b/core/res/res/drawable-mdpi/ic_lockscreen_podcast_activated.png differ
diff --git a/core/res/res/drawable-mdpi/ic_lockscreen_podcast_normal.png b/core/res/res/drawable-mdpi/ic_lockscreen_podcast_normal.png
new file mode 100644
index 0000000..ceda3f9
Binary files /dev/null and b/core/res/res/drawable-mdpi/ic_lockscreen_podcast_normal.png differ
diff --git a/core/res/res/drawable-mdpi/ic_lockscreen_rss_activated.png b/core/res/res/drawable-mdpi/ic_lockscreen_rss_activated.png
new file mode 100644
index 0000000..dc113fa
Binary files /dev/null and b/core/res/res/drawable-mdpi/ic_lockscreen_rss_activated.png differ
diff --git a/core/res/res/drawable-mdpi/ic_lockscreen_rss_normal.png b/core/res/res/drawable-mdpi/ic_lockscreen_rss_normal.png
new file mode 100644
index 0000000..e802305
Binary files /dev/null and b/core/res/res/drawable-mdpi/ic_lockscreen_rss_normal.png differ
diff --git a/core/res/res/drawable-mdpi/ic_lockscreen_sms_activated.png b/core/res/res/drawable-mdpi/ic_lockscreen_sms_activated.png
new file mode 100644
index 0000000..0fda783
Binary files /dev/null and b/core/res/res/drawable-mdpi/ic_lockscreen_sms_activated.png differ
diff --git a/core/res/res/drawable-mdpi/ic_lockscreen_sms_normal.png b/core/res/res/drawable-mdpi/ic_lockscreen_sms_normal.png
new file mode 100644
index 0000000..fd4771e
Binary files /dev/null and b/core/res/res/drawable-mdpi/ic_lockscreen_sms_normal.png differ
diff --git a/core/res/res/drawable-mdpi/ic_lockscreen_target_activated.png b/core/res/res/drawable-mdpi/ic_lockscreen_target_activated.png
new file mode 100644
index 0000000..f810ae1
Binary files /dev/null and b/core/res/res/drawable-mdpi/ic_lockscreen_target_activated.png differ
diff --git a/core/res/res/drawable-mdpi/ic_lockscreen_twitter_activated.png b/core/res/res/drawable-mdpi/ic_lockscreen_twitter_activated.png
new file mode 100644
index 0000000..5f66e9c
Binary files /dev/null and b/core/res/res/drawable-mdpi/ic_lockscreen_twitter_activated.png differ
diff --git a/core/res/res/drawable-mdpi/ic_lockscreen_twitter_normal.png b/core/res/res/drawable-mdpi/ic_lockscreen_twitter_normal.png
new file mode 100644
index 0000000..5c746b2
Binary files /dev/null and b/core/res/res/drawable-mdpi/ic_lockscreen_twitter_normal.png differ
diff --git a/core/res/res/drawable-mdpi/stat_sys_tether_bluetooth.png b/core/res/res/drawable-mdpi/stat_sys_tether_bluetooth.png
index f42dae0..fc620b8 100644
Binary files a/core/res/res/drawable-mdpi/stat_sys_tether_bluetooth.png and b/core/res/res/drawable-mdpi/stat_sys_tether_bluetooth.png differ
diff --git a/core/res/res/drawable-mdpi/stat_sys_tether_usb.png b/core/res/res/drawable-mdpi/stat_sys_tether_usb.png
index 2e2b8ca..0915809 100644
Binary files a/core/res/res/drawable-mdpi/stat_sys_tether_usb.png and b/core/res/res/drawable-mdpi/stat_sys_tether_usb.png differ
diff --git a/core/res/res/drawable-mdpi/stat_sys_tether_wifi.png b/core/res/res/drawable-mdpi/stat_sys_tether_wifi.png
index 869ad35..584dc1f 100644
Binary files a/core/res/res/drawable-mdpi/stat_sys_tether_wifi.png and b/core/res/res/drawable-mdpi/stat_sys_tether_wifi.png differ
diff --git a/core/res/res/drawable-mdpi/weather_0.png b/core/res/res/drawable-mdpi/weather_0.png
new file mode 100644
index 0000000..1553c55
Binary files /dev/null and b/core/res/res/drawable-mdpi/weather_0.png differ
diff --git a/core/res/res/drawable-mdpi/weather_1.png b/core/res/res/drawable-mdpi/weather_1.png
new file mode 100644
index 0000000..1553c55
Binary files /dev/null and b/core/res/res/drawable-mdpi/weather_1.png differ
diff --git a/core/res/res/drawable-mdpi/weather_10.png b/core/res/res/drawable-mdpi/weather_10.png
new file mode 100644
index 0000000..c44b8f7
Binary files /dev/null and b/core/res/res/drawable-mdpi/weather_10.png differ
diff --git a/core/res/res/drawable-mdpi/weather_11.png b/core/res/res/drawable-mdpi/weather_11.png
new file mode 100644
index 0000000..ee01b1cf
Binary files /dev/null and b/core/res/res/drawable-mdpi/weather_11.png differ
diff --git a/core/res/res/drawable-mdpi/weather_12.png b/core/res/res/drawable-mdpi/weather_12.png
new file mode 100644
index 0000000..ee01b1cf
Binary files /dev/null and b/core/res/res/drawable-mdpi/weather_12.png differ
diff --git a/core/res/res/drawable-mdpi/weather_13.png b/core/res/res/drawable-mdpi/weather_13.png
new file mode 100644
index 0000000..c922139
Binary files /dev/null and b/core/res/res/drawable-mdpi/weather_13.png differ
diff --git a/core/res/res/drawable-mdpi/weather_14.png b/core/res/res/drawable-mdpi/weather_14.png
new file mode 100644
index 0000000..c922139
Binary files /dev/null and b/core/res/res/drawable-mdpi/weather_14.png differ
diff --git a/core/res/res/drawable-mdpi/weather_15.png b/core/res/res/drawable-mdpi/weather_15.png
new file mode 100644
index 0000000..27dbc3f
Binary files /dev/null and b/core/res/res/drawable-mdpi/weather_15.png differ
diff --git a/core/res/res/drawable-mdpi/weather_16.png b/core/res/res/drawable-mdpi/weather_16.png
new file mode 100644
index 0000000..d575139
Binary files /dev/null and b/core/res/res/drawable-mdpi/weather_16.png differ
diff --git a/core/res/res/drawable-mdpi/weather_17.png b/core/res/res/drawable-mdpi/weather_17.png
new file mode 100644
index 0000000..7ac7828
Binary files /dev/null and b/core/res/res/drawable-mdpi/weather_17.png differ
diff --git a/core/res/res/drawable-mdpi/weather_18.png b/core/res/res/drawable-mdpi/weather_18.png
new file mode 100644
index 0000000..a1ae654
Binary files /dev/null and b/core/res/res/drawable-mdpi/weather_18.png differ
diff --git a/core/res/res/drawable-mdpi/weather_19.png b/core/res/res/drawable-mdpi/weather_19.png
new file mode 100644
index 0000000..b750e26
Binary files /dev/null and b/core/res/res/drawable-mdpi/weather_19.png differ
diff --git a/core/res/res/drawable-mdpi/weather_2.png b/core/res/res/drawable-mdpi/weather_2.png
new file mode 100644
index 0000000..1553c55
Binary files /dev/null and b/core/res/res/drawable-mdpi/weather_2.png differ
diff --git a/core/res/res/drawable-mdpi/weather_20.png b/core/res/res/drawable-mdpi/weather_20.png
new file mode 100644
index 0000000..8790ddd
Binary files /dev/null and b/core/res/res/drawable-mdpi/weather_20.png differ
diff --git a/core/res/res/drawable-mdpi/weather_21.png b/core/res/res/drawable-mdpi/weather_21.png
new file mode 100644
index 0000000..242ab7a
Binary files /dev/null and b/core/res/res/drawable-mdpi/weather_21.png differ
diff --git a/core/res/res/drawable-mdpi/weather_22.png b/core/res/res/drawable-mdpi/weather_22.png
new file mode 100644
index 0000000..b750e26
Binary files /dev/null and b/core/res/res/drawable-mdpi/weather_22.png differ
diff --git a/core/res/res/drawable-mdpi/weather_23.png b/core/res/res/drawable-mdpi/weather_23.png
new file mode 100644
index 0000000..ddefbf1
Binary files /dev/null and b/core/res/res/drawable-mdpi/weather_23.png differ
diff --git a/core/res/res/drawable-mdpi/weather_24.png b/core/res/res/drawable-mdpi/weather_24.png
new file mode 100644
index 0000000..ddefbf1
Binary files /dev/null and b/core/res/res/drawable-mdpi/weather_24.png differ
diff --git a/core/res/res/drawable-mdpi/weather_25.png b/core/res/res/drawable-mdpi/weather_25.png
new file mode 100644
index 0000000..766d094
Binary files /dev/null and b/core/res/res/drawable-mdpi/weather_25.png differ
diff --git a/core/res/res/drawable-mdpi/weather_26.png b/core/res/res/drawable-mdpi/weather_26.png
new file mode 100644
index 0000000..1445f9e
Binary files /dev/null and b/core/res/res/drawable-mdpi/weather_26.png differ
diff --git a/core/res/res/drawable-mdpi/weather_27.png b/core/res/res/drawable-mdpi/weather_27.png
new file mode 100644
index 0000000..3835d5b
Binary files /dev/null and b/core/res/res/drawable-mdpi/weather_27.png differ
diff --git a/core/res/res/drawable-mdpi/weather_28.png b/core/res/res/drawable-mdpi/weather_28.png
new file mode 100644
index 0000000..a362aaf
Binary files /dev/null and b/core/res/res/drawable-mdpi/weather_28.png differ
diff --git a/core/res/res/drawable-mdpi/weather_29.png b/core/res/res/drawable-mdpi/weather_29.png
new file mode 100644
index 0000000..3835d5b
Binary files /dev/null and b/core/res/res/drawable-mdpi/weather_29.png differ
diff --git a/core/res/res/drawable-mdpi/weather_3.png b/core/res/res/drawable-mdpi/weather_3.png
new file mode 100644
index 0000000..0fd0158
Binary files /dev/null and b/core/res/res/drawable-mdpi/weather_3.png differ
diff --git a/core/res/res/drawable-mdpi/weather_30.png b/core/res/res/drawable-mdpi/weather_30.png
new file mode 100644
index 0000000..a362aaf
Binary files /dev/null and b/core/res/res/drawable-mdpi/weather_30.png differ
diff --git a/core/res/res/drawable-mdpi/weather_31.png b/core/res/res/drawable-mdpi/weather_31.png
new file mode 100644
index 0000000..886b845
Binary files /dev/null and b/core/res/res/drawable-mdpi/weather_31.png differ
diff --git a/core/res/res/drawable-mdpi/weather_32.png b/core/res/res/drawable-mdpi/weather_32.png
new file mode 100644
index 0000000..4e6827a
Binary files /dev/null and b/core/res/res/drawable-mdpi/weather_32.png differ
diff --git a/core/res/res/drawable-mdpi/weather_33.png b/core/res/res/drawable-mdpi/weather_33.png
new file mode 100644
index 0000000..886b845
Binary files /dev/null and b/core/res/res/drawable-mdpi/weather_33.png differ
diff --git a/core/res/res/drawable-mdpi/weather_34.png b/core/res/res/drawable-mdpi/weather_34.png
new file mode 100644
index 0000000..4e6827a
Binary files /dev/null and b/core/res/res/drawable-mdpi/weather_34.png differ
diff --git a/core/res/res/drawable-mdpi/weather_35.png b/core/res/res/drawable-mdpi/weather_35.png
new file mode 100644
index 0000000..b8ba7c4
Binary files /dev/null and b/core/res/res/drawable-mdpi/weather_35.png differ
diff --git a/core/res/res/drawable-mdpi/weather_36.png b/core/res/res/drawable-mdpi/weather_36.png
new file mode 100644
index 0000000..005295a
Binary files /dev/null and b/core/res/res/drawable-mdpi/weather_36.png differ
diff --git a/core/res/res/drawable-mdpi/weather_37.png b/core/res/res/drawable-mdpi/weather_37.png
new file mode 100644
index 0000000..290e2a2
Binary files /dev/null and b/core/res/res/drawable-mdpi/weather_37.png differ
diff --git a/core/res/res/drawable-mdpi/weather_38.png b/core/res/res/drawable-mdpi/weather_38.png
new file mode 100644
index 0000000..92785f5
Binary files /dev/null and b/core/res/res/drawable-mdpi/weather_38.png differ
diff --git a/core/res/res/drawable-mdpi/weather_39.png b/core/res/res/drawable-mdpi/weather_39.png
new file mode 100644
index 0000000..290e2a2
Binary files /dev/null and b/core/res/res/drawable-mdpi/weather_39.png differ
diff --git a/core/res/res/drawable-mdpi/weather_4.png b/core/res/res/drawable-mdpi/weather_4.png
new file mode 100644
index 0000000..0fd0158
Binary files /dev/null and b/core/res/res/drawable-mdpi/weather_4.png differ
diff --git a/core/res/res/drawable-mdpi/weather_40.png b/core/res/res/drawable-mdpi/weather_40.png
new file mode 100644
index 0000000..25fbd20
Binary files /dev/null and b/core/res/res/drawable-mdpi/weather_40.png differ
diff --git a/core/res/res/drawable-mdpi/weather_41.png b/core/res/res/drawable-mdpi/weather_41.png
new file mode 100644
index 0000000..d575139
Binary files /dev/null and b/core/res/res/drawable-mdpi/weather_41.png differ
diff --git a/core/res/res/drawable-mdpi/weather_42.png b/core/res/res/drawable-mdpi/weather_42.png
new file mode 100644
index 0000000..f259805
Binary files /dev/null and b/core/res/res/drawable-mdpi/weather_42.png differ
diff --git a/core/res/res/drawable-mdpi/weather_43.png b/core/res/res/drawable-mdpi/weather_43.png
new file mode 100644
index 0000000..d575139
Binary files /dev/null and b/core/res/res/drawable-mdpi/weather_43.png differ
diff --git a/core/res/res/drawable-mdpi/weather_44.png b/core/res/res/drawable-mdpi/weather_44.png
new file mode 100644
index 0000000..3835d5b
Binary files /dev/null and b/core/res/res/drawable-mdpi/weather_44.png differ
diff --git a/core/res/res/drawable-mdpi/weather_45.png b/core/res/res/drawable-mdpi/weather_45.png
new file mode 100644
index 0000000..0fd0158
Binary files /dev/null and b/core/res/res/drawable-mdpi/weather_45.png differ
diff --git a/core/res/res/drawable-mdpi/weather_46.png b/core/res/res/drawable-mdpi/weather_46.png
new file mode 100644
index 0000000..c922139
Binary files /dev/null and b/core/res/res/drawable-mdpi/weather_46.png differ
diff --git a/core/res/res/drawable-mdpi/weather_47.png b/core/res/res/drawable-mdpi/weather_47.png
new file mode 100644
index 0000000..92785f5
Binary files /dev/null and b/core/res/res/drawable-mdpi/weather_47.png differ
diff --git a/core/res/res/drawable-mdpi/weather_5.png b/core/res/res/drawable-mdpi/weather_5.png
new file mode 100644
index 0000000..a1ae654
Binary files /dev/null and b/core/res/res/drawable-mdpi/weather_5.png differ
diff --git a/core/res/res/drawable-mdpi/weather_6.png b/core/res/res/drawable-mdpi/weather_6.png
new file mode 100644
index 0000000..a1ae654
Binary files /dev/null and b/core/res/res/drawable-mdpi/weather_6.png differ
diff --git a/core/res/res/drawable-mdpi/weather_7.png b/core/res/res/drawable-mdpi/weather_7.png
new file mode 100644
index 0000000..a1ae654
Binary files /dev/null and b/core/res/res/drawable-mdpi/weather_7.png differ
diff --git a/core/res/res/drawable-mdpi/weather_8.png b/core/res/res/drawable-mdpi/weather_8.png
new file mode 100644
index 0000000..37a339e
Binary files /dev/null and b/core/res/res/drawable-mdpi/weather_8.png differ
diff --git a/core/res/res/drawable-mdpi/weather_9.png b/core/res/res/drawable-mdpi/weather_9.png
new file mode 100644
index 0000000..0a9c8c3
Binary files /dev/null and b/core/res/res/drawable-mdpi/weather_9.png differ
diff --git a/core/res/res/drawable-mdpi/weather_na.png b/core/res/res/drawable-mdpi/weather_na.png
new file mode 100644
index 0000000..48c2879
Binary files /dev/null and b/core/res/res/drawable-mdpi/weather_na.png differ
diff --git a/core/res/res/drawable-nodpi/background_holo_dark.png b/core/res/res/drawable-nodpi/background_holo_dark.png
index 85bd6f7..4a26e62 100644
Binary files a/core/res/res/drawable-nodpi/background_holo_dark.png and b/core/res/res/drawable-nodpi/background_holo_dark.png differ
diff --git a/core/res/res/drawable-xhdpi/ic_lock_idle_calendar.png b/core/res/res/drawable-xhdpi/ic_lock_idle_calendar.png
new file mode 100644
index 0000000..5ae7782
Binary files /dev/null and b/core/res/res/drawable-xhdpi/ic_lock_idle_calendar.png differ
diff --git a/core/res/res/drawable-xhdpi/ic_lock_profile.png b/core/res/res/drawable-xhdpi/ic_lock_profile.png
new file mode 100644
index 0000000..4c9472c
Binary files /dev/null and b/core/res/res/drawable-xhdpi/ic_lock_profile.png differ
diff --git a/core/res/res/drawable-xhdpi/ic_lock_reboot.png b/core/res/res/drawable-xhdpi/ic_lock_reboot.png
new file mode 100644
index 0000000..653970f
Binary files /dev/null and b/core/res/res/drawable-xhdpi/ic_lock_reboot.png differ
diff --git a/core/res/res/drawable-xhdpi/ic_lock_screenshot.png b/core/res/res/drawable-xhdpi/ic_lock_screenshot.png
new file mode 100644
index 0000000..7e4c0ee
Binary files /dev/null and b/core/res/res/drawable-xhdpi/ic_lock_screenshot.png differ
diff --git a/core/res/res/drawable-xhdpi/ic_lockscreen_alarm_activated.png b/core/res/res/drawable-xhdpi/ic_lockscreen_alarm_activated.png
new file mode 100644
index 0000000..9ce624e
Binary files /dev/null and b/core/res/res/drawable-xhdpi/ic_lockscreen_alarm_activated.png differ
diff --git a/core/res/res/drawable-xhdpi/ic_lockscreen_alarm_normal.png b/core/res/res/drawable-xhdpi/ic_lockscreen_alarm_normal.png
new file mode 100644
index 0000000..0744227
Binary files /dev/null and b/core/res/res/drawable-xhdpi/ic_lockscreen_alarm_normal.png differ
diff --git a/core/res/res/drawable-xhdpi/ic_lockscreen_browser_activated.png b/core/res/res/drawable-xhdpi/ic_lockscreen_browser_activated.png
new file mode 100644
index 0000000..c7cdd3c
Binary files /dev/null and b/core/res/res/drawable-xhdpi/ic_lockscreen_browser_activated.png differ
diff --git a/core/res/res/drawable-xhdpi/ic_lockscreen_browser_normal.png b/core/res/res/drawable-xhdpi/ic_lockscreen_browser_normal.png
new file mode 100644
index 0000000..9f3989b
Binary files /dev/null and b/core/res/res/drawable-xhdpi/ic_lockscreen_browser_normal.png differ
diff --git a/core/res/res/drawable-xhdpi/ic_lockscreen_calendar_activated.png b/core/res/res/drawable-xhdpi/ic_lockscreen_calendar_activated.png
new file mode 100644
index 0000000..31cc06f
Binary files /dev/null and b/core/res/res/drawable-xhdpi/ic_lockscreen_calendar_activated.png differ
diff --git a/core/res/res/drawable-xhdpi/ic_lockscreen_calendar_normal.png b/core/res/res/drawable-xhdpi/ic_lockscreen_calendar_normal.png
new file mode 100644
index 0000000..d536058
Binary files /dev/null and b/core/res/res/drawable-xhdpi/ic_lockscreen_calendar_normal.png differ
diff --git a/core/res/res/drawable-xhdpi/ic_lockscreen_camera_activated.png b/core/res/res/drawable-xhdpi/ic_lockscreen_camera_activated.png
index 760ef2d..1cb37f9 100644
Binary files a/core/res/res/drawable-xhdpi/ic_lockscreen_camera_activated.png and b/core/res/res/drawable-xhdpi/ic_lockscreen_camera_activated.png differ
diff --git a/core/res/res/drawable-xhdpi/ic_lockscreen_camera_normal.png b/core/res/res/drawable-xhdpi/ic_lockscreen_camera_normal.png
index 093bc05..b468d5a 100644
Binary files a/core/res/res/drawable-xhdpi/ic_lockscreen_camera_normal.png and b/core/res/res/drawable-xhdpi/ic_lockscreen_camera_normal.png differ
diff --git a/core/res/res/drawable-xhdpi/ic_lockscreen_email_activated.png b/core/res/res/drawable-xhdpi/ic_lockscreen_email_activated.png
new file mode 100644
index 0000000..cb8f1e8
Binary files /dev/null and b/core/res/res/drawable-xhdpi/ic_lockscreen_email_activated.png differ
diff --git a/core/res/res/drawable-xhdpi/ic_lockscreen_email_normal.png b/core/res/res/drawable-xhdpi/ic_lockscreen_email_normal.png
new file mode 100644
index 0000000..250fe68
Binary files /dev/null and b/core/res/res/drawable-xhdpi/ic_lockscreen_email_normal.png differ
diff --git a/core/res/res/drawable-xhdpi/ic_lockscreen_facebook_activated.png b/core/res/res/drawable-xhdpi/ic_lockscreen_facebook_activated.png
new file mode 100644
index 0000000..d2d3c9f
Binary files /dev/null and b/core/res/res/drawable-xhdpi/ic_lockscreen_facebook_activated.png differ
diff --git a/core/res/res/drawable-xhdpi/ic_lockscreen_facebook_normal.png b/core/res/res/drawable-xhdpi/ic_lockscreen_facebook_normal.png
new file mode 100644
index 0000000..0f87fd5
Binary files /dev/null and b/core/res/res/drawable-xhdpi/ic_lockscreen_facebook_normal.png differ
diff --git a/core/res/res/drawable-xhdpi/ic_lockscreen_gallery_activated.png b/core/res/res/drawable-xhdpi/ic_lockscreen_gallery_activated.png
new file mode 100644
index 0000000..3c94a90
Binary files /dev/null and b/core/res/res/drawable-xhdpi/ic_lockscreen_gallery_activated.png differ
diff --git a/core/res/res/drawable-xhdpi/ic_lockscreen_gallery_normal.png b/core/res/res/drawable-xhdpi/ic_lockscreen_gallery_normal.png
new file mode 100644
index 0000000..54ef51b
Binary files /dev/null and b/core/res/res/drawable-xhdpi/ic_lockscreen_gallery_normal.png differ
diff --git a/core/res/res/drawable-xhdpi/ic_lockscreen_gplus_activated.png b/core/res/res/drawable-xhdpi/ic_lockscreen_gplus_activated.png
new file mode 100644
index 0000000..3c04e0d
Binary files /dev/null and b/core/res/res/drawable-xhdpi/ic_lockscreen_gplus_activated.png differ
diff --git a/core/res/res/drawable-xhdpi/ic_lockscreen_gplus_normal.png b/core/res/res/drawable-xhdpi/ic_lockscreen_gplus_normal.png
new file mode 100644
index 0000000..9ec36bf
Binary files /dev/null and b/core/res/res/drawable-xhdpi/ic_lockscreen_gplus_normal.png differ
diff --git a/core/res/res/drawable-xhdpi/ic_lockscreen_gtalk_activated.png b/core/res/res/drawable-xhdpi/ic_lockscreen_gtalk_activated.png
new file mode 100644
index 0000000..055f3d1
Binary files /dev/null and b/core/res/res/drawable-xhdpi/ic_lockscreen_gtalk_activated.png differ
diff --git a/core/res/res/drawable-xhdpi/ic_lockscreen_gtalk_normal.png b/core/res/res/drawable-xhdpi/ic_lockscreen_gtalk_normal.png
new file mode 100644
index 0000000..7e0c0b8
Binary files /dev/null and b/core/res/res/drawable-xhdpi/ic_lockscreen_gtalk_normal.png differ
diff --git a/core/res/res/drawable-xhdpi/ic_lockscreen_lock_pressed.png b/core/res/res/drawable-xhdpi/ic_lockscreen_lock_pressed.png
index 2264dc3..fb1af78 100644
Binary files a/core/res/res/drawable-xhdpi/ic_lockscreen_lock_pressed.png and b/core/res/res/drawable-xhdpi/ic_lockscreen_lock_pressed.png differ
diff --git a/core/res/res/drawable-xhdpi/ic_lockscreen_maps_activated.png b/core/res/res/drawable-xhdpi/ic_lockscreen_maps_activated.png
new file mode 100644
index 0000000..91267ce
Binary files /dev/null and b/core/res/res/drawable-xhdpi/ic_lockscreen_maps_activated.png differ
diff --git a/core/res/res/drawable-xhdpi/ic_lockscreen_maps_normal.png b/core/res/res/drawable-xhdpi/ic_lockscreen_maps_normal.png
new file mode 100644
index 0000000..34a3dda
Binary files /dev/null and b/core/res/res/drawable-xhdpi/ic_lockscreen_maps_normal.png differ
diff --git a/core/res/res/drawable-xhdpi/ic_lockscreen_movie_activated.png b/core/res/res/drawable-xhdpi/ic_lockscreen_movie_activated.png
new file mode 100644
index 0000000..2830a5d
Binary files /dev/null and b/core/res/res/drawable-xhdpi/ic_lockscreen_movie_activated.png differ
diff --git a/core/res/res/drawable-xhdpi/ic_lockscreen_movie_normal.png b/core/res/res/drawable-xhdpi/ic_lockscreen_movie_normal.png
new file mode 100644
index 0000000..c293338
Binary files /dev/null and b/core/res/res/drawable-xhdpi/ic_lockscreen_movie_normal.png differ
diff --git a/core/res/res/drawable-xhdpi/ic_lockscreen_music_activated.png b/core/res/res/drawable-xhdpi/ic_lockscreen_music_activated.png
new file mode 100644
index 0000000..06416b3
Binary files /dev/null and b/core/res/res/drawable-xhdpi/ic_lockscreen_music_activated.png differ
diff --git a/core/res/res/drawable-xhdpi/ic_lockscreen_music_normal.png b/core/res/res/drawable-xhdpi/ic_lockscreen_music_normal.png
new file mode 100644
index 0000000..67d23df
Binary files /dev/null and b/core/res/res/drawable-xhdpi/ic_lockscreen_music_normal.png differ
diff --git a/core/res/res/drawable-xhdpi/ic_lockscreen_nav_activated.png b/core/res/res/drawable-xhdpi/ic_lockscreen_nav_activated.png
new file mode 100644
index 0000000..aa2ff3d
Binary files /dev/null and b/core/res/res/drawable-xhdpi/ic_lockscreen_nav_activated.png differ
diff --git a/core/res/res/drawable-xhdpi/ic_lockscreen_nav_normal.png b/core/res/res/drawable-xhdpi/ic_lockscreen_nav_normal.png
new file mode 100644
index 0000000..f0802c8
Binary files /dev/null and b/core/res/res/drawable-xhdpi/ic_lockscreen_nav_normal.png differ
diff --git a/core/res/res/drawable-xhdpi/ic_lockscreen_phone_activated.png b/core/res/res/drawable-xhdpi/ic_lockscreen_phone_activated.png
new file mode 100644
index 0000000..f818166
Binary files /dev/null and b/core/res/res/drawable-xhdpi/ic_lockscreen_phone_activated.png differ
diff --git a/core/res/res/drawable-xhdpi/ic_lockscreen_phone_normal.png b/core/res/res/drawable-xhdpi/ic_lockscreen_phone_normal.png
new file mode 100644
index 0000000..5d65d81
Binary files /dev/null and b/core/res/res/drawable-xhdpi/ic_lockscreen_phone_normal.png differ
diff --git a/core/res/res/drawable-xhdpi/ic_lockscreen_podcast_activated.png b/core/res/res/drawable-xhdpi/ic_lockscreen_podcast_activated.png
new file mode 100644
index 0000000..004ca78
Binary files /dev/null and b/core/res/res/drawable-xhdpi/ic_lockscreen_podcast_activated.png differ
diff --git a/core/res/res/drawable-xhdpi/ic_lockscreen_podcast_normal.png b/core/res/res/drawable-xhdpi/ic_lockscreen_podcast_normal.png
new file mode 100644
index 0000000..cd2e712
Binary files /dev/null and b/core/res/res/drawable-xhdpi/ic_lockscreen_podcast_normal.png differ
diff --git a/core/res/res/drawable-xhdpi/ic_lockscreen_rss_activated.png b/core/res/res/drawable-xhdpi/ic_lockscreen_rss_activated.png
new file mode 100644
index 0000000..9f96548
Binary files /dev/null and b/core/res/res/drawable-xhdpi/ic_lockscreen_rss_activated.png differ
diff --git a/core/res/res/drawable-xhdpi/ic_lockscreen_rss_normal.png b/core/res/res/drawable-xhdpi/ic_lockscreen_rss_normal.png
new file mode 100644
index 0000000..4c958cf
Binary files /dev/null and b/core/res/res/drawable-xhdpi/ic_lockscreen_rss_normal.png differ
diff --git a/core/res/res/drawable-xhdpi/ic_lockscreen_sms_activated.png b/core/res/res/drawable-xhdpi/ic_lockscreen_sms_activated.png
new file mode 100644
index 0000000..aca6804
Binary files /dev/null and b/core/res/res/drawable-xhdpi/ic_lockscreen_sms_activated.png differ
diff --git a/core/res/res/drawable-xhdpi/ic_lockscreen_sms_normal.png b/core/res/res/drawable-xhdpi/ic_lockscreen_sms_normal.png
new file mode 100644
index 0000000..6431084
Binary files /dev/null and b/core/res/res/drawable-xhdpi/ic_lockscreen_sms_normal.png differ
diff --git a/core/res/res/drawable-xhdpi/ic_lockscreen_target_activated.png b/core/res/res/drawable-xhdpi/ic_lockscreen_target_activated.png
new file mode 100644
index 0000000..6f84ff2
Binary files /dev/null and b/core/res/res/drawable-xhdpi/ic_lockscreen_target_activated.png differ
diff --git a/core/res/res/drawable-xhdpi/ic_lockscreen_twitter_activated.png b/core/res/res/drawable-xhdpi/ic_lockscreen_twitter_activated.png
new file mode 100644
index 0000000..65e04a1
Binary files /dev/null and b/core/res/res/drawable-xhdpi/ic_lockscreen_twitter_activated.png differ
diff --git a/core/res/res/drawable-xhdpi/ic_lockscreen_twitter_normal.png b/core/res/res/drawable-xhdpi/ic_lockscreen_twitter_normal.png
new file mode 100644
index 0000000..81b5f39
Binary files /dev/null and b/core/res/res/drawable-xhdpi/ic_lockscreen_twitter_normal.png differ
diff --git a/core/res/res/drawable-xhdpi/stat_sys_tether_bluetooth.png b/core/res/res/drawable-xhdpi/stat_sys_tether_bluetooth.png
index 3f57d1c..16c0d2d 100644
Binary files a/core/res/res/drawable-xhdpi/stat_sys_tether_bluetooth.png and b/core/res/res/drawable-xhdpi/stat_sys_tether_bluetooth.png differ
diff --git a/core/res/res/drawable-xhdpi/stat_sys_tether_usb.png b/core/res/res/drawable-xhdpi/stat_sys_tether_usb.png
index 36afe48..633b181 100644
Binary files a/core/res/res/drawable-xhdpi/stat_sys_tether_usb.png and b/core/res/res/drawable-xhdpi/stat_sys_tether_usb.png differ
diff --git a/core/res/res/drawable-xhdpi/stat_sys_tether_wifi.png b/core/res/res/drawable-xhdpi/stat_sys_tether_wifi.png
index dc48646..d381c20 100644
Binary files a/core/res/res/drawable-xhdpi/stat_sys_tether_wifi.png and b/core/res/res/drawable-xhdpi/stat_sys_tether_wifi.png differ
diff --git a/core/res/res/drawable-xhdpi/weather_0.png b/core/res/res/drawable-xhdpi/weather_0.png
new file mode 100644
index 0000000..335af4b
Binary files /dev/null and b/core/res/res/drawable-xhdpi/weather_0.png differ
diff --git a/core/res/res/drawable-xhdpi/weather_1.png b/core/res/res/drawable-xhdpi/weather_1.png
new file mode 100644
index 0000000..335af4b
Binary files /dev/null and b/core/res/res/drawable-xhdpi/weather_1.png differ
diff --git a/core/res/res/drawable-xhdpi/weather_10.png b/core/res/res/drawable-xhdpi/weather_10.png
new file mode 100644
index 0000000..9432a13
Binary files /dev/null and b/core/res/res/drawable-xhdpi/weather_10.png differ
diff --git a/core/res/res/drawable-xhdpi/weather_11.png b/core/res/res/drawable-xhdpi/weather_11.png
new file mode 100644
index 0000000..3f7c5ad
Binary files /dev/null and b/core/res/res/drawable-xhdpi/weather_11.png differ
diff --git a/core/res/res/drawable-xhdpi/weather_12.png b/core/res/res/drawable-xhdpi/weather_12.png
new file mode 100644
index 0000000..3f7c5ad
Binary files /dev/null and b/core/res/res/drawable-xhdpi/weather_12.png differ
diff --git a/core/res/res/drawable-xhdpi/weather_13.png b/core/res/res/drawable-xhdpi/weather_13.png
new file mode 100644
index 0000000..3f9e500
Binary files /dev/null and b/core/res/res/drawable-xhdpi/weather_13.png differ
diff --git a/core/res/res/drawable-xhdpi/weather_14.png b/core/res/res/drawable-xhdpi/weather_14.png
new file mode 100644
index 0000000..3f9e500
Binary files /dev/null and b/core/res/res/drawable-xhdpi/weather_14.png differ
diff --git a/core/res/res/drawable-xhdpi/weather_15.png b/core/res/res/drawable-xhdpi/weather_15.png
new file mode 100644
index 0000000..2ad1e46
Binary files /dev/null and b/core/res/res/drawable-xhdpi/weather_15.png differ
diff --git a/core/res/res/drawable-xhdpi/weather_16.png b/core/res/res/drawable-xhdpi/weather_16.png
new file mode 100644
index 0000000..4bad358
Binary files /dev/null and b/core/res/res/drawable-xhdpi/weather_16.png differ
diff --git a/core/res/res/drawable-xhdpi/weather_17.png b/core/res/res/drawable-xhdpi/weather_17.png
new file mode 100644
index 0000000..6fced6c
Binary files /dev/null and b/core/res/res/drawable-xhdpi/weather_17.png differ
diff --git a/core/res/res/drawable-xhdpi/weather_18.png b/core/res/res/drawable-xhdpi/weather_18.png
new file mode 100644
index 0000000..aae6d11
Binary files /dev/null and b/core/res/res/drawable-xhdpi/weather_18.png differ
diff --git a/core/res/res/drawable-xhdpi/weather_19.png b/core/res/res/drawable-xhdpi/weather_19.png
new file mode 100644
index 0000000..d8e5e82
Binary files /dev/null and b/core/res/res/drawable-xhdpi/weather_19.png differ
diff --git a/core/res/res/drawable-xhdpi/weather_2.png b/core/res/res/drawable-xhdpi/weather_2.png
new file mode 100644
index 0000000..335af4b
Binary files /dev/null and b/core/res/res/drawable-xhdpi/weather_2.png differ
diff --git a/core/res/res/drawable-xhdpi/weather_20.png b/core/res/res/drawable-xhdpi/weather_20.png
new file mode 100644
index 0000000..73cbc39
Binary files /dev/null and b/core/res/res/drawable-xhdpi/weather_20.png differ
diff --git a/core/res/res/drawable-xhdpi/weather_21.png b/core/res/res/drawable-xhdpi/weather_21.png
new file mode 100644
index 0000000..800f484
Binary files /dev/null and b/core/res/res/drawable-xhdpi/weather_21.png differ
diff --git a/core/res/res/drawable-xhdpi/weather_22.png b/core/res/res/drawable-xhdpi/weather_22.png
new file mode 100644
index 0000000..d8e5e82
Binary files /dev/null and b/core/res/res/drawable-xhdpi/weather_22.png differ
diff --git a/core/res/res/drawable-xhdpi/weather_23.png b/core/res/res/drawable-xhdpi/weather_23.png
new file mode 100644
index 0000000..be446c2
Binary files /dev/null and b/core/res/res/drawable-xhdpi/weather_23.png differ
diff --git a/core/res/res/drawable-xhdpi/weather_24.png b/core/res/res/drawable-xhdpi/weather_24.png
new file mode 100644
index 0000000..be446c2
Binary files /dev/null and b/core/res/res/drawable-xhdpi/weather_24.png differ
diff --git a/core/res/res/drawable-xhdpi/weather_25.png b/core/res/res/drawable-xhdpi/weather_25.png
new file mode 100644
index 0000000..63f019a
Binary files /dev/null and b/core/res/res/drawable-xhdpi/weather_25.png differ
diff --git a/core/res/res/drawable-xhdpi/weather_26.png b/core/res/res/drawable-xhdpi/weather_26.png
new file mode 100644
index 0000000..3eb5734
Binary files /dev/null and b/core/res/res/drawable-xhdpi/weather_26.png differ
diff --git a/core/res/res/drawable-xhdpi/weather_27.png b/core/res/res/drawable-xhdpi/weather_27.png
new file mode 100644
index 0000000..abf4096
Binary files /dev/null and b/core/res/res/drawable-xhdpi/weather_27.png differ
diff --git a/core/res/res/drawable-xhdpi/weather_28.png b/core/res/res/drawable-xhdpi/weather_28.png
new file mode 100644
index 0000000..0cbae30
Binary files /dev/null and b/core/res/res/drawable-xhdpi/weather_28.png differ
diff --git a/core/res/res/drawable-xhdpi/weather_29.png b/core/res/res/drawable-xhdpi/weather_29.png
new file mode 100644
index 0000000..abf4096
Binary files /dev/null and b/core/res/res/drawable-xhdpi/weather_29.png differ
diff --git a/core/res/res/drawable-xhdpi/weather_3.png b/core/res/res/drawable-xhdpi/weather_3.png
new file mode 100644
index 0000000..7dda34c
Binary files /dev/null and b/core/res/res/drawable-xhdpi/weather_3.png differ
diff --git a/core/res/res/drawable-xhdpi/weather_30.png b/core/res/res/drawable-xhdpi/weather_30.png
new file mode 100644
index 0000000..0cbae30
Binary files /dev/null and b/core/res/res/drawable-xhdpi/weather_30.png differ
diff --git a/core/res/res/drawable-xhdpi/weather_31.png b/core/res/res/drawable-xhdpi/weather_31.png
new file mode 100644
index 0000000..16f2d9f
Binary files /dev/null and b/core/res/res/drawable-xhdpi/weather_31.png differ
diff --git a/core/res/res/drawable-xhdpi/weather_32.png b/core/res/res/drawable-xhdpi/weather_32.png
new file mode 100644
index 0000000..409373d
Binary files /dev/null and b/core/res/res/drawable-xhdpi/weather_32.png differ
diff --git a/core/res/res/drawable-xhdpi/weather_33.png b/core/res/res/drawable-xhdpi/weather_33.png
new file mode 100644
index 0000000..16f2d9f
Binary files /dev/null and b/core/res/res/drawable-xhdpi/weather_33.png differ
diff --git a/core/res/res/drawable-xhdpi/weather_34.png b/core/res/res/drawable-xhdpi/weather_34.png
new file mode 100644
index 0000000..409373d
Binary files /dev/null and b/core/res/res/drawable-xhdpi/weather_34.png differ
diff --git a/core/res/res/drawable-xhdpi/weather_35.png b/core/res/res/drawable-xhdpi/weather_35.png
new file mode 100644
index 0000000..445b884
Binary files /dev/null and b/core/res/res/drawable-xhdpi/weather_35.png differ
diff --git a/core/res/res/drawable-xhdpi/weather_36.png b/core/res/res/drawable-xhdpi/weather_36.png
new file mode 100644
index 0000000..a424ad6
Binary files /dev/null and b/core/res/res/drawable-xhdpi/weather_36.png differ
diff --git a/core/res/res/drawable-xhdpi/weather_37.png b/core/res/res/drawable-xhdpi/weather_37.png
new file mode 100644
index 0000000..e98c8b8
Binary files /dev/null and b/core/res/res/drawable-xhdpi/weather_37.png differ
diff --git a/core/res/res/drawable-xhdpi/weather_38.png b/core/res/res/drawable-xhdpi/weather_38.png
new file mode 100644
index 0000000..b47249c
Binary files /dev/null and b/core/res/res/drawable-xhdpi/weather_38.png differ
diff --git a/core/res/res/drawable-xhdpi/weather_39.png b/core/res/res/drawable-xhdpi/weather_39.png
new file mode 100644
index 0000000..e98c8b8
Binary files /dev/null and b/core/res/res/drawable-xhdpi/weather_39.png differ
diff --git a/core/res/res/drawable-xhdpi/weather_4.png b/core/res/res/drawable-xhdpi/weather_4.png
new file mode 100644
index 0000000..7dda34c
Binary files /dev/null and b/core/res/res/drawable-xhdpi/weather_4.png differ
diff --git a/core/res/res/drawable-xhdpi/weather_40.png b/core/res/res/drawable-xhdpi/weather_40.png
new file mode 100644
index 0000000..1505fea
Binary files /dev/null and b/core/res/res/drawable-xhdpi/weather_40.png differ
diff --git a/core/res/res/drawable-xhdpi/weather_41.png b/core/res/res/drawable-xhdpi/weather_41.png
new file mode 100644
index 0000000..4bad358
Binary files /dev/null and b/core/res/res/drawable-xhdpi/weather_41.png differ
diff --git a/core/res/res/drawable-xhdpi/weather_42.png b/core/res/res/drawable-xhdpi/weather_42.png
new file mode 100644
index 0000000..196026d
Binary files /dev/null and b/core/res/res/drawable-xhdpi/weather_42.png differ
diff --git a/core/res/res/drawable-xhdpi/weather_43.png b/core/res/res/drawable-xhdpi/weather_43.png
new file mode 100644
index 0000000..4bad358
Binary files /dev/null and b/core/res/res/drawable-xhdpi/weather_43.png differ
diff --git a/core/res/res/drawable-xhdpi/weather_44.png b/core/res/res/drawable-xhdpi/weather_44.png
new file mode 100644
index 0000000..abf4096
Binary files /dev/null and b/core/res/res/drawable-xhdpi/weather_44.png differ
diff --git a/core/res/res/drawable-xhdpi/weather_45.png b/core/res/res/drawable-xhdpi/weather_45.png
new file mode 100644
index 0000000..7dda34c
Binary files /dev/null and b/core/res/res/drawable-xhdpi/weather_45.png differ
diff --git a/core/res/res/drawable-xhdpi/weather_46.png b/core/res/res/drawable-xhdpi/weather_46.png
new file mode 100644
index 0000000..3f9e500
Binary files /dev/null and b/core/res/res/drawable-xhdpi/weather_46.png differ
diff --git a/core/res/res/drawable-xhdpi/weather_47.png b/core/res/res/drawable-xhdpi/weather_47.png
new file mode 100644
index 0000000..b47249c
Binary files /dev/null and b/core/res/res/drawable-xhdpi/weather_47.png differ
diff --git a/core/res/res/drawable-xhdpi/weather_5.png b/core/res/res/drawable-xhdpi/weather_5.png
new file mode 100644
index 0000000..aae6d11
Binary files /dev/null and b/core/res/res/drawable-xhdpi/weather_5.png differ
diff --git a/core/res/res/drawable-xhdpi/weather_6.png b/core/res/res/drawable-xhdpi/weather_6.png
new file mode 100644
index 0000000..aae6d11
Binary files /dev/null and b/core/res/res/drawable-xhdpi/weather_6.png differ
diff --git a/core/res/res/drawable-xhdpi/weather_7.png b/core/res/res/drawable-xhdpi/weather_7.png
new file mode 100644
index 0000000..aae6d11
Binary files /dev/null and b/core/res/res/drawable-xhdpi/weather_7.png differ
diff --git a/core/res/res/drawable-xhdpi/weather_8.png b/core/res/res/drawable-xhdpi/weather_8.png
new file mode 100644
index 0000000..1a7e699
Binary files /dev/null and b/core/res/res/drawable-xhdpi/weather_8.png differ
diff --git a/core/res/res/drawable-xhdpi/weather_9.png b/core/res/res/drawable-xhdpi/weather_9.png
new file mode 100644
index 0000000..0da4419
Binary files /dev/null and b/core/res/res/drawable-xhdpi/weather_9.png differ
diff --git a/core/res/res/drawable-xhdpi/weather_na.png b/core/res/res/drawable-xhdpi/weather_na.png
new file mode 100644
index 0000000..8125ce2
Binary files /dev/null and b/core/res/res/drawable-xhdpi/weather_na.png differ
diff --git a/core/res/res/drawable/ic_lockscreen_send_sms.xml b/core/res/res/drawable/ic_lockscreen_send_sms.xml
index 2503a5c..43fd8d6 100644
--- a/core/res/res/drawable/ic_lockscreen_send_sms.xml
+++ b/core/res/res/drawable/ic_lockscreen_send_sms.xml
@@ -19,12 +19,12 @@
         android:state_enabled="true"
         android:state_active="false"
         android:state_focused="false"
-        android:drawable="@drawable/ic_lockscreen_text_normal" />
+        android:drawable="@drawable/ic_lockscreen_sms_normal" />
 
     <item
         android:state_enabled="true"
         android:state_active="true"
         android:state_focused="false"
-        android:drawable="@drawable/ic_lockscreen_text_activated" />
+        android:drawable="@drawable/ic_lockscreen_sms_activated" />
 
 </selector>
diff --git a/core/res/res/layout-sw600dp/keyguard_screen_password_landscape.xml b/core/res/res/layout-sw600dp/keyguard_screen_password_landscape.xml
index 568933c..b8deb4b 100644
--- a/core/res/res/layout-sw600dp/keyguard_screen_password_landscape.xml
+++ b/core/res/res/layout-sw600dp/keyguard_screen_password_landscape.xml
@@ -21,7 +21,8 @@
     xmlns:android="http://schemas.android.com/apk/res/android"
     android:orientation="horizontal"
     android:layout_width="match_parent"
-    android:layout_height="match_parent">
+    android:layout_height="match_parent"
+    android:id="@+id/root">
 
     <!-- left side: status and music -->
     <RelativeLayout
diff --git a/core/res/res/layout-sw600dp/keyguard_screen_password_portrait.xml b/core/res/res/layout-sw600dp/keyguard_screen_password_portrait.xml
index 335a641..2594873 100644
--- a/core/res/res/layout-sw600dp/keyguard_screen_password_portrait.xml
+++ b/core/res/res/layout-sw600dp/keyguard_screen_password_portrait.xml
@@ -20,7 +20,8 @@
     xmlns:android="http://schemas.android.com/apk/res/android"
     android:orientation="vertical"
     android:layout_width="match_parent"
-    android:layout_height="match_parent">
+    android:layout_height="match_parent"
+    android:id="@+id/root">
 
     <!-- top: status and emergency/forgot pattern buttons -->
     <RelativeLayout
diff --git a/core/res/res/layout-sw600dp/keyguard_screen_sim_pin_portrait.xml b/core/res/res/layout-sw600dp/keyguard_screen_sim_pin_portrait.xml
index d8bea56..5d04ff5 100644
--- a/core/res/res/layout-sw600dp/keyguard_screen_sim_pin_portrait.xml
+++ b/core/res/res/layout-sw600dp/keyguard_screen_sim_pin_portrait.xml
@@ -20,11 +20,12 @@
     android:layout_width="match_parent"
     android:layout_height="match_parent"
     android:orientation="vertical"
-    android:background="@android:color/background_dark"
-    android:gravity="center_horizontal">
+    android:background="@android:color/transparent"
+    android:cacheColorHint="@android:color/transparent"
+    android:gravity="center|center_horizontal">
 
     <LinearLayout android:id="@+id/topDisplayGroup"
-        android:layout_width="match_parent"
+        android:layout_width="400dp"
         android:layout_height="wrap_content"
         android:orientation="vertical">
 
@@ -81,39 +82,19 @@
     <include
         android:id="@+id/keyPad"
         layout="@android:layout/twelve_key_entry"
-        android:layout_width="fill_parent"
+        android:layout_width="400dp"
         android:layout_height="wrap_content"
         android:layout_below="@id/topDisplayGroup"
         android:layout_marginTop="10dip"
     />
-
-    <!-- spacer below keypad -->
-    <View
-        android:id="@+id/spacerBottom"
-        android:layout_width="match_parent"
-        android:layout_height="1dip"
-        android:layout_marginTop="6dip"
-        android:layout_above="@id/emergencyCallButton"
-        android:background="@android:drawable/divider_horizontal_dark"
-    />
-
-    <!-- The emergency button should take the rest of the space and be centered vertically -->
-    <LinearLayout
-        android:layout_width="match_parent"
-        android:layout_height="0dip"
-        android:layout_weight="1"
-        android:gravity="center"
-        android:orientation="vertical">
-
-        <!-- emergency call button -->
+   
+   <!-- emergency call button -->
         <Button
             android:id="@+id/emergencyCallButton"
             android:layout_width="wrap_content"
             android:layout_height="wrap_content"
             android:drawableLeft="@android:drawable/ic_emergency"
             android:drawablePadding="8dip"
-            android:text="@android:string/lockscreen_emergency_call"
-        />
-    </LinearLayout>
+            android:text="@android:string/lockscreen_emergency_call" />
 
 </LinearLayout>
diff --git a/core/res/res/layout-sw600dp/keyguard_screen_status_land.xml b/core/res/res/layout-sw600dp/keyguard_screen_status_land.xml
index 4fafc3c..b8acc9c 100644
--- a/core/res/res/layout-sw600dp/keyguard_screen_status_land.xml
+++ b/core/res/res/layout-sw600dp/keyguard_screen_status_land.xml
@@ -2,6 +2,7 @@
 <!--
 **
 ** Copyright 2010, The Android Open Source Project
+** Copyright 2012, The CyanogenMod Project (Weather, Calendar)
 **
 ** Licensed under the Apache License, Version 2.0 (the "License")
 ** you may not use this file except in compliance with the License.
@@ -38,12 +39,108 @@
         android:visibility="gone"
         />
 
+    <!-- CyanogenMod Weather Panel -->
+    <RelativeLayout
+        android:id="@+id/weather_panel"
+        android:layout_height="wrap_content"
+        android:layout_width="fill_parent"
+        android:orientation="horizontal" >
+
+        <ImageView
+            android:id="@+id/weather_image"
+            android:layout_width="wrap_content"
+            android:layout_height="wrap_content"
+            android:layout_centerHorizontal="true"
+            android:layout_centerVertical="true"
+            android:paddingLeft="8dip"
+            android:paddingRight="8dip"
+            android:src="@android:drawable/ic_dialog_alert" />
+
+        <RelativeLayout
+            android:layout_width="wrap_content"
+            android:layout_height="wrap_content"
+            android:layout_centerVertical="true"
+            android:layout_toLeftOf="@id/weather_image"
+            android:orientation="horizontal"
+            android:padding="4dip" >
+
+            <TextView
+                android:id="@+id/weather_city"
+                android:layout_width="wrap_content"
+                android:layout_height="wrap_content"
+                android:textSize="14sp"
+                android:textStyle="bold"
+                android:layout_alignParentRight="true"
+                android:gravity="right"
+                android:singleLine="true"
+                android:ellipsize="marquee"
+                android:textColor="?android:attr/textColorPrimary"/>
+
+            <TextView
+                android:id="@+id/weather_condition"
+                android:layout_width="wrap_content"
+                android:layout_height="wrap_content"
+                android:layout_below="@id/weather_city"
+                android:layout_alignParentRight="true"
+                android:gravity="right"
+                android:singleLine="true"
+                android:ellipsize="marquee"
+                android:textSize="12sp"
+                android:textColor="?android:attr/textColorPrimary" />
+
+            <TextView
+                android:id="@+id/update_time"
+                android:layout_width="wrap_content"
+                android:layout_height="wrap_content"
+                android:layout_below="@id/weather_condition"
+                android:layout_alignParentRight="true"
+                android:gravity="right"
+                android:textSize="6sp"
+                android:textColor="?android:attr/textColorSecondary" />
+
+        </RelativeLayout>
+
+        <RelativeLayout
+            android:id="@+id/weather_temps_panel"
+            android:layout_width="wrap_content"
+            android:layout_height="wrap_content"
+            android:layout_toRightOf="@id/weather_image"
+            android:orientation="horizontal"
+            android:layout_centerVertical="true" >
+
+            <TextView
+                android:id="@+id/weather_temp"
+                android:layout_width="wrap_content"
+                android:layout_height="wrap_content"
+                android:layout_centerHorizontal="true"
+                android:textSize="20sp"
+                android:textColor="?android:attr/textColorPrimary" />
+
+            <View
+                android:id="@+id/weather_divider"
+                android:layout_below="@id/weather_temp"
+                android:layout_width="44dip"
+                android:layout_height="1dip"
+                android:background="@android:drawable/divider_horizontal_dark" />
+
+            <TextView
+                android:id="@+id/weather_low_high"
+                android:layout_width="wrap_content"
+                android:layout_height="wrap_content"
+                android:layout_below="@id/weather_divider"
+                android:layout_centerHorizontal="true"
+                android:paddingTop="2dip"
+                android:textSize="12sp"
+                android:textColor="?android:attr/textColorPrimary" />
+
+        </RelativeLayout>
+
+    </RelativeLayout>
+
     <com.android.internal.widget.DigitalClock android:id="@+id/time"
         android:layout_width="wrap_content"
         android:layout_height="wrap_content"
-        android:layout_marginTop="8dip"
-        android:layout_marginBottom="8dip"
-        >
+        android:layout_marginBottom="8dip" >
 
         <!-- Because we can't have multi-tone fonts, we render two TextViews, one on
         top of the other. Hence the redundant layout... -->
@@ -120,4 +217,69 @@
         android:textColor="@color/lockscreen_owner_info"
         android:visibility="invisible"
         />
+
+    <!-- CyanogenMod Calendar Panel -->
+    <LinearLayout
+        android:id="@+id/calendar_panel"
+        android:layout_width="wrap_content"
+        android:layout_height="wrap_content"
+        android:minHeight="28dip"
+        android:layout_gravity="center_horizontal"
+        android:gravity="center_vertical"
+        android:layout_marginTop="10dip"
+        android:paddingLeft="12dip"
+        android:paddingRight="12dip" >
+
+        <ImageView
+            android:layout_width="36dp"
+            android:layout_height="wrap_content"
+            android:layout_gravity="center_vertical"
+            android:gravity="center"
+            android:src="@drawable/ic_lock_idle_calendar" />
+
+        <View
+            android:layout_width="1dip"
+            android:layout_height="match_parent"
+            android:paddingTop="6dip"
+            android:paddingBottom="6dip"
+            android:background="@android:drawable/divider_horizontal_dark" />
+
+        <RelativeLayout
+            android:layout_width="0dip"
+            android:layout_height="wrap_content"
+            android:layout_weight="1"
+            android:paddingTop="6dip"
+            android:paddingBottom="6dip"
+            android:paddingLeft="4dip" >
+
+            <TextView
+                android:id="@+id/calendar_event_title"
+                android:layout_width="wrap_content"
+                android:layout_height="wrap_content"
+                android:singleLine="true"
+                android:textSize="14sp"
+                android:textColor="?android:attr/textColorPrimary"
+                android:ellipsize="marquee"
+                android:fadingEdge="horizontal" />
+
+            <TextView
+                android:id="@+id/calendar_event_details"
+                android:layout_width="wrap_content"
+                android:layout_height="wrap_content"
+                android:layout_below="@id/calendar_event_title"
+                android:layout_alignLeft="@id/calendar_event_title"
+                android:textSize="12sp"
+                android:singleLine="true"
+                android:ellipsize="marquee"
+                android:marqueeRepeatLimit="marquee_forever"
+                android:scrollHorizontally="true"
+                android:focusable="true"
+                android:focusableInTouchMode="true"
+                android:fadingEdge="horizontal"
+                android:textColor="?android:attr/textColorSecondary" />
+
+        </RelativeLayout>
+
+    </LinearLayout>
+
 </LinearLayout>
diff --git a/core/res/res/layout-sw600dp/keyguard_screen_status_port.xml b/core/res/res/layout-sw600dp/keyguard_screen_status_port.xml
index dfab3e3..ea461d2 100644
--- a/core/res/res/layout-sw600dp/keyguard_screen_status_port.xml
+++ b/core/res/res/layout-sw600dp/keyguard_screen_status_port.xml
@@ -2,6 +2,7 @@
 <!--
 **
 ** Copyright 2010, The Android Open Source Project
+** Copyright 2012, The CyanogenMod Project (Weather, Calendar)
 **
 ** Licensed under the Apache License, Version 2.0 (the "License")
 ** you may not use this file except in compliance with the License.
@@ -40,11 +41,108 @@
         android:visibility="gone"
         />
 
+    <!-- CyanogenMod Weather Panel -->
+    <RelativeLayout
+        android:id="@+id/weather_panel"
+        android:layout_height="wrap_content"
+        android:layout_width="fill_parent"
+        android:orientation="horizontal" >
+
+        <ImageView
+            android:id="@+id/weather_image"
+            android:layout_width="wrap_content"
+            android:layout_height="wrap_content"
+            android:layout_centerHorizontal="true"
+            android:layout_centerVertical="true"
+            android:paddingLeft="8dip"
+            android:paddingRight="8dip"
+            android:src="@android:drawable/ic_dialog_alert" />
+
+        <RelativeLayout
+            android:layout_width="wrap_content"
+            android:layout_height="wrap_content"
+            android:layout_centerVertical="true"
+            android:layout_toLeftOf="@id/weather_image"
+            android:orientation="horizontal"
+            android:padding="4dip" >
+
+            <TextView
+                android:id="@+id/weather_city"
+                android:layout_width="wrap_content"
+                android:layout_height="wrap_content"
+                android:textSize="14sp"
+                android:textStyle="bold"
+                android:layout_alignParentRight="true"
+                android:gravity="right"
+                android:singleLine="true"
+                android:ellipsize="marquee"
+                android:textColor="?android:attr/textColorPrimary"/>
+
+            <TextView
+                android:id="@+id/weather_condition"
+                android:layout_width="wrap_content"
+                android:layout_height="wrap_content"
+                android:layout_below="@id/weather_city"
+                android:layout_alignParentRight="true"
+                android:gravity="right"
+                android:singleLine="true"
+                android:ellipsize="marquee"
+                android:textSize="12sp"
+                android:textColor="?android:attr/textColorPrimary" />
+
+            <TextView
+                android:id="@+id/update_time"
+                android:layout_width="wrap_content"
+                android:layout_height="wrap_content"
+                android:layout_below="@id/weather_condition"
+                android:layout_alignParentRight="true"
+                android:gravity="right"
+                android:textSize="6sp"
+                android:textColor="?android:attr/textColorSecondary" />
+
+        </RelativeLayout>
+
+        <RelativeLayout
+            android:id="@+id/weather_temps_panel"
+            android:layout_width="wrap_content"
+            android:layout_height="wrap_content"
+            android:layout_toRightOf="@id/weather_image"
+            android:orientation="horizontal"
+            android:layout_centerVertical="true" >
+
+            <TextView
+                android:id="@+id/weather_temp"
+                android:layout_width="wrap_content"
+                android:layout_height="wrap_content"
+                android:layout_centerHorizontal="true"
+                android:textSize="20sp"
+                android:textColor="?android:attr/textColorPrimary" />
+
+            <View
+                android:id="@+id/weather_divider"
+                android:layout_below="@id/weather_temp"
+                android:layout_width="44dip"
+                android:layout_height="1dip"
+                android:background="@android:drawable/divider_horizontal_dark" />
+
+            <TextView
+                android:id="@+id/weather_low_high"
+                android:layout_width="wrap_content"
+                android:layout_height="wrap_content"
+                android:layout_below="@id/weather_divider"
+                android:layout_centerHorizontal="true"
+                android:paddingTop="2dip"
+                android:textSize="12sp"
+                android:textColor="?android:attr/textColorPrimary" />
+
+        </RelativeLayout>
+
+    </RelativeLayout>
+
     <com.android.internal.widget.DigitalClock android:id="@+id/time"
         android:layout_width="wrap_content"
         android:layout_height="wrap_content"
-        android:layout_marginTop="8dip"
-        android:layout_marginBottom="8dip">
+        android:layout_marginBottom="8dip" >
 
         <!-- Because we can't have multi-tone fonts, we render two TextViews, one on
         top of the other. Hence the redundant layout... -->
@@ -120,4 +218,68 @@
         android:visibility="invisible"
         android:textColor="@color/lockscreen_owner_info"
         />
+
+    <!-- CyanogenMod Calendar Panel -->
+    <LinearLayout
+        android:id="@+id/calendar_panel"
+        android:layout_width="match_parent"
+        android:layout_height="wrap_content"
+        android:layout_marginTop="10dip"
+        android:minHeight="28dip"
+        android:gravity="center_vertical"
+        android:paddingLeft="12dip"
+        android:paddingRight="12dip" >
+
+        <ImageView
+            android:layout_width="36dp"
+            android:layout_height="wrap_content"
+            android:layout_gravity="center_vertical"
+            android:gravity="center"
+            android:src="@drawable/ic_lock_idle_calendar" />
+
+        <View
+            android:layout_width="1dip"
+            android:layout_height="match_parent"
+            android:paddingTop="6dip"
+            android:paddingBottom="6dip"
+            android:background="@android:drawable/divider_horizontal_dark" />
+
+        <RelativeLayout
+            android:layout_width="0dip"
+            android:layout_height="wrap_content"
+            android:layout_weight="1"
+            android:paddingTop="6dip"
+            android:paddingBottom="6dip"
+            android:paddingLeft="4dip" >
+
+            <TextView
+                android:id="@+id/calendar_event_title"
+                android:layout_width="wrap_content"
+                android:layout_height="wrap_content"
+                android:singleLine="true"
+                android:textSize="14sp"
+                android:textColor="?android:attr/textColorPrimary"
+                android:ellipsize="marquee"
+                android:fadingEdge="horizontal" />
+
+            <TextView
+                android:id="@+id/calendar_event_details"
+                android:layout_width="wrap_content"
+                android:layout_height="wrap_content"
+                android:layout_below="@id/calendar_event_title"
+                android:layout_alignLeft="@id/calendar_event_title"
+                android:textSize="12sp"
+                android:singleLine="true"
+                android:ellipsize="marquee"
+                android:marqueeRepeatLimit="marquee_forever"
+                android:scrollHorizontally="true"
+                android:focusable="true"
+                android:focusableInTouchMode="true"
+                android:fadingEdge="horizontal"
+                android:textColor="?android:attr/textColorSecondary" />
+
+        </RelativeLayout>
+
+    </LinearLayout>
+
 </LinearLayout>
diff --git a/core/res/res/layout-sw600dp/keyguard_screen_tab_unlock.xml b/core/res/res/layout-sw600dp/keyguard_screen_tab_unlock.xml
index 73dadb4..929adf7 100644
--- a/core/res/res/layout-sw600dp/keyguard_screen_tab_unlock.xml
+++ b/core/res/res/layout-sw600dp/keyguard_screen_tab_unlock.xml
@@ -53,6 +53,7 @@
                 />
 
             <include layout="@layout/keyguard_screen_status_port"
+                android:id="@+id/screen_status_port"
                 android:layout_width="wrap_content"
                 android:layout_height="wrap_content"
                 android:layout_marginLeft="50dip"
@@ -121,4 +122,3 @@
     </LinearLayout>
 
 </LinearLayout>
-
diff --git a/core/res/res/layout-sw600dp/keyguard_screen_tab_unlock_land.xml b/core/res/res/layout-sw600dp/keyguard_screen_tab_unlock_land.xml
index 10b1ace..d4a2d75 100644
--- a/core/res/res/layout-sw600dp/keyguard_screen_tab_unlock_land.xml
+++ b/core/res/res/layout-sw600dp/keyguard_screen_tab_unlock_land.xml
@@ -51,6 +51,7 @@
                 />
 
             <include layout="@layout/keyguard_screen_status_land"
+                android:id="@+id/screen_status_land"
                 android:layout_width="match_parent"
                 android:layout_height="wrap_content"
                 android:layout_marginLeft="50dip"
@@ -60,9 +61,9 @@
                 android:layout_alignParentTop="true"
                 android:layout_alignParentLeft="true"/>
 
-        </RelativeLayout>
+            </RelativeLayout>
 
-    </RelativeLayout>
+     </RelativeLayout>
 
     <!-- right side -->
     <RelativeLayout
diff --git a/core/res/res/layout-sw600dp/keyguard_screen_unlock_landscape.xml b/core/res/res/layout-sw600dp/keyguard_screen_unlock_landscape.xml
index 802ef82..e13495a 100644
--- a/core/res/res/layout-sw600dp/keyguard_screen_unlock_landscape.xml
+++ b/core/res/res/layout-sw600dp/keyguard_screen_unlock_landscape.xml
@@ -25,7 +25,8 @@
     xmlns:android="http://schemas.android.com/apk/res/android"
     android:orientation="horizontal"
     android:layout_width="match_parent"
-    android:layout_height="match_parent">
+    android:layout_height="match_parent"
+    android:id="@+id/root">
 
     <!-- left side: status and music -->
     <RelativeLayout
diff --git a/core/res/res/layout-sw600dp/keyguard_screen_unlock_portrait.xml b/core/res/res/layout-sw600dp/keyguard_screen_unlock_portrait.xml
index 40f2492..18489af 100644
--- a/core/res/res/layout-sw600dp/keyguard_screen_unlock_portrait.xml
+++ b/core/res/res/layout-sw600dp/keyguard_screen_unlock_portrait.xml
@@ -20,6 +20,7 @@
 <com.android.internal.widget.LinearLayoutWithDefaultTouchRecepient
     xmlns:android="http://schemas.android.com/apk/res/android"
     android:orientation="vertical"
+    android:id="@+id/root"
     android:layout_width="match_parent"
     android:layout_height="match_parent">
 
@@ -47,7 +48,7 @@
                 android:layout_height="512dip"
                 />
 
-            <include layout="@layout/keyguard_screen_status_land"
+            <include layout="@layout/keyguard_screen_status_port"
                 android:layout_width="wrap_content"
                 android:layout_height="wrap_content"
                 android:layout_marginLeft="50dip"
diff --git a/core/res/res/layout/keyguard_screen_password_portrait.xml b/core/res/res/layout/keyguard_screen_password_portrait.xml
index 053acb2..3a1ad48 100644
--- a/core/res/res/layout/keyguard_screen_password_portrait.xml
+++ b/core/res/res/layout/keyguard_screen_password_portrait.xml
@@ -21,6 +21,7 @@
     android:orientation="vertical"
     android:layout_width="match_parent"
     android:layout_height="match_parent"
+    android:id="@+id/root"
     android:gravity="center_horizontal">
 
     <com.android.internal.widget.DigitalClock android:id="@+id/time"
diff --git a/core/res/res/layout/keyguard_screen_tab_unlock.xml b/core/res/res/layout/keyguard_screen_tab_unlock.xml
index 0ec8f75..51bacea 100644
--- a/core/res/res/layout/keyguard_screen_tab_unlock.xml
+++ b/core/res/res/layout/keyguard_screen_tab_unlock.xml
@@ -2,6 +2,7 @@
 <!--
 **
 ** Copyright 2009, The Android Open Source Project
+** Copyright 2012, The CyanogenMod Project (Weather, Calendar)
 **
 ** Licensed under the Apache License, Version 2.0 (the "License")
 ** you may not use this file except in compliance with the License.
@@ -26,6 +27,7 @@
     android:orientation="vertical"
     android:layout_width="match_parent"
     android:layout_height="match_parent"
+    android:id="@+id/root"
     android:gravity="center_horizontal">
 
     <com.android.internal.widget.DigitalClock android:id="@+id/time"
@@ -102,6 +104,105 @@
         android:drawablePadding="4dip"
         />
 
+    <!-- CyanogenMod Weather Panel -->
+    <RelativeLayout
+        android:id="@+id/weather_panel"
+        android:layout_width="fill_parent"
+        android:layout_height="wrap_content"
+        android:orientation="horizontal"
+        android:paddingTop="4dip" >
+
+        <ImageView
+            android:id="@+id/weather_image"
+            android:layout_width="wrap_content"
+            android:layout_height="wrap_content"
+            android:layout_centerHorizontal="true"
+            android:layout_centerVertical="true"
+            android:paddingLeft="8dip"
+            android:paddingRight="8dip" 
+            android:src="@android:drawable/ic_dialog_alert" />
+
+        <RelativeLayout
+            android:layout_width="wrap_content"
+            android:layout_height="wrap_content"
+            android:layout_centerVertical="true"
+            android:layout_toLeftOf="@id/weather_image"
+            android:orientation="horizontal"
+            android:padding="4dip" >
+
+            <TextView
+                android:id="@+id/weather_city"
+                android:layout_width="wrap_content"
+                android:layout_height="wrap_content"
+                android:textSize="14sp"
+                android:textStyle="bold"
+                android:layout_alignParentRight="true"
+                android:gravity="right"
+                android:singleLine="true"
+                android:ellipsize="marquee"
+                android:textColor="?android:attr/textColorPrimary"/>
+
+            <TextView
+                android:id="@+id/weather_condition"
+                android:layout_width="wrap_content"
+                android:layout_height="wrap_content"
+                android:layout_below="@id/weather_city"
+                android:layout_alignParentRight="true"
+                android:gravity="right"
+                android:singleLine="true"
+                android:ellipsize="marquee"
+                android:textSize="12sp"
+                android:textColor="?android:attr/textColorPrimary" />
+
+            <TextView
+                android:id="@+id/update_time"
+                android:layout_width="wrap_content"
+                android:layout_height="wrap_content"
+                android:gravity="right"
+                android:layout_below="@id/weather_condition"
+                android:layout_alignParentRight="true"
+                android:textSize="6sp"
+                android:textColor="?android:attr/textColorSecondary" />
+
+        </RelativeLayout>
+
+        <RelativeLayout
+            android:id="@+id/weather_temps_panel"
+            android:layout_width="wrap_content"
+            android:layout_height="wrap_content"
+            android:layout_toRightOf="@id/weather_image"
+            android:orientation="horizontal"
+            android:layout_centerVertical="true" >
+
+            <TextView
+                android:id="@+id/weather_temp"
+                android:layout_width="wrap_content"
+                android:layout_height="wrap_content"
+                android:layout_centerHorizontal="true"
+                android:textSize="20sp"
+                android:textColor="?android:attr/textColorPrimary" />
+
+            <View
+                android:id="@+id/weather_divider"
+                android:layout_below="@id/weather_temp"
+                android:layout_width="44dip"
+                android:layout_height="1dip"
+                android:background="@android:drawable/divider_horizontal_dark" />
+
+            <TextView
+                android:id="@+id/weather_low_high"
+                android:layout_width="wrap_content"
+                android:layout_height="wrap_content"
+                android:layout_below="@id/weather_divider"
+                android:layout_centerHorizontal="true"
+                android:paddingTop="2dip"
+                android:textSize="12sp"
+                android:textColor="?android:attr/textColorPrimary" />
+
+        </RelativeLayout>
+
+    </RelativeLayout>
+
     <Space android:layout_gravity="fill" />
 
     <!-- emergency call button shown when sim is PUKd and tab_selector is hidden -->
@@ -123,6 +224,69 @@
         android:layout_width="match_parent"
         android:layout_height="302dip">
 
+    <!-- CyanogenMod Calendar Panel -->
+    <LinearLayout
+        android:id="@+id/calendar_panel"
+        android:layout_width="match_parent"
+        android:layout_height="wrap_content"
+        android:minHeight="28dip"
+        android:gravity="center_vertical"
+        android:paddingLeft="12dip"
+        android:paddingRight="12dip" >
+
+        <ImageView
+            android:layout_width="36dp"
+            android:layout_height="wrap_content"
+            android:layout_gravity="center_vertical"
+            android:gravity="center"
+            android:src="@drawable/ic_lock_idle_calendar" />
+
+        <View
+            android:layout_width="1dip"
+            android:layout_height="match_parent"
+            android:paddingTop="6dip"
+            android:paddingBottom="6dip"
+            android:background="@android:drawable/divider_horizontal_dark" />
+
+        <RelativeLayout
+            android:layout_width="0dip"
+            android:layout_height="wrap_content"
+            android:layout_weight="1"
+            android:paddingTop="6dip"
+            android:paddingBottom="6dip"
+            android:paddingLeft="4dip" >
+
+            <TextView
+                android:id="@+id/calendar_event_title"
+                android:layout_width="wrap_content"
+                android:layout_height="wrap_content"
+                android:singleLine="true"
+                android:textSize="14sp"
+                android:textColor="?android:attr/textColorPrimary"
+                android:ellipsize="marquee"
+                android:fadingEdge="horizontal" />
+
+            <TextView
+                android:id="@+id/calendar_event_details"
+                android:layout_width="wrap_content"
+                android:layout_height="wrap_content"
+                android:layout_below="@id/calendar_event_title"
+                android:layout_alignLeft="@id/calendar_event_title"
+                android:textSize="12sp"
+                android:singleLine="true"
+                android:ellipsize="marquee"
+                android:marqueeRepeatLimit="marquee_forever"
+                android:scrollHorizontally="true"
+                android:focusable="true"
+                android:focusableInTouchMode="true"
+                android:fadingEdge="horizontal"
+                android:textColor="?android:attr/textColorSecondary" />
+
+        </RelativeLayout>
+
+    </LinearLayout>
+
+
         <com.android.internal.widget.multiwaveview.MultiWaveView
             android:id="@+id/unlock_widget"
             android:orientation="horizontal"
@@ -188,7 +352,7 @@
         layout="@layout/keyguard_transport_control"
         android:layout_row="0"
         android:layout_column="0"
-        android:layout_rowSpan="4"
+        android:layout_rowSpan="5"
         android:layout_columnSpan="1"
         android:layout_gravity="fill"
         android:layout_width="0dip"
diff --git a/core/res/res/layout/keyguard_screen_tab_unlock_land.xml b/core/res/res/layout/keyguard_screen_tab_unlock_land.xml
index 294f91e..b23a50c 100644
--- a/core/res/res/layout/keyguard_screen_tab_unlock_land.xml
+++ b/core/res/res/layout/keyguard_screen_tab_unlock_land.xml
@@ -30,8 +30,9 @@
 
     <!-- Column 0 -->
     <com.android.internal.widget.DigitalClock android:id="@+id/time"
-        android:layout_marginTop="80dip"
+        android:layout_marginTop="40dip"
         android:layout_marginBottom="8dip"
+        android:layout_columnSpan="3"
         android:layout_gravity="right">
 
        <!-- Because we can't have multi-tone fonts, we render two TextViews, one on
@@ -64,7 +65,7 @@
 
     <TextView
         android:id="@+id/date"
-        android:layout_width="0dip"
+        android:layout_columnSpan="3"
         android:layout_gravity="fill_horizontal"
         android:gravity="right"
         android:layout_marginTop="6dip"
@@ -76,6 +77,7 @@
 
     <TextView
         android:id="@+id/alarm_status"
+        android:layout_columnSpan="3"
         android:singleLine="true"
         android:ellipsize="marquee"
         android:textAppearance="?android:attr/textAppearanceMedium"
@@ -87,7 +89,7 @@
 
     <TextView
         android:id="@+id/status1"
-        android:layout_width="0dip"
+        android:layout_columnSpan="3"
         android:layout_gravity="fill_horizontal"
         android:gravity="right"
         android:layout_marginTop="4dip"
@@ -98,11 +100,110 @@
         android:drawablePadding="4dip"
         />
 
+    <!-- CyanogenMod Weather Panel -->
+    <RelativeLayout
+        android:id="@+id/weather_panel"
+        android:layout_columnSpan="3"
+        android:gravity="right"
+        android:layout_gravity="fill_horizontal"
+        android:layout_height="wrap_content"
+        android:orientation="horizontal" >
+
+        <ImageView
+            android:id="@+id/weather_image"
+            android:layout_width="wrap_content"
+            android:layout_height="wrap_content"
+            android:layout_centerVertical="true"
+            android:paddingLeft="8dip"
+            android:paddingRight="8dip"
+            android:src="@android:drawable/ic_dialog_alert" />
+
+        <RelativeLayout
+            android:layout_width="wrap_content"
+            android:layout_height="wrap_content"
+            android:layout_centerVertical="true"
+            android:layout_toLeftOf="@id/weather_image"
+            android:orientation="horizontal"
+            android:padding="4dip" >
+
+            <TextView
+                android:id="@+id/weather_city"
+                android:layout_width="wrap_content"
+                android:layout_height="wrap_content"
+                android:textSize="14sp"
+                android:textStyle="bold"
+                android:layout_alignParentRight="true"
+                android:gravity="right"
+                android:singleLine="true"
+                android:ellipsize="marquee"
+                android:textColor="?android:attr/textColorPrimary"/>
+
+            <TextView
+                android:id="@+id/weather_condition"
+                android:layout_width="wrap_content"
+                android:layout_height="wrap_content"
+                android:layout_below="@id/weather_city"
+                android:layout_alignParentRight="true"
+                android:gravity="right"
+                android:singleLine="true"
+                android:ellipsize="marquee"
+                android:textSize="12sp"
+                android:textColor="?android:attr/textColorPrimary" />
+
+            <TextView
+                android:id="@+id/update_time"
+                android:layout_width="wrap_content"
+                android:layout_height="wrap_content"
+                android:layout_below="@id/weather_condition"
+                android:layout_alignParentRight="true"
+                android:gravity="right"
+                android:textSize="6sp"
+                android:textColor="?android:attr/textColorSecondary" />
+
+        </RelativeLayout>
+
+        <RelativeLayout
+            android:id="@+id/weather_temps_panel"
+            android:layout_width="wrap_content"
+            android:layout_height="wrap_content"
+            android:layout_toRightOf="@id/weather_image"
+            android:orientation="horizontal"
+            android:layout_centerVertical="true" >
+
+            <TextView
+                android:id="@+id/weather_temp"
+                android:layout_width="wrap_content"
+                android:layout_height="wrap_content"
+                android:layout_centerHorizontal="true"
+                android:textSize="20sp"
+                android:textColor="?android:attr/textColorPrimary" />
+
+            <View
+                android:id="@+id/weather_divider"
+                android:layout_below="@id/weather_temp"
+                android:layout_width="44dip"
+                android:layout_height="1dip"
+                android:background="@android:drawable/divider_horizontal_dark" />
+
+            <TextView
+                android:id="@+id/weather_low_high"
+                android:layout_width="wrap_content"
+                android:layout_height="wrap_content"
+                android:layout_below="@id/weather_divider"
+                android:layout_centerHorizontal="true"
+                android:paddingTop="2dip"
+                android:textSize="12sp"
+                android:textColor="?android:attr/textColorPrimary" />
+
+        </RelativeLayout>
+
+    </RelativeLayout>
+
     <Space android:layout_gravity="fill" />
 
     <TextView
         android:id="@+id/carrier"
-        android:layout_width="0dip"
+        android:layout_columnSpan="3"
         android:layout_gravity="fill_horizontal"
         android:layout_marginBottom="12dip"
         android:gravity="right"
@@ -156,7 +257,7 @@
         android:layout_row="0"
         android:layout_column="0"
         android:layout_rowSpan="5"
-        android:layout_columnSpan="1"
+        android:layout_columnSpan="3"
         android:layout_gravity="fill"
         android:layout_width="0dip"
         android:layout_height="0dip"
diff --git a/core/res/res/layout/keyguard_screen_unlock_portrait.xml b/core/res/res/layout/keyguard_screen_unlock_portrait.xml
index 336faa1..0ea680b 100644
--- a/core/res/res/layout/keyguard_screen_unlock_portrait.xml
+++ b/core/res/res/layout/keyguard_screen_unlock_portrait.xml
@@ -25,6 +25,7 @@
     android:orientation="vertical"
     android:layout_width="match_parent"
     android:layout_height="match_parent"
+    android:id="@+id/root"
     android:gravity="center_horizontal">
 
     <com.android.internal.widget.DigitalClock android:id="@+id/time"
diff --git a/core/res/res/layout/preference_child_holo.xml b/core/res/res/layout/preference_child_holo.xml
index 3c6a12e..4167862 100644
--- a/core/res/res/layout/preference_child_holo.xml
+++ b/core/res/res/layout/preference_child_holo.xml
@@ -60,7 +60,7 @@
             android:layout_alignLeft="@android:id/title"
             android:textAppearance="?android:attr/textAppearanceSmall"
             android:textColor="?android:attr/textColorSecondary"
-            android:maxLines="4" />
+            android:maxLines="10" />
 
     </RelativeLayout>
 
diff --git a/core/res/res/layout/preference_holo.xml b/core/res/res/layout/preference_holo.xml
index 48f483d..e574219 100644
--- a/core/res/res/layout/preference_holo.xml
+++ b/core/res/res/layout/preference_holo.xml
@@ -63,7 +63,7 @@
             android:layout_alignLeft="@android:id/title"
             android:textAppearance="?android:attr/textAppearanceSmall"
             android:textColor="?android:attr/textColorSecondary"
-            android:maxLines="4" />
+            android:maxLines="10" />
 
     </RelativeLayout>
 
diff --git a/core/res/res/layout/preference_information_holo.xml b/core/res/res/layout/preference_information_holo.xml
index e29ed03..5e03cfb 100644
--- a/core/res/res/layout/preference_information_holo.xml
+++ b/core/res/res/layout/preference_information_holo.xml
@@ -61,7 +61,7 @@
             android:layout_alignLeft="@android:id/title"
             android:textAppearance="?android:attr/textAppearanceSmall"
             android:textColor="?android:attr/textColorSecondary"
-            android:maxLines="2" />
+            android:maxLines="10" />
 
     </RelativeLayout>
 
diff --git a/core/res/res/layout/transient_notification.xml b/core/res/res/layout/transient_notification.xml
index 21d58aa..5523807 100644
--- a/core/res/res/layout/transient_notification.xml
+++ b/core/res/res/layout/transient_notification.xml
@@ -29,6 +29,7 @@
         android:layout_width="wrap_content"
         android:layout_height="wrap_content"
         android:layout_weight="1"
+        android:layout_gravity="center_horizontal"
         android:textAppearance="@style/TextAppearance.Small"
         android:textColor="@color/bright_foreground_dark"
         android:shadowColor="#BB000000"
diff --git a/core/res/res/layout/volume_adjust.xml b/core/res/res/layout/volume_adjust.xml
index c16a12c..d39de3a 100644
--- a/core/res/res/layout/volume_adjust.xml
+++ b/core/res/res/layout/volume_adjust.xml
@@ -57,4 +57,4 @@
             />
 
     </LinearLayout>
-</FrameLayout>
\ No newline at end of file
+</FrameLayout>
diff --git a/core/res/res/values-de/strings.xml b/core/res/res/values-de/strings.xml
index 6550f5b..2d1ab12 100644
--- a/core/res/res/values-de/strings.xml
+++ b/core/res/res/values-de/strings.xml
@@ -137,6 +137,29 @@
     <string name="turn_off_radio" msgid="8198784949987062346">"Funk ausschalten"</string>
     <string name="screen_lock" msgid="799094655496098153">"Display-Sperre"</string>
     <string name="power_off" msgid="4266614107412865048">"Ausschalten"</string>
+
+    <!-- Button to reboot the phone, within the Phone Options dialog -->
+    <string name="reboot_system" product="tablet">Tablet neu starten</string>
+    <string name="reboot_system" product="default">Telefon neu starten</string>
+
+    <!-- Button to reboot the phone, within the Reboot Options dialog -->
+    <string name="reboot_reboot">Neu starten</string>
+    <!-- Button to reboot the phone into recovery, within the Reboot Options dialog -->
+    <string name="reboot_recovery">Recovery</string>
+    <!-- Button to reboot the phone into bootloader, within the Reboot Options dialog -->
+    <string name="reboot_bootloader">Bootloader</string>
+    <!-- Button to reboot the phone into bootmenu, within the Reboot Options dialog -->
+    <string name="reboot_bootmenu">Bootmenü</string>
+    <!-- Button to reboot the phone into fastboot, within the Reboot Options dialog -->
+    <string name="reboot_fastboot">Fastboot</string>
+    <!-- Button to reboot the phone into download, within the Reboot Options dialog -->
+    <string name="reboot_download">Download</string>
+
+    <!-- Reboot Progress Dialog. This is shown if the user chooses to reboot the phone. -->
+    <string name="reboot_progress">Neu starten\u2026</string>
+    <!-- Reboot Confirmation Dialog.  When the user chooses to reboot the phone, there will be a confirmation dialog.  This is the message. -->
+    <string name="reboot_confirm">Telefon wird neu gestartet.</string>
+
     <string name="silent_mode_silent" msgid="319298163018473078">"Klingelton aus"</string>
     <string name="silent_mode_vibrate" msgid="7072043388581551395">"Klingeltonmodus \"Vibration\""</string>
     <string name="silent_mode_ring" msgid="8592241816194074353">"Klingelton ein"</string>
@@ -150,6 +173,8 @@
     <string name="global_actions" product="default" msgid="2406416831541615258">"Telefonoptionen"</string>
     <string name="global_action_lock" msgid="2844945191792119712">"Display-Sperre"</string>
     <string name="global_action_power_off" msgid="4471879440839879722">"Ausschalten"</string>
+    <string name="global_action_reboot">Neu starten</string>
+    <string name="global_action_screenshot">Bildschirmfoto</string>
     <string name="global_action_toggle_silent_mode" msgid="8219525344246810925">"Lautlos-Modus"</string>
     <string name="global_action_silent_mode_on_status" msgid="3289841937003758806">"Ton ist AUS."</string>
     <string name="global_action_silent_mode_off_status" msgid="1506046579177066419">"Ton ist AN."</string>
@@ -1024,8 +1049,8 @@
     <string name="extmedia_format_message" product="nosdcard" msgid="8296908079722897772">"USB-Speicher formatieren und alle darin befindlichen Dateien löschen? Diese Aktion kann nicht rückgängig gemacht werden!"</string>
     <string name="extmedia_format_message" product="default" msgid="3621369962433523619">"Möchten Sie die SD-Karte wirklich formatieren? Alle Daten auf Ihrer Karte gehen dann verloren."</string>
     <string name="extmedia_format_button_format" msgid="4131064560127478695">"Format"</string>
-    <string name="adb_active_notification_title" msgid="6729044778949189918">"USB-Debugging"</string>
-    <string name="adb_active_notification_message" msgid="8470296818270110396">"USB-Debugging deaktivieren: auswählen"</string>
+    <string name="adb_active_notification_title" msgid="6729044778949189918">"Android-Debugging eingeschaltet"</string>
+    <string name="adb_active_notification_message" msgid="8470296818270110396">"Android-Debugging deaktivieren: auswählen"</string>
     <string name="select_input_method" msgid="6865512749462072765">"Eingabemethode auswählen"</string>
     <string name="configure_input_methods" msgid="6324843080254191535">"Eingabemethoden konfigurieren"</string>
     <string name="fast_scroll_alphabet" msgid="5433275485499039199">" ABCDEFGHIJKLMNOPQRSTUVWXYZ"</string>
@@ -1227,4 +1252,75 @@
     <string name="sending" msgid="8715108995741758718">"Wird gesendet..."</string>
     <string name="launchBrowserDefault" msgid="2057951947297614725">"Browser starten?"</string>
     <string name="SetupCallDefault" msgid="6870275517518479651">"Anruf annehmen?"</string>
+
+    <!--Application killed toast -->
+    <string name="app_killed_message">Anwendung beendet</string>
+
+    <!-- Lock screen Weather - Weather codes -->
+    <string name="weather_0">Tornado</string>
+    <string name="weather_1">Tropensturm</string>
+    <string name="weather_2">Hurrikan</string>
+    <string name="weather_3">Heftige Gewitter</string>
+    <string name="weather_4">Gewitter</string>
+    <string name="weather_5">Wechselnd Regen und Schnee</string>
+    <string name="weather_6">Wechselnd Regen und Schneeregen</string>
+    <string name="weather_7">Wechselnd Schnee und Schneeregen</string>
+    <string name="weather_8">Gefrierender Niesel</string>
+    <string name="weather_9">Niesel</string>
+    <string name="weather_10">Gefrierender Regen</string>
+    <string name="weather_11">Schauer</string>
+    <string name="weather_12">Schauer</string>
+    <string name="weather_13">Scheegestöber</string>
+    <string name="weather_14">Leichte Schneeschauer</string>
+    <string name="weather_15">Schneesturm</string>
+    <string name="weather_16">Schnee</string>
+    <string name="weather_17">Hagel</string>
+    <string name="weather_18">Schneeregen</string>
+    <string name="weather_19">Staubig</string>
+    <string name="weather_20">Neblig</string>
+    <string name="weather_21">Dunst</string>
+    <string name="weather_22">Rauch</string>
+    <string name="weather_23">Stürmisch</string>
+    <string name="weather_24">Windig</string>
+    <string name="weather_25">Kalt</string>
+    <string name="weather_26">Bedeckt</string>
+    <string name="weather_27">Stark bewölkt</string> <!-- Night -->
+    <string name="weather_28">Stark bewölkt</string> <!-- Day -->
+    <string name="weather_29">Teilweise bewölkt</string> <!-- Night -->
+    <string name="weather_30">Teilweise bewölkt</string> <!-- Day -->
+    <string name="weather_31">Klar</string> <!-- Night -->
+    <string name="weather_32">Sonnig</string>
+    <string name="weather_33">Heiter</string> <!-- Night -->
+    <string name="weather_34">Heiter</string> <!-- Day -->
+    <string name="weather_35">Wechselnd Regen und Hagel</string>
+    <string name="weather_36">Heiß</string>
+    <string name="weather_37">Örtliche Gewitter</string>
+    <string name="weather_38">Einzelne Gewitter</string>
+    <string name="weather_39">Einzelne Gewitter</string>
+    <string name="weather_40">Einzelne Schauer</string>
+    <string name="weather_41">Heftiger Schneefall</string>
+    <string name="weather_42">Einzelne Schneeschauer</string>
+    <string name="weather_43">Heftiger Schneefall</string>
+    <string name="weather_44">Teilweise bewölkt</string>
+    <string name="weather_45">Gewitterschauer</string>
+    <string name="weather_46">Schneeschauer</string>
+    <string name="weather_47">Örtliche Gewitterschauer</string>
+    <!-- Forecast unavailable -->
+    <string name="weather_3200"></string>
+
+    <!-- Lock screen Weather - Wind directions -->
+    <string name="weather_N">N</string>
+    <string name="weather_NE">NO</string>
+    <string name="weather_E">O</string>
+    <string name="weather_SE">SO</string>
+    <string name="weather_S">S</string>
+    <string name="weather_SW">SW</string>
+    <string name="weather_W">W</string>
+    <string name="weather_NW">NW</string>
+
+    <!-- Lock screen Weather - error messages -->
+    <string name="weather_no_data">Keine Daten</string>
+    <string name="weather_tap_to_refresh">Zum Aktualisieren berühren</string>
+    <string name="weather_refreshing">Aktualisiere\u2026</string>
+
 </resources>
diff --git a/core/res/res/values-el/strings.xml b/core/res/res/values-el/strings.xml
index e15e2fc..5f495b6 100644
--- a/core/res/res/values-el/strings.xml
+++ b/core/res/res/values-el/strings.xml
@@ -36,6 +36,17 @@
     <string name="defaultMsisdnAlphaTag" msgid="2850889754919584674">"MSISDN1"</string>
     <string name="mmiError" msgid="5154499457739052907">"Πρόβλημα σύνδεσης ή μη έγκυρος κώδικας MMI."</string>
     <string name="mmiFdnError" msgid="5224398216385316471">"Η λειτουργία περιορίζεται μόνο σε καθορισμένους αριθμούς κλήσης."</string>
+    <string name="profileNameDefault">Προεπιλογή</string>
+    <string name="profileNameWork">Εργασία</string>
+    <string name="profileNameHome">Οικία</string>
+    <string name="profileNameSilent">Αθόρυβο</string>
+    <string name="profileNameNight">Νύχτα</string>
+    <string name="profileGroupPhone">Τηλέφωνο</string>
+    <string name="profileGroupCalendar">Ημερολόγιο</string>
+    <string name="profileGroupGmail">Gmail</string>
+    <string name="profileGroupEmail">Email</string>
+    <string name="profileGroupSMS">SMS</string>
+    <string name="wildcardProfile">Άλλο</string>
     <string name="serviceEnabled" msgid="8147278346414714315">"Η υπηρεσία ενεργοποιήθηκε."</string>
     <string name="serviceEnabledFor" msgid="6856228140453471041">"Η υπηρεσία ενεργοποιήθηκε για:"</string>
     <string name="serviceDisabled" msgid="1937553226592516411">"Η υπηρεσία έχει απενεργοποιηθεί."</string>
@@ -137,6 +148,10 @@
     <string name="turn_off_radio" msgid="8198784949987062346">"Απενεργοποίηση ασύρματου"</string>
     <string name="screen_lock" msgid="799094655496098153">"Κλείδωμα οθόνης"</string>
     <string name="power_off" msgid="4266614107412865048">"Απενεργοποίηση"</string>
+    <string name="reboot_system">Επανεκκίνηση τηλεφώνου</string>
+    <string name="reboot_reboot">Επανεκκίνηση</string>
+    <string name="reboot_progress">Επανεκκίνηση\u2026</string>
+    <string name="reboot_confirm">Το τηλέφωνό σας θα επανεκκινηθεί.</string>
     <string name="silent_mode_silent" msgid="319298163018473078">"Ειδοποίηση ήχου ανενεργή"</string>
     <string name="silent_mode_vibrate" msgid="7072043388581551395">"Δόνηση ειδοποίησης ήχου"</string>
     <string name="silent_mode_ring" msgid="8592241816194074353">"Ειδοποίηση ήχου ενεργή"</string>
@@ -150,6 +165,8 @@
     <string name="global_actions" product="default" msgid="2406416831541615258">"Επιλογές τηλεφώνου"</string>
     <string name="global_action_lock" msgid="2844945191792119712">"Κλείδωμα οθόνης"</string>
     <string name="global_action_power_off" msgid="4471879440839879722">"Απενεργοποίηση"</string>
+    <string name="global_action_reboot">Επανεκκίνηση</string>
+    <string name="global_action_choose_profile">Προφίλ</string>
     <string name="global_action_toggle_silent_mode" msgid="8219525344246810925">"Λειτουργία σίγασης"</string>
     <string name="global_action_silent_mode_on_status" msgid="3289841937003758806">"Ο ήχος είναι απενεργοποιημένος"</string>
     <string name="global_action_silent_mode_off_status" msgid="1506046579177066419">"Ο ήχος είναι ενεργοποιημένος"</string>
diff --git a/core/res/res/values-es/strings.xml b/core/res/res/values-es/strings.xml
old mode 100644
new mode 100755
index 4691bbe..2902965
--- a/core/res/res/values-es/strings.xml
+++ b/core/res/res/values-es/strings.xml
@@ -36,6 +36,17 @@
     <string name="defaultMsisdnAlphaTag" msgid="2850889754919584674">"MSISDN1"</string>
     <string name="mmiError" msgid="5154499457739052907">"Se ha producido un problema de conexión o el código MMI no es válido."</string>
     <string name="mmiFdnError" msgid="5224398216385316471">"La operación solo es válida para números de marcación fija."</string>
+    <string name="profileNameDefault">"Predeterminado"</string>
+    <string name="profileNameWork">"Trabajo"</string>
+    <string name="profileNameHome">"Casa"</string>
+    <string name="profileNameSilent">"Silencio"</string>
+    <string name="profileNameNight">"Noche"</string>
+    <string name="profileGroupPhone">"Teléfono"</string>
+    <string name="profileGroupCalendar">"Calendario"</string>
+    <string name="profileGroupGmail">"Gmail"</string>
+    <string name="profileGroupEmail">"Email"</string>
+    <string name="profileGroupSMS">SMS</string>
+    <string name="wildcardProfile">Otro</string>
     <string name="serviceEnabled" msgid="8147278346414714315">"El servicio se ha habilitado."</string>
     <string name="serviceEnabledFor" msgid="6856228140453471041">"Se ha habilitado el servicio para:"</string>
     <string name="serviceDisabled" msgid="1937553226592516411">"El servicio se ha inhabilitado."</string>
@@ -137,6 +148,17 @@
     <string name="turn_off_radio" msgid="8198784949987062346">"Desactivar función inalámbrica"</string>
     <string name="screen_lock" msgid="799094655496098153">"Bloqueo de pantalla"</string>
     <string name="power_off" msgid="4266614107412865048">"Apagar"</string>
+    <string name="reboot_system" product="tablet">"Reiniciar tablet"</string>
+    <string name="reboot_system" product="default">"Reiniciar teléfono"</string>
+    <string name="global_action_screenshot">"Captura de pantalla"</string>
+    <string name="reboot_reboot">"Reiniciar"</string>
+    <string name="reboot_recovery">"Modo Recovery"</string>
+    <string name="reboot_bootloader">"Modo Bootloader"</string>
+    <string name="reboot_bootmenu">"Modo Bootmenu"</string>
+    <string name="reboot_fastboot">"Modo Fastboot"</string>
+    <string name="reboot_download">"Modo Download"</string>
+    <string name="reboot_progress">"Reiniciando\u2026"</string>
+    <string name="reboot_confirm">"El teléfono se reiniciará."</string>
     <string name="silent_mode_silent" msgid="319298163018473078">"Timbre desactivado"</string>
     <string name="silent_mode_vibrate" msgid="7072043388581551395">"Modo vibración"</string>
     <string name="silent_mode_ring" msgid="8592241816194074353">"Timbre activado"</string>
@@ -150,6 +172,8 @@
     <string name="global_actions" product="default" msgid="2406416831541615258">"Opciones del teléfono"</string>
     <string name="global_action_lock" msgid="2844945191792119712">"Bloqueo de pantalla"</string>
     <string name="global_action_power_off" msgid="4471879440839879722">"Apagar"</string>
+    <string name="global_action_reboot">"Reiniciar"</string>
+    <string name="global_action_choose_profile">"Perfil"</string>
     <string name="global_action_toggle_silent_mode" msgid="8219525344246810925">"Modo silencio"</string>
     <string name="global_action_silent_mode_on_status" msgid="3289841937003758806">"El sonido está desactivado. Activar"</string>
     <string name="global_action_silent_mode_off_status" msgid="1506046579177066419">"El sonido está activado. Desactivar"</string>
@@ -301,6 +325,8 @@
     <string name="permdesc_clearAppCache" product="default" msgid="7740465694193671402">"Permite que una aplicación libere espacio de almacenamiento en el teléfono mediante la eliminación de archivos en el directorio de caché de la aplicación. El acceso al proceso del sistema suele estar muy restringido."</string>
     <string name="permlab_movePackage" msgid="728454979946503926">"Mover recursos de aplicaciones"</string>
     <string name="permdesc_movePackage" msgid="6323049291923925277">"Permite que una aplicación mueva los recursos de aplicaciones de un medio interno a otro externo y viceversa."</string>
+    <string name="permlab_preventpower">"anular tecla encendido"</string>
+    <string name="permdesc_preventpower">"Permite que una aplicación anule la tecla de encendido"</string>
     <string name="permlab_readLogs" msgid="6615778543198967614">"leer datos de registro personales"</string>
     <string name="permdesc_readLogs" product="tablet" msgid="4077356893924755294">"Permite que una aplicación lea diversos archivos de registro del sistema. Con este permiso, la aplicación puede ver información general sobre las acciones que se realizan con el tablet (que puede incluir datos personales o privados)."</string>
     <string name="permdesc_readLogs" product="default" msgid="8896449437464867766">"Permite que una aplicación lea distintos archivos de registro del sistema. Con este permiso, la aplicación puede ver información general sobre las acciones que realizas con el teléfono, que puede incluir datos personales o privados."</string>
@@ -1227,4 +1253,61 @@
     <string name="sending" msgid="8715108995741758718">"Enviando..."</string>
     <string name="launchBrowserDefault" msgid="2057951947297614725">"¿Iniciar el navegador?"</string>
     <string name="SetupCallDefault" msgid="6870275517518479651">"¿Aceptar la llamada?"</string>
+    <string name="app_killed_message">"Aplicación finalizada"</string>
+    <!-- Lock screen Weather - Weather codes -->
+    <string name="weather_0">Tornado</string>
+    <string name="weather_1">Torm. tropical</string>
+    <string name="weather_2">Huracan</string>
+    <string name="weather_3">Torm. severas</string>
+    <string name="weather_4">Tormentas</string>
+    <string name="weather_5">Agua y nieve</string>
+    <string name="weather_6">Agua y aguanieve</string>
+    <string name="weather_7">Nieve y aguanieve</string>
+    <string name="weather_8">Llovizna helada</string>
+    <string name="weather_9">Llovizna</string>
+    <string name="weather_10">Lluvia helada</string>
+    <string name="weather_11">Lluvias</string>
+    <string name="weather_12">Lluvias</string>
+    <string name="weather_13">Copos de nieve</string>
+    <string name="weather_14">Nevadas ligeras</string>
+    <string name="weather_15">Chub. de nieve</string>
+    <string name="weather_16">Nieve</string>
+    <string name="weather_17">Granizo</string>
+    <string name="weather_18">Aguanieve</string>
+    <string name="weather_19">Polvo</string>
+    <string name="weather_20">Nublado</string>
+    <string name="weather_21">Neblina</string>
+    <string name="weather_22">Humo</string>
+    <string name="weather_23">Borrascoso</string>
+    <string name="weather_24">Ventoso</string>
+    <string name="weather_25">Frío</string>
+    <string name="weather_26">Nublado</string>
+    <string name="weather_27">Mayorm. nublado</string> <!-- Night -->
+    <string name="weather_28">Mayorm. nublado</string> <!-- Day -->
+    <string name="weather_29">Parc. nublado</string> <!-- Night -->
+    <string name="weather_30">Parc. nublado</string> <!-- Day -->
+    <string name="weather_31">Despejado</string> <!-- Night -->
+    <string name="weather_32">Soleado</string>
+    <string name="weather_33">Moderado</string> <!-- Night -->
+    <string name="weather_34">Moderado</string> <!-- Day -->
+    <string name="weather_35">Lluvia y granizo</string>
+    <string name="weather_36">Caluroso</string>
+    <string name="weather_37">Torm. eléctricas</string>
+    <string name="weather_38">Torm. elec. aisladas</string>
+    <string name="weather_39">Torm. elec. aisladas</string>
+    <string name="weather_40">Parc. Nublado</string>
+    <string name="weather_41">Fuertes Nevadas</string>
+    <string name="weather_42">Chub. de nieve</string>
+  <string name="weather_43">Fuertes nevadas</string>
+    <string name="weather_44">Parc. nublado</string>
+    <string name="weather_45">Chaparrones</string>
+    <string name="weather_46">Nieve</string>
+    <string name="weather_47">Chap. aislados</string>
+    <!-- Forecast unavailable -->
+    <string name="weather_3200">No disponible</string>
+
+    <!-- Lock screen Weather - error messages -->
+    <string name="weather_no_data">Sin datos</string>
+    <string name="weather_tap_to_refresh">Toca para refrescar</string>
+    <string name="weather_refreshing">Actualizando</string>
 </resources>
diff --git a/core/res/res/values-fi/strings.xml b/core/res/res/values-fi/strings.xml
index 97f4ab1..b7b54ce 100644
--- a/core/res/res/values-fi/strings.xml
+++ b/core/res/res/values-fi/strings.xml
@@ -150,6 +150,7 @@
     <string name="global_actions" product="default" msgid="2406416831541615258">"Puhelimen asetukset"</string>
     <string name="global_action_lock" msgid="2844945191792119712">"Näytön lukitus"</string>
     <string name="global_action_power_off" msgid="4471879440839879722">"Katkaise virta"</string>
+    <string name="global_action_reboot">Käynnistä uudelleen</string>
     <string name="global_action_toggle_silent_mode" msgid="8219525344246810925">"Äänetön tila"</string>
     <string name="global_action_silent_mode_on_status" msgid="3289841937003758806">"Äänet ovat POISSA KÄYTÖSTÄ"</string>
     <string name="global_action_silent_mode_off_status" msgid="1506046579177066419">"Äänet ovat KÄYTÖSSÄ"</string>
@@ -665,7 +666,7 @@
     <string name="lockscreen_pattern_wrong" msgid="4817583279053112312">"Yritä uudelleen"</string>
     <string name="lockscreen_password_wrong" msgid="6237443657358168819">"Yritä uudelleen"</string>
     <string name="lockscreen_plugged_in" msgid="8057762828355572315">"Ladataan (<xliff:g id="NUMBER">%d</xliff:g> <xliff:g id="PERCENT">%%</xliff:g>)"</string>
-    <string name="lockscreen_charged" msgid="4938930459620989972">"Muutettu."</string>
+    <string name="lockscreen_charged" msgid="4938930459620989972">"Ladattu."</string>
     <string name="lockscreen_battery_short" msgid="3617549178603354656">"<xliff:g id="NUMBER">%d</xliff:g><xliff:g id="PERCENT">%%</xliff:g>"</string>
     <string name="lockscreen_low_battery" msgid="1482873981919249740">"Kytke laturi."</string>
     <string name="lockscreen_missing_sim_message_short" msgid="7381499217732227295">"Ei SIM-korttia."</string>
@@ -695,7 +696,7 @@
     <string name="lockscreen_failed_attempts_now_wiping" product="tablet" msgid="280873516493934365">"Tablet-laitteen lukituksen poisto epäonnistui <xliff:g id="NUMBER">%d</xliff:g> kertaa. Laitteeseen palautetaan nyt tehdasasetukset."</string>
     <string name="lockscreen_failed_attempts_now_wiping" product="default" msgid="3025504721764922246">"Puhelimen lukituksen poisto epäonnistui <xliff:g id="NUMBER">%d</xliff:g> kertaa. Puhelimeen palautetaan nyt tehdasasetukset."</string>
     <string name="lockscreen_too_many_failed_attempts_countdown" msgid="6251480343394389665">"Yritä uudelleen <xliff:g id="NUMBER">%d</xliff:g> sekunnin kuluttua."</string>
-    <string name="lockscreen_forgot_pattern_button_text" msgid="2626999449610695930">"Unohditko mallin?"</string>
+    <string name="lockscreen_forgot_pattern_button_text" msgid="2626999449610695930">"Unohditko kuvion?"</string>
     <string name="lockscreen_glogin_forgot_pattern" msgid="2588521501166032747">"Tilin lukituksen poisto"</string>
     <string name="lockscreen_glogin_too_many_attempts" msgid="2446246026221678244">"Liikaa kuvion piirtoyrityksiä!"</string>
     <string name="lockscreen_glogin_instructions" msgid="1816635201812207709">"Poista lukitus kirjautumalla sisään Google-tilisi avulla"</string>
@@ -1227,4 +1228,70 @@
     <string name="sending" msgid="8715108995741758718">"Lähetetään..."</string>
     <string name="launchBrowserDefault" msgid="2057951947297614725">"Käynnistetäänkö selain?"</string>
     <string name="SetupCallDefault" msgid="6870275517518479651">"Vastataanko puheluun?"</string>
+    <string name="global_action_screenshot">Kuvakaappaus</string>
+    <string name="reboot_reboot">Käynnistä uudelleen</string>
+    <string name="reboot_system" product="tablet">Käynnistä tablet uudelleen</string>
+    <string name="reboot_system" product="default">Käynnistä puhelin uudelleen</string>
+    <string name="reboot_progress">Uudelleenkäynnistetään\u2026</string>
+    <string name="reboot_confirm">Laitteesi käynnistyy uudelleen</string>
+    <string name="profileNameDefault">Oletus</string>
+    <string name="profileNameWork">Työ</string>
+    <string name="profileNameHome">Koti</string>
+    <string name="profileNameSilent">Äänetön</string>
+    <string name="profileNameNight">Yö</string>
+    <string name="profileGroupPhone">Puhelin</string>
+    <string name="profileGroupCalendar">Kalenteri</string>
+    <string name="profileGroupEmail">Sähköposti</string>
+    <string name="profileGroupSMS">Tekstiviesti</string>
+    <string name="wildcardProfile">Muu</string>
+    <string name="global_action_choose_profile">Profiili</string>
+    <string name="weather_0">Pyörremyrsky</string>
+    <string name="weather_1">Trooppinen myrsky</string>
+    <string name="weather_2">Hurrikaani</string>
+    <string name="weather_3">Kovia ukkosmyrskyjä</string>
+    <string name="weather_4">Ukkosmyrskyjä</string>
+    <string name="weather_5">Räntäsadetta</string>
+    <string name="weather_6">Räntäsadetta</string>
+    <string name="weather_7">Räntäsadetta</string>
+    <string name="weather_8">Jäätävää tihkua</string>
+    <string name="weather_9">Tihkusadetta</string>
+    <string name="weather_10">Jäätävää sadetta</string>
+    <string name="weather_11">Sadekuuroja</string>
+    <string name="weather_12">Sadekuuroja</string>
+    <string name="weather_13">Lumikuuroja</string>
+    <string name="weather_14">Kevyitä lumikuuroja</string>
+    <string name="weather_15">Lumituiskuja</string>
+    <string name="weather_16">Lumisadetta</string>
+    <string name="weather_17">Raekuuroja</string>
+    <string name="weather_18">Räntäsadetta</string>
+    <string name="weather_19">Pölyistä</string>
+    <string name="weather_20">Sumua</string>
+    <string name="weather_21">Usvaa</string>
+    <string name="weather_22">Savua</string>
+    <string name="weather_23">Tuulenpuuskia</string>
+    <string name="weather_24">Tuulista</string>
+    <string name="weather_25">Kylmää</string>
+    <string name="weather_26">Pilvistä</string>
+    <string name="weather_27">Enimmäkseen pilvistä</string> <!-- Night -->
+    <string name="weather_28">Enimmäkseen pilvistä</string> <!-- Day -->
+    <string name="weather_29">Puolipilvistä</string> <!-- Night -->
+    <string name="weather_30">Puolipilvistä</string> <!-- Day -->
+    <string name="weather_31">Kirkasta</string> <!-- Night -->
+    <string name="weather_32">Aurinkoista</string>
+    <string name="weather_33">Selkeää</string> <!-- Night -->
+    <string name="weather_34">Poutaa</string> <!-- Day -->
+    <string name="weather_35">Raekuuroja</string>
+    <string name="weather_36">Hellettä</string>
+    <string name="weather_37">Paikallisia ukkosia</string>
+    <string name="weather_38">Satunnaisia ukkosia</string>
+    <string name="weather_39">Satunnaisia ukkosia</string>
+    <string name="weather_40">Satunnaisia sateita</string>
+    <string name="weather_41">Sankkaa lumisadetta</string>
+    <string name="weather_42">Satunnaisia lumisateita</string>
+    <string name="weather_43">Sankkaa lumisadetta</string>
+    <string name="weather_44">Puolipilvistä</string>
+    <string name="weather_45">Ukkoskuuroja</string>
+    <string name="weather_46">Lumikuuroja</string>
+    <string name="weather_47">Paikallisia ukkoskuuroja</string>
+    <string name="weather_tap_to_refresh">Päivitä</string>
 </resources>
diff --git a/core/res/res/values-fr/strings.xml b/core/res/res/values-fr/strings.xml
index 3fe492e..cf6fe05 100644
--- a/core/res/res/values-fr/strings.xml
+++ b/core/res/res/values-fr/strings.xml
@@ -20,6 +20,87 @@
 
 <resources xmlns:android="http://schemas.android.com/apk/res/android"
     xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
+
+    <!-- Names of default profiles. -->
+    <string name="profileNameDefault">Défaut</string>
+    <string name="profileNameWork">Bureau</string>
+    <string name="profileNameHome">Maison</string>
+    <string name="profileNameSilent">Silence</string>
+    <string name="profileNameNight">Nuit</string>
+
+    <!-- Names of application groups. -->
+    <string name="profileGroupPhone">Téléphone</string>
+    <string name="profileGroupCalendar">Agenda</string>
+    <string name="profileGroupGmail">Gmail</string>
+    <string name="profileGroupEmail">Email</string>
+    <string name="profileGroupSMS">SMS</string>
+
+    <!-- Name of wildcard profile. -->
+    <string name="wildcardProfile">Autres</string>
+
+    <!-- Lock screen Weather - Weather codes -->
+    <string name="weather_0">Tornade</string>
+    <string name="weather_1">Orage tropical</string>
+    <string name="weather_2">Ouragan</string>
+    <string name="weather_3">Orages sévères</string>
+    <string name="weather_4">Orages</string>
+    <string name="weather_5">Neige ou pluie</string>
+    <string name="weather_6">Pluie ou verglas</string>
+    <string name="weather_7">Neige ou verglas</string>
+    <string name="weather_8">Brouillard givrant</string>
+    <string name="weather_9">Bruine</string>
+    <string name="weather_10">Pluie givrante</string>
+    <string name="weather_11">Pluie</string>
+    <string name="weather_12">Averses</string>
+    <string name="weather_13">Chûtes de neige</string>
+    <string name="weather_14">Neige légère</string>
+    <string name="weather_15">Poudreuse</string>
+    <string name="weather_16">Neige</string>
+    <string name="weather_17">Grêle</string>
+    <string name="weather_18">Neige fondue</string>
+    <string name="weather_19">Poussière</string>
+    <string name="weather_20">Brouillard</string>
+    <string name="weather_21">Brume</string>
+    <string name="weather_22">Enfumé</string>
+    <string name="weather_23">Vent</string>
+    <string name="weather_24">Venteux</string>
+    <string name="weather_25">Froid</string>
+    <string name="weather_26">Couvert</string>
+    <string name="weather_27">Ciel couvert</string> <!-- Night -->
+    <string name="weather_28">Nuageux</string> <!-- Day -->
+    <string name="weather_29">Quelques nuages</string> <!-- Night -->
+    <string name="weather_30">Quelques nuages</string> <!-- Day -->
+    <string name="weather_31">Ciel dégagé</string> <!-- Night -->
+    <string name="weather_32">Ensoleillé</string>
+    <string name="weather_33">Plutôt dégagé</string> <!-- Fair, Night -->
+    <string name="weather_34">Beau temps</string> <!-- Fair, Day -->
+    <string name="weather_35">Pluie et grêle</string>
+    <string name="weather_36">Chaud</string>
+    <string name="weather_37">Orages isolés</string>
+    <string name="weather_38">Orages épars</string>
+    <string name="weather_39">Orageux</string>
+    <string name="weather_40">Quelques averses</string>
+    <string name="weather_41">Chûtes de neige</string>
+    <string name="weather_42">Neige par moment</string>
+    <string name="weather_43">Neige importante</string>
+    <string name="weather_44">Peu nuageux</string>
+    <string name="weather_45">Averses</string>
+    <string name="weather_46">Averses de neige</string>
+    <string name="weather_47">Averses isolées</string>
+
+    <!-- Lock screen Weather - Wind directions -->
+    <string name="weather_N">N</string>
+    <string name="weather_NE">NE</string>
+    <string name="weather_E">E</string>
+    <string name="weather_SE">SE</string>
+    <string name="weather_S">S</string>
+    <string name="weather_SW">SO</string>
+    <string name="weather_W">O</string>
+    <string name="weather_NW">NO</string>
+
+    <!-- Lock screen Weather - error messages -->
+    <string name="weather_tap_to_refresh">Appuyer pour rafraîchir</string>
+
     <string name="byteShort" msgid="8340973892742019101">"o"</string>
     <string name="kilobyteShort" msgid="5973789783504771878">"Ko"</string>
     <string name="megabyteShort" msgid="6355851576770428922">"Mo"</string>
@@ -146,6 +227,18 @@
     <string name="shutdown_confirm_question" msgid="6656441286856415014">"Éteindre votre appareil ?"</string>
     <string name="recent_tasks_title" msgid="3691764623638127888">"Récentes"</string>
     <string name="no_recent_tasks" msgid="279702952298056674">"Aucune application récente"</string>
+    <string name="reboot_system">Redémarrage</string>
+    <string name="reboot_reboot">Redémarrer</string>
+    <string name="reboot_recovery">Recovery</string>
+    <string name="reboot_bootloader">Bootloader</string>
+    <string name="reboot_bootmenu">Bootmenu</string>
+    <string name="reboot_fastboot">Fastboot</string>
+    <string name="reboot_download">Download</string>
+    <string name="reboot_confirm">Votre appareil va redémarrer</string>
+    <string name="reboot_progress">Redémarrage en cours...</string>
+    <string name="global_action_reboot">Redémarrer</string>
+    <string name="global_action_screenshot">Capture d\'écran</string>
+    <string name="global_action_choose_profile">Profils</string>
     <string name="global_actions" product="tablet" msgid="408477140088053665">"Options de la tablette"</string>
     <string name="global_actions" product="default" msgid="2406416831541615258">"Options du téléphone"</string>
     <string name="global_action_lock" msgid="2844945191792119712">"Verrouillage de l\'écran"</string>
@@ -1024,8 +1117,8 @@
     <string name="extmedia_format_message" product="nosdcard" msgid="8296908079722897772">"Formater la mémoire de stockage USB en effaçant tous les fichiers ? Cette action est irréversible."</string>
     <string name="extmedia_format_message" product="default" msgid="3621369962433523619">"Voulez-vous vraiment formater la carte SD ? Toutes les données de cette carte seront perdues."</string>
     <string name="extmedia_format_button_format" msgid="4131064560127478695">"Format"</string>
-    <string name="adb_active_notification_title" msgid="6729044778949189918">"Débogage USB activé"</string>
-    <string name="adb_active_notification_message" msgid="8470296818270110396">"Sélectionnez cette option pour désactiver le débogage USB."</string>
+    <string name="adb_active_notification_title">Débogage android activé</string>
+    <string name="adb_active_notification_message">Désactiver le débogage android (adb).</string>
     <string name="select_input_method" msgid="6865512749462072765">"Sélectionner un mode de saisie"</string>
     <string name="configure_input_methods" msgid="6324843080254191535">"Configurer les modes de saisie"</string>
     <string name="fast_scroll_alphabet" msgid="5433275485499039199">" ABCDEFGHIJKLMNOPQRSTUVWXYZ"</string>
diff --git a/core/res/res/values-hr/strings.xml b/core/res/res/values-hr/strings.xml
index a945aa0..bd01f09 100644
--- a/core/res/res/values-hr/strings.xml
+++ b/core/res/res/values-hr/strings.xml
@@ -895,8 +895,8 @@
     <string name="no" msgid="5141531044935541497">"Odustani"</string>
     <string name="dialog_alert_title" msgid="2049658708609043103">"Pažnja"</string>
     <string name="loading" msgid="1760724998928255250">"Učitavanje..."</string>
-    <string name="capital_on" msgid="1544682755514494298">"Uključeno"</string>
-    <string name="capital_off" msgid="6815870386972805832">"Isključeno"</string>
+    <string name="capital_on" msgid="1544682755514494298">"Uklj"</string>
+    <string name="capital_off" msgid="6815870386972805832">"Isklj"</string>
     <string name="whichApplication" msgid="4533185947064773386">"Radnju dovrši pomoću stavke"</string>
     <string name="alwaysUse" msgid="4583018368000610438">"Koristi se kao zadana postavka za ovu lokaciju."</string>
     <string name="clearDefaultHintMsg" msgid="4815455344600932173">"Izbrišite zadane postavke u izborniku Početne postavke &gt; Aplikacije &gt; Upravljanje aplikacijama."</string>
diff --git a/core/res/res/values-hu/strings.xml b/core/res/res/values-hu/strings.xml
index 88a814d..b21b191 100644
--- a/core/res/res/values-hu/strings.xml
+++ b/core/res/res/values-hu/strings.xml
@@ -100,6 +100,7 @@
     <string name="roamingText11" msgid="4154476854426920970">"Barangolást jelző szalaghirdetés bekapcsolva"</string>
     <string name="roamingText12" msgid="1189071119992726320">"Barangolást jelző szalaghirdetés kikapcsolva"</string>
     <string name="roamingTextSearching" msgid="8360141885972279963">"Szolgáltatás keresése"</string>
+    <string name="roamingTextAirplaneMode">Repülőgép üzemmód</string>
     <string name="cfTemplateNotForwarded" msgid="1683685883841272560">"<xliff:g id="BEARER_SERVICE_CODE">{0}</xliff:g>: nincs átirányítva"</string>
     <string name="cfTemplateForwarded" msgid="1302922117498590521">"<xliff:g id="BEARER_SERVICE_CODE">{0}</xliff:g>: <xliff:g id="DIALING_NUMBER">{1}</xliff:g>"</string>
     <string name="cfTemplateForwardedTime" msgid="9206251736527085256">"<xliff:g id="BEARER_SERVICE_CODE">{0}</xliff:g>: <xliff:g id="DIALING_NUMBER">{1}</xliff:g> <xliff:g id="TIME_DELAY">{2}</xliff:g> másodperc után"</string>
@@ -301,6 +302,8 @@
     <string name="permdesc_clearAppCache" product="default" msgid="7740465694193671402">"Lehetővé teszi egy alkalmazás számára, hogy az alkalmazás-gyorsítótár könyvtárából töröljön fájlokat a telefon memóriájának felszabadításához. A hozzáférés erősen korlátozott, főleg rendszerfolyamatokra."</string>
     <string name="permlab_movePackage" msgid="728454979946503926">"További alkalmazás-erőforrások"</string>
     <string name="permdesc_movePackage" msgid="6323049291923925277">"Lehetővé teszi egy alkalmazás számára alkalmazás-erőforrások áthelyezését a belső tárolóról egy külső tárolóra, és fordítva."</string>
+    <string name="permlab_preventpower">"kikapcsológomb felülbírálata"</string>
+    <string name="permdesc_preventpower">"Lehetővé teszi egy alkalmazás számára a kikapcsológomb felülbírálatát"</string>
     <string name="permlab_readLogs" msgid="6615778543198967614">"érzékeny naplóadatok olvasása"</string>
     <string name="permdesc_readLogs" product="tablet" msgid="4077356893924755294">"Lehetővé teszi az alkalmazások számára, hogy olvassák a rendszer különböző naplófájljait. Ezáltal általános információkat deríthetnek ki arról, hogy mire használja a táblagépét, valamint személyes, magánjellegű adatokhoz is hozzájuthatnak."</string>
     <string name="permdesc_readLogs" product="default" msgid="8896449437464867766">"Lehetővé teszi az alkalmazások számára, hogy olvassák a rendszer különböző naplófájljait. Ezáltal általános információkat deríthetnek ki arról, hogy mire használja a telefonját, valamint személyes, magánjellegű adatokhoz is hozzájuthatnak."</string>
@@ -574,6 +577,11 @@
     <item msgid="2506857312718630823">"ICQ"</item>
     <item msgid="1648797903785279353">"Jabber"</item>
   </string-array>
+
+    <!-- Hardware Rotation lock string -->
+    <string name="toast_rotation_unlocked">Képernyő elforgatás engedélyezve</string>
+    <string name="toast_rotation_locked">Képernyő elforgatás letiltva</string>
+
     <string name="phoneTypeCustom" msgid="1644738059053355820">"Egyéni"</string>
     <string name="phoneTypeHome" msgid="2570923463033985887">"Otthoni"</string>
     <string name="phoneTypeMobile" msgid="6501463557754751037">"Mobil"</string>
@@ -1227,4 +1235,114 @@
     <string name="sending" msgid="8715108995741758718">"Küldés..."</string>
     <string name="launchBrowserDefault" msgid="2057951947297614725">"Böngésző indítása?"</string>
     <string name="SetupCallDefault" msgid="6870275517518479651">"Hívás fogadása?"</string>
+
+    <!-- 20120420 -->
+    <!-- Button to reboot the phone, within the Phone Options dialog -->
+    <string name="reboot_system" product="tablet">Táblagép újraindítása</string>
+    <string name="reboot_system" product="default">Telefon újraindítása</string>
+    <!-- label for item that screenshots in phone options dialog -->
+    <string name="global_action_screenshot">Képernyőmentés</string>
+    <!-- Button to reboot the phone, within the Reboot Options dialog -->
+    <string name="reboot_reboot">Újraindítás</string>
+    <!-- Button to reboot the phone into recovery, within the Reboot Options dialog -->
+    <string name="reboot_recovery">Recovery</string>
+    <!-- Button to reboot the phone into bootloader, within the Reboot Options dialog -->
+    <string name="reboot_bootloader">Bootloader</string>
+    <!-- Button to reboot the phone into bootmenu, within the Reboot Options dialog -->
+    <string name="reboot_bootmenu">Bootmenu</string>
+    <!-- Button to reboot the phone into fastboot, within the Reboot Options dialog -->
+    <string name="reboot_fastboot">Fastboot</string>
+    <!-- Button to reboot the phone into download, within the Reboot Options dialog -->
+    <string name="reboot_download">Download</string>
+    <!-- Reboot Progress Dialog. This is shown if the user chooses to reboot the phone. -->
+    <string name="reboot_progress">Újraindítás\u2026</string>
+    <!-- Reboot Confirmation Dialog.  When the user chooses to reboot the phone, there will be a confirmation dialog.  This is the message. -->
+    <string name="reboot_confirm">A telefon újraindul.</string>
+    <!-- label for item that reboots the phone in phone options dialog -->
+    <string name="global_action_reboot">Újraindítás</string>
+    <!-- label for item that opens the profile choosing dialog -->
+    <string name="global_action_choose_profile">Profil</string>
+    <!-- Names of default profiles. -->
+    <string name="profileNameDefault">Alapértelmezett</string>
+    <string name="profileNameWork">Munka</string>
+    <string name="profileNameHome">Otthon</string>
+    <string name="profileNameSilent">Néma</string>
+    <string name="profileNameNight">Éjszaka</string>
+    <!-- Names of application groups. -->
+    <string name="profileGroupPhone">Telefon</string>
+    <string name="profileGroupCalendar">Naptár</string>
+    <string name="profileGroupGmail">Gmail</string>
+    <string name="profileGroupEmail">E-mail</string>
+    <string name="profileGroupSMS">SMS</string>
+    <!-- Name of wildcard profile. -->
+    <string name="wildcardProfile">Egyéb</string>
+    <!--Application killed toast -->
+    <string name="app_killed_message">Alkalmazás leállítva.</string>
+
+    <!-- Lock screen Weather - Weather codes -->
+    <string name="weather_0">Tornádó</string>
+    <string name="weather_1">Trópusi vihar</string>
+    <string name="weather_2">Hurrikán</string>
+    <string name="weather_3">Komoly viharok</string>
+    <string name="weather_4">Viharok</string>
+    <string name="weather_5">Havas eső</string>
+    <string name="weather_6">Eső és ónos eső</string>
+    <string name="weather_7">Hó és ónos eső</string>
+    <string name="weather_8">Fagyos permet</string>
+    <string name="weather_9">Permet</string>
+    <string name="weather_10">Fagyos eső</string>
+    <string name="weather_11">Záporok</string>
+    <string name="weather_12">Záporok</string>
+    <string name="weather_13">Hófúvás</string>
+    <string name="weather_14">Könnyű hózáporok</string>
+    <string name="weather_15">Hóátfúvás</string>
+    <string name="weather_16">Hó</string>
+    <string name="weather_17">Jégeső</string>
+    <string name="weather_18">Ónos eső</string>
+    <string name="weather_19">Por</string>
+    <string name="weather_20">Köd</string>
+    <string name="weather_21">Pára</string>
+    <string name="weather_22">Füst</string>
+    <string name="weather_23">Viharos erejű szél</string>
+    <string name="weather_24">Szeles</string>
+    <string name="weather_25">Hideg</string>
+    <string name="weather_26">Felhős</string>
+    <string name="weather_27">Túlnyomóan felhős</string> <!-- Night -->
+    <string name="weather_28">Túlnyomóan felhős</string> <!-- Day -->
+    <string name="weather_29">Nyomokban felhős</string> <!-- Night -->
+    <string name="weather_30">Nyomokban felhős</string> <!-- Day -->
+    <string name="weather_31">Tiszta</string> <!-- Night -->
+    <string name="weather_32">Napos</string>
+    <string name="weather_33">Derűs</string> <!-- Night -->
+    <string name="weather_34">Derűs</string> <!-- Day -->
+    <string name="weather_35">Eső és jégeső</string>
+    <string name="weather_36">Forróság</string>
+    <string name="weather_37">Elszigetelt vihar</string>
+    <string name="weather_38">Elszórt viharok</string>
+    <string name="weather_39">Elszórt viharok</string>
+    <string name="weather_40">Elszórt záporok</string>
+    <string name="weather_41">Kemény havazás</string>
+    <string name="weather_42">Elszórt hózápor</string>
+    <string name="weather_43">Kemény havazás</string>
+    <string name="weather_44">Foltokban felhős</string>
+    <string name="weather_45">Viharos</string>
+    <string name="weather_46">Hózáporok</string>
+    <string name="weather_47">Elszigetelt vihar</string>
+    <!-- Forecast unavailable -->
+    <string name="weather_3200"></string>
+
+    <!-- Lock screen Weather - Wind directions -->
+    <string name="weather_N">É</string>
+    <string name="weather_NE">ÉK</string>
+    <string name="weather_E">K</string>
+    <string name="weather_SE">DK</string>
+    <string name="weather_S">D</string>
+    <string name="weather_SW">DNy</string>
+    <string name="weather_W">Ny</string>
+    <string name="weather_NW">ÉNy</string>
+
+    <!-- Lock screen Weather - error messages -->
+    <string name="weather_no_data">Nincs adat</string>
+    <string name="weather_tap_to_refresh">Érintse meg a frissítéshez</string>
+    <string name="weather_refreshing">Frissítés…</string>
 </resources>
diff --git a/core/res/res/values-it/strings.xml b/core/res/res/values-it/strings.xml
index 50b5418..5f17cc3 100644
--- a/core/res/res/values-it/strings.xml
+++ b/core/res/res/values-it/strings.xml
@@ -36,6 +36,17 @@
     <string name="defaultMsisdnAlphaTag" msgid="2850889754919584674">"MSISDN1"</string>
     <string name="mmiError" msgid="5154499457739052907">"Problema di connessione o codice MMI non valido."</string>
     <string name="mmiFdnError" msgid="5224398216385316471">"Operazione limitata solo ai numeri di selezione fissa."</string>
+    <string name="profileNameDefault">Predefinito</string>
+    <string name="profileNameWork">Lavoro</string>
+    <string name="profileNameHome">Casa</string>
+    <string name="profileNameSilent">Silenzioso</string>
+    <string name="profileNameNight">Notte</string>
+    <string name="profileGroupPhone">Telefono</string>
+    <string name="profileGroupCalendar">Calendario</string>
+    <string name="profileGroupGmail">Gmail</string>
+    <string name="profileGroupEmail">Email</string>
+    <string name="profileGroupSMS">SMS</string>
+    <string name="wildcardProfile">Altro</string>
     <string name="serviceEnabled" msgid="8147278346414714315">"Il servizio è stato attivato."</string>
     <string name="serviceEnabledFor" msgid="6856228140453471041">"Il servizio è stato attivato per:"</string>
     <string name="serviceDisabled" msgid="1937553226592516411">"Il servizio è stato disattivato."</string>
@@ -100,6 +111,7 @@
     <string name="roamingText11" msgid="4154476854426920970">"Banner roaming attivato"</string>
     <string name="roamingText12" msgid="1189071119992726320">"Banner roaming disattivato"</string>
     <string name="roamingTextSearching" msgid="8360141885972279963">"Ricerca servizio"</string>
+    <string name="roamingTextAirplaneMode">Modalità aereo</string>
     <string name="cfTemplateNotForwarded" msgid="1683685883841272560">"<xliff:g id="BEARER_SERVICE_CODE">{0}</xliff:g>: inoltro non effettuato"</string>
     <string name="cfTemplateForwarded" msgid="1302922117498590521">"<xliff:g id="BEARER_SERVICE_CODE">{0}</xliff:g>: <xliff:g id="DIALING_NUMBER">{1}</xliff:g>"</string>
     <string name="cfTemplateForwardedTime" msgid="9206251736527085256">"<xliff:g id="BEARER_SERVICE_CODE">{0}</xliff:g><xliff:g id="DIALING_NUMBER">{1}</xliff:g> dopo <xliff:g id="TIME_DELAY">{2}</xliff:g> secondi"</string>
@@ -137,6 +149,17 @@
     <string name="turn_off_radio" msgid="8198784949987062346">"Disattiva wireless"</string>
     <string name="screen_lock" msgid="799094655496098153">"Blocco schermo"</string>
     <string name="power_off" msgid="4266614107412865048">"Spegni"</string>
+    <string name="reboot_system" product="tablet">Riavvia tablet</string>
+    <string name="reboot_system" product="default">Riavvia telefono</string>
+    <string name="global_action_screenshot">Cattura schermata</string>
+    <string name="reboot_reboot">Riavvia</string>
+    <string name="reboot_recovery">Recovery</string>
+    <string name="reboot_bootloader">Bootloader</string>
+    <string name="reboot_bootmenu">Bootmenu</string>
+    <string name="reboot_fastboot">Fastboot</string>
+    <string name="reboot_download">Download</string>
+    <string name="reboot_progress">Riavvio\u2026</string>
+    <string name="reboot_confirm">Il telefono verrà riavviato.</string>
     <string name="silent_mode_silent" msgid="319298163018473078">"Suoneria disattivata"</string>
     <string name="silent_mode_vibrate" msgid="7072043388581551395">"Suoneria vibrazione"</string>
     <string name="silent_mode_ring" msgid="8592241816194074353">"Suoneria attiva"</string>
@@ -150,6 +173,8 @@
     <string name="global_actions" product="default" msgid="2406416831541615258">"Opzioni telefono"</string>
     <string name="global_action_lock" msgid="2844945191792119712">"Blocco schermo"</string>
     <string name="global_action_power_off" msgid="4471879440839879722">"Spegni"</string>
+    <string name="global_action_reboot">Riavvia</string>
+    <string name="global_action_choose_profile">Profilo</string>
     <string name="global_action_toggle_silent_mode" msgid="8219525344246810925">"Modalità silenziosa"</string>
     <string name="global_action_silent_mode_on_status" msgid="3289841937003758806">"Audio non attivo"</string>
     <string name="global_action_silent_mode_off_status" msgid="1506046579177066419">"Audio attivo"</string>
@@ -301,6 +326,8 @@
     <string name="permdesc_clearAppCache" product="default" msgid="7740465694193671402">"Consente a un\'applicazione di liberare spazio sul telefono eliminando file nella directory della cache dell\'applicazione. L\'accesso è generalmente limitato a processi di sistema."</string>
     <string name="permlab_movePackage" msgid="728454979946503926">"Spostare risorse dell\'applicazione"</string>
     <string name="permdesc_movePackage" msgid="6323049291923925277">"Consente a un\'applicazione di spostare risorse applicative da supporti interni a esterni e viceversa."</string>
+    <string name="permlab_preventpower">modifica azione tasto spegnimento</string>
+    <string name="permdesc_preventpower">Consente a un\'applicazione di cambiare il comportamento del tasto di spegnimento</string>
     <string name="permlab_readLogs" msgid="6615778543198967614">"Lettura dati di registro sensibili"</string>
     <string name="permdesc_readLogs" product="tablet" msgid="4077356893924755294">"Consente a un\'applicazione di leggere vari file di registro del sistema per trovare informazioni generali sulle operazioni effettuate con il tablet. Tali file potrebbero contenere informazioni personali o riservate."</string>
     <string name="permdesc_readLogs" product="default" msgid="8896449437464867766">"Consente a un\'applicazione di leggere vari file di registro del sistema per trovare informazioni generali sulle operazioni effettuate con il telefono. Tali file potrebbero contenere informazioni personali o riservate."</string>
@@ -574,6 +601,8 @@
     <item msgid="2506857312718630823">"ICQ"</item>
     <item msgid="1648797903785279353">"Jabber"</item>
   </string-array>
+    <string name="toast_rotation_unlocked">Rotazione display sbloccata</string>
+    <string name="toast_rotation_locked">Rotazione display bloccata</string>
     <string name="phoneTypeCustom" msgid="1644738059053355820">"Personalizzato"</string>
     <string name="phoneTypeHome" msgid="2570923463033985887">"Casa"</string>
     <string name="phoneTypeMobile" msgid="6501463557754751037">"Cellulare"</string>
@@ -1227,4 +1256,65 @@
     <string name="sending" msgid="8715108995741758718">"Invio..."</string>
     <string name="launchBrowserDefault" msgid="2057951947297614725">"Avviare l\'applicazione Browser?"</string>
     <string name="SetupCallDefault" msgid="6870275517518479651">"Accettare la chiamata?"</string>
+    <string name="app_killed_message">Applicazione terminata</string>
+    <string name="weather_0">Tornado</string>
+    <string name="weather_1">Tempesta Tropicale</string>
+    <string name="weather_2">Uragano</string>
+    <string name="weather_3">Temporali Violenti</string>
+    <string name="weather_4">Temporali</string>
+    <string name="weather_5">Piodiff --git a/Android.mk b/Android.mk
index 5ea36b1..a7d65d9 100644
--- a/Android.mk
+++ b/Android.mk
@@ -58,6 +58,7 @@ LOCAL_SRC_FILES := $(filter-out \
 ## across process boundaries.
 ##
 ## READ ME: ########################################################
+# BEGIN privacy-added: IPrivacySettingsManager.aidl
 LOCAL_SRC_FILES += \
 	core/java/android/accessibilityservice/IAccessibilityServiceConnection.aidl \
 	core/java/android/accessibilityservice/IEventListener.aidl \
@@ -190,6 +191,7 @@ LOCAL_SRC_FILES += \
 	media/java/android/media/IMediaScannerService.aidl \
 	media/java/android/media/IRemoteControlClient.aidl \
 	media/java/android/media/IRemoteControlDisplay.aidl \
+	privacy/java/android/privacy/IPrivacySettingsManager.aidl \
 	telephony/java/com/android/internal/telephony/IPhoneStateListener.aidl \
 	telephony/java/com/android/internal/telephony/IPhoneSubInfo.aidl \
 	telephony/java/com/android/internal/telephony/ITelephony.aidl \
@@ -202,8 +204,23 @@ LOCAL_SRC_FILES += \
 	telephony/java/com/android/internal/telephony/IExtendedNetworkService.aidl \
 	voip/java/android/net/sip/ISipSession.aidl \
 	voip/java/android/net/sip/ISipSessionListener.aidl \
-	voip/java/android/net/sip/ISipService.aidl
+	voip/java/android/net/sip/ISipService.aidl \
+	fmradio/java/com/stericsson/hardware/fm/IFmReceiver.aidl \
+	fmradio/java/com/stericsson/hardware/fm/IFmTransmitter.aidl \
+	fmradio/java/com/stericsson/hardware/fm/IOnStateChangedListener.aidl \
+	fmradio/java/com/stericsson/hardware/fm/IOnStartedListener.aidl \
+	fmradio/java/com/stericsson/hardware/fm/IOnErrorListener.aidl \
+	fmradio/java/com/stericsson/hardware/fm/IOnScanListener.aidl \
+	fmradio/java/com/stericsson/hardware/fm/IOnForcedPauseListener.aidl \
+	fmradio/java/com/stericsson/hardware/fm/IOnForcedResetListener.aidl \
+	fmradio/java/com/stericsson/hardware/fm/IOnBlockScanListener.aidl \
+	fmradio/java/com/stericsson/hardware/fm/IOnRDSDataFoundListener.aidl \
+	fmradio/java/com/stericsson/hardware/fm/IOnSignalStrengthListener.aidl \
+	fmradio/java/com/stericsson/hardware/fm/IOnStereoListener.aidl \
+	fmradio/java/com/stericsson/hardware/fm/IOnExtraCommandListener.aidl \
+	fmradio/java/com/stericsson/hardware/fm/IOnAutomaticSwitchListener.aidl
 #
+# END privacy-added: IPrivacySettingsManager.aidl
 
 
 # FRAMEWORKS_BASE_JAVA_SRC_DIRS comes from build/core/pathmap.mk
@@ -246,6 +263,7 @@ framework_built := $(call java-lib-deps,framework)
 # AIDL files to be preprocessed and included in the SDK,
 # relative to the root of the build tree.
 # ============================================================
+# BEGIN privacy-added: PrivacySettings.aidl
 aidl_files := \
 	frameworks/base/core/java/android/accounts/IAccountManager.aidl \
 	frameworks/base/core/java/android/accounts/IAccountManagerResponse.aidl \
@@ -293,11 +311,13 @@ aidl_files := \
 	frameworks/base/graphics/java/android/graphics/Region.aidl \
 	frameworks/base/location/java/android/location/Criteria.aidl \
 	frameworks/base/location/java/android/location/Location.aidl \
+	frameworks/base/privacy/java/android/privacy/PrivacySettings.aidl \
 	frameworks/base/telephony/java/android/telephony/ServiceState.aidl \
 	frameworks/base/telephony/java/com/android/internal/telephony/IPhoneSubInfo.aidl \
 	frameworks/base/telephony/java/com/android/internal/telephony/ITelephony.aidl \
 
 gen := $(TARGET_OUT_COMMON_INTERMEDIATES)/framework.aidl
+# END privacy-added: PrivacySettings.aidl
 $(gen): PRIVATE_SRC_FILES := $(aidl_files)
 ALL_SDK_FILES += $(gen)
 $(gen): $(aidl_files) | $(AIDL)
@@ -528,7 +548,7 @@ include $(CLEAR_VARS)
 
 LOCAL_SRC_FILES:=$(framework_docs_LOCAL_API_CHECK_SRC_FILES)
 LOCAL_INTERMEDIATE_SOURCES:=$(framework_docs_LOCAL_INTERMEDIATE_SOURCES)
-LOCAL_JAVA_LIBRARIES:=$(framework_docs_LOCAL_JAVA_LIBRARIES)
+LOCAL_JAVA_LIBRARIES:=$(framework_docs_LOCAL_JAVA_LIBRARIES) framework
 LOCAL_MODULE_CLASS:=$(framework_docs_LOCAL_MODULE_CLASS)
 LOCAL_DROIDDOC_SOURCE_PATH:=$(framework_docs_LOCAL_DROIDDOC_SOURCE_PATH)
 LOCAL_DROIDDOC_HTML_DIR:=$(framework_docs_LOCAL_DROIDDOC_HTML_DIR)
diff --git a/core/java/android/app/ContextImpl.java b/core/java/android/app/ContextImpl.java
index a8e40fd..957ccd8 100644
--- a/core/java/android/app/ContextImpl.java
+++ b/core/java/android/app/ContextImpl.java
@@ -84,6 +84,13 @@ import android.os.RemoteException;
 import android.os.ServiceManager;
 import android.os.Vibrator;
 import android.os.storage.StorageManager;
+// BEGIN privacy-added
+import android.privacy.IPrivacySettingsManager;
+import android.privacy.PrivacySettingsManager;
+import android.privacy.surrogate.PrivacyAccountManager;
+import android.privacy.surrogate.PrivacyLocationManager;
+import android.privacy.surrogate.PrivacyTelephonyManager;
+// END privacy-added
 import android.telephony.TelephonyManager;
 import android.content.ClipboardManager;
 import android.util.AndroidRuntimeException;
@@ -107,6 +114,13 @@ import java.io.InputStream;
 import java.util.ArrayList;
 import java.util.HashMap;
 
+import com.stericsson.hardware.fm.IFmReceiver;
+import com.stericsson.hardware.fm.IFmTransmitter;
+import com.stericsson.hardware.fm.FmReceiver;
+import com.stericsson.hardware.fm.FmTransmitter;
+import com.stericsson.hardware.fm.FmReceiverImpl;
+import com.stericsson.hardware.fm.FmTransmitterImpl;
+
 class ReceiverRestrictedContext extends ContextWrapper {
     ReceiverRestrictedContext(Context base) {
         super(base);
@@ -154,6 +168,7 @@ class ContextImpl extends Context {
     private Resources mResources;
     /*package*/ ActivityThread mMainThread;
     private Context mOuterContext;
+    private static Context sOuterContext;
     private IBinder mActivityToken = null;
     private ApplicationContentResolver mContentResolver;
     private int mThemeResource = 0;
@@ -267,7 +282,9 @@ class ContextImpl extends Context {
                 public Object createService(ContextImpl ctx) {
                     IBinder b = ServiceManager.getService(ACCOUNT_SERVICE);
                     IAccountManager service = IAccountManager.Stub.asInterface(b);
-                    return new AccountManager(ctx, service);
+                    // BEGIN privacy-modified
+                    return new PrivacyAccountManager(ctx, service);
+                    // END privacy-modified
                 }});
 
         registerService(ACTIVITY_SERVICE, new ServiceFetcher() {
@@ -352,7 +369,10 @@ class ContextImpl extends Context {
         registerService(LOCATION_SERVICE, new StaticServiceFetcher() {
                 public Object createStaticService() {
                     IBinder b = ServiceManager.getService(LOCATION_SERVICE);
-                    return new LocationManager(ILocationManager.Stub.asInterface(b));
+                    // BEGIN privacy-modified
+                    ILocationManager service = ILocationManager.Stub.asInterface(b);
+                    return new PrivacyLocationManager(service,getStaticOuterContext());
+                    // END privacy-modified
                 }});
 
         registerService(NETWORK_POLICY_SERVICE, new ServiceFetcher() {
@@ -414,7 +434,9 @@ class ContextImpl extends Context {
 
         registerService(TELEPHONY_SERVICE, new ServiceFetcher() {
                 public Object createService(ContextImpl ctx) {
-                    return new TelephonyManager(ctx.getOuterContext());
+                    // BEGIN privacy-modified
+                    return new PrivacyTelephonyManager(ctx.getOuterContext());
+                    // END privacy-modified
                 }});
 
         registerService(THROTTLE_SERVICE, new StaticServiceFetcher() {
@@ -470,6 +492,30 @@ class ContextImpl extends Context {
                     final Context outerContext = ctx.getOuterContext();
                     return new ProfileManager (outerContext, ctx.mMainThread.getHandler());
                 }});
+
+        registerService("fm_receiver", new ServiceFetcher() {
+                public Object createService(ContextImpl ctx) {
+                    IBinder b = ServiceManager.getService("fm_receiver");
+                    IFmReceiver service = IFmReceiver.Stub.asInterface(b);
+                    return new FmReceiverImpl(service);
+                }});
+
+        registerService("fm_transmitter", new ServiceFetcher() {
+                public Object createService(ContextImpl ctx) {
+                    IBinder b = ServiceManager.getService("fm_transmitter");
+                    IFmTransmitter service = IFmTransmitter.Stub.asInterface(b);
+                    return new FmTransmitterImpl(service);
+                }});
+
+        // BEGIN privacy-added
+        registerService("privacy", new StaticServiceFetcher() {
+                public Object createStaticService() {
+                    IBinder b = ServiceManager.getService("privacy");
+                    IPrivacySettingsManager service = IPrivacySettingsManager.Stub.asInterface(b);
+                    return new PrivacySettingsManager(getStaticOuterContext(),service);
+                }});
+        // END privacy-added
+
     }
 
     static ContextImpl getImpl(Context context) {
@@ -1494,7 +1540,7 @@ class ContextImpl extends Context {
     }
 
     ContextImpl() {
-        mOuterContext = this;
+        sOuterContext = mOuterContext = this;
     }
 
     /**
@@ -1509,7 +1555,7 @@ class ContextImpl extends Context {
         mResources = context.mResources;
         mMainThread = context.mMainThread;
         mContentResolver = context.mContentResolver;
-        mOuterContext = this;
+        sOuterContext = mOuterContext = this;
     }
 
     final void init(LoadedApk packageInfo,
@@ -1569,13 +1615,17 @@ class ContextImpl extends Context {
     }
 
     final void setOuterContext(Context context) {
-        mOuterContext = context;
+        sOuterContext = mOuterContext = context;
     }
 
     final Context getOuterContext() {
         return mOuterContext;
     }
 
+    final static Context getStaticOuterContext() {
+        return sOuterContext;
+    }
+
     final IBinder getActivityToken() {
         return mActivityToken;
     }
diff --git a/core/java/android/bluetooth/HeadsetBase.java b/core/java/android/bluetooth/HeadsetBase.java
index 9ef2eb5..1374377 100644
--- a/core/java/android/bluetooth/HeadsetBase.java
+++ b/core/java/android/bluetooth/HeadsetBase.java
@@ -109,6 +109,12 @@ public final class HeadsetBase {
 
     private native void initializeNativeDataNative(int socketFd);
 
+    // interface for dealing with special input situations
+    public interface SpecialPDUInputHandler {
+        void handleInput(String input);
+    }
+    public SpecialPDUInputHandler specialPDUInputHandler = null;
+
     /* Process an incoming AT command line
      */
     protected void handleInput(String input) {
@@ -122,7 +128,6 @@ public final class HeadsetBase {
                 sAtInputCount++;
             }
         }
-
         if (DBG) timestamp = System.currentTimeMillis();
         AtCommandResult result = mAtParser.process(input);
         if (DBG) Log.d(TAG, "Processing " + input + " took " +
@@ -158,10 +163,19 @@ public final class HeadsetBase {
                 public void run() {
                     int last_read_error;
                     while (!mEventThreadInterrupted) {
-                        String input = readNative(500);
-                        if (input != null) {
-                            handleInput(input);
+                        String input;
+                        if (null == specialPDUInputHandler) {
+                            input = readNative(500);
+                            if (input != null) {
+                                handleInput(input);
+                            }
                         } else {
+                            input = readNativePDUStream((500));
+                            if (input != null) {
+                                specialPDUInputHandler.handleInput(input);
+                            }
+                        }
+                        if (null == input) {
                             last_read_error = getLastReadStatusNative();
                             if (last_read_error != 0) {
                                 Log.i(TAG, "headset read error " + last_read_error);
@@ -181,6 +195,7 @@ public final class HeadsetBase {
     }
 
     private native String readNative(int timeout_ms);
+    private native String readNativePDUStream(int timeout_ms);
     private native int getLastReadStatusNative();
 
     private void stopEventThread() {
@@ -276,6 +291,15 @@ public final class HeadsetBase {
     }
     private native boolean sendURCNative(String urc);
 
+    public synchronized boolean sendURCChars(String urc) {
+        if (urc.length() > 0) {
+            boolean ret = sendURCNativeChars(urc);
+            return ret;
+        }
+        return true;
+    }
+    private native boolean sendURCNativeChars(String urc);
+
     private synchronized void acquireWakeLock() {
         if (!mWakeLock.isHeld()) {
             mWakeLock.acquire();
diff --git a/core/java/android/content/ContentResolver.java b/core/java/android/content/ContentResolver.java
index ce525a6..073eb76 100644
--- a/core/java/android/content/ContentResolver.java
+++ b/core/java/android/content/ContentResolver.java
@@ -38,6 +38,9 @@ import android.os.RemoteException;
 import android.os.ServiceManager;
 import android.os.StrictMode;
 import android.os.SystemClock;
+// BEGIN privacy-added
+import android.privacy.surrogate.PrivacyContentResolver;
+// END privacy-added
 import android.text.TextUtils;
 import android.util.EventLog;
 import android.util.Log;
@@ -314,6 +317,10 @@ public abstract class ContentResolver {
         try {
             long startTime = SystemClock.uptimeMillis();
             Cursor qCursor = provider.query(uri, projection, selection, selectionArgs, sortOrder);
+            // BEGIN privacy-added
+//            qCursor = PrivacyContentResolver.enforcePrivacyPermission(uri, mContext, qCursor);
+            qCursor = PrivacyContentResolver.enforcePrivacyPermission(uri, projection, mContext, qCursor);
+            // END privacy-added
             if (qCursor == null) {
                 releaseProvider(provider);
                 return null;
diff --git a/core/java/android/content/pm/PackageManager.java b/core/java/android/content/pm/PackageManager.java
index c249a53..ca1aa4f 100644
--- a/core/java/android/content/pm/PackageManager.java
+++ b/core/java/android/content/pm/PackageManager.java
@@ -807,6 +807,22 @@ public abstract class PackageManager {
 
     /**
      * Feature for {@link #getSystemAvailableFeatures} and
+     * {@link #hasSystemFeature}: The device is able to receive FM radio.
+     * @hide
+     */
+    @SdkConstant(SdkConstantType.FEATURE)
+    public static final String FEATURE_RADIO_FM_RECEIVER = "com.stericsson.hardware.fm.receiver";
+
+    /**
+     * Feature for {@link #getSystemAvailableFeatures} and
+     * {@link #hasSystemFeature}: The device is able to transmit FM radio.
+     * @hide
+     */
+    @SdkConstant(SdkConstantType.FEATURE)
+    public static final String FEATURE_RADIO_FM_TRANSMITTER = "com.stericsson.hardware.fm.transmitter";
+
+    /**
+     * Feature for {@link #getSystemAvailableFeatures} and
      * {@link #hasSystemFeature}: The device supports one or more methods of
      * reporting current location.
      */
diff --git a/core/java/android/hardware/Camera.java b/core/java/android/hardware/Camera.java
index 0b1dc44..1e8ea4e 100644
--- a/core/java/android/hardware/Camera.java
+++ b/core/java/android/hardware/Camera.java
@@ -1850,6 +1850,12 @@ public class Camera {
         public static final String FLASH_MODE_TORCH = "torch";
 
         /**
+         * Scene mode is off. (for some QCom)
+         * @hide
+         */
+        public static final String SCENE_MODE_OFF = "off";
+
+        /**
          * Scene mode is off.
          * @hide
          */
diff --git a/core/jni/android_bluetooth_HeadsetBase.cpp b/core/jni/android_bluetooth_HeadsetBase.cpp
index 5b21c56..bb49ebd 100644
--- a/core/jni/android_bluetooth_HeadsetBase.cpp
+++ b/core/jni/android_bluetooth_HeadsetBase.cpp
@@ -96,6 +96,22 @@ static int send_line(int fd, const char* line) {
     return 0;
 }
 
+static int send_chars(int fd, const char* line) {
+    int nw;
+    int len = strlen(line);
+    int llen = len + 1;
+    char *buffer = (char *)calloc(llen, sizeof(char));
+
+    snprintf(buffer, llen, "%s", line);
+
+    if (write_error_check(fd, buffer, llen - 1)) {
+        free(buffer);
+        return -1;
+    }
+    free(buffer);
+    return 0;
+}
+
 static void mask_eighth_bit(char *line)
 {
    for (;;line++) {
@@ -165,18 +181,97 @@ again:
 
     *bufit = NULL;
 
-    // According to ITU V.250 section 5.1, IA5 7 bit chars are used, 
+    // According to ITU V.250 section 5.1, IA5 7 bit chars are used,
     //   the eighth bit or higher bits are ignored if they exists
     // We mask out only eighth bit, no higher bit, since we do char
     // string here, not wide char.
     // We added this processing due to 2 real world problems.
     // 1 BMW 2005 E46 which sends binary junk
-    // 2 Audi 2010 A3, dial command use 0xAD (soft-hyphen) as number 
+    // 2 Audi 2010 A3, dial command use 0xAD (soft-hyphen) as number
     //   formater, which was rejected by the AT handler
     mask_eighth_bit(buf);
 
     return buf;
 }
+
+// specialized version of get_line that terminates on ESC(abort) or Ctrl-Z
+
+static const char* get_PDUline(int fd, char *buf, int len, int timeout_ms,
+                            int *err) {
+    char *bufit=buf;
+    int fd_flags = fcntl(fd, F_GETFL, 0);
+    struct pollfd pfd;
+
+again:
+    *bufit = 0;
+    pfd.fd = fd;
+    pfd.events = POLLIN;
+    *err = errno = 0;
+    int ret = poll(&pfd, 1, timeout_ms);
+    if (ret < 0) {
+        LOGE("poll() error\n");
+        *err = errno;
+        return NULL;
+    }
+    if (ret == 0) {
+        return NULL;
+    }
+
+    if (pfd.revents & (POLLHUP | POLLERR | POLLNVAL)) {
+        LOGW("RFCOMM poll() returned  success (%d), "
+             "but with an unexpected revents bitmask: %#x\n", ret, pfd.revents);
+        errno = EIO;
+        *err = errno;
+        return NULL;
+    }
+
+    while ((int)(bufit - buf) < (len - 1))
+    {
+        errno = 0;
+        int rc = read(fd, bufit, 1);
+
+        if (!rc)
+            break;
+
+        if (rc < 0) {
+            if (errno == EBUSY) {
+                LOGI("read() error %s (%d): repeating read()...",
+                     strerror(errno), errno);
+                goto again;
+            }
+            *err = errno;
+            LOGE("read() error %s (%d)", strerror(errno), errno);
+            return NULL;
+        }
+
+        if (*bufit == '\x1b') { // ESC  - cause a string containing only ESC to be returned
+            *buf = '\x1b';
+            bufit = buf+1;
+            break;
+        }
+
+        if (*bufit=='\x1a') { // ctrl-z
+            break;
+        }
+
+        bufit++;
+    }
+
+    *bufit = NULL;
+
+    // According to ITU V.250 section 5.1, IA5 7 bit chars are used,
+    //   the eighth bit or higher bits are ignored if they exists
+    // We mask out only eighth bit, no higher bit, since we do char
+    // string here, not wide char.
+    // We added this processing due to 2 real world problems.
+    // 1 BMW 2005 E46 which sends binary junk
+    // 2 Audi 2010 A3, dial command use 0xAD (soft-hyphen) as number
+    //   formater, which was rejected by the AT handler
+    mask_eighth_bit(buf);
+
+    return buf;
+}
+
 #endif
 
 static void classInitNative(JNIEnv* env, jclass clazz) {
@@ -513,6 +608,21 @@ static jboolean sendURCNative(JNIEnv *env, jobject obj, jstring urc) {
     return JNI_FALSE;
 }
 
+static jboolean sendURCNativeChars(JNIEnv *env, jobject obj, jstring urc) {
+#ifdef HAVE_BLUETOOTH
+    native_data_t *nat = get_native_data(env, obj);
+    if (nat->rfcomm_connected) {
+        const char *c_urc = env->GetStringUTFChars(urc, NULL);
+        jboolean ret = send_chars(nat->rfcomm_sock, c_urc) == 0 ? JNI_TRUE : JNI_FALSE;
+        if (ret == JNI_TRUE) pretty_log_urc(c_urc);
+        env->ReleaseStringUTFChars(urc, c_urc);
+        return ret;
+    }
+#endif
+    return JNI_FALSE;
+}
+
+
 static jstring readNative(JNIEnv *env, jobject obj, jint timeout_ms) {
 #ifdef HAVE_BLUETOOTH
     {
@@ -532,6 +642,25 @@ static jstring readNative(JNIEnv *env, jobject obj, jint timeout_ms) {
 #endif
 }
 
+static jstring readNativePDUStream(JNIEnv *env, jobject obj, jint timeout_ms) {
+#ifdef HAVE_BLUETOOTH
+    {
+        native_data_t *nat = get_native_data(env, obj);
+        if (nat->rfcomm_connected) {
+            char buf[256];
+            const char *ret = get_PDUline(nat->rfcomm_sock,
+                                       buf, sizeof(buf),
+                                       timeout_ms,
+                                       &nat->last_read_err);
+            return ret ? env->NewStringUTF(ret) : NULL;
+        }
+        return NULL;
+    }
+#else
+    return NULL;
+#endif
+}
+
 static jint getLastReadStatusNative(JNIEnv *env, jobject obj) {
 #ifdef HAVE_BLUETOOTH
     {
@@ -555,7 +684,9 @@ static JNINativeMethod sMethods[] = {
     {"waitForAsyncConnectNative", "(I)I", (void *)waitForAsyncConnectNative},
     {"disconnectNative", "()V", (void *)disconnectNative},
     {"sendURCNative", "(Ljava/lang/String;)Z", (void *)sendURCNative},
+    {"sendURCNativeChars", "(Ljava/lang/String;)Z", (void *)sendURCNativeChars},
     {"readNative", "(I)Ljava/lang/String;", (void *)readNative},
+    {"readNativePDUStream", "(I)Ljava/lang/String;", (void *)readNativePDUStream},
     {"getLastReadStatusNative", "()I", (void *)getLastReadStatusNative},
 };
 
diff --git a/core/res/AndroidManifest.xml b/core/res/AndroidManifest.xml
index 9e6fdf8..973c5c8 100644
--- a/core/res/AndroidManifest.xml
+++ b/core/res/AndroidManifest.xml
@@ -557,6 +557,22 @@
         android:label="@string/permlab_vibrate"
         android:description="@string/permdesc_vibrate" />
 
+    <!-- Allows access to the FM Radio receiver
+        @hide Pending API council approval -->
+    <permission android:name="com.stericsson.permission.FM_RADIO_RECEIVER"
+        android:permissionGroup="android.permission-group.HARDWARE_CONTROLS"
+        android:protectionLevel="normal"
+        android:label="@string/permlab_fm_radio_receiver"
+        android:description="@string/permdesc_fm_radio_receiver" />
+
+    <!-- Allows access to the FM Radio transmitter
+         @hide Pending API council approval -->
+    <permission android:name="com.stericsson.permission.FM_RADIO_TRANSMITTER"
+        android:permissionGroup="android.permission-group.HARDWARE_CONTROLS"
+        android:protectionLevel="dangerous"
+        android:label="@string/permlab_fm_radio_transmitter"
+        android:description="@string/permdesc_fm_radio_transmitter" />
+
     <!-- Allows access to the flashlight -->
     <permission android:name="android.permission.FLASHLIGHT"
         android:permissionGroup="android.permission-group.HARDWARE_CONTROLS"
diff --git a/core/res/res/drawable-ldpi/stat_sys_adb.png b/core/res/res/drawable-ldpi/stat_sys_adb.png
index 86b945b..7cf15b9 100644
Binary files a/core/res/res/drawable-ldpi/stat_sys_adb.png and b/core/res/res/drawable-ldpi/stat_sys_adb.png differ
diff --git a/core/res/res/values/strings.xml b/core/res/res/values/strings.xml
index 16d7d08..5174242 100755
--- a/core/res/res/values/strings.xml
+++ b/core/res/res/values/strings.xml
@@ -1180,6 +1180,18 @@
         the vibrator.</string>
 
     <!-- Title of an application permission, listed so the user can choose whether they want to allow the application to do this. -->
+    <string name="permlab_fm_radio_receiver">control FM receiver</string>
+    <!-- Description of an application permission, listed so the user can choose whether they want to allow the application to do this. -->
+    <string name="permdesc_fm_radio_receiver">Allows the application to control
+        the FM receiver.</string>
+
+    <!-- Title of an application permission, listed so the user can choose whether they want to allow the application to do this. -->
+    <string name="permlab_fm_radio_transmitter">control FM transmitter</string>
+    <!-- Description of an application permission, listed so the user can choose whether they want to allow the application to do this. -->
+    <string name="permdesc_fm_radio_transmitter">Allows the application to control
+        the FM transmitter.</string>
+
+    <!-- Title of an application permission, listed so the user can choose whether they want to allow the application to do this. -->
     <string name="permlab_flashlight">control flashlight</string>
     <!-- Description of an application permission, listed so the user can choose whether they want to allow the application to do this. -->
     <string name="permdesc_flashlight">Allows the application to control
diff --git a/data/etc/com.stericsson.hardware.fm.receiver.xml b/data/etc/com.stericsson.hardware.fm.receiver.xml
new file mode 100644
index 0000000..13092fa
--- /dev/null
+++ b/data/etc/com.stericsson.hardware.fm.receiver.xml
@@ -0,0 +1,20 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!-- Copyright (C) 2009 The Android Open Source Project
+
+     Licensed under the Apache License, Version 2.0 (the "License");
+     you may not use this file except in compliance with the License.
+     You may obtain a copy of the License at
+
+          http://www.apache.org/licenses/LICENSE-2.0
+
+     Unless required by applicable law or agreed to in writing, software
+     distributed under the License is distributed on an "AS IS" BASIS,
+     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+     See the License for the specific language governing permissions and
+     limitations under the License.
+-->
+
+<!-- This is the standard feature indicating that the device includes FM receiver. -->
+<permissions>
+    <feature name="com.stericsson.hardware.fm.receiver" />
+</permissions>
diff --git a/data/etc/com.stericsson.hardware.fm.transmitter.xml b/data/etc/com.stericsson.hardware.fm.transmitter.xml
new file mode 100644
index 0000000..9b51c03
--- /dev/null
+++ b/data/etc/com.stericsson.hardware.fm.transmitter.xml
@@ -0,0 +1,20 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!-- Copyright (C) 2009 The Android Open Source Project
+
+     Licensed under the Apache License, Version 2.0 (the "License");
+     you may not use this file except in compliance with the License.
+     You may obtain a copy of the License at
+
+          http://www.apache.org/licenses/LICENSE-2.0
+
+     Unless required by applicable law or agreed to in writing, software
+     distributed under the License is distributed on an "AS IS" BASIS,
+     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+     See the License for the specific language governing permissions and
+     limitations under the License.
+-->
+
+<!-- This is the standard feature indicating that the device includes FM transmitter. -->
+<permissions>
+    <feature name="com.stericsson.hardware.fm.transmitter" />
+</permissions>
diff --git a/fmradio/include/android_fmradio.h b/fmradio/include/android_fmradio.h
new file mode 100644
index 0000000..18518b6
--- /dev/null
+++ b/fmradio/include/android_fmradio.h
@@ -0,0 +1,203 @@
+/*
+ * Copyright (C) ST-Ericsson SA 2010
+ * Copyright (C) 2010 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+ * Author: johan.xj.palmaeus@stericsson.com for ST-Ericsson
+ */
+
+/*
+ * Internal stuff for android_fmradio(_Receiver/_Transmitter).cpp
+ */
+
+#ifndef ANDROID_FMRADIO_H
+#define ANDROID_FMRADIO_H
+
+#include "jni.h"
+#include "fmradio.h"
+
+enum FmRadioState_t {
+    FMRADIO_STATE_IDLE,
+    FMRADIO_STATE_STARTING,
+    FMRADIO_STATE_STARTED,
+    FMRADIO_STATE_PAUSED,
+    FMRADIO_STATE_SCANNING,
+    FMRADIO_STATE_EXTRA_COMMAND,
+    /* sum up */
+    FMRADIO_NUMBER_OF_STATES
+};
+
+enum FmRadioCommand_t {
+    FMRADIO_EVENT_START,
+    FMRADIO_EVENT_START_ASYNC,
+    FMRADIO_EVENT_PAUSE,
+    FMRADIO_EVENT_RESUME,
+    FMRADIO_EVENT_RESET,
+    FMRADIO_EVENT_GET_FREQUENCY,
+    FMRADIO_EVENT_SET_FREQUENCY,
+    FMRADIO_EVENT_SET_PARAMETER,
+    FMRADIO_EVENT_STOP_SCAN,
+    FMRADIO_EVENT_EXTRA_COMMAND,
+    /* RX Only */
+    FMRADIO_EVENT_GET_PARAMETER,
+    FMRADIO_EVENT_GET_SIGNAL_STRENGTH,
+    FMRADIO_EVENT_SCAN,
+    FMRADIO_EVENT_FULL_SCAN,
+    /* TX Only */
+    FMRADIO_EVENT_BLOCK_SCAN,
+    /* sum up */
+    FMRADIO_NUMBER_OF_EVENTS
+};
+
+enum RadioMode_t {
+    FMRADIO_RX,
+    FMRADIO_TX
+};
+
+typedef bool ValidEventsForStates_t[FMRADIO_NUMBER_OF_EVENTS]
+    [FMRADIO_NUMBER_OF_STATES];
+
+struct FmRadioCallbacks_t {
+    void (*onStateChanged) (int, int);
+    void (*onError) (void);
+    void (*onStarted) (void);
+    void (*onScan) (int, int, int, bool);    /* RX only */
+    void (*onFullScan) (int, int *, int *, bool);       /* RX only */
+    void (*onBlockScan) (int, int *, int *, bool);      /* TX only */
+    void (*onForcedReset) (enum fmradio_reset_reason_t reason);
+    void (*onSendExtraCommand) (char*, struct fmradio_extra_command_ret_item_t *);
+};
+
+struct bundle_descriptor_offsets_t {
+    jclass mClass;
+    jmethodID mConstructor;
+    jmethodID mGetInt;
+    jmethodID mGetIntArray;
+    jmethodID mGetShort;
+    jmethodID mGetShortArray;
+    jmethodID mGetString;
+    jmethodID mContainsKey;
+    jmethodID mSize;
+    jmethodID mKeySet;
+    jmethodID mPutInt;
+    jmethodID mPutShort;
+    jmethodID mPutIntArray;
+    jmethodID mPutShortArray;
+    jmethodID mPutString;
+};
+
+struct FmSession_t {
+    // vendor specific data, we do not know about this type
+    void *vendorData_p;
+    void *fmLibrary_p;
+    bool isRegistered;
+    enum FmRadioState_t state;
+    struct fmradio_vendor_methods_t *vendorMethods_p;
+    const ValidEventsForStates_t *validEventsForStates_p;
+    const struct FmRadioCallbacks_t *callbacks_p;
+    JavaVM *jvm_p;
+    jobject jobj;
+    struct FmSession_t *partnerSession_p;
+    struct bundle_descriptor_offsets_t *bundleOffsets_p;
+    enum FmRadioState_t oldState;    /* used when scanning */
+    bool lastScanAborted;            /* used when scanning */
+    bool pendingPause;               /* used when scanning & asyncStarting */
+    bool ongoingReset;               /* used during reset while waiting */
+    pthread_mutex_t *dataMutex_p;    /* data access to this struct */
+    pthread_cond_t  sync_cond;
+    struct ThreadCtrl_t *signalStrengthThreadCtrl_p;    /* RX Only */
+};
+
+#define FMRADIO_SET_STATE(_session_p,_newState) {int _oldState = (_session_p)->state; (_session_p)->state = _newState;(_session_p)->callbacks_p->onStateChanged(_oldState, _newState);}
+
+/* exceptions */
+
+#define THROW_ILLEGAL_ARGUMENT(_session_p) \
+      androidFmRadioThrowException(_session_p,\
+           "java/lang/IllegalArgumentException",\
+           "Illegal argument", __FILE__, __LINE__,\
+           __FUNCTION__)
+#define THROW_UNSUPPORTED_OPERATION(_session_p) \
+      androidFmRadioThrowException(_session_p,\
+           "java/lang/UnsupportedOperationException",\
+           "Unsupported operation", __FILE__, __LINE__,\
+            __FUNCTION__)
+#define THROW_INVALID_STATE(_session_p)	\
+      androidFmRadioThrowException(_session_p,\
+           "java/lang/IllegalStateException",\
+           "State is invalid", __FILE__, __LINE__,\
+           __FUNCTION__)
+#define THROW_IO_ERROR(_session_p) \
+      androidFmRadioThrowException(_session_p,\
+           "java/io/IOException",\
+           "IO Exception", __FILE__, __LINE__,\
+           __FUNCTION__)
+
+
+#define FM_LIBRARY_NAME_MAX_LENGTH 128
+
+#define THREAD_WAIT_TIMEOUT_S 2
+
+#define SIGNAL_STRENGTH_MAX 1000
+#define SIGNAL_STRENGTH_UNKNOWN -1
+
+extern pthread_mutex_t rx_tx_common_mutex;
+
+jobject extraCommandRetList2Bundle(JNIEnv * env_p, struct bundle_descriptor_offsets_t
+                                   *bundleOffsets_p,
+                                   struct fmradio_extra_command_ret_item_t *itemList);
+
+void freeExtraCommandRetList(struct extra_command_ret_item_t *itemList);
+
+void androidFmRadioTempResumeIfPaused(struct FmSession_t *session_p);
+
+void androidFmRadioPauseIfTempResumed(struct FmSession_t *session_p);
+
+bool androidFmRadioIsValidEventForState(struct FmSession_t *session_p,
+                                        enum FmRadioCommand_t event);
+
+void androidFmRadioThrowException(struct FmSession_t *session_p,
+                                  const char *exception,
+                                  const char *message, const char *file,
+                                  int line, const char *function);
+
+bool androidFmRadioLoadFmLibrary(struct FmSession_t *session_p,
+                                 enum RadioMode_t mode);
+
+void androidFmRadioUnLoadFmLibrary(struct FmSession_t *session_p);
+
+int
+androidFmRadioStart(struct FmSession_t *session_p, enum RadioMode_t mode,
+                    const struct fmradio_vendor_callbacks_t *callbacks,
+                    bool async, int lowFreq, int highFreq, int defaultFreq,
+                    int grid);
+
+int androidFmRadioPause(struct FmSession_t *session_p);
+
+int androidFmRadioResume(struct FmSession_t *session_p);
+
+int androidFmRadioReset(struct FmSession_t *session_p);
+
+void androidFmRadioSetFrequency(struct FmSession_t *session_p,
+                                int frequency);
+
+int androidFmRadioGetFrequency(struct FmSession_t *session_p);
+
+void androidFmRadioStopScan(struct FmSession_t *session_p);
+
+void
+androidFmRadioSendExtraCommand(struct FmSession_t *session_p, JNIEnv * env,
+                               jstring command, jobjectArray parameter);
+
+#endif
diff --git a/fmradio/java/com/stericsson/hardware/fm/FmBand.aidl b/fmradio/java/com/stericsson/hardware/fm/FmBand.aidl
new file mode 100644
index 0000000..76def36
--- /dev/null
+++ b/fmradio/java/com/stericsson/hardware/fm/FmBand.aidl
@@ -0,0 +1,22 @@
+/*
+ * Copyright (C) ST-Ericsson SA 2010
+ * Copyright (C) 2010 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+ * Author: Markus Grape (markus.grape@stericsson.com) for ST-Ericsson
+ */
+
+package com.stericsson.hardware.fm;
+
+parcelable FmBand;
diff --git a/fmradio/java/com/stericsson/hardware/fm/FmBand.java b/fmradio/java/com/stericsson/hardware/fm/FmBand.java
new file mode 100644
index 0000000..f1002f3
--- /dev/null
+++ b/fmradio/java/com/stericsson/hardware/fm/FmBand.java
@@ -0,0 +1,258 @@
+/*
+ * Copyright (C) ST-Ericsson SA 2010
+ * Copyright (C) 2010 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+ * Author: Bjorn Pileryd (bjorn.pileryd@sonyericsson.com)
+ * Author: Markus Grape (markus.grape@stericsson.com) for ST-Ericsson
+ */
+
+package com.stericsson.hardware.fm;
+
+import android.os.Parcel;
+import android.os.Parcelable;
+
+/**
+ * Describes the properties of the FM frequency band. The frequency band range
+ * and the channel offset vary in different regions. The unit for all
+ * frequencies in this class is kHz.
+ */
+public class FmBand implements Parcelable {
+
+    /**
+     * Default band for US 87.9MHz - 107.9MHz, 200kHz channel offset.
+     */
+    public static final int BAND_US = 0;
+
+    /**
+     * Default band for EU 87.5MHz - 108MHz, 100kHz channel offset.
+     */
+    public static final int BAND_EU = 1;
+
+    /**
+     * Default band for Japan 76MHz - 90MHz, 100kHz channel offset.
+     */
+    public static final int BAND_JAPAN = 2;
+
+    /**
+     * Default band for China 70MHz - 108MHz, 50kHz channel offset.
+     */
+    public static final int BAND_CHINA = 3;
+
+    /**
+     * Default band for EU 87.5MHz - 108MHz, 50kHz channel offset.
+     */
+    public static final int BAND_EU_50K_OFFSET = 4;
+
+    /**
+     * Unknown frequency.
+     */
+    public static final int FM_FREQUENCY_UNKNOWN = -1;
+
+    /**
+     * The lowest frequency of the band.
+     */
+    private int mMinFrequency;
+
+    /**
+     * The highest frequency of the band.
+     */
+    private int mMaxFrequency;
+
+    /**
+     * The default frequency of the band.
+     */
+    private int mDefaultFrequency;
+
+    /**
+     * The offset between the channels in the band.
+     */
+    private int mChannelOffset;
+
+    /**
+     * Creates a band representation.
+     *
+     * @param minFrequency
+     *            the lowest frequency of the band in kHz
+     * @param maxFrequency
+     *            the highest frequency of the band in kHz
+     * @param channelOffset
+     *            the offset between the channels in the band in kHz
+     * @param defaultFrequency
+     *            the default frequency that the hardware will tune to at
+     *            startup
+     * @throws IllegalArgumentException
+     *             if the minFrequency is equal or higher then maxFrequency
+     * @throws IllegalArgumentException
+     *             if the defaultFrequency is not within the limits of
+     *             minFrequency and maxFrequency
+     * @throws IllegalArgumentException
+     *             if the minFrequency or maxFrequency is not a multiplier of channelOffset
+     */
+    public FmBand(int minFrequency, int maxFrequency, int channelOffset, int defaultFrequency) {
+        if (minFrequency >= maxFrequency) {
+            throw new IllegalArgumentException(
+                    "Minimum frequency can not be equal or higher than maximum frequency");
+        }
+        if (defaultFrequency < minFrequency) {
+            throw new IllegalArgumentException(
+                    "Default frequency can not be less than minFrequency");
+        }
+        if (defaultFrequency > maxFrequency) {
+            throw new IllegalArgumentException(
+                    "Default frequency can not be higher than maxFrequency");
+        }
+        if ((maxFrequency - minFrequency) % channelOffset != 0
+                || (defaultFrequency - minFrequency) % channelOffset != 0) {
+            throw new IllegalArgumentException(
+                    "Frequency has invalid offset");
+        }
+        this.mMinFrequency = minFrequency;
+        this.mMaxFrequency = maxFrequency;
+        this.mDefaultFrequency = defaultFrequency;
+        this.mChannelOffset = channelOffset;
+    }
+
+    /**
+     * Creates a standard band representation. The default frequency will be the
+     * lowest frequency for the specified band.
+     *
+     * @param band
+     *            one of {@link #BAND_US}, {@link #BAND_EU}, {@link #BAND_JAPAN}
+     *            , {@link #BAND_CHINA}, {@link #BAND_EU_50K_OFFSET}
+     * @throws IllegalArgumentException
+     *             if the band is not one of {@link #BAND_US}, {@link #BAND_EU},
+     *             {@link #BAND_JAPAN}, {@link #BAND_CHINA}, {@link #BAND_EU_50K_OFFSET}
+     */
+    public FmBand(int band) {
+        switch (band) {
+        case BAND_US:
+            this.mMinFrequency = 87900;
+            this.mMaxFrequency = 107900;
+            this.mDefaultFrequency = 87900;
+            this.mChannelOffset = 200;
+            break;
+        case BAND_EU:
+            this.mMinFrequency = 87500;
+            this.mMaxFrequency = 108000;
+            this.mDefaultFrequency = 87500;
+            this.mChannelOffset = 100;
+            break;
+        case BAND_JAPAN:
+            this.mMinFrequency = 76000;
+            this.mMaxFrequency = 90000;
+            this.mDefaultFrequency = 76000;
+            this.mChannelOffset = 100;
+            break;
+        case BAND_CHINA:
+            this.mMinFrequency = 70000;
+            this.mMaxFrequency = 108000;
+            this.mDefaultFrequency = 70000;
+            this.mChannelOffset = 50;
+            break;
+        case BAND_EU_50K_OFFSET:
+            this.mMinFrequency = 87500;
+            this.mMaxFrequency = 108000;
+            this.mDefaultFrequency = 87500;
+            this.mChannelOffset = 50;
+            break;
+        default:
+            throw new IllegalArgumentException("Wrong band identifier");
+        }
+    }
+
+    /**
+     * Checks if a frequency is valid to the band. To be valid it must be within
+     * the frequency range and on a frequency with correct channel offset.
+     *
+     * @param frequency
+     *            the frequency to validate
+     * @return true if the frequency is valid for this band
+     */
+    public boolean isFrequencyValid(int frequency) {
+        if (frequency < mMinFrequency || frequency > mMaxFrequency) {
+            return false;
+        }
+        if ((frequency - mMinFrequency) % mChannelOffset != 0) {
+            return false;
+        }
+        return true;
+    }
+
+    /**
+     * Return the lowest frequency of the band.
+     *
+     * @return the lowest frequency of the band in kHz
+     */
+    public int getMinFrequency() {
+        return mMinFrequency;
+    }
+
+    /**
+     * Returns the highest frequency of the band.
+     *
+     * @return the highest frequency of the band in kHz
+     */
+    public int getMaxFrequency() {
+        return mMaxFrequency;
+    }
+
+    /**
+     * Returns the default frequency of the band that the hardware will tune to
+     * at startup.
+     *
+     * @return the default frequency of the band in kHz
+     */
+    public int getDefaultFrequency() {
+        return mDefaultFrequency;
+    }
+
+    /**
+     * Returns the offset between the channels in the band.
+     *
+     * @return the offset between the channels in the band in kHz
+     */
+    public int getChannelOffset() {
+        return mChannelOffset;
+    }
+
+    /** Implement the Parcelable interface {@hide} */
+    public int describeContents() {
+        return 0;
+    }
+
+    /** Implement the Parcelable interface {@hide} */
+    public void writeToParcel(Parcel dest, int flags) {
+        dest.writeInt(mMinFrequency);
+        dest.writeInt(mMaxFrequency);
+        dest.writeInt(mChannelOffset);
+        dest.writeInt(mDefaultFrequency);
+    }
+
+    /** Implement the Parcelable interface {@hide} */
+    public static final Creator<FmBand> CREATOR = new Creator<FmBand>() {
+        public FmBand createFromParcel(Parcel in) {
+            int minfreq = in.readInt();
+            int maxfreq = in.readInt();
+            int offset = in.readInt();
+            int defaultFreq = in.readInt();
+            FmBand band = new FmBand(minfreq, maxfreq, offset, defaultFreq);
+            return band;
+        }
+
+        public FmBand[] newArray(int size) {
+            return new FmBand[size];
+        }
+    };
+}
diff --git a/fmradio/java/com/stericsson/hardware/fm/FmReceiver.java b/fmradio/java/com/stericsson/hardware/fm/FmReceiver.java
new file mode 100644
index 0000000..1055429
--- /dev/null
+++ b/fmradio/java/com/stericsson/hardware/fm/FmReceiver.java
@@ -0,0 +1,1327 @@
+/*
+ * Copyright (C) ST-Ericsson SA 2010
+ * Copyright (C) 2010 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+ * Author: Bjorn Pileryd (bjorn.pileryd@sonyericsson.com)
+ * Author: Markus Grape (markus.grape@stericsson.com) for ST-Ericsson
+ */
+
+package com.stericsson.hardware.fm;
+
+import android.content.Context;
+import android.content.pm.PackageManager;
+import android.os.Bundle;
+
+import java.io.IOException;
+
+/**
+ * The FmReceiver controls reception of FM radio. This API enables an
+ * application to tune/scan for channels, receive RDS data, etc. The unit for
+ * all frequencies in this class is kHz. Note that this API only controls the
+ * reception of FM radio, to play FM radio the MediaPlayer interfaces should be
+ * used, see code example below the state diagram.
+ * <p>
+ * Get an instance of this class by calling
+ * {@link android.content.Context#getSystemService(String)
+ * Context.getSystemService("fm_receiver")}.
+ * </p>
+ * <a name="StateDiagram"></a> <h3>State Diagram</h3>
+ * <p>
+ * The state machine is designed to take into account that some hardware may
+ * need time to prepare, and that it is likely to consume more power when paused
+ * and started than it does in the idle state. The hardware implementation of
+ * this interface should do the time consuming preparation procedures in the
+ * starting state. The switching between paused and started states should be
+ * fast to give a good user experience.
+ * </p>
+ * <p>
+ * <img src="../../../../images/FmReceiver_states.gif"
+ * alt="FmReceiver State diagram" border="0" />
+ * </p>
+ * <table border="1">
+ * <tr>
+ * <th>Method Name</th>
+ * <th>Valid States</th>
+ * <th>Invalid States</th>
+ * <th>Comments</th>
+ * </tr>
+ * <tr>
+ * <td>{@link #startAsync(FmBand)}</td>
+ * <td>{idle}</td>
+ * <td>{starting, paused, started, scanning}</td>
+ * <td>Successful invocation of this method in a valid state transfers the
+ * object to the starting state. Calling this method in an invalid state throws
+ * an IllegalStateException.</td>
+ * </tr>
+ * <tr>
+ * <td>{@link #start(FmBand)}</td>
+ * <td>{idle}</td>
+ * <td>{starting, paused, started, scanning}</td>
+ * <td>Successful invocation of this method in a valid state transfers the
+ * object to the started state. Calling this method in an invalid state throws
+ * an IllegalStateException.</td>
+ * </tr>
+ * <tr>
+ * <td>{@link #resume()}</td>
+ * <td>{paused, started}</td>
+ * <td>{idle, starting, scanning}</td>
+ * <td>Successful invocation of this method in a valid state transfers the
+ * object to the started state. Calling this method in an invalid state throws
+ * an IllegalStateException.</td>
+ * </tr>
+ * <tr>
+ * <td>{@link #pause()}</td>
+ * <td>{started, paused}</td>
+ * <td>{idle, starting, scanning}</td>
+ * <td>Successful invocation of this method in a valid state transfers the
+ * object to the paused state. Calling this method in an invalid state throws an
+ * IllegalStateException.</td>
+ * </tr>
+ * <tr>
+ * <td>{@link #reset()}</td>
+ * <td>any</td>
+ * <td>{}</td>
+ * <td>Successful invocation of this method transfers the object to the idle
+ * state, the object is like being just created.</td>
+ * </tr>
+ * <tr>
+ * <td>{@link #getState()}</td>
+ * <td>any</td>
+ * <td>{}</td>
+ * <td>This method can be called in any state and calling it does not change the
+ * object state.</td>
+ * </tr>
+ * <tr>
+ * <td>{@link #isApiSupported(Context)}</td>
+ * <td>any</td>
+ * <td>{}</td>
+ * <td>This method can be called in any state and calling it does not change the
+ * object state.</td>
+ * </tr>
+ * <tr>
+ * <td>{@link #isRDSDataSupported()}</td>
+ * <td>any</td>
+ * <td>{}</td>
+ * <td>This method can be called in any state and calling it does not change the
+ * object state.</td>
+ * </tr>
+ * <tr>
+ * <td>{@link #isTunedToValidChannel()}</td>
+ * <td>any</td>
+ * <td>{}</td>
+ * <td>This method can be called in any state and calling it does not change the
+ * object state.</td>
+ * </tr>
+ * <tr>
+ * <td>{@link #setThreshold(int)}</td>
+ * <td>{started, paused, scanning}</td>
+ * <td>{idle, starting}</td>
+ * <td>Calling this method in an invalid state throws an IllegalStateException.
+ * </td>
+ * </tr>
+ * <tr>
+ * <td>{@link #getThreshold()}</td>
+ * <td>{started, paused, scanning}</td>
+ * <td>{idle, starting}</td>
+ * <td>Calling this method in an invalid state throws an IllegalStateException.
+ * </td>
+ * </tr>
+ * <tr>
+ * <td>{@link #getFrequency()}</td>
+ * <td>{paused, started}</td>
+ * <td>{idle, starting, scanning}</td>
+ * <td>Successful invocation of this method in a valid state does not change the
+ * object state. Calling this method in an invalid state throws an
+ * IllegalStateException.</td>
+ * </tr>
+ * <tr>
+ * <td>{@link #getSignalStrength()}</td>
+ * <td>any</td>
+ * <td>{}</td>
+ * <td>This method can be called in any state and calling it does not change the
+ * object state.</td>
+ * </tr>
+ * <tr>
+ * <td>{@link #isPlayingInStereo()}</td>
+ * <td>any</td>
+ * <td>{}</td>
+ * <td>This method can be called in any state and calling it does not change the
+ * object state.</td>
+ * </tr>
+ * <tr>
+ * <td>{@link #setForceMono(boolean)}</td>
+ * <td>{started, paused, scanning}</td>
+ * <td>{idle, starting}</td>
+ * <td>Calling this method in an invalid state throws an IllegalStateException.
+ * </td>
+ * </tr>
+ * <tr>
+ * <td>{@link #setAutomaticAFSwitching(boolean)}</td>
+ * <td>{started, paused, scanning}</td>
+ * <td>{idle, starting}</td>
+ * <td>Calling this method in an invalid state throws an IllegalStateException.
+ * </td>
+ * </tr>
+ * <tr>
+ * <td>{@link #setAutomaticTASwitching(boolean)}</td>
+ * <td>{started, paused, scanning}</td>
+ * <td>{idle, starting}</td>
+ * <td>Calling this method in an invalid state throws an IllegalStateException.
+ * </td>
+ * </tr>
+ * <tr>
+ * <td>{@link #setFrequency(int)}</td>
+ * <td>{started, paused}</td>
+ * <td>{idle, starting, scanning}</td>
+ * <td>Successful invocation of this method in a valid state does not change the
+ * object state. Calling this method in an invalid state throws an
+ * IllegalStateException.</td>
+ * </tr>
+ * <tr>
+ * <td>{@link #startFullScan()}</td>
+ * <td>{started, paused}</td>
+ * <td>{idle, starting, scanning}</td>
+ * <td>Successful invocation of this method in a valid state transfers the
+ * object to the scanning state. Calling this method in an invalid state throws
+ * an IllegalStateException.</td>
+ * </tr>
+ * <tr>
+ * <td>{@link #scanUp()}</td>
+ * <td>{started, paused}</td>
+ * <td>{idle, starting, scanning}</td>
+ * <td>Successful invocation of this method in a valid state transfers the
+ * object to the scanning state. Calling this method in an invalid state throws
+ * an IllegalStateException.</td>
+ * </tr>
+ * <tr>
+ * <td>{@link #scanDown()}</td>
+ * <td>{started, paused}</td>
+ * <td>{idle, starting, scanning}</td>
+ * <td>Successful invocation of this method in a valid state transfers the
+ * object to the scanning state. Calling this method in an invalid state throws
+ * an IllegalStateException.</td>
+ * </tr>
+ * <tr>
+ * <td>{@link #stopScan()}</td>
+ * <td>any</td>
+ * <td>{}</td>
+ * <td>Successful invocation of this method in a valid state tries to stop
+ * performing a scan operation. The hardware might continue the scan for an
+ * unspecified amount of time after this method is called. Once the scan has
+ * stopped, it will be notified via {@link OnScanListener}</td>
+ * </tr>
+ * <tr>
+ * <td>{@link #sendExtraCommand(String, String[])}</td>
+ * <td>vendor specific</td>
+ * <td>vendor specific</td>
+ * <td>vendor specific</td>
+ * </tr>
+ * </table>
+ * <a name="Examples"></a> <h3>Example code</h3>
+ * <pre>
+ * // start receiving FM radio
+ * FmReceiver fmr = (FmReceiver) getSystemService("fm_receiver");
+ * fmr.start(new FmBand(FmBand.BAND_EU));
+ *
+ * // prepare and start playback
+ * MediaPlayer mp = new MediaPlayer();
+ * mp.setDataSource(&quot;fmradio://rx&quot;);
+ * mp.prepare();
+ * mp.start();
+ * </pre>
+ * <a name="FMHandling"></a> <h3>FM receiving/transmission handling</h3>
+ * <p>
+ * In this API, FM radio cannot be received and transmitted at the same time,
+ * therefore the state machine is designed to prevent incorrect usage. The
+ * FmReceiver and FmTransmitter has a separate state machine and only one can be
+ * <i>active</i> (state other than idle).
+ * <ul>
+ * <li>If start is called on FmReceiver and the FmTransmitter is <i>active</i>,
+ * the FmTransmitter MUST release resources and change state to idle.</li>
+ * <li>The FmTransmitter will in that case be notified by
+ * {@link com.stericsson.hardware.fm.FmTransmitter.OnForcedResetListener#onForcedReset(int)}.</li>
+ * </ul>
+ * </p>
+ * <a name="RDSHandling"></a> <h3>Receiving/transmitting RDS data</h3>
+ * <p>
+ * RDS data can be received by setting the
+ * {@link #addOnRDSDataFoundListener(OnRDSDataFoundListener)}. When RDS data is
+ * available the data can be extracted from the Bundle object in
+ * {@link OnRDSDataFoundListener#onRDSDataFound(Bundle, int)} according to the
+ * table below. This table can also be used when transmitting RDS data with the
+ * FmTransmitter.
+ * </p>
+ * <table border="1">
+ * <tr>
+ * <th>RDS description</th>
+ * <th>key name</th>
+ * <th>value type</th>
+ * <th>value description</th>
+ * </tr>
+ * <tr>
+ * <td>Program Identification code</td>
+ * <td>PI</td>
+ * <td>short</td>
+ * <td>N/A</td>
+ * </tr>
+ * <tr>
+ * <td>Traffic Program Identification code</td>
+ * <td>TP</td>
+ * <td>short</td>
+ * <td>1 bit</td>
+ * </tr>
+ * <tr>
+ * <td>Program Type code</td>
+ * <td>PTY</td>
+ * <td>short</td>
+ * <td>5 bits</td>
+ * </tr>
+ * <tr>
+ * <td>Traffic Announcement code</td>
+ * <td>TA</td>
+ * <td>short</td>
+ * <td>1 bit</td>
+ * </tr>
+ * <tr>
+ * <td>Music/Speech switch code</td>
+ * <td>M/S</td>
+ * <td>short</td>
+ * <td>1 bit</td>
+ * </tr>
+ * <tr>
+ * <td>Alternative Frequency</td>
+ * <td>AF</td>
+ * <td>int[]</td>
+ * <td>kHz</td>
+ * </tr>
+ * <tr>
+ * <td>Program service name</td>
+ * <td>PSN</td>
+ * <td>string</td>
+ * <td>8 chars</td>
+ * </tr>
+ * <tr>
+ * <td>Radio text</td>
+ * <td>RT</td>
+ * <td>string</td>
+ * <td>64 chars</td>
+ * </tr>
+ * <tr>
+ * <td>Clock-time and date</td>
+ * <td>CT</td>
+ * <td>string</td>
+ * <td>Yr:mo:dy:hr:min</td>
+ * </tr>
+ * <tr>
+ * <td>Program Type name</td>
+ * <td>PTYN</td>
+ * <td>string</td>
+ * <td>8 chars</td>
+ * </tr>
+ * <tr>
+ * <td>Traffic Message Channel</td>
+ * <td>TMC</td>
+ * <td>short[]</td>
+ * <td>X:Y:Z -> 5+16+16 bits</td>
+ * </tr>
+ * <tr>
+ * <td>TA Frequency</td>
+ * <td>TAF</td>
+ * <td>int</td>
+ * <td>kHz</td>
+ * </tr>
+ * </table>
+ * <p>
+ * The RDS specification can be found <a
+ * href="http://www.rds.org.uk/rds98/pdf/IEC%2062106-E_no%20print.pdf">here</a>
+ * </p>
+ * <a name="ErrorHandling"></a> <h3>Error handling</h3>
+ * <p>
+ * In general, it is up to the application that uses this API to keep track of
+ * events that could affect the FM radio user experience. The hardware
+ * implementation side of this API should only take actions when it is really
+ * necessary, e.g. if the hardware is forced to pause or reset, and notify the
+ * application by using the {@link OnForcedPauseListener},
+ * {@link OnForcedResetListener} or {@link OnErrorListener}.
+ * </p>
+ */
+public abstract class FmReceiver {
+
+    /**
+     * The FmReceiver had to be shut down due to a non-critical error, meaning
+     * that it is OK to attempt a restart immediately after this. For example,
+     * if the hardware was shut down in order to save power after being in the
+     * paused state for too long.
+     */
+    public static final int RESET_NON_CRITICAL = 0;
+
+    /**
+     * The FmReceiver had to be shut down due to a critical error. The FM
+     * hardware it not guaranteed to work as expected after receiving this
+     * error.
+     */
+    public static final int RESET_CRITICAL = 1;
+
+    /**
+     * The FmTransmitter was activated and therefore the FmReceiver must be put
+     * in idle.
+     *
+     * @see FmTransmitter#startAsync(FmBand)
+     */
+    public static final int RESET_TX_IN_USE = 2;
+
+    /**
+     * The radio is not allowed to be used, typically when flight mode is
+     * enabled.
+     */
+    public static final int RESET_RADIO_FORBIDDEN = 3;
+
+    /**
+     * Indicates that the FmReceiver is in an idle state. No resources are
+     * allocated and power consumption is kept to a minimum.
+     */
+    public static final int STATE_IDLE = 0;
+
+    /**
+     * Indicates that the FmReceiver is allocating resources and preparing to
+     * receive FM radio.
+     */
+    public static final int STATE_STARTING = 1;
+
+    /**
+     * Indicates that the FmReceiver is receiving FM radio. Note that the
+     * FmReceiver is considered to be started even if it is receiving noise or
+     * gets a signal with not good enough quality to consider a valid channel.
+     */
+    public static final int STATE_STARTED = 2;
+
+    /**
+     * Indicates that the FmReceiver has allocated resources and is ready to
+     * instantly receive FM radio.
+     */
+    public static final int STATE_PAUSED = 3;
+
+    /**
+     * Indicates that the FmReceiver is scanning. FM radio will not be received
+     * in this state.
+     */
+    public static final int STATE_SCANNING = 4;
+
+    /**
+     * Unknown signal strength.
+     */
+    public static final int SIGNAL_STRENGTH_UNKNOWN = -1;
+
+    /**
+     * The frequency switch occurred as a stronger alternate frequency was
+     * found.
+     */
+    public static final int SWITCH_AF = 0;
+
+    /**
+     * The frequency switch occurred as there is a traffic announcement
+     * in progress.
+     */
+    public static final int SWITCH_TA = 1;
+
+    /**
+     * The frequency switch occurred at the cessation of a traffic
+     * announcement.
+     */
+    public static final int SWITCH_TA_END = 2;
+
+    /**
+     * Scan direction down towards lower frequencies.
+     */
+    public static final int SCAN_DOWN = 0;
+
+    /**
+     * Scan direction up towards higher frequencies.
+     */
+    public static final int SCAN_UP = 1;
+
+    /**
+     * Returns true if the FM receiver API is supported by the system.
+     */
+    public static boolean isApiSupported(Context context) {
+        return context.getPackageManager().hasSystemFeature(
+        PackageManager.FEATURE_RADIO_FM_RECEIVER);
+    }
+
+    /**
+     * Starts reception of the FM hardware. This is an asynchronous method since
+     * different hardware can have varying startup times. When the reception is
+     * started a callback to {@link OnStartedListener#onStarted()} is made.
+     * <p>
+     * When calling this method, an FmBand parameter must be passed that
+     * describes the properties of the band that the FmReceiver should prepare
+     * for. If the band is null, invalid or not supported, an exception will be
+     * thrown.
+     * </p>
+     * <p>
+     * If the FmTransmitter is active it will be forced to reset. See
+     * {@link FmTransmitter#RESET_RX_IN_USE}.
+     * </p>
+     *
+     * @param band
+     *            the band to use
+     * @throws IllegalArgumentException
+     *             if the band is null
+     * @throws UnsupportedOperationException
+     *             if the band is not supported by the hardware
+     * @throws IllegalStateException
+     *             if it is called in an invalid state
+     * @throws IOException
+     *             if the FM hardware failed to start
+     * @throws SecurityException
+     *             if the FM_RADIO_RECEIVER permission is not present
+     * @see FmBand
+     */
+    public abstract void startAsync(FmBand band) throws IOException;
+
+    /**
+     * Starts reception of the FM hardware. This is a synchronous method and the
+     * method call will block until the hardware is started.
+     * <p>
+     * When calling this method, an FmBand parameter must be passed that
+     * describes the properties of the band that the FmReceiver should prepare
+     * for. If the band is null, invalid or not supported, an exception will be
+     * thrown.
+     * </p>
+     * <p>
+     * If the FmTransmitter is active it will be forced to reset. See
+     * {@link FmTransmitter#RESET_RX_IN_USE}.
+     * </p>
+     *
+     * @param band
+     *            the band to use
+     * @throws IllegalArgumentException
+     *             if the band is null
+     * @throws UnsupportedOperationException
+     *             if the band is not supported by the hardware
+     * @throws IllegalStateException
+     *             if it is called in an invalid state
+     * @throws IOException
+     *             if the FM hardware failed to start
+     * @throws SecurityException
+     *             if the FM_RADIO_RECEIVER permission is not present
+     * @see FmBand
+     */
+    public abstract void start(FmBand band) throws IOException;
+
+    /**
+     * Resumes FM reception.
+     * <p>
+     * Calling this method when the FmReceiver is in started state has no
+     * affect.
+     * </p>
+     *
+     * @throws IllegalStateException
+     *             if it is called in an invalid state
+     * @throws IOException
+     *             if the FM hardware failed to resume
+     * @throws SecurityException
+     *             if the FM_RADIO_RECEIVER permission is not present
+     */
+    public abstract void resume() throws IOException;
+
+    /**
+     * Pauses FM reception. No FM radio is received as long as the FmReceiver is
+     * paused. Call {@link #resume()} to resume reception. The hardware should
+     * be able to resume reception quickly from the paused state to give a good
+     * user experience.
+     * <p>
+     * Note that the hardware provider may choose to turn off the hardware after
+     * being paused a certain amount of time to save power. This will be
+     * reported in {@link OnForcedResetListener#onForcedReset(int)} with reason
+     * {@link #RESET_NON_CRITICAL} and the FmReceiver will be set to the idle
+     * state.
+     * </p>
+     * <p>
+     * Calling this method when the FmReceiver is in paused state has no affect.
+     * </p>
+     *
+     * @throws IllegalStateException
+     *             if it is called in an invalid state
+     * @throws IOException
+     *             if the FM hardware failed to pause
+     * @throws SecurityException
+     *             if the FM_RADIO_RECEIVER permission is not present
+     */
+    public abstract void pause() throws IOException;
+
+    /**
+     * Resets the FmReceiver to its idle state.
+     *
+     * @throws IOException
+     *             if the FM hardware failed to reset
+     * @throws SecurityException
+     *             if the FM_RADIO_RECEIVER permission is not present
+     */
+    public abstract void reset() throws IOException;
+
+    /**
+     * Returns the state of the FmReceiver.
+     *
+     * @return One of {@link #STATE_IDLE}, {@link #STATE_STARTING},
+     *         {@link #STATE_STARTED}, {@link #STATE_PAUSED},
+     *         {@link #STATE_SCANNING}
+     * @throws SecurityException
+     *             if the FM_RADIO_RECEIVER permission is not present
+     */
+    public abstract int getState();
+
+    /**
+     * Returns true if the hardware/implementation supports RDS data. If true
+     * the {@link OnRDSDataFoundListener} will work. If not it will never report
+     * any data.
+     * <p>
+     * The motivation for having this function is that an application can take
+     * this capability into account when laying out its UI.
+     * </p>
+     *
+     * @return true if RDS data is supported by the FmReceiver, false otherwise
+     *
+     * @throws SecurityException
+     *             if the FM_RADIO_RECEIVER permission is not present
+     */
+    public abstract boolean isRDSDataSupported();
+
+    /**
+     * Checks if the tuned frequency is considered to contain a channel.
+     *
+     * @return true if the FmReceiver is tuned to a valid channel
+     *
+     * @throws SecurityException
+     *             if the FM_RADIO_RECEIVER permission is not present
+     */
+    public abstract boolean isTunedToValidChannel();
+
+    /**
+     * Sets the threshold for the tuner. The threshold can be 0-1000. A low
+     * threshold indicates that the tuner will find stations with a weak signal
+     * and a high threshold will find stations with a strong signal.
+     * <p>
+     * This is used then calling {@link FmReceiver#scanUp()},
+     * {@link FmReceiver#scanDown()} or {@link FmReceiver#startFullScan()}.
+     * </p>
+     *
+     * @param threshold
+     *            a value between 0-1000
+     * @throws IllegalArgumentException
+     *             if the value is not between 0-1000
+     * @throws IllegalStateException
+     *             if it is called in an invalid state
+     * @throws IOException
+     *             if the FM hardware failed to set threshold
+     * @throws SecurityException
+     *             if the FM_RADIO_RECEIVER permission is not present
+     */
+    public abstract void setThreshold(int threshold) throws IOException;
+
+    /**
+     * Returns the threshold for the tuner.
+     *
+     * @return the threshold for the tuner
+     *
+     * @throws IllegalStateException
+     *             if it is called in an invalid state
+     * @throws IOException
+     *             if the FM hardware failed to get the threshold
+     * @throws SecurityException
+     *             if the FM_RADIO_RECEIVER permission is not present
+     */
+    public abstract int getThreshold() throws IOException;
+
+    /**
+     * Returns the tuned frequency.
+     *
+     * @return the tuned frequency in kHz
+     *
+     * @throws IllegalStateException
+     *             if it is called in an invalid state
+     * @throws IOException
+     *             if the FM hardware failed to get the frequency
+     * @throws SecurityException
+     *             if the FM_RADIO_RECEIVER permission is not present
+     */
+    public abstract int getFrequency() throws IOException;
+
+    /**
+     * Returns the signal strength of the tuned frequency. The signal strength
+     * is a value from 0 to 1000. A high value indicates a strong signal and a
+     * low value indicates a weak signal.
+     *
+     * @return the signal strength or {@link #SIGNAL_STRENGTH_UNKNOWN}
+     *
+     * @throws IOException
+     *             if the FM hardware failed to get the signal strength
+     * @throws SecurityException
+     *             if the FM_RADIO_RECEIVER permission is not present
+     */
+    public abstract int getSignalStrength() throws IOException;
+
+    /**
+     * Checks if the tuned frequency is played in stereo. If
+     * {@link #setForceMono(boolean)} is set, this method will always return
+     * false.
+     *
+     * @return true if the tuned frequency is playing in stereo
+     *
+     * @throws SecurityException
+     *             if the FM_RADIO_RECEIVER permission is not present
+     */
+    public abstract boolean isPlayingInStereo();
+
+    /**
+     * Force the playback to always be in mono.
+     *
+     * @param forceMono
+     *            if true, the hardware will only output mono audio. If false,
+     *            stereo is allowed if supported by hardware and signal.
+     * @throws IllegalStateException
+     *             if it is called in an invalid state
+     * @throws SecurityException
+     *             if the FM_RADIO_RECEIVER permission is not present
+     */
+    public abstract void setForceMono(boolean forceMono);
+
+    /**
+     * Sets the automatic switching of the FmReceiver in the case of a stronger
+     * transmitter with the same Programme Identification (PI) presence. The
+     * application should register for callbacks using
+     * {@link #addOnAutomaticSwitchListener(OnAutomaticSwitchListener)}
+     * to receive a callback when channels are found. The reason stated in
+     * the callback will be {@link FmReceiver#SWITCH_AF}.
+     *
+     * @param automatic
+     *            enable or disable automatic switching
+     * @throws IllegalStateException
+     *             if it is called in an invalid state
+     * @throws SecurityException
+     *             if the FM_RADIO_RECEIVER permission is not present
+     */
+    public abstract void setAutomaticAFSwitching(boolean automatic);
+
+    /**
+     * Sets the automatic switching of the program in case of the presence of
+     * traffic announcement in another program. The application should register
+     * for callbacks using {@link #addOnAutomaticSwitchListener(OnAutomaticSwitchListener)}
+     * to receive a callback when channels are found. The reason stated in
+     * the callback will be {@link FmReceiver#SWITCH_TA} when switching to
+     * traffic announcement and {@link FmReceiver#SWITCH_TA_END} when switching
+     * back after the announcement.
+     *
+     * @param automatic
+     *            enable or disable automatic switching
+     * @throws IllegalStateException
+     *             if it is called in an invalid state
+     * @throws SecurityException
+     *             if the FM_RADIO_RECEIVER permission is not present
+     */
+    public abstract void setAutomaticTASwitching(boolean automatic);
+
+    /**
+     * Sets the frequency. Unlike {@link #scanUp()} and {@link #scanDown()},
+     * this method will directly jump to the specified frequency instead of
+     * trying to find a channel while scanning.
+     * <p>
+     * The frequency must be within the band that the FmReceiver prepared for.
+     * </p>
+     *
+     * @param frequency
+     *            the frequency to tune to in kHz
+     * @throws IllegalArgumentException
+     *             if the frequency is not supported
+     * @throws IllegalStateException
+     *             if it is called in an invalid state
+     * @throws IOException
+     *             if the FM hardware failed to set frequency
+     * @throws SecurityException
+     *             if the FM_RADIO_RECEIVER permission is not present
+     * @see FmBand
+     */
+    public abstract void setFrequency(int frequency) throws IOException;
+
+    /**
+     * Starts a full scan. The tuner will scan the entire frequency band for
+     * channels. The application should register for callbacks using
+     * {@link #addOnScanListener(OnScanListener)} to receive a callback when
+     * channels are found.
+     * <p>
+     * If the application wants to stop the full scan, a call to
+     * {@link #stopScan()} should be made.
+     * </p>
+     *
+     * @throws IllegalStateException
+     *             if it is called in an invalid state
+     * @throws SecurityException
+     *             if the FM_RADIO_RECEIVER permission is not present
+     */
+    public abstract void startFullScan();
+
+    /**
+     * Starts seeking for a channel downwards in the frequency band from the
+     * currently tuned frequency. When a channel with enough signal strength is
+     * found the scanning will stop.
+     * <p>
+     * The seek will always stop if it reaches back to the frequency it started
+     * from, meaning that in the worst case scenario, when no channel can be
+     * found, the seek will run through one full cycle of the frequency band
+     * and stop at the frequency it started from.
+     * </p>
+     * The application should register for callbacks using
+     * {@link #addOnScanListener(OnScanListener)} to receive a callback when the
+     * scan is complete.
+     * <p>
+     * If the application wants to stop the scan, a call to {@link #stopScan()}
+     * should be made.
+     * </p>
+     *
+     * @throws IllegalStateException
+     *             if it is called in an invalid state
+     * @throws SecurityException
+     *             if the FM_RADIO_RECEIVER permission is not present
+     * @see FmReceiver#scanUp()
+     */
+    public abstract void scanDown();
+
+    /**
+     * Same as {@link #scanDown()} but seeks upwards in the frequency band.
+     *
+     * @throws IllegalStateException
+     *             if it is called in an invalid state
+     * @throws SecurityException
+     *             if the FM_RADIO_RECEIVER permission is not present
+     * @see FmReceiver#scanDown()
+     */
+    public abstract void scanUp();
+
+    /**
+     * Stops performing a scan operation. The hardware might continue the scan
+     * for an unspecified amount of time after this method is called. Once the
+     * scan has stopped, it will be notified via {@link OnScanListener}.
+     * <p>
+     * Note that this method has no affect if called in other states than the
+     * scanning state.
+     * </p>
+     *
+     * @throws SecurityException
+     *             if the FM_RADIO_RECEIVER permission is not present
+     */
+    public abstract void stopScan();
+
+    /**
+     * This method can be used to send vendor specific commands. These commands
+     * must not follow any common design for all vendors, and information about
+     * the commands that a vendor implements is out of scope in this API.
+     * <p>
+     * However, one command must be supported by all vendors that implements
+     * vendor specific commands, the <i>vendor_information</i> command. In the
+     * Bundle parameter in
+     * {@link OnExtraCommandListener#onExtraCommand(String, Bundle)} the FM
+     * radio device name and version can be extracted according to the table
+     * below.
+     * </p>
+     * <table border="1">
+     * <tr>
+     * <th>key name</th>
+     * <th>value type</th>
+     * </tr>
+     * <tr>
+     * <td>device_name</td>
+     * <td>string</td>
+     * </tr>
+     * <tr>
+     * <td>device_version</td>
+     * <td>string</td>
+     * </tr>
+     * </table>
+     *
+     * @param command
+     *            the command to send
+     * @param extras
+     *            extra parameters to the command
+     * @return true if the command was accepted, otherwise false
+     *
+     * @throws SecurityException
+     *             if the FM_RADIO_RECEIVER permission is not present
+     */
+    public abstract boolean sendExtraCommand(String command, String[] extras);
+
+    /**
+     * Register a callback to be invoked when the FmReceiver is started.
+     *
+     * @param listener
+     *            the callback that will be run
+     * @throws SecurityException
+     *             if the FM_RADIO_RECEIVER permission is not present
+     */
+    public abstract void addOnStartedListener(OnStartedListener listener);
+
+    /**
+     * Unregister a callback to be invoked when the FmReceiver is started.
+     *
+     * @param listener
+     *            the callback to remove
+     * @throws SecurityException
+     *             if the FM_RADIO_RECEIVER permission is not present
+     */
+    public abstract void removeOnStartedListener(OnStartedListener listener);
+
+    /**
+     * Register a callback to be invoked during a scan.
+     *
+     * @param listener
+     *            the callback that will be run
+     * @throws SecurityException
+     *             if the FM_RADIO_RECEIVER permission is not present
+     */
+    public abstract void addOnScanListener(OnScanListener listener);
+
+    /**
+     * Unregister a callback to be invoked during a scan.
+     *
+     * @param listener
+     *            the callback to remove
+     * @throws SecurityException
+     *             if the FM_RADIO_RECEIVER permission is not present
+     */
+    public abstract void removeOnScanListener(OnScanListener listener);
+
+    /**
+     * Register a callback to be invoked when RDS data is found. Having a
+     * listener registered for this might cause continuous callbacks, so it is
+     * considered good practice to set this listener to null whenever the
+     * application is not interested in these updates, e.g. when the application
+     * UI is not visible.
+     *
+     * @param listener
+     *            the callback that will be run
+     * @throws SecurityException
+     *             if the FM_RADIO_RECEIVER permission is not present
+     */
+    public abstract void addOnRDSDataFoundListener(OnRDSDataFoundListener listener);
+
+    /**
+     * Unregister a callback to be invoked when RDS data is found.
+     *
+     * @param listener
+     *            the callback to remove
+     * @throws SecurityException
+     *             if the FM_RADIO_RECEIVER permission is not present
+     */
+    public abstract void removeOnRDSDataFoundListener(OnRDSDataFoundListener listener);
+
+    /**
+     * Register a callback to be invoked when an error has happened during an
+     * asynchronous operation.
+     *
+     * @param listener
+     *            the callback that will be run
+     * @throws SecurityException
+     *             if the FM_RADIO_RECEIVER permission is not present
+     */
+    public abstract void addOnErrorListener(OnErrorListener listener);
+
+    /**
+     * Unregister a callback to be invoked when an error has happened during an
+     * asynchronous operation.
+     *
+     * @param listener
+     *            the callback to remove
+     * @throws SecurityException
+     *             if the FM_RADIO_RECEIVER permission is not present
+     */
+    public abstract void removeOnErrorListener(OnErrorListener listener);
+
+    /**
+     * Register a callback to be invoked when the signal strength of the
+     * currently tuned frequency changes. Having a listener registered to this
+     * method may cause frequent callbacks, hence it is good practice to only
+     * have a listener registered for this when necessary.
+     * <p>
+     * Example: If the application uses this information to visualize the signal
+     * strength on the UI, it should unregister the listener whenever the UI is
+     * not visible.
+     * </p>
+     * <p>
+     * The listener will only receive callbacks when the signal strength
+     * changes.
+     * </p>
+     *
+     * @param listener
+     *            the callback that will be run
+     * @throws SecurityException
+     *             if the FM_RADIO_RECEIVER permission is not present
+     */
+    public abstract void addOnSignalStrengthChangedListener(OnSignalStrengthChangedListener listener);
+
+    /**
+     * Unregister a callback to be invoked when the signal strength of the
+     * currently tuned frequency changes.
+     *
+     * @param listener
+     *            the callback to remove
+     * @throws SecurityException
+     *             if the FM_RADIO_RECEIVER permission is not present
+     */
+    public abstract void removeOnSignalStrengthChangedListener(OnSignalStrengthChangedListener listener);
+
+    /**
+     * Register a callback to be invoked when playback of the tuned frequency
+     * changes between mono and stereo. Having a listener registered to this
+     * method may cause frequent callbacks, hence it is good practice to only
+     * have a listener registered for this when necessary.
+     *
+     * @param listener
+     *            the callback that will be run
+     * @throws SecurityException
+     *             if the FM_RADIO_RECEIVER permission is not present
+     */
+    public abstract void addOnPlayingInStereoListener(OnPlayingInStereoListener listener);
+
+    /**
+     * Unregister a callback to be invoked when playback of the tuned frequency
+     * changes between mono and stereo.
+     *
+     * @param listener
+     *            the callback to remove
+     * @throws SecurityException
+     *             if the FM_RADIO_RECEIVER permission is not present
+     */
+    public abstract void removeOnPlayingInStereoListener(OnPlayingInStereoListener listener);
+
+    /**
+     * Register a callback to be invoked when the FmReceiver is forced to pause
+     * due to external reasons.
+     *
+     * @param listener
+     *            the callback that will be run
+     * @throws SecurityException
+     *             if the FM_RADIO_RECEIVER permission is not present
+     */
+    public abstract void addOnForcedPauseListener(OnForcedPauseListener listener);
+
+    /**
+     * Unregister a callback to be invoked when the FmReceiver is forced to
+     * pause due to external reasons.
+     *
+     * @param listener
+     *            the callback to remove
+     * @throws SecurityException
+     *             if the FM_RADIO_RECEIVER permission is not present
+     */
+    public abstract void removeOnForcedPauseListener(OnForcedPauseListener listener);
+
+    /**
+     * Register a callback to be invoked when the FmReceiver is forced to reset
+     * due to external reasons.
+     *
+     * @param listener
+     *            the callback that will be run
+     * @throws SecurityException
+     *             if the FM_RADIO_RECEIVER permission is not present
+     */
+    public abstract void addOnForcedResetListener(OnForcedResetListener listener);
+
+    /**
+     * Unregister a callback to be invoked when the FmReceiver is forced to
+     * reset due to external reasons.
+     *
+     * @param listener
+     *            the callback to remove
+     * @throws SecurityException
+     *             if the FM_RADIO_RECEIVER permission is not present
+     */
+    public abstract void removeOnForcedResetListener(OnForcedResetListener listener);
+
+    /**
+     * Register a callback to be invoked when the FmReceiver changes state.
+     * Having a listener registered to this method may cause frequent callbacks,
+     * hence it is good practice to only have a listener registered for this
+     * when necessary.
+     *
+     * @param listener
+     *            the callback that will be run
+     * @throws SecurityException
+     *             if the FM_RADIO_RECEIVER permission is not present
+     */
+    public abstract void addOnStateChangedListener(OnStateChangedListener listener);
+
+    /**
+     * Unregister a callback to be invoked when the FmReceiver changes state.
+     *
+     * @param listener
+     *            the callback to remove
+     * @throws SecurityException
+     *             if the FM_RADIO_RECEIVER permission is not present
+     */
+    public abstract void removeOnStateChangedListener(OnStateChangedListener listener);
+
+    /**
+     * Register a callback to be invoked when the FmReceiver want's to invoke a
+     * vendor specific callback.
+     *
+     * @param listener
+     *            the callback that will be run
+     * @throws SecurityException
+     *             if the FM_RADIO_RECEIVER permission is not present
+     */
+    public abstract void addOnExtraCommandListener(OnExtraCommandListener listener);
+
+    /**
+     * Unregister a callback to be invoked when the FmReceiver want's to invoke
+     * a vendor specific callback.
+     *
+     * @param listener
+     *            the callback to remove
+     * @throws SecurityException
+     *             if the FM_RADIO_RECEIVER permission is not present
+     */
+    public abstract void removeOnExtraCommandListener(OnExtraCommandListener listener);
+
+    /**
+     * Register a callback to be invoked when the FmReceiver has triggered
+     * a changed frequency.
+     *
+     * @param listener
+     *            the callback that will be run
+     * @throws SecurityException
+     *             if the FM_RADIO_RECEIVER permission is not present
+     */
+    public abstract void addOnAutomaticSwitchListener(OnAutomaticSwitchListener listener);
+
+    /**
+     * Unregister  a callback to be invoked when the FmReceiver has triggered
+     * a changed frequency.
+     *
+     * @param listener
+     *            the callback to remove
+     * @throws SecurityException
+     *             if the FM_RADIO_RECEIVER permission is not present
+     */
+    public abstract void removeOnAutomaticSwitchListener(OnAutomaticSwitchListener listener);
+
+    /**
+     * Interface definition of a callback to be invoked when the FmReceiver is
+     * started.
+     */
+    public interface OnStartedListener {
+        /**
+         * Called when the FmReceiver is started. The FmReceiver is now
+         * receiving FM radio.
+         */
+        void onStarted();
+    }
+
+    /**
+     * Interface definition of a callback to be invoked when a scan operation is
+     * complete.
+     */
+    public interface OnScanListener {
+        /**
+         * Called when the full scan is completed.
+         * <p>
+         * If the full scan is aborted with stopScan, this will be indicated
+         * with the aborted argument.
+         * <p>
+         * If an error occurs during a full scan, it will be reported via
+         * {@link OnErrorListener#onError()} and this method callback will not
+         * be invoked.
+         * </p>
+         *
+         * @param frequency
+         *            the frequency in kHz where the channel was found
+         * @param signalStrength
+         *            the signal strength, 0-1000
+         * @param aborted
+         *            true if the full scan was aborted, false otherwise
+         */
+        void onFullScan(int[] frequency, int[] signalStrength, boolean aborted);
+
+        /**
+         * Called when {@link FmReceiver#scanDown()} or
+         * {@link FmReceiver#scanUp()} has successfully completed a scan
+         * operation. Note that failing to find a channel during a scan
+         * operation does not mean that it is an error, and it will still result
+         * in a call to this interface.
+         * <p>
+         * If the scan is aborted with stopScan, this will be indicated with the
+         * aborted argument.
+         * <p>
+         *
+         * @param tunedFrequency
+         *            the current frequency in kHz of the tuner after the scan
+         *            operation was completed
+         * @param signalStrength
+         *            the signal strength, 0-1000
+         * @param scanDirection
+         *            direction of scan, SCAN_DOWN or SCAN_UP
+         * @param aborted
+         *            true if the scan was aborted, false otherwise
+         */
+        void onScan(int tunedFrequency, int signalStrength, int scanDirection, boolean aborted);
+    }
+
+    /**
+     * Interface definition of a callback to be invoked when RDS data has been
+     * found. Note that there is not necessarily a relation between the
+     * frequency that the RDS data is found at and the currently tuned
+     * frequency.
+     */
+    public interface OnRDSDataFoundListener {
+        /**
+         * Called when RDS data has been found or updated.
+         *
+         * @param rdsData
+         *            the RDS data that was found
+         * @param frequency
+         *            the frequency where the RDS data was found
+         */
+        void onRDSDataFound(Bundle rdsData, int frequency);
+    };
+
+    /**
+     * Interface definition of a callback to be invoked when there has been an
+     * error during an asynchronous operation.
+     */
+    public interface OnErrorListener {
+        /**
+         * Called to indicate an error.
+         */
+        void onError();
+    }
+
+    /**
+     * Interface definition of a callback to be invoked when the signal strength
+     * of the currently tuned frequency changes.
+     */
+    public interface OnSignalStrengthChangedListener {
+        /**
+         * Called to indicate that the signal strength has changed.
+         *
+         * @param signalStrength
+         *            the signal strength, 0-1000
+         */
+        void onSignalStrengthChanged(int signalStrength);
+    }
+
+    /**
+     * Interface definition of a callback to be invoked when playback of the
+     * tuned frequency changes between mono and stereo. This is useful if the
+     * application wants to display some icon that shows if playing in stereo or
+     * not.
+     */
+    public interface OnPlayingInStereoListener {
+        /**
+         * Called when switching between mono and stereo.
+         *
+         * @param inStereo
+         *            true if playback is in stereo, false if in mono
+         */
+        void onPlayingInStereo(boolean inStereo);
+    }
+
+    /**
+     * Interface definition of a callback to be invoked when the FmReceiver was
+     * forced to pause due to external reasons.
+     */
+    public interface OnForcedPauseListener {
+        /**
+         * Called when an external reason caused the FmReceiver to pause. When
+         * this callback is received, the FmReceiver is still able to resume
+         * reception by calling {@link FmReceiver#resume()}.
+         */
+        void onForcedPause();
+    }
+
+    /**
+     * Interface definition of a callback to be invoked when the FmReceiver was
+     * forced to reset due to external reasons.
+     */
+    public interface OnForcedResetListener {
+        /**
+         * Called when an external reason caused the FmReceiver to reset. The
+         * application that uses the FmReceiver should take action according to
+         * the reason for resetting.
+         *
+         * @param reason
+         *            reason why the FmReceiver reset:
+         *            <ul>
+         *            <li>{@link FmReceiver#RESET_NON_CRITICAL}
+         *            <li>{@link FmReceiver#RESET_CRITICAL}
+         *            <li>{@link FmReceiver#RESET_TX_IN_USE}
+         *            <li>{@link FmReceiver#RESET_RADIO_FORBIDDEN}
+         *            </ul>
+         */
+        void onForcedReset(int reason);
+    }
+
+    /**
+     * Interface definition of a callback to be invoked when the FmReceiver
+     * changes state.
+     */
+    public interface OnStateChangedListener {
+        /**
+         * Called when the state is changed in the FmReceiver. This is useful if
+         * an application want's to monitor the FmReceiver state.
+         *
+         * @param oldState
+         *            the old state of the FmReceiver
+         * @param newState
+         *            the new state of the FmReceiver
+         */
+        void onStateChanged(int oldState, int newState);
+    }
+
+    /**
+     * Interface definition of a callback to be invoked when the FmReceiver
+     * responds to a vendor specific command.
+     */
+    public interface OnExtraCommandListener {
+        /**
+         * Called when the FmReceiver responds to a vendor specific command.
+         *
+         * @param response
+         *            the command the FmReceiver responds to
+         * @param extras
+         *            extra parameters to the command
+         */
+        void onExtraCommand(String response, Bundle extras);
+    }
+
+    /**
+     * Interface definition of a callback to be invoked when the FmReceiver
+     * changes frequency either due to AF switch or TA event.
+     */
+    public interface OnAutomaticSwitchListener {
+        /**
+         * Called when the FmReceiver changes frequency either due to AF
+         * switch or TA event.
+         *
+         * @param newFrequency
+         *            the frequency switched to
+         * @param reason
+         *            the reason for the switch:
+         *            <ul>
+         *            <li>{@link FmReceiver#SWITCH_AF}
+         *            <li>{@link FmReceiver#SWITCH_TA}
+         *            <li>{@link FmReceiver#SWITCH_TA_END}
+         *            </ul>
+         */
+        void onAutomaticSwitch(int newFrequency, int reason);
+    }
+}
diff --git a/fmradio/java/com/stericsson/hardware/fm/FmReceiverImpl.java b/fmradio/java/com/stericsson/hardware/fm/FmReceiverImpl.java
new file mode 100644
index 0000000..da57bc0
--- /dev/null
+++ b/fmradio/java/com/stericsson/hardware/fm/FmReceiverImpl.java
@@ -0,0 +1,1126 @@
+/*
+ * Copyright (C) ST-Ericsson SA 2010
+ * Copyright (C) 2010 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+ * Author: Bjorn Pileryd (bjorn.pileryd@sonyericsson.com)
+ * Author: Markus Grape (markus.grape@stericsson.com) for ST-Ericsson
+ * Author: Andreas Gustafsson (andreas.a.gustafsson@stericsson.com) for ST-Ericsson
+ */
+
+package com.stericsson.hardware.fm;
+
+import android.content.Context;
+import android.os.Bundle;
+import android.os.Handler;
+import android.os.Message;
+import android.os.RemoteException;
+import android.util.Log;
+
+import java.io.IOException;
+import java.util.HashMap;
+
+/**
+ * The implementation of the FmReceiver.
+ *
+ * @hide
+ */
+public class FmReceiverImpl extends FmReceiver {
+
+    private static final String TAG = "FmReceiver";
+
+    private IFmReceiver mService;
+
+    /**
+     * Save the FmBand used to be able to validate frequencies.
+     */
+    private FmBand mBand;
+
+    /**
+     * Map from OnStateChanged to their associated ListenerTransport objects.
+     */
+    private HashMap<OnStateChangedListener, OnStateChangedListenerTransport> mOnStateChanged =
+        new HashMap<OnStateChangedListener, OnStateChangedListenerTransport>();
+
+    /**
+     * Map from OnStarted to their associated ListenerTransport objects.
+     */
+    private HashMap<OnStartedListener, OnStartedListenerTransport> mOnStarted =
+        new HashMap<OnStartedListener, OnStartedListenerTransport>();
+
+    /**
+     * Map from OnError to their associated ListenerTransport objects.
+     */
+    private HashMap<OnErrorListener, OnErrorListenerTransport> mOnError =
+        new HashMap<OnErrorListener, OnErrorListenerTransport>();
+
+    /**
+     * Map from OnScan to their associated ListenerTransport objects.
+     */
+    private HashMap<OnScanListener, OnScanListenerTransport> mOnScan =
+        new HashMap<OnScanListener, OnScanListenerTransport>();
+
+    /**
+     * Map from OnForcedPause to their associated ListenerTransport objects.
+     */
+    private HashMap<OnForcedPauseListener, OnForcedPauseListenerTransport> mOnForcedPause =
+        new HashMap<OnForcedPauseListener, OnForcedPauseListenerTransport>();
+
+    /**
+     * Map from OnForcedReset to their associated ListenerTransport objects.
+     */
+    private HashMap<OnForcedResetListener, OnForcedResetListenerTransport> mOnForcedReset =
+        new HashMap<OnForcedResetListener, OnForcedResetListenerTransport>();
+
+    /**
+     * Map from OnRDSDataFound to their associated ListenerTransport objects.
+     */
+    private HashMap<OnRDSDataFoundListener, OnRDSDataListenerTransport> mOnRDSData =
+        new HashMap<OnRDSDataFoundListener, OnRDSDataListenerTransport>();
+
+    /**
+     * Map from OnSignalStrength to their associated ListenerTransport objects.
+     */
+    private HashMap<OnSignalStrengthChangedListener, OnSignalStrengthListenerTransport> mOnSignalStrength =
+        new HashMap<OnSignalStrengthChangedListener, OnSignalStrengthListenerTransport>();
+
+    /**
+     * Map from OnStereo to their associated ListenerTransport objects.
+     */
+    private HashMap<OnPlayingInStereoListener, OnStereoListenerTransport> mOnStereo =
+        new HashMap<OnPlayingInStereoListener, OnStereoListenerTransport>();
+
+    /**
+     * Map from OnExtraCommand to their associated ListenerTransport objects.
+     */
+    private HashMap<OnExtraCommandListener, OnExtraCommandListenerTransport> mOnExtraCommand =
+        new HashMap<OnExtraCommandListener, OnExtraCommandListenerTransport>();
+
+    /**
+     * Map from OnAutomaticSwitch to their associated ListenerTransport objects.
+     */
+    private HashMap<OnAutomaticSwitchListener, OnAutomaticSwitchListenerTransport> mOnAutomaticSwitch =
+        new HashMap<OnAutomaticSwitchListener, OnAutomaticSwitchListenerTransport>();
+
+    private static class OnStateChangedListenerTransport extends IOnStateChangedListener.Stub {
+        private static final int TYPE_ON_STATE_CHANGED = 1;
+
+        private OnStateChangedListener mListener;
+        private final Handler mListenerHandler;
+
+        OnStateChangedListenerTransport(OnStateChangedListener listener) {
+            mListener = listener;
+
+            mListenerHandler = new Handler() {
+                @Override
+                public void handleMessage(Message msg) {
+                    _handleMessage(msg);
+                }
+            };
+        }
+
+
+        public void onStateChanged(int oldState, int newState) {
+            Message msg = Message.obtain();
+            msg.what = TYPE_ON_STATE_CHANGED;
+            Bundle b = new Bundle();
+            b.putInt("oldState", oldState);
+            b.putInt("newState", newState);
+            msg.obj = b;
+            mListenerHandler.sendMessage(msg);
+        }
+
+        private void _handleMessage(Message msg) {
+            switch (msg.what) {
+            case TYPE_ON_STATE_CHANGED:
+                Bundle b = (Bundle) msg.obj;
+                int oldState = b.getInt("oldState");
+                int newState = b.getInt("newState");
+                mListener.onStateChanged(oldState, newState);
+                break;
+            }
+        }
+    }
+
+    private static class OnStartedListenerTransport extends IOnStartedListener.Stub {
+        private static final int TYPE_ON_STARTED = 1;
+
+        private OnStartedListener mListener;
+        private final Handler mListenerHandler;
+
+        OnStartedListenerTransport(OnStartedListener listener) {
+            mListener = listener;
+
+            mListenerHandler = new Handler() {
+                @Override
+                public void handleMessage(Message msg) {
+                    _handleMessage(msg);
+                }
+            };
+        }
+
+        public void onStarted() {
+            Message msg = Message.obtain();
+            msg.what = TYPE_ON_STARTED;
+            mListenerHandler.sendMessage(msg);
+        }
+
+        private void _handleMessage(Message msg) {
+            switch (msg.what) {
+            case TYPE_ON_STARTED:
+                mListener.onStarted();
+                break;
+            }
+        }
+    }
+
+    private static class OnErrorListenerTransport extends IOnErrorListener.Stub {
+        private static final int TYPE_ON_ERROR = 1;
+
+        private OnErrorListener mListener;
+        private final Handler mListenerHandler;
+
+        OnErrorListenerTransport(OnErrorListener listener) {
+            mListener = listener;
+
+            mListenerHandler = new Handler() {
+                @Override
+                public void handleMessage(Message msg) {
+                    _handleMessage(msg);
+                }
+            };
+        }
+
+        public void onError() {
+            Message msg = Message.obtain();
+            msg.what = TYPE_ON_ERROR;
+            mListenerHandler.sendMessage(msg);
+        }
+
+        private void _handleMessage(Message msg) {
+            switch (msg.what) {
+            case TYPE_ON_ERROR:
+                mListener.onError();
+                break;
+            }
+        }
+    }
+
+    private static class OnScanListenerTransport extends IOnScanListener.Stub {
+        private static final int TYPE_ON_SCAN = 1;
+        private static final int TYPE_ON_FULLSCAN = 2;
+
+        private OnScanListener mListener;
+        private final Handler mListenerHandler;
+
+        OnScanListenerTransport(OnScanListener listener) {
+            mListener = listener;
+
+            mListenerHandler = new Handler() {
+                @Override
+                public void handleMessage(Message msg) {
+                    _handleMessage(msg);
+                }
+            };
+        }
+
+        public void onScan(int tunedFrequency, int signalStrength,
+                           int scanDirection, boolean aborted) {
+            Message msg = Message.obtain();
+            msg.what = TYPE_ON_SCAN;
+            Bundle b = new Bundle();
+            b.putInt("tunedFrequency", tunedFrequency);
+            b.putInt("signalStrength", signalStrength);
+            b.putInt("scanDirection", scanDirection);
+            b.putBoolean("aborted", aborted);
+            msg.obj = b;
+            mListenerHandler.sendMessage(msg);
+        }
+
+        public void onFullScan(int[] frequency, int[] signalStrength, boolean aborted) {
+            Message msg = Message.obtain();
+            msg.what = TYPE_ON_FULLSCAN;
+            Bundle b = new Bundle();
+            b.putIntArray("frequency", frequency);
+            b.putIntArray("signalStrength", signalStrength);
+            b.putBoolean("aborted", aborted);
+            msg.obj = b;
+            mListenerHandler.sendMessage(msg);
+        }
+
+        private void _handleMessage(Message msg) {
+            Bundle b;
+            boolean aborted;
+
+            switch (msg.what) {
+            case TYPE_ON_SCAN:
+                b = (Bundle) msg.obj;
+                int tunedFrequency = b.getInt("tunedFrequency");
+                int signalStrength = b.getInt("signalStrength");
+                int scanDirection = b.getInt("scanDirection");
+                aborted = b.getBoolean("aborted");
+                mListener.onScan(tunedFrequency, signalStrength, scanDirection, aborted);
+                break;
+            case TYPE_ON_FULLSCAN:
+                b = (Bundle) msg.obj;
+                int[] frequency = b.getIntArray("frequency");
+                int[] signalStrengths = b.getIntArray("signalStrength");
+                aborted = b.getBoolean("aborted");
+                mListener.onFullScan(frequency, signalStrengths, aborted);
+                break;
+            }
+        }
+    }
+
+    private static class OnForcedPauseListenerTransport extends IOnForcedPauseListener.Stub {
+        private static final int TYPE_ON_FORCEDPAUSE = 1;
+
+        private OnForcedPauseListener mListener;
+        private final Handler mListenerHandler;
+
+        OnForcedPauseListenerTransport(OnForcedPauseListener listener) {
+            mListener = listener;
+
+            mListenerHandler = new Handler() {
+                @Override
+                public void handleMessage(Message msg) {
+                    _handleMessage(msg);
+                }
+            };
+        }
+
+        public void onForcedPause() {
+            Message msg = Message.obtain();
+            msg.what = TYPE_ON_FORCEDPAUSE;
+            Bundle b = new Bundle();
+            // Need more here? Or remove?
+            msg.obj = b;
+            mListenerHandler.sendMessage(msg);
+        }
+
+        private void _handleMessage(Message msg) {
+            switch (msg.what) {
+            case TYPE_ON_FORCEDPAUSE:
+                Bundle b = (Bundle) msg.obj;
+                mListener.onForcedPause();
+                break;
+            }
+        }
+    }
+
+    private static class OnForcedResetListenerTransport extends IOnForcedResetListener.Stub {
+        private static final int TYPE_ON_FORCEDRESET = 1;
+
+        private OnForcedResetListener mListener;
+        private final Handler mListenerHandler;
+
+        OnForcedResetListenerTransport(OnForcedResetListener listener) {
+            mListener = listener;
+
+            mListenerHandler = new Handler() {
+                @Override
+                public void handleMessage(Message msg) {
+                    _handleMessage(msg);
+                }
+            };
+        }
+
+        public void onForcedReset(int reason) {
+            Message msg = Message.obtain();
+            msg.what = TYPE_ON_FORCEDRESET;
+            Bundle b = new Bundle();
+            b.putInt("reason", reason);
+            msg.obj = b;
+            mListenerHandler.sendMessage(msg);
+        }
+
+        private void _handleMessage(Message msg) {
+            switch (msg.what) {
+            case TYPE_ON_FORCEDRESET:
+                Bundle b = (Bundle) msg.obj;
+                int reason = b.getInt("reason");
+                mListener.onForcedReset(reason);
+                break;
+            }
+        }
+    }
+
+    private static class OnRDSDataListenerTransport extends IOnRDSDataFoundListener.Stub {
+        private static final int TYPE_ON_RDS_DATA = 1;
+
+        private OnRDSDataFoundListener mListener;
+        private final Handler mListenerHandler;
+
+        OnRDSDataListenerTransport(OnRDSDataFoundListener listener) {
+            mListener = listener;
+
+            mListenerHandler = new Handler() {
+                @Override
+                public void handleMessage(Message msg) {
+                    _handleMessage(msg);
+                }
+            };
+        }
+
+        public void onRDSDataFound(Bundle rdsData, int frequency) {
+            Message msg = Message.obtain();
+            msg.what = TYPE_ON_RDS_DATA;
+            Bundle b = new Bundle();
+            if (rdsData != null) {
+                b.putBundle("rdsData", rdsData);
+            }
+            b.putInt("frequency", frequency);
+            msg.obj = b;
+            mListenerHandler.sendMessage(msg);
+        }
+
+        private void _handleMessage(Message msg) {
+            Bundle b;
+
+            switch (msg.what) {
+            case TYPE_ON_RDS_DATA:
+                b = (Bundle) msg.obj;
+                int frequency = b.getInt("frequency");
+                Bundle rdsData = b.getBundle("rdsData");
+                mListener.onRDSDataFound(rdsData, frequency);
+                break;
+            }
+        }
+    }
+
+    private static class OnSignalStrengthListenerTransport extends IOnSignalStrengthListener.Stub {
+        private static final int TYPE_ON_SIGNAL_STRENGTH_CHANGED = 1;
+
+        private OnSignalStrengthChangedListener mListener;
+        private final Handler mListenerHandler;
+
+        OnSignalStrengthListenerTransport(OnSignalStrengthChangedListener listener) {
+            mListener = listener;
+
+            mListenerHandler = new Handler() {
+                @Override
+                public void handleMessage(Message msg) {
+                    _handleMessage(msg);
+                }
+            };
+        }
+
+        public void onSignalStrengthChanged(int signalStrength) {
+            Message msg = Message.obtain();
+            msg.what = TYPE_ON_SIGNAL_STRENGTH_CHANGED;
+            Bundle b = new Bundle();
+            b.putInt("signalStrength", signalStrength);
+            msg.obj = b;
+            mListenerHandler.sendMessage(msg);
+        }
+
+        private void _handleMessage(Message msg) {
+            Bundle b;
+            boolean aborted;
+
+            switch (msg.what) {
+            case TYPE_ON_SIGNAL_STRENGTH_CHANGED:
+                b = (Bundle) msg.obj;
+                int signalStrength = b.getInt("signalStrength");
+                mListener.onSignalStrengthChanged(signalStrength);
+                break;
+            }
+        }
+    }
+
+    private static class OnStereoListenerTransport extends IOnStereoListener.Stub {
+        private static final int TYPE_ON_STEREO = 1;
+
+        private OnPlayingInStereoListener mListener;
+        private final Handler mListenerHandler;
+
+        OnStereoListenerTransport(OnPlayingInStereoListener listener) {
+            mListener = listener;
+
+            mListenerHandler = new Handler() {
+                @Override
+                public void handleMessage(Message msg) {
+                    _handleMessage(msg);
+                }
+            };
+        }
+
+        public void onPlayingInStereo(boolean inStereo) {
+            Message msg = Message.obtain();
+            msg.what = TYPE_ON_STEREO;
+            Bundle b = new Bundle();
+            b.putBoolean("inStereo", inStereo);
+            msg.obj = b;
+            mListenerHandler.sendMessage(msg);
+        }
+
+        private void _handleMessage(Message msg) {
+            Bundle b;
+            boolean aborted;
+
+            switch (msg.what) {
+            case TYPE_ON_STEREO:
+                b = (Bundle) msg.obj;
+                boolean inStereo = b.getBoolean("inStereo");
+                mListener.onPlayingInStereo(inStereo);
+                break;
+            }
+        }
+    }
+
+    private static class OnExtraCommandListenerTransport extends IOnExtraCommandListener.Stub {
+        private static final int TYPE_ON_EXTRA_COMMAND = 1;
+
+        private OnExtraCommandListener mListener;
+        private final Handler mListenerHandler;
+
+        OnExtraCommandListenerTransport(OnExtraCommandListener listener) {
+            mListener = listener;
+
+            mListenerHandler = new Handler() {
+                @Override
+                public void handleMessage(Message msg) {
+                    _handleMessage(msg);
+                }
+            };
+        }
+
+        public void onExtraCommand(String response, Bundle extras) {
+            Message msg = Message.obtain();
+            msg.what = TYPE_ON_EXTRA_COMMAND;
+            Bundle b = new Bundle();
+            b.putString("response", response);
+            b.putBundle("extras", extras);
+            msg.obj = b;
+            mListenerHandler.sendMessage(msg);
+        }
+
+        private void _handleMessage(Message msg) {
+            Bundle b;
+            boolean aborted;
+
+            switch (msg.what) {
+            case TYPE_ON_EXTRA_COMMAND:
+                b = (Bundle) msg.obj;
+                String response = b.getString("response");
+                Bundle extras = b.getBundle("extras");
+                mListener.onExtraCommand(response, extras);
+                break;
+            }
+        }
+    }
+
+    private static class OnAutomaticSwitchListenerTransport extends IOnAutomaticSwitchListener.Stub {
+        private static final int TYPE_ON_AUTOMATIC_SWITCH = 1;
+
+        private OnAutomaticSwitchListener mListener;
+        private final Handler mListenerHandler;
+
+        OnAutomaticSwitchListenerTransport(OnAutomaticSwitchListener listener) {
+            mListener = listener;
+
+            mListenerHandler = new Handler() {
+                @Override
+                public void handleMessage(Message msg) {
+                    _handleMessage(msg);
+                }
+            };
+        }
+
+        public void onAutomaticSwitch(int newFrequency, int reason) {
+            Message msg = Message.obtain();
+            msg.what = TYPE_ON_AUTOMATIC_SWITCH;
+            Bundle b = new Bundle();
+            b.putInt("newFrequency", newFrequency);
+            b.putInt("reason", reason);
+            msg.obj = b;
+            mListenerHandler.sendMessage(msg);
+        }
+
+        private void _handleMessage(Message msg) {
+            Bundle b;
+            boolean aborted;
+
+            switch (msg.what) {
+            case TYPE_ON_AUTOMATIC_SWITCH:
+                b = (Bundle) msg.obj;
+                int newFrequency = b.getInt("newFrequency");
+                int reason = b.getInt("reason");
+                mListener.onAutomaticSwitch(newFrequency, reason);
+                break;
+            }
+        }
+    }
+
+    /**
+     * Creates a new FmReceiver instance. Applications will almost always want
+     * to use {@link android.content.Context#getSystemService
+     * Context.getSystemService()} to retrieve the standard
+     * {@link android.content.Context "fm_receiver"}.
+     *
+     * @param service
+     *            the Binder interface
+     * @hide - hide this because it takes in a parameter of type IFmReceiver,
+     *       which is a system private class.
+     */
+    public FmReceiverImpl(IFmReceiver service) {
+        mService = service;
+    }
+
+    @Override
+    public void startAsync(FmBand band) throws IOException {
+        if (band == null) {
+            throw new IllegalArgumentException("Band cannot be null");
+        }
+        try {
+            mService.startAsync(band);
+            mBand = band;
+        } catch (RemoteException ex) {
+            Log.e(TAG, "startAsync: RemoteException", ex);
+        }
+    }
+
+    @Override
+    public void start(FmBand band) throws IOException {
+        if (band == null) {
+            throw new IllegalArgumentException("Band cannot be null");
+        }
+        try {
+            mService.start(band);
+            mBand = band;
+        } catch (RemoteException ex) {
+            Log.e(TAG, "start: RemoteException", ex);
+        }
+    }
+
+    @Override
+    public void resume() throws IOException {
+        try {
+            mService.resume();
+        } catch (RemoteException ex) {
+            Log.e(TAG, "resume: RemoteException", ex);
+        }
+    }
+
+    @Override
+    public void pause() throws IOException {
+        try {
+            mService.pause();
+        } catch (RemoteException ex) {
+            Log.e(TAG, "pause: RemoteException", ex);
+        }
+    }
+
+    @Override
+    public void reset() throws IOException {
+        try {
+            mService.reset();
+            mBand = null;
+        } catch (RemoteException ex) {
+            Log.e(TAG, "reset: RemoteException", ex);
+        }
+    }
+
+    @Override
+    public int getState() {
+        try {
+            return mService.getState();
+        } catch (RemoteException ex) {
+            Log.e(TAG, "getState: RemoteException", ex);
+            return STATE_IDLE;
+        }
+    }
+
+    @Override
+    public boolean isRDSDataSupported() {
+        try {
+            return mService.isRDSDataSupported();
+        } catch (RemoteException ex) {
+            Log.e(TAG, "isRDSDataSupported: RemoteException", ex);
+            return false;
+        }
+    }
+
+    @Override
+    public boolean isTunedToValidChannel() {
+        try {
+            return mService.isTunedToValidChannel();
+        } catch (RemoteException ex) {
+            Log.e(TAG, "isTunedToValidChannel: RemoteException", ex);
+            return false;
+        }
+    }
+
+    @Override
+    public void setThreshold(int threshold) throws IOException {
+        if (threshold < 0 || threshold > 1000) {
+            throw new IllegalArgumentException("threshold not within limits");
+        }
+        try {
+            mService.setThreshold(threshold);
+        } catch (RemoteException ex) {
+            Log.e(TAG, "setThreshold: RemoteException", ex);
+        }
+    }
+
+    @Override
+    public int getThreshold() throws IOException {
+        try {
+            return mService.getThreshold();
+        } catch (RemoteException ex) {
+            Log.e(TAG, "getThreshold: RemoteException", ex);
+            return 0;
+        }
+    }
+
+    @Override
+    public int getFrequency() throws IOException {
+        try {
+            return mService.getFrequency();
+        } catch (RemoteException ex) {
+            Log.e(TAG, "getFrequency: RemoteException", ex);
+            return FmBand.FM_FREQUENCY_UNKNOWN;
+        }
+    }
+
+    @Override
+    public int getSignalStrength() throws IOException {
+        try {
+            return mService.getSignalStrength();
+        } catch (RemoteException ex) {
+            Log.e(TAG, "getSignalStrength: RemoteException", ex);
+            return SIGNAL_STRENGTH_UNKNOWN;
+        }
+    }
+
+    @Override
+    public boolean isPlayingInStereo() {
+        try {
+            return mService.isPlayingInStereo();
+        } catch (RemoteException ex) {
+            Log.e(TAG, "isPlayingInStereo: RemoteException", ex);
+            return false;
+        }
+    }
+
+    @Override
+    public void setForceMono(boolean forceMono) {
+        try {
+            mService.setForceMono(forceMono);
+        } catch (RemoteException ex) {
+            Log.e(TAG, "setForceMono: RemoteException", ex);
+        }
+    }
+
+    @Override
+    public void setAutomaticAFSwitching(boolean automatic) {
+        try {
+            mService.setAutomaticAFSwitching(automatic);
+        } catch (RemoteException ex) {
+            Log.e(TAG, "setAutomaticAFSwitching: RemoteException", ex);
+        }
+    }
+
+    @Override
+    public void setAutomaticTASwitching(boolean automatic) {
+        try {
+            mService.setAutomaticTASwitching(automatic);
+        } catch (RemoteException ex) {
+            Log.e(TAG, "setAutomaticTASwitching: RemoteException", ex);
+        }
+    }
+
+    @Override
+    public void setFrequency(int frequency) throws IOException {
+        if (mBand != null && !mBand.isFrequencyValid(frequency)) {
+            throw new IllegalArgumentException("Frequency is not valid in this band.");
+        }
+
+        try {
+            mService.setFrequency(frequency);
+        } catch (RemoteException ex) {
+            Log.e(TAG, "setFrequency: RemoteException", ex);
+        }
+    }
+
+    @Override
+    public void startFullScan() {
+        try {
+            mService.startFullScan();
+        } catch (RemoteException ex) {
+            Log.e(TAG, "startFullScan: RemoteException", ex);
+        }
+    }
+
+    @Override
+    public void scanDown() {
+        try {
+            mService.scanDown();
+        } catch (RemoteException ex) {
+            Log.e(TAG, "scanDown: RemoteException", ex);
+        }
+    }
+
+    @Override
+    public void scanUp() {
+        try {
+            mService.scanUp();
+        } catch (RemoteException ex) {
+            Log.e(TAG, "scanUp: RemoteException", ex);
+        }
+    }
+
+    @Override
+    public void stopScan() {
+        try {
+            mService.stopScan();
+        } catch (RemoteException ex) {
+            Log.e(TAG, "stopScan: RemoteException", ex);
+        }
+    }
+
+    @Override
+    public boolean sendExtraCommand(String command, String[] extras) {
+        try {
+            return mService.sendExtraCommand(command, extras);
+        } catch (RemoteException ex) {
+            Log.e(TAG, "sendExtraCommand: RemoteException", ex);
+            return false;
+        }
+    }
+
+    @Override
+    public void addOnStartedListener(OnStartedListener listener) {
+        if (mOnStarted.get(listener) != null) {
+            // listener is already registered
+            return;
+        }
+        try {
+            synchronized (mOnStarted) {
+                OnStartedListenerTransport transport = new OnStartedListenerTransport(listener);
+                mService.addOnStartedListener(transport);
+                mOnStarted.put(listener, transport);
+            }
+        } catch (RemoteException ex) {
+            Log.e(TAG, "addOnStartedListener: RemoteException", ex);
+        }
+    }
+
+    @Override
+    public void removeOnStartedListener(OnStartedListener listener) {
+        try {
+            OnStartedListenerTransport transport = mOnStarted.remove(listener);
+            if (transport != null) {
+                mService.removeOnStartedListener(transport);
+            }
+        } catch (RemoteException ex) {
+            Log.e(TAG, "removeOnStartedListener: DeadObjectException", ex);
+        }
+    }
+
+    @Override
+    public void addOnScanListener(OnScanListener listener) {
+        if (mOnScan.get(listener) != null) {
+            // listener is already registered
+            return;
+        }
+        try {
+            synchronized (mOnScan) {
+                OnScanListenerTransport transport = new OnScanListenerTransport(listener);
+                mService.addOnScanListener(transport);
+                mOnScan.put(listener, transport);
+            }
+        } catch (RemoteException ex) {
+            Log.e(TAG, "addOnScanListener: RemoteException", ex);
+        }
+    }
+
+    @Override
+    public void removeOnScanListener(OnScanListener listener) {
+        try {
+            OnScanListenerTransport transport = mOnScan.remove(listener);
+            if (transport != null) {
+                mService.removeOnScanListener(transport);
+            }
+        } catch (RemoteException ex) {
+            Log.e(TAG, "removeOnScanListener: DeadObjectException", ex);
+        }
+    }
+
+    @Override
+    public void addOnRDSDataFoundListener(OnRDSDataFoundListener listener) {
+        if (mOnRDSData.get(listener) != null) {
+            // listener is already registered
+            return;
+        }
+        try {
+            synchronized (mOnRDSData) {
+                OnRDSDataListenerTransport transport = new OnRDSDataListenerTransport(listener);
+                mService.addOnRDSDataFoundListener(transport);
+                mOnRDSData.put(listener, transport);
+            }
+        } catch (RemoteException ex) {
+            Log.e(TAG, "addOnRDSDataFoundListener: RemoteException", ex);
+        }
+    }
+
+    @Override
+    public void removeOnRDSDataFoundListener(OnRDSDataFoundListener listener) {
+        try {
+            OnRDSDataListenerTransport transport = mOnRDSData.remove(listener);
+            if (transport != null) {
+                mService.removeOnRDSDataFoundListener(transport);
+            }
+        } catch (RemoteException ex) {
+            Log.e(TAG, "removeOnRDSDataFoundListener: DeadObjectException", ex);
+        }
+    }
+
+    @Override
+    public void addOnErrorListener(OnErrorListener listener) {
+        if (mOnError.get(listener) != null) {
+            // listener is already registered
+            return;
+        }
+        try {
+            synchronized (mOnError) {
+                OnErrorListenerTransport transport = new OnErrorListenerTransport(listener);
+                mService.addOnErrorListener(transport);
+                mOnError.put(listener, transport);
+            }
+        } catch (RemoteException ex) {
+            Log.e(TAG, "addOnErrorListener: RemoteException", ex);
+        }
+    }
+
+    @Override
+    public void removeOnErrorListener(OnErrorListener listener) {
+        try {
+            OnErrorListenerTransport transport = mOnError.remove(listener);
+            if (transport != null) {
+                mService.removeOnErrorListener(transport);
+            }
+        } catch (RemoteException ex) {
+            Log.e(TAG, "removeOnErrorListener: DeadObjectException", ex);
+        }
+    }
+
+    @Override
+    public void addOnSignalStrengthChangedListener(OnSignalStrengthChangedListener listener) {
+        if (mOnSignalStrength.get(listener) != null) {
+            // listener is already registered
+            return;
+        }
+        try {
+            synchronized (mOnSignalStrength) {
+                OnSignalStrengthListenerTransport transport = new OnSignalStrengthListenerTransport(
+                        listener);
+                mService.addOnSignalStrengthChangedListener(transport);
+                mOnSignalStrength.put(listener, transport);
+            }
+        } catch (RemoteException ex) {
+            Log.e(TAG, "addOnSignalStrengthChangedListener: RemoteException", ex);
+        }
+    }
+
+    @Override
+    public void removeOnSignalStrengthChangedListener(OnSignalStrengthChangedListener listener) {
+        try {
+            OnSignalStrengthListenerTransport transport = mOnSignalStrength.remove(listener);
+            if (transport != null) {
+                mService.removeOnSignalStrengthChangedListener(transport);
+            }
+        } catch (RemoteException ex) {
+            Log.e(TAG, "removeOnSignalStrengthChangedListener: DeadObjectException", ex);
+        }
+    }
+
+    @Override
+    public void addOnPlayingInStereoListener(OnPlayingInStereoListener listener) {
+        if (mOnStereo.get(listener) != null) {
+            // listener is already registered
+            return;
+        }
+        try {
+            synchronized (mOnStereo) {
+                OnStereoListenerTransport transport = new OnStereoListenerTransport(listener);
+                mService.addOnPlayingInStereoListener(transport);
+                mOnStereo.put(listener, transport);
+            }
+        } catch (RemoteException ex) {
+            Log.e(TAG, "addOnPlayingInStereoListener: RemoteException", ex);
+        }
+    }
+
+    @Override
+    public void removeOnPlayingInStereoListener(OnPlayingInStereoListener listener) {
+        try {
+            OnStereoListenerTransport transport = mOnStereo.remove(listener);
+            if (transport != null) {
+                mService.removeOnPlayingInStereoListener(transport);
+            }
+        } catch (RemoteException ex) {
+            Log.e(TAG, "removeOnPlayingInStereoListener: DeadObjectException", ex);
+        }
+    }
+
+    @Override
+    public void addOnForcedPauseListener(OnForcedPauseListener listener) {
+        if (mOnForcedPause.get(listener) != null) {
+            // listener is already registered
+            return;
+        }
+        try {
+            synchronized (mOnForcedPause) {
+                OnForcedPauseListenerTransport transport = new OnForcedPauseListenerTransport(
+                        listener);
+                mService.addOnForcedPauseListener(transport);
+                mOnForcedPause.put(listener, transport);
+            }
+        } catch (RemoteException ex) {
+            Log.e(TAG, "addOnForcedPauseListener: RemoteException", ex);
+        }
+    }
+
+    @Override
+    public void removeOnForcedPauseListener(OnForcedPauseListener listener) {
+        try {
+            OnForcedPauseListenerTransport transport = mOnForcedPause.remove(listener);
+            if (transport != null) {
+                mService.removeOnForcedPauseListener(transport);
+            }
+        } catch (RemoteException ex) {
+            Log.e(TAG, "removeOnForcedPauseListener: DeadObjectException", ex);
+        }
+    }
+
+    @Override
+    public void addOnForcedResetListener(OnForcedResetListener listener) {
+        if (mOnForcedReset.get(listener) != null) {
+            // listener is already registered
+            return;
+        }
+        try {
+            synchronized (mOnForcedReset) {
+                OnForcedResetListenerTransport transport = new OnForcedResetListenerTransport(
+                        listener);
+                mService.addOnForcedResetListener(transport);
+                mOnForcedReset.put(listener, transport);
+            }
+        } catch (RemoteException ex) {
+            Log.e(TAG, "addOnForcedResetListener: RemoteException", ex);
+        }
+    }
+
+    @Override
+    public void removeOnForcedResetListener(OnForcedResetListener listener) {
+        try {
+            OnForcedResetListenerTransport transport = mOnForcedReset.remove(listener);
+            if (transport != null) {
+                mService.removeOnForcedResetListener(transport);
+            }
+        } catch (RemoteException ex) {
+            Log.e(TAG, "removeOnForcedResetListener: DeadObjectException", ex);
+        }
+    }
+
+    @Override
+    public void addOnStateChangedListener(OnStateChangedListener listener) {
+        if (mOnStateChanged.get(listener) != null) {
+            // listener is already registered
+            return;
+        }
+        try {
+            synchronized (mOnStateChanged) {
+                OnStateChangedListenerTransport transport = new OnStateChangedListenerTransport(
+                        listener);
+                mService.addOnStateChangedListener(transport);
+                mOnStateChanged.put(listener, transport);
+            }
+        } catch (RemoteException ex) {
+            Log.e(TAG, "addOnStateChangedListener: RemoteException", ex);
+        }
+    }
+
+    @Override
+    public void removeOnStateChangedListener(OnStateChangedListener listener) {
+        try {
+            OnStateChangedListenerTransport transport = mOnStateChanged.remove(listener);
+            if (transport != null) {
+                mService.removeOnStateChangedListener(transport);
+            }
+        } catch (RemoteException ex) {
+            Log.e(TAG, "removeOnStateChangedListener: DeadObjectException", ex);
+        }
+    }
+
+    @Override
+    public void addOnExtraCommandListener(OnExtraCommandListener listener) {
+        if (mOnExtraCommand.get(listener) != null) {
+            // listener is already registered
+            return;
+        }
+        try {
+            synchronized (mOnExtraCommand) {
+                OnExtraCommandListenerTransport transport = new OnExtraCommandListenerTransport(
+                        listener);
+                mService.addOnExtraCommandListener(transport);
+                mOnExtraCommand.put(listener, transport);
+            }
+        } catch (RemoteException ex) {
+            Log.e(TAG, "addOnExtraCommandListener: RemoteException", ex);
+        }
+    }
+
+    @Override
+    public void removeOnExtraCommandListener(OnExtraCommandListener listener) {
+        try {
+            OnExtraCommandListenerTransport transport = mOnExtraCommand.remove(listener);
+            if (transport != null) {
+                mService.removeOnExtraCommandListener(transport);
+            }
+        } catch (RemoteException ex) {
+            Log.e(TAG, "removeOnExtraCommandListener: DeadObjectException", ex);
+        }
+    }
+
+    @Override
+    public void addOnAutomaticSwitchListener(OnAutomaticSwitchListener listener) {
+        if (mOnAutomaticSwitch.get(listener) != null) {
+            // listener is already registered
+            return;
+        }
+        try {
+            synchronized (mOnAutomaticSwitch) {
+                OnAutomaticSwitchListenerTransport transport = new OnAutomaticSwitchListenerTransport(listener);
+                mService.addOnAutomaticSwitchListener(transport);
+                mOnAutomaticSwitch.put(listener, transport);
+            }
+        } catch (RemoteException ex) {
+            Log.e(TAG, "addOnAutomaticSwitchListener: RemoteException", ex);
+        }
+    }
+
+    @Override
+    public void removeOnAutomaticSwitchListener(OnAutomaticSwitchListener listener) {
+        try {
+            OnAutomaticSwitchListenerTransport transport = mOnAutomaticSwitch.remove(listener);
+            if (transport != null) {
+                mService.removeOnAutomaticSwitchListener(transport);
+            }
+        } catch (RemoteException ex) {
+            Log.e(TAG, "removeOnAutomaticSwitchListener: DeadObjectException", ex);
+        }
+    }
+}
diff --git a/fmradio/java/com/stericsson/hardware/fm/FmReceiverService.java b/fmradio/java/com/stericsson/hardware/fm/FmReceiverService.java
new file mode 100644
index 0000000..2299c14
--- /dev/null
+++ b/fmradio/java/com/stericsson/hardware/fm/FmReceiverService.java
@@ -0,0 +1,1346 @@
+/*
+ * Copyright (C) ST-Ericsson SA 2010
+ * Copyright (C) 2010 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+ * Author: Markus Grape (markus.grape@stericsson.com) for ST-Ericsson
+ */
+
+package com.stericsson.hardware.fm;
+
+import android.content.BroadcastReceiver;
+import android.content.Context;
+import android.content.Intent;
+import android.content.IntentFilter;
+import android.content.pm.PackageManager;
+import android.os.Bundle;
+import android.os.IBinder;
+import android.os.Process;
+import android.os.RemoteException;
+import android.provider.Settings;
+import android.util.Log;
+import android.util.Slog;
+
+import java.util.Collection;
+import java.util.HashMap;
+import java.util.Iterator;
+
+/**
+ * The implementation of the FM receiver service.
+ *
+ * @hide
+ */
+public class FmReceiverService extends IFmReceiver.Stub {
+
+    private static final String TAG = "FmReceiverService";
+
+    private Context mContext;
+
+    private final HashMap<Object, OnStateChangedReceiver> mOnStateChangedReceivers =
+        new HashMap<Object, OnStateChangedReceiver>();
+
+    private final HashMap<Object, OnStartedReceiver> mOnStartedReceivers =
+        new HashMap<Object, OnStartedReceiver>();
+
+    private final HashMap<Object, OnErrorReceiver> mOnErrorReceivers =
+        new HashMap<Object, OnErrorReceiver>();
+
+    private final HashMap<Object, OnScanReceiver> mOnScanReceivers =
+        new HashMap<Object, OnScanReceiver>();
+
+    private final HashMap<Object, OnForcedPauseReceiver> mOnForcedPauseReceivers =
+        new HashMap<Object, OnForcedPauseReceiver>();
+
+    private final HashMap<Object, OnForcedResetReceiver> mOnForcedResetReceivers =
+        new HashMap<Object, OnForcedResetReceiver>();
+
+    private final HashMap<Object, OnRDSDataReceiver> mOnRDSDataReceivers =
+        new HashMap<Object, OnRDSDataReceiver>();
+
+    private final HashMap<Object, OnSignalStrengthReceiver> mOnSignalStrengthReceivers =
+        new HashMap<Object, OnSignalStrengthReceiver>();
+
+    private final HashMap<Object, OnStereoReceiver> mOnStereoReceivers =
+        new HashMap<Object, OnStereoReceiver>();
+
+    private final HashMap<Object, OnExtraCommandReceiver> mOnExtraCommandReceivers =
+        new HashMap<Object, OnExtraCommandReceiver>();
+
+    private final HashMap<Object, OnAutomaticSwitchReceiver> mOnAutomaticSwitchReceivers =
+        new HashMap<Object, OnAutomaticSwitchReceiver>();
+
+    private final class OnStateChangedReceiver implements IBinder.DeathRecipient {
+        final IOnStateChangedListener mListener;
+
+        final Object mKey;
+
+        OnStateChangedReceiver(IOnStateChangedListener listener) {
+            mListener = listener;
+            mKey = listener.asBinder();
+        }
+
+        public IOnStateChangedListener getListener() {
+            return mListener;
+        }
+
+        public boolean callOnStateChanged(int oldState, int newState) {
+            try {
+                synchronized (this) {
+                    mListener.onStateChanged(oldState, newState);
+                }
+            } catch (RemoteException ex) {
+                Log.e(TAG, "callOnStateChanged: RemoteException", ex);
+                return false;
+            }
+            return true;
+        }
+
+        public void binderDied() {
+            Log.d(TAG, "FM receiver listener died");
+
+            synchronized (mOnStateChangedReceivers) {
+                mOnStateChangedReceivers.remove(this.mKey);
+            }
+            if (mListener != null) {
+                mListener.asBinder().unlinkToDeath(this, 0);
+            }
+        }
+    }
+
+    private final class OnStartedReceiver implements IBinder.DeathRecipient {
+        final IOnStartedListener mListener;
+
+        final Object mKey;
+
+        OnStartedReceiver(IOnStartedListener listener) {
+            mListener = listener;
+            mKey = listener.asBinder();
+        }
+
+        public IOnStartedListener getListener() {
+            return mListener;
+        }
+
+        public boolean callOnStarted() {
+            try {
+                synchronized (this) {
+                    mListener.onStarted();
+                }
+            } catch (RemoteException ex) {
+                Log.e(TAG, "callOnStarted: RemoteException", ex);
+                return false;
+            }
+            return true;
+        }
+
+        public void binderDied() {
+            Log.d(TAG, "FM receiver listener died");
+
+            synchronized (mOnStartedReceivers) {
+                mOnStartedReceivers.remove(this.mKey);
+            }
+            if (mListener != null) {
+                mListener.asBinder().unlinkToDeath(this, 0);
+            }
+        }
+    }
+
+    private final class OnErrorReceiver implements IBinder.DeathRecipient {
+        final IOnErrorListener mListener;
+
+        final Object mKey;
+
+        OnErrorReceiver(IOnErrorListener listener) {
+            mListener = listener;
+            mKey = listener.asBinder();
+        }
+
+        public IOnErrorListener getListener() {
+            return mListener;
+        }
+
+        public boolean callOnError() {
+            try {
+                synchronized (this) {
+                    mListener.onError();
+                }
+            } catch (RemoteException ex) {
+                Log.e(TAG, "callOnError: RemoteException", ex);
+                return false;
+            }
+            return true;
+        }
+
+        public void binderDied() {
+            Log.d(TAG, "FM receiver listener died");
+
+            synchronized (mOnErrorReceivers) {
+                mOnErrorReceivers.remove(this.mKey);
+            }
+            if (mListener != null) {
+                mListener.asBinder().unlinkToDeath(this, 0);
+            }
+        }
+    }
+
+    private final class OnScanReceiver implements IBinder.DeathRecipient {
+        final IOnScanListener mListener;
+
+        final Object mKey;
+
+        OnScanReceiver(IOnScanListener listener) {
+            mListener = listener;
+            mKey = listener.asBinder();
+        }
+
+        public IOnScanListener getListener() {
+            return mListener;
+        }
+
+        public boolean callOnScan(int tunedFrequency, int signalLevel, int scanDirection, boolean aborted) {
+            try {
+                synchronized (this) {
+                    mListener.onScan(tunedFrequency, signalLevel, scanDirection, aborted);
+                }
+            } catch (RemoteException ex) {
+                Log.e(TAG, "callOnScan: RemoteException", ex);
+                return false;
+            }
+            return true;
+        }
+
+        public boolean callOnFullScan(int[] frequency, int[] signalLevel, boolean aborted) {
+            try {
+                synchronized (this) {
+                    mListener.onFullScan(frequency, signalLevel, aborted);
+                }
+            } catch (RemoteException ex) {
+                Log.e(TAG, "callOnFullScan: RemoteException", ex);
+                return false;
+            }
+            return true;
+        }
+
+        public void binderDied() {
+            Log.d(TAG, "FM receiver listener died");
+
+            synchronized (mOnScanReceivers) {
+                mOnScanReceivers.remove(this.mKey);
+            }
+            if (mListener != null) {
+                mListener.asBinder().unlinkToDeath(this, 0);
+            }
+        }
+    }
+
+    private final class OnForcedPauseReceiver implements IBinder.DeathRecipient {
+        final IOnForcedPauseListener mListener;
+
+        final Object mKey;
+
+        OnForcedPauseReceiver(IOnForcedPauseListener listener) {
+            mListener = listener;
+            mKey = listener.asBinder();
+        }
+
+        public IOnForcedPauseListener getListener() {
+            return mListener;
+        }
+
+        public boolean callOnForcedPause() {
+            try {
+                synchronized (this) {
+                    mListener.onForcedPause();
+                }
+            } catch (RemoteException ex) {
+                Log.e(TAG, "callOnForcedPause: RemoteException", ex);
+                return false;
+            }
+            return true;
+        }
+
+        public void binderDied() {
+            Log.d(TAG, "FM receiver listener died");
+
+            synchronized (mOnForcedPauseReceivers) {
+                mOnForcedPauseReceivers.remove(this.mKey);
+            }
+            if (mListener != null) {
+                mListener.asBinder().unlinkToDeath(this, 0);
+            }
+        }
+    }
+
+    private final class OnForcedResetReceiver implements IBinder.DeathRecipient {
+        final IOnForcedResetListener mListener;
+
+        final Object mKey;
+
+        OnForcedResetReceiver(IOnForcedResetListener listener) {
+            mListener = listener;
+            mKey = listener.asBinder();
+        }
+
+        public IOnForcedResetListener getListener() {
+            return mListener;
+        }
+
+        public boolean callOnForcedReset(int reason) {
+            try {
+                synchronized (this) {
+                    mListener.onForcedReset(reason);
+                }
+            } catch (RemoteException ex) {
+                Log.e(TAG, "callOnForcedReset: RemoteException", ex);
+                return false;
+            }
+            return true;
+        }
+
+        public void binderDied() {
+            Log.d(TAG, "FM receiver listener died");
+
+            synchronized (mOnForcedResetReceivers) {
+                mOnForcedResetReceivers.remove(this.mKey);
+            }
+            if (mListener != null) {
+                mListener.asBinder().unlinkToDeath(this, 0);
+            }
+        }
+    }
+
+    private final class OnRDSDataReceiver implements IBinder.DeathRecipient {
+        final IOnRDSDataFoundListener mListener;
+
+        final Object mKey;
+
+        OnRDSDataReceiver(IOnRDSDataFoundListener listener) {
+            mListener = listener;
+            mKey = listener.asBinder();
+        }
+
+        public IOnRDSDataFoundListener getListener() {
+            return mListener;
+        }
+
+        public boolean callOnRDSDataFound(Bundle bundle, int frequency) {
+            try {
+                synchronized (this) {
+                    mListener.onRDSDataFound(bundle, frequency);
+                }
+            } catch (RemoteException ex) {
+                Log.e(TAG, "callOnRDSDataFound: RemoteException", ex);
+                return false;
+            }
+            return true;
+        }
+
+        public void binderDied() {
+            Log.d(TAG, "FM receiver listener died");
+
+            synchronized (mOnRDSDataReceivers) {
+                mOnRDSDataReceivers.remove(this.mKey);
+            }
+            if (mListener != null) {
+                mListener.asBinder().unlinkToDeath(this, 0);
+            }
+        }
+    }
+
+    private final class OnSignalStrengthReceiver implements IBinder.DeathRecipient {
+        final IOnSignalStrengthListener mListener;
+
+        final Object mKey;
+
+        OnSignalStrengthReceiver(IOnSignalStrengthListener listener) {
+            mListener = listener;
+            mKey = listener.asBinder();
+        }
+
+        public IOnSignalStrengthListener getListener() {
+            return mListener;
+        }
+
+        public boolean callOnSignalStrengthChanged(int signalStrength) {
+            try {
+                synchronized (this) {
+                    mListener.onSignalStrengthChanged(signalStrength);
+                }
+            } catch (RemoteException ex) {
+                Log.e(TAG, "callOnSignalStrengthChanged: RemoteException", ex);
+                return false;
+            }
+            return true;
+        }
+
+        public void binderDied() {
+            Log.d(TAG, "FM receiver listener died");
+
+            synchronized (mOnSignalStrengthReceivers) {
+                mOnSignalStrengthReceivers.remove(this.mKey);
+            }
+            if (mListener != null) {
+                mListener.asBinder().unlinkToDeath(this, 0);
+            }
+        }
+    }
+
+    private final class OnStereoReceiver implements IBinder.DeathRecipient {
+        final IOnStereoListener mListener;
+
+        final Object mKey;
+
+        OnStereoReceiver(IOnStereoListener listener) {
+            mListener = listener;
+            mKey = listener.asBinder();
+        }
+
+        public IOnStereoListener getListener() {
+            return mListener;
+        }
+
+        public boolean callOnPlayingInStereo(boolean inStereo) {
+            try {
+                synchronized (this) {
+                    mListener.onPlayingInStereo(inStereo);
+                }
+            } catch (RemoteException ex) {
+                Log.e(TAG, "callOnPlayingInStereo: RemoteException", ex);
+                return false;
+            }
+            return true;
+        }
+
+        public void binderDied() {
+            Log.d(TAG, "FM receiver listener died");
+
+            synchronized (mOnStereoReceivers) {
+                mOnStereoReceivers.remove(this.mKey);
+            }
+            if (mListener != null) {
+                mListener.asBinder().unlinkToDeath(this, 0);
+            }
+        }
+    }
+
+    private final class OnExtraCommandReceiver implements IBinder.DeathRecipient {
+        final IOnExtraCommandListener mListener;
+
+        final Object mKey;
+
+        OnExtraCommandReceiver(IOnExtraCommandListener listener) {
+            mListener = listener;
+            mKey = listener.asBinder();
+        }
+
+        public IOnExtraCommandListener getListener() {
+            return mListener;
+        }
+
+        public boolean callOnExtraCommand(String response, Bundle extras) {
+            try {
+                synchronized (this) {
+                    mListener.onExtraCommand(response, extras);
+                }
+            } catch (RemoteException ex) {
+                Log.e(TAG, "callOnExtraCommand: RemoteException", ex);
+                return false;
+            }
+            return true;
+        }
+
+        public void binderDied() {
+            Log.d(TAG, "FM receiver listener died");
+
+            synchronized (mOnExtraCommandReceivers) {
+                mOnExtraCommandReceivers.remove(this.mKey);
+            }
+            if (mListener != null) {
+                mListener.asBinder().unlinkToDeath(this, 0);
+            }
+        }
+    }
+
+    private final class OnAutomaticSwitchReceiver implements IBinder.DeathRecipient {
+        final IOnAutomaticSwitchListener mListener;
+
+        final Object mKey;
+
+        OnAutomaticSwitchReceiver(IOnAutomaticSwitchListener listener) {
+            mListener = listener;
+            mKey = listener.asBinder();
+        }
+
+        public IOnAutomaticSwitchListener getListener() {
+            return mListener;
+        }
+
+        public boolean callOnAutomaticSwitch(int newFrequency, int reason) {
+            try {
+                synchronized (this) {
+                    mListener.onAutomaticSwitch(newFrequency, reason);
+                }
+            } catch (RemoteException ex) {
+                Log.e(TAG, "callOnAutomaticSwitch: RemoteException", ex);
+                return false;
+            }
+            return true;
+        }
+
+        public void binderDied() {
+            Log.d(TAG, "FM receiver listener died");
+
+            synchronized (mOnAutomaticSwitchReceivers) {
+                mOnAutomaticSwitchReceivers.remove(this.mKey);
+            }
+            if (mListener != null) {
+                mListener.asBinder().unlinkToDeath(this, 0);
+            }
+        }
+    }
+
+    private final BroadcastReceiver mReceiver = new BroadcastReceiver() {
+
+        @Override
+        public void onReceive(Context context, Intent intent) {
+            if (intent == null) {
+                return;
+            }
+
+            String action = intent.getAction();
+            if (action.equals(Intent.ACTION_AIRPLANE_MODE_CHANGED)) {
+                Log.d(TAG, "onReceive:ACTION_AIRPLANE_MODE_CHANGED");
+
+                // check that airplane mode is off
+                if (!isAirplaneModeOn()) {
+                    return;
+                }
+
+                // power down hardware
+                if (_fm_receiver_reset() > FmReceiver.STATE_IDLE) {
+                    notifyOnForcedReset(FmReceiver.RESET_RADIO_FORBIDDEN);
+                }
+            }
+        }
+
+    };
+
+    /* Returns true if airplane mode is currently on */
+    private boolean isAirplaneModeOn() {
+        return Settings.System.getInt(mContext.getContentResolver(),
+                Settings.System.AIRPLANE_MODE_ON, 0) == 1;
+    }
+
+    public FmReceiverService(Context context) {
+        Log.i(TAG, "FmReceiverService created");
+        mContext = context;
+
+        // Register for airplane mode
+        IntentFilter filter = new IntentFilter();
+        filter.addAction(Intent.ACTION_AIRPLANE_MODE_CHANGED);
+        filter.addAction(Intent.ACTION_DOCK_EVENT);
+
+        mContext.registerReceiver(mReceiver, filter);
+
+    }
+
+    public void start(FmBand band) {
+        if (mContext.checkCallingOrSelfPermission(android.Manifest.permission.FM_RADIO_RECEIVER)
+                != PackageManager.PERMISSION_GRANTED) {
+            throw new SecurityException("Requires FM_RADIO_RECEIVER permission");
+        }
+
+        _fm_receiver_start(band.getMinFrequency(), band.getMaxFrequency(), band
+                .getDefaultFrequency(), band.getChannelOffset());
+
+        if (mOnRDSDataReceivers.size() > 0) {
+            Log.d(TAG, "Started with RDS receiver(s), switching on RDS");
+            _fm_receiver_setRDS(true);
+        }
+    }
+
+    public void startAsync(FmBand band) {
+        if (mContext.checkCallingOrSelfPermission(android.Manifest.permission.FM_RADIO_RECEIVER)
+                != PackageManager.PERMISSION_GRANTED) {
+            throw new SecurityException("Requires FM_RADIO_RECEIVER permission");
+        }
+
+        _fm_receiver_startAsync(band.getMinFrequency(), band.getMaxFrequency(), band
+                .getDefaultFrequency(), band.getChannelOffset());
+    }
+
+    public void reset() {
+        if (mContext.checkCallingOrSelfPermission(android.Manifest.permission.FM_RADIO_RECEIVER)
+                != PackageManager.PERMISSION_GRANTED) {
+            throw new SecurityException("Requires FM_RADIO_RECEIVER permission");
+        }
+
+        _fm_receiver_reset();
+    }
+
+    public void pause() {
+        if (mContext.checkCallingOrSelfPermission(android.Manifest.permission.FM_RADIO_RECEIVER)
+                != PackageManager.PERMISSION_GRANTED) {
+            throw new SecurityException("Requires FM_RADIO_RECEIVER permission");
+        }
+
+        _fm_receiver_pause();
+    }
+
+    public void resume() {
+        if (mContext.checkCallingOrSelfPermission(android.Manifest.permission.FM_RADIO_RECEIVER)
+                != PackageManager.PERMISSION_GRANTED) {
+            throw new SecurityException("Requires FM_RADIO_RECEIVER permission");
+        }
+
+        _fm_receiver_resume();
+    }
+
+    public int getState() {
+        if (mContext.checkCallingOrSelfPermission(android.Manifest.permission.FM_RADIO_RECEIVER)
+                != PackageManager.PERMISSION_GRANTED) {
+            throw new SecurityException("Requires FM_RADIO_RECEIVER permission");
+        }
+
+        return _fm_receiver_getState();
+    }
+
+    public void setFrequency(int frequency) {
+        if (mContext.checkCallingOrSelfPermission(android.Manifest.permission.FM_RADIO_RECEIVER)
+                != PackageManager.PERMISSION_GRANTED) {
+            throw new SecurityException("Requires FM_RADIO_RECEIVER permission");
+        }
+
+        _fm_receiver_setFrequency(frequency);
+    }
+
+    public int getFrequency() {
+        if (mContext.checkCallingOrSelfPermission(android.Manifest.permission.FM_RADIO_RECEIVER)
+                != PackageManager.PERMISSION_GRANTED) {
+            throw new SecurityException("Requires FM_RADIO_RECEIVER permission");
+        }
+
+        return _fm_receiver_getFrequency();
+    }
+
+    public void scanUp() {
+        if (mContext.checkCallingOrSelfPermission(android.Manifest.permission.FM_RADIO_RECEIVER)
+                != PackageManager.PERMISSION_GRANTED) {
+            throw new SecurityException("Requires FM_RADIO_RECEIVER permission");
+        }
+
+        _fm_receiver_scanUp();
+    }
+
+    public void scanDown() {
+        if (mContext.checkCallingOrSelfPermission(android.Manifest.permission.FM_RADIO_RECEIVER)
+                != PackageManager.PERMISSION_GRANTED) {
+            throw new SecurityException("Requires FM_RADIO_RECEIVER permission");
+        }
+
+        _fm_receiver_scanDown();
+    }
+
+    public void startFullScan() {
+        if (mContext.checkCallingOrSelfPermission(android.Manifest.permission.FM_RADIO_RECEIVER)
+                != PackageManager.PERMISSION_GRANTED) {
+            throw new SecurityException("Requires FM_RADIO_RECEIVER permission");
+        }
+
+        _fm_receiver_startFullScan();
+    }
+
+    public void stopScan() {
+        if (mContext.checkCallingOrSelfPermission(android.Manifest.permission.FM_RADIO_RECEIVER)
+                != PackageManager.PERMISSION_GRANTED) {
+            throw new SecurityException("Requires FM_RADIO_RECEIVER permission");
+        }
+
+        _fm_receiver_stopScan();
+    }
+
+    public boolean isRDSDataSupported() {
+        if (mContext.checkCallingOrSelfPermission(android.Manifest.permission.FM_RADIO_RECEIVER)
+                != PackageManager.PERMISSION_GRANTED) {
+            throw new SecurityException("Requires FM_RADIO_RECEIVER permission");
+        }
+
+        return _fm_receiver_isRDSDataSupported();
+    }
+
+    public boolean isTunedToValidChannel() {
+        if (mContext.checkCallingOrSelfPermission(android.Manifest.permission.FM_RADIO_RECEIVER)
+                != PackageManager.PERMISSION_GRANTED) {
+            throw new SecurityException("Requires FM_RADIO_RECEIVER permission");
+        }
+
+        return _fm_receiver_isTunedToValidChannel();
+    }
+
+    public void setThreshold(int threshold) {
+        if (mContext.checkCallingOrSelfPermission(android.Manifest.permission.FM_RADIO_RECEIVER)
+                != PackageManager.PERMISSION_GRANTED) {
+            throw new SecurityException("Requires FM_RADIO_RECEIVER permission");
+        }
+
+        _fm_receiver_setThreshold(threshold);
+    }
+
+    public int getThreshold() {
+        if (mContext.checkCallingOrSelfPermission(android.Manifest.permission.FM_RADIO_RECEIVER)
+                != PackageManager.PERMISSION_GRANTED) {
+            throw new SecurityException("Requires FM_RADIO_RECEIVER permission");
+        }
+
+        return _fm_receiver_getThreshold();
+    }
+
+    public int getSignalStrength() {
+        if (mContext.checkCallingOrSelfPermission(android.Manifest.permission.FM_RADIO_RECEIVER)
+                != PackageManager.PERMISSION_GRANTED) {
+            throw new SecurityException("Requires FM_RADIO_RECEIVER permission");
+        }
+
+        return _fm_receiver_getSignalStrength();
+    }
+
+    public boolean isPlayingInStereo() {
+        if (mContext.checkCallingOrSelfPermission(android.Manifest.permission.FM_RADIO_RECEIVER)
+                != PackageManager.PERMISSION_GRANTED) {
+            throw new SecurityException("Requires FM_RADIO_RECEIVER permission");
+        }
+
+        return _fm_receiver_isPlayingInStereo();
+    }
+
+    public void setForceMono(boolean forceMono) {
+        if (mContext.checkCallingOrSelfPermission(android.Manifest.permission.FM_RADIO_RECEIVER)
+                != PackageManager.PERMISSION_GRANTED) {
+            throw new SecurityException("Requires FM_RADIO_RECEIVER permission");
+        }
+
+        _fm_receiver_setForceMono(forceMono);
+    }
+
+    public void setAutomaticAFSwitching(boolean automatic) {
+        if (mContext.checkCallingOrSelfPermission(android.Manifest.permission.FM_RADIO_RECEIVER)
+                != PackageManager.PERMISSION_GRANTED) {
+            throw new SecurityException("Requires FM_RADIO_RECEIVER permission");
+        }
+
+        _fm_receiver_setAutomaticAFSwitching(automatic);
+    }
+
+    public void setAutomaticTASwitching(boolean automatic) {
+        if (mContext.checkCallingOrSelfPermission(android.Manifest.permission.FM_RADIO_RECEIVER)
+                != PackageManager.PERMISSION_GRANTED) {
+            throw new SecurityException("Requires FM_RADIO_RECEIVER permission");
+        }
+
+        _fm_receiver_setAutomaticTASwitching(automatic);
+    }
+
+    public boolean sendExtraCommand(String command, String[] extras) {
+        if (mContext.checkCallingOrSelfPermission(android.Manifest.permission.FM_RADIO_RECEIVER)
+                != PackageManager.PERMISSION_GRANTED) {
+            throw new SecurityException("Requires FM_RADIO_RECEIVER permission");
+        }
+
+        return _fm_receiver_sendExtraCommand(command, extras);
+    }
+
+    public void addOnStateChangedListener(IOnStateChangedListener listener) {
+        if (mContext.checkCallingOrSelfPermission(android.Manifest.permission.FM_RADIO_RECEIVER)
+                != PackageManager.PERMISSION_GRANTED) {
+            throw new SecurityException("Requires FM_RADIO_RECEIVER permission");
+        }
+
+        IBinder binder = listener.asBinder();
+        OnStateChangedReceiver receiver = mOnStateChangedReceivers.get(binder);
+        if (receiver == null) {
+            receiver = new OnStateChangedReceiver(listener);
+            mOnStateChangedReceivers.put(binder, receiver);
+            Log.d(TAG, "addOnStateChangedListener(), new receiver added");
+            try {
+                receiver.getListener().asBinder().linkToDeath(receiver, 0);
+            } catch (RemoteException ex) {
+                Slog.e(TAG, "linkToDeath failed:", ex);
+            }
+        }
+    }
+
+    public void removeOnStateChangedListener(IOnStateChangedListener listener) {
+        if (mContext.checkCallingOrSelfPermission(android.Manifest.permission.FM_RADIO_RECEIVER)
+                != PackageManager.PERMISSION_GRANTED) {
+            throw new SecurityException("Requires FM_RADIO_RECEIVER permission");
+        }
+
+        IBinder binder = listener.asBinder();
+        OnStateChangedReceiver receiver = mOnStateChangedReceivers.get(binder);
+        if (receiver != null) {
+            mOnStateChangedReceivers.remove(receiver.mKey);
+            Log.d(TAG, "removeOnStateChangedListener(), receiver removed");
+            receiver.getListener().asBinder().unlinkToDeath(receiver, 0);
+        }
+    }
+
+    public void addOnStartedListener(IOnStartedListener listener) {
+        if (mContext.checkCallingOrSelfPermission(android.Manifest.permission.FM_RADIO_RECEIVER)
+                != PackageManager.PERMISSION_GRANTED) {
+            throw new SecurityException("Requires FM_RADIO_RECEIVER permission");
+        }
+
+        IBinder binder = listener.asBinder();
+        OnStartedReceiver receiver = mOnStartedReceivers.get(binder);
+        if (receiver == null) {
+            receiver = new OnStartedReceiver(listener);
+            mOnStartedReceivers.put(binder, receiver);
+            Log.d(TAG, "addOnStartedListener(), new receiver added");
+            try {
+                receiver.getListener().asBinder().linkToDeath(receiver, 0);
+            } catch (RemoteException ex) {
+                Slog.e(TAG, "linkToDeath failed:", ex);
+            }
+        }
+    }
+
+    public void removeOnStartedListener(IOnStartedListener listener) {
+        if (mContext.checkCallingOrSelfPermission(android.Manifest.permission.FM_RADIO_RECEIVER)
+                != PackageManager.PERMISSION_GRANTED) {
+            throw new SecurityException("Requires FM_RADIO_RECEIVER permission");
+        }
+
+        IBinder binder = listener.asBinder();
+        OnStartedReceiver receiver = mOnStartedReceivers.get(binder);
+        if (receiver != null) {
+            mOnStartedReceivers.remove(receiver.mKey);
+            Log.d(TAG, "removeOnStartedListener(), receiver removed");
+            receiver.getListener().asBinder().unlinkToDeath(receiver, 0);
+        }
+    }
+
+    public void addOnErrorListener(IOnErrorListener listener) {
+        if (mContext.checkCallingOrSelfPermission(android.Manifest.permission.FM_RADIO_RECEIVER)
+                != PackageManager.PERMISSION_GRANTED) {
+            throw new SecurityException("Requires FM_RADIO_RECEIVER permission");
+        }
+
+        IBinder binder = listener.asBinder();
+        OnErrorReceiver receiver = mOnErrorReceivers.get(binder);
+        if (receiver == null) {
+            receiver = new OnErrorReceiver(listener);
+            mOnErrorReceivers.put(binder, receiver);
+            Log.d(TAG, "addOnErrorListener(), new receiver added");
+            try {
+                receiver.getListener().asBinder().linkToDeath(receiver, 0);
+            } catch (RemoteException ex) {
+                Slog.e(TAG, "linkToDeath failed:", ex);
+            }
+        }
+    }
+
+    public void removeOnErrorListener(IOnErrorListener listener) {
+        if (mContext.checkCallingOrSelfPermission(android.Manifest.permission.FM_RADIO_RECEIVER)
+                != PackageManager.PERMISSION_GRANTED) {
+            throw new SecurityException("Requires FM_RADIO_RECEIVER permission");
+        }
+
+        IBinder binder = listener.asBinder();
+        OnErrorReceiver receiver = mOnErrorReceivers.get(binder);
+        if (receiver != null) {
+            mOnErrorReceivers.remove(receiver.mKey);
+            Log.d(TAG, "removeOnErrorListener(), receiver removed");
+            receiver.getListener().asBinder().unlinkToDeath(receiver, 0);
+        }
+    }
+
+    public void addOnScanListener(IOnScanListener listener) {
+        if (mContext.checkCallingOrSelfPermission(android.Manifest.permission.FM_RADIO_RECEIVER)
+                != PackageManager.PERMISSION_GRANTED) {
+            throw new SecurityException("Requires FM_RADIO_RECEIVER permission");
+        }
+
+        IBinder binder = listener.asBinder();
+        OnScanReceiver receiver = mOnScanReceivers.get(binder);
+        if (receiver == null) {
+            receiver = new OnScanReceiver(listener);
+            mOnScanReceivers.put(binder, receiver);
+            Log.d(TAG, "addOnScanListener(), new receiver added");
+            try {
+                receiver.getListener().asBinder().linkToDeath(receiver, 0);
+            } catch (RemoteException ex) {
+                Slog.e(TAG, "linkToDeath failed:", ex);
+            }
+        }
+    }
+
+    public void removeOnScanListener(IOnScanListener listener) {
+        if (mContext.checkCallingOrSelfPermission(android.Manifest.permission.FM_RADIO_RECEIVER)
+                != PackageManager.PERMISSION_GRANTED) {
+            throw new SecurityException("Requires FM_RADIO_RECEIVER permission");
+        }
+
+        IBinder binder = listener.asBinder();
+        OnScanReceiver receiver = mOnScanReceivers.get(binder);
+        if (receiver != null) {
+            mOnScanReceivers.remove(receiver.mKey);
+            Log.d(TAG, "removeOnScanListener(), receiver removed");
+            receiver.getListener().asBinder().unlinkToDeath(receiver, 0);
+        }
+    }
+
+    public void addOnForcedPauseListener(IOnForcedPauseListener listener) {
+        if (mContext.checkCallingOrSelfPermission(android.Manifest.permission.FM_RADIO_RECEIVER)
+                != PackageManager.PERMISSION_GRANTED) {
+            throw new SecurityException("Requires FM_RADIO_RECEIVER permission");
+        }
+
+        IBinder binder = listener.asBinder();
+        OnForcedPauseReceiver receiver = mOnForcedPauseReceivers.get(binder);
+        if (receiver == null) {
+            receiver = new OnForcedPauseReceiver(listener);
+            mOnForcedPauseReceivers.put(binder, receiver);
+            Log.d(TAG, "addOnForcedPauseListener(), new receiver added");
+            try {
+                receiver.getListener().asBinder().linkToDeath(receiver, 0);
+            } catch (RemoteException ex) {
+                Slog.e(TAG, "linkToDeath failed:", ex);
+            }
+        }
+    }
+
+    public void removeOnForcedPauseListener(IOnForcedPauseListener listener) {
+        if (mContext.checkCallingOrSelfPermission(android.Manifest.permission.FM_RADIO_RECEIVER)
+                != PackageManager.PERMISSION_GRANTED) {
+            throw new SecurityException("Requires FM_RADIO_RECEIVER permission");
+        }
+
+        IBinder binder = listener.asBinder();
+        OnForcedPauseReceiver receiver = mOnForcedPauseReceivers.get(binder);
+        if (receiver != null) {
+            mOnForcedPauseReceivers.remove(receiver.mKey);
+            Log.d(TAG, "removeOnForcedPauseListener(), receiver removed");
+            receiver.getListener().asBinder().unlinkToDeath(receiver, 0);
+        }
+    }
+
+    public void addOnForcedResetListener(IOnForcedResetListener listener) {
+        if (mContext.checkCallingOrSelfPermission(android.Manifest.permission.FM_RADIO_RECEIVER)
+                != PackageManager.PERMISSION_GRANTED) {
+            throw new SecurityException("Requires FM_RADIO_RECEIVER permission");
+        }
+
+        IBinder binder = listener.asBinder();
+        OnForcedResetReceiver receiver = mOnForcedResetReceivers.get(binder);
+        if (receiver == null) {
+            receiver = new OnForcedResetReceiver(listener);
+            mOnForcedResetReceivers.put(binder, receiver);
+            Log.d(TAG, "addOnForcedResetListener(), new receiver added");
+            try {
+                receiver.getListener().asBinder().linkToDeath(receiver, 0);
+            } catch (RemoteException ex) {
+                Slog.e(TAG, "linkToDeath failed:", ex);
+            }
+        }
+    }
+
+    public void removeOnForcedResetListener(IOnForcedResetListener listener) {
+        if (mContext.checkCallingOrSelfPermission(android.Manifest.permission.FM_RADIO_RECEIVER)
+                != PackageManager.PERMISSION_GRANTED) {
+            throw new SecurityException("Requires FM_RADIO_RECEIVER permission");
+        }
+
+        IBinder binder = listener.asBinder();
+        OnForcedResetReceiver receiver = mOnForcedResetReceivers.get(binder);
+        if (receiver != null) {
+            mOnForcedResetReceivers.remove(receiver.mKey);
+            Log.d(TAG, "removeOnForcedResetListener(), receiver removed");
+            receiver.getListener().asBinder().unlinkToDeath(receiver, 0);
+        }
+    }
+
+    public void addOnRDSDataFoundListener(IOnRDSDataFoundListener listener) {
+        if (mContext.checkCallingOrSelfPermission(android.Manifest.permission.FM_RADIO_RECEIVER)
+                != PackageManager.PERMISSION_GRANTED) {
+            throw new SecurityException("Requires FM_RADIO_RECEIVER permission");
+        }
+
+        IBinder binder = listener.asBinder();
+        OnRDSDataReceiver receiver = mOnRDSDataReceivers.get(binder);
+        if (receiver == null) {
+            receiver = new OnRDSDataReceiver(listener);
+            mOnRDSDataReceivers.put(binder, receiver);
+            Log.d(TAG, "addOnRDSDataFoundListener(), new receiver added");
+            try {
+                receiver.getListener().asBinder().linkToDeath(receiver, 0);
+            } catch (RemoteException ex) {
+                Slog.e(TAG, "linkToDeath failed:", ex);
+            }
+            if ((getState() >= FmReceiver.STATE_STARTED) &&
+                (mOnRDSDataReceivers.size() == 1)) {
+                Log.d(TAG, "First RDS receiver added, switching on RDS");
+                _fm_receiver_setRDS(true);
+            }
+        }
+    }
+
+    public void removeOnRDSDataFoundListener(IOnRDSDataFoundListener listener) {
+        if (mContext.checkCallingOrSelfPermission(android.Manifest.permission.FM_RADIO_RECEIVER)
+                != PackageManager.PERMISSION_GRANTED) {
+            throw new SecurityException("Requires FM_RADIO_RECEIVER permission");
+        }
+
+        IBinder binder = listener.asBinder();
+        OnRDSDataReceiver receiver = mOnRDSDataReceivers.get(binder);
+        if (receiver != null) {
+            mOnRDSDataReceivers.remove(receiver.mKey);
+            Log.d(TAG, "removeOnRDSDataFoundListener(), receiver removed");
+            receiver.getListener().asBinder().unlinkToDeath(receiver, 0);
+            if ((getState() >= FmReceiver.STATE_STARTED) &&
+                mOnRDSDataReceivers.isEmpty()) {
+                Log.d(TAG, "Last RDS receiver removed, switching off RDS");
+                _fm_receiver_setRDS(false);
+            }
+        }
+    }
+
+    public void addOnSignalStrengthChangedListener(IOnSignalStrengthListener listener) {
+        if (mContext.checkCallingOrSelfPermission(android.Manifest.permission.FM_RADIO_RECEIVER)
+                != PackageManager.PERMISSION_GRANTED) {
+            throw new SecurityException("Requires FM_RADIO_RECEIVER permission");
+        }
+
+        IBinder binder = listener.asBinder();
+        OnSignalStrengthReceiver receiver = mOnSignalStrengthReceivers.get(binder);
+        if (receiver == null) {
+            receiver = new OnSignalStrengthReceiver(listener);
+            mOnSignalStrengthReceivers.put(binder, receiver);
+            Log.d(TAG, "addOnSignalStrengthChangedListener(), new receiver added");
+            try {
+                receiver.getListener().asBinder().linkToDeath(receiver, 0);
+            } catch (RemoteException ex) {
+                Slog.e(TAG, "linkToDeath failed:", ex);
+            }
+        }
+    }
+
+    public void removeOnSignalStrengthChangedListener(IOnSignalStrengthListener listener) {
+        if (mContext.checkCallingOrSelfPermission(android.Manifest.permission.FM_RADIO_RECEIVER)
+                != PackageManager.PERMISSION_GRANTED) {
+            throw new SecurityException("Requires FM_RADIO_RECEIVER permission");
+        }
+
+        IBinder binder = listener.asBinder();
+        OnSignalStrengthReceiver receiver = mOnSignalStrengthReceivers.get(binder);
+        if (receiver != null) {
+            mOnSignalStrengthReceivers.remove(receiver.mKey);
+            Log.d(TAG, "removeOnSignalStrengthChangedListener(), receiver removed");
+            receiver.getListener().asBinder().unlinkToDeath(receiver, 0);
+        }
+    }
+
+    public void addOnPlayingInStereoListener(IOnStereoListener listener) {
+        if (mContext.checkCallingOrSelfPermission(android.Manifest.permission.FM_RADIO_RECEIVER)
+                != PackageManager.PERMISSION_GRANTED) {
+            throw new SecurityException("Requires FM_RADIO_RECEIVER permission");
+        }
+
+        IBinder binder = listener.asBinder();
+        OnStereoReceiver receiver = mOnStereoReceivers.get(binder);
+        if (receiver == null) {
+            receiver = new OnStereoReceiver(listener);
+            mOnStereoReceivers.put(binder, receiver);
+            Log.d(TAG, "addOnPlayingInStereoListener(), new receiver added");
+            try {
+                receiver.getListener().asBinder().linkToDeath(receiver, 0);
+            } catch (RemoteException ex) {
+                Slog.e(TAG, "linkToDeath failed:", ex);
+            }
+        }
+    }
+
+    public void removeOnPlayingInStereoListener(IOnStereoListener listener) {
+        if (mContext.checkCallingOrSelfPermission(android.Manifest.permission.FM_RADIO_RECEIVER)
+                != PackageManager.PERMISSION_GRANTED) {
+            throw new SecurityException("Requires FM_RADIO_RECEIVER permission");
+        }
+
+        IBinder binder = listener.asBinder();
+        OnStereoReceiver receiver = mOnStereoReceivers.get(binder);
+        if (receiver != null) {
+            mOnStereoReceivers.remove(receiver.mKey);
+            Log.d(TAG, "removeOnPlayingInStereoListener(), receiver removed");
+            receiver.getListener().asBinder().unlinkToDeath(receiver, 0);
+        }
+    }
+
+    public void addOnExtraCommandListener(IOnExtraCommandListener listener) {
+        if (mContext.checkCallingOrSelfPermission(android.Manifest.permission.FM_RADIO_RECEIVER)
+                != PackageManager.PERMISSION_GRANTED) {
+            throw new SecurityException("Requires FM_RADIO_RECEIVER permission");
+        }
+
+        IBinder binder = listener.asBinder();
+        OnExtraCommandReceiver receiver = mOnExtraCommandReceivers.get(binder);
+        if (receiver == null) {
+            receiver = new OnExtraCommandReceiver(listener);
+            mOnExtraCommandReceivers.put(binder, receiver);
+            Log.d(TAG, "addOnExtraCommandListener(), new receiver added");
+            try {
+                receiver.getListener().asBinder().linkToDeath(receiver, 0);
+            } catch (RemoteException ex) {
+                Slog.e(TAG, "linkToDeath failed:", ex);
+            }
+        }
+    }
+
+    public void removeOnExtraCommandListener(IOnExtraCommandListener listener) {
+        if (mContext.checkCallingOrSelfPermission(android.Manifest.permission.FM_RADIO_RECEIVER)
+                != PackageManager.PERMISSION_GRANTED) {
+            throw new SecurityException("Requires FM_RADIO_RECEIVER permission");
+        }
+
+        IBinder binder = listener.asBinder();
+        OnExtraCommandReceiver receiver = mOnExtraCommandReceivers.get(binder);
+        if (receiver != null) {
+            mOnExtraCommandReceivers.remove(receiver.mKey);
+            Log.d(TAG, "removeOnExtraCommandListener(), receiver removed");
+            receiver.getListener().asBinder().unlinkToDeath(receiver, 0);
+        }
+    }
+
+    public void addOnAutomaticSwitchListener(IOnAutomaticSwitchListener listener) {
+        if (mContext.checkCallingOrSelfPermission(android.Manifest.permission.FM_RADIO_RECEIVER)
+                != PackageManager.PERMISSION_GRANTED) {
+            throw new SecurityException("Requires FM_RADIO_RECEIVER permission");
+        }
+
+        IBinder binder = listener.asBinder();
+        OnAutomaticSwitchReceiver receiver = mOnAutomaticSwitchReceivers.get(binder);
+        if (receiver == null) {
+            receiver = new OnAutomaticSwitchReceiver(listener);
+            mOnAutomaticSwitchReceivers.put(binder, receiver);
+            Log.d(TAG, "addOnAutomaticSwitchListener(), new receiver added");
+            try {
+                receiver.getListener().asBinder().linkToDeath(receiver, 0);
+            } catch (RemoteException ex) {
+                Slog.e(TAG, "linkToDeath failed:", ex);
+            }
+        }
+    }
+
+    public void removeOnAutomaticSwitchListener(IOnAutomaticSwitchListener listener) {
+        if (mContext.checkCallingOrSelfPermission(android.Manifest.permission.FM_RADIO_RECEIVER)
+                != PackageManager.PERMISSION_GRANTED) {
+            throw new SecurityException("Requires FM_RADIO_RECEIVER permission");
+        }
+
+        IBinder binder = listener.asBinder();
+        OnAutomaticSwitchReceiver receiver = mOnAutomaticSwitchReceivers.get(binder);
+        if (receiver != null) {
+            mOnAutomaticSwitchReceivers.remove(receiver.mKey);
+            Log.d(TAG, "removeOnAutomaticSwitchListener(), receiver removed");
+            receiver.getListener().asBinder().unlinkToDeath(receiver, 0);
+        }
+    }
+
+    private void notifyOnStateChanged(int oldState, int newState) {
+        synchronized (mOnStateChangedReceivers) {
+            Collection c = mOnStateChangedReceivers.values();
+            Iterator iterator = c.iterator();
+            while (iterator.hasNext()) {
+                OnStateChangedReceiver m = (OnStateChangedReceiver) iterator.next();
+                m.callOnStateChanged(oldState, newState);
+            }
+        }
+    }
+
+    private void notifyOnStarted() {
+        synchronized (mOnStartedReceivers) {
+            Collection c = mOnStartedReceivers.values();
+            Iterator iterator = c.iterator();
+            while (iterator.hasNext()) {
+                OnStartedReceiver m = (OnStartedReceiver) iterator.next();
+                m.callOnStarted();
+            }
+
+            if (mOnRDSDataReceivers.size() > 0) {
+                Log.d(TAG, "Started event with RDS receiver(s), switching on RDS");
+                _fm_receiver_setRDS(true);
+            }
+        }
+    }
+
+    private void notifyOnScan(int frequency, int signalLevel, int scanDirection, boolean aborted) {
+        synchronized (mOnScanReceivers) {
+            Collection c = mOnScanReceivers.values();
+            Iterator iterator = c.iterator();
+            while (iterator.hasNext()) {
+                OnScanReceiver m = (OnScanReceiver) iterator.next();
+                m.callOnScan(frequency, signalLevel, scanDirection, aborted);
+            }
+        }
+    }
+
+    private void notifyOnFullScan(int[] frequency, int[] signalLevel, boolean aborted) {
+        synchronized (mOnScanReceivers) {
+            Collection c = mOnScanReceivers.values();
+            Iterator iterator = c.iterator();
+            while (iterator.hasNext()) {
+                OnScanReceiver m = (OnScanReceiver) iterator.next();
+                m.callOnFullScan(frequency, signalLevel, aborted);
+            }
+        }
+    }
+
+    private void notifyOnForcedPause() {
+        synchronized (mOnForcedPauseReceivers) {
+            Collection c = mOnForcedPauseReceivers.values();
+            Iterator iterator = c.iterator();
+            while (iterator.hasNext()) {
+                OnForcedPauseReceiver m = (OnForcedPauseReceiver) iterator.next();
+                m.callOnForcedPause();
+            }
+        }
+    }
+
+    private void notifyOnForcedReset(int reason) {
+        synchronized (mOnForcedResetReceivers) {
+            Collection c = mOnForcedResetReceivers.values();
+            Iterator iterator = c.iterator();
+            while (iterator.hasNext()) {
+                OnForcedResetReceiver m = (OnForcedResetReceiver) iterator.next();
+                m.callOnForcedReset(reason);
+            }
+        }
+    }
+
+    private void notifyOnError() {
+        synchronized (mOnErrorReceivers) {
+            Collection c = mOnErrorReceivers.values();
+            Iterator iterator = c.iterator();
+            while (iterator.hasNext()) {
+                OnErrorReceiver m = (OnErrorReceiver) iterator.next();
+                m.callOnError();
+            }
+        }
+    }
+
+    private void notifyOnRDSDataFound(Bundle bundle, int frequency) {
+        synchronized (mOnRDSDataReceivers) {
+            Collection c = mOnRDSDataReceivers.values();
+            Iterator iterator = c.iterator();
+            while (iterator.hasNext()) {
+                OnRDSDataReceiver m = (OnRDSDataReceiver) iterator.next();
+                m.callOnRDSDataFound(bundle, frequency);
+            }
+        }
+    }
+
+    private void notifyOnSignalStrengthChanged(int signalStrength) {
+        synchronized (mOnSignalStrengthReceivers) {
+            Collection c = mOnSignalStrengthReceivers.values();
+            Iterator iterator = c.iterator();
+            while (iterator.hasNext()) {
+                OnSignalStrengthReceiver m = (OnSignalStrengthReceiver) iterator.next();
+                m.callOnSignalStrengthChanged(signalStrength);
+            }
+        }
+    }
+
+    private void notifyOnPlayingInStereo(boolean inStereo) {
+        synchronized (mOnStereoReceivers) {
+            Collection c = mOnStereoReceivers.values();
+            Iterator iterator = c.iterator();
+            while (iterator.hasNext()) {
+                OnStereoReceiver m = (OnStereoReceiver) iterator.next();
+                m.callOnPlayingInStereo(inStereo);
+            }
+        }
+    }
+
+    private void notifyOnExtraCommand(String response, Bundle extras) {
+        synchronized (mOnExtraCommandReceivers) {
+            Collection c = mOnExtraCommandReceivers.values();
+            Iterator iterator = c.iterator();
+            while (iterator.hasNext()) {
+                OnExtraCommandReceiver m = (OnExtraCommandReceiver) iterator.next();
+                m.callOnExtraCommand(response, extras);
+            }
+        }
+    }
+
+    private void notifyOnAutomaticSwitching(int newFrequency, int reason) {
+        synchronized (mOnAutomaticSwitchReceivers) {
+            Collection c = mOnAutomaticSwitchReceivers.values();
+            Iterator iterator = c.iterator();
+            while (iterator.hasNext()) {
+                OnAutomaticSwitchReceiver m = (OnAutomaticSwitchReceiver) iterator.next();
+                m.callOnAutomaticSwitch(newFrequency, reason);
+            }
+        }
+    }
+
+    static
+    {
+        System.loadLibrary("analogradiobroadcasting");
+    }
+
+    private native void _fm_receiver_start(int minFreq, int maxFreq, int defaultFreq, int offset);
+
+    private native void _fm_receiver_startAsync(int minFreq, int maxFreq, int defaultFreq,
+            int offset);
+
+    private native int _fm_receiver_reset();
+
+    private native void _fm_receiver_pause();
+
+    private native void _fm_receiver_resume();
+
+    private native int _fm_receiver_getState();
+
+    private native void _fm_receiver_setFrequency(int frequency);
+
+    private native int _fm_receiver_getFrequency();
+
+    private native void _fm_receiver_scanUp();
+
+    private native void _fm_receiver_scanDown();
+
+    private native void _fm_receiver_startFullScan();
+
+    private native void _fm_receiver_stopScan();
+
+    private native boolean _fm_receiver_isRDSDataSupported();
+
+    private native boolean _fm_receiver_isTunedToValidChannel();
+
+    private native void _fm_receiver_setThreshold(int threshold);
+
+    private native int _fm_receiver_getThreshold();
+
+    private native int _fm_receiver_getSignalStrength();
+
+    private native boolean _fm_receiver_isPlayingInStereo();
+
+    private native void _fm_receiver_setForceMono(boolean forceMono);
+
+    private native void _fm_receiver_setAutomaticAFSwitching(boolean automatic);
+
+    private native void _fm_receiver_setAutomaticTASwitching(boolean automatic);
+
+    private native void _fm_receiver_setRDS(boolean receiveRDS);
+
+    private native boolean _fm_receiver_sendExtraCommand(String command, String[] extras);
+}
diff --git a/fmradio/java/com/stericsson/hardware/fm/FmTransmitter.java b/fmradio/java/com/stericsson/hardware/fm/FmTransmitter.java
new file mode 100644
index 0000000..9581651
--- /dev/null
+++ b/fmradio/java/com/stericsson/hardware/fm/FmTransmitter.java
@@ -0,0 +1,807 @@
+/*
+ * Copyright (C) ST-Ericsson SA 2010
+ * Copyright (C) 2010 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+ * Author: Bjorn Pileryd (bjorn.pileryd@sonyericsson.com)
+ * Author: Markus Grape (markus.grape@stericsson.com) for ST-Ericsson
+ */
+
+package com.stericsson.hardware.fm;
+
+import android.content.Context;
+import android.content.pm.PackageManager;
+import android.os.Bundle;
+
+import java.io.IOException;
+
+/**
+ * The FmTransmitter controls the output of FM radio from the device. When
+ * started, the transmitter will transmit audio via FM signals. The unit for all
+ * frequencies in this class is kHz. Note that this API only controls the output
+ * of FM radio, to select the audio stream the MediaPlayer interface should be
+ * used, see code example below the state diagram.
+ * <p>
+ * The output frequency can be changed at any time using
+ * {@link #setFrequency(int)}. The transmitter also supports transmission of RDS
+ * data, see {@link #setRdsData(Bundle)}.
+ * </p>
+ * <p>
+ * Get an instance of this class by calling
+ * {@link android.content.Context#getSystemService(String)
+ * Context.getSystemService("fm_transmitter")}.
+ * </p>
+ * <a name="StateDiagram"></a> <h3>State Diagram</h3>
+ * <p>
+ * The state machine is designed to take into account that some hardware may
+ * need time to prepare, and that it is likely to consume more power when paused
+ * and started than it does in the idle state. The hardware implementation of
+ * this interface should do the time consuming preparation procedures in the
+ * starting state. The switching between paused and started states should be
+ * fast to give a good user experience.
+ * </p>
+ * <p>
+ * <img src="../../../../images/FmTransmitter_states.gif"
+ * alt="FmTransmitter State diagram" border="0" />
+ * </p>
+ * <table border="1">
+ * <tr>
+ * <th>Method Name</th>
+ * <th>Valid States</th>
+ * <th>Invalid States</th>
+ * <th>Comments</th>
+ * </tr>
+ * <tr>
+ * <td>{@link #startAsync(FmBand)}</td>
+ * <td>{idle}</td>
+ * <td>{starting, started, paused, scanning}</td>
+ * <td>Successful invocation of this method in a valid state transfers the
+ * object to the starting state. Calling this method in an invalid state throws
+ * an IllegalStateException.</td>
+ * </tr>
+ * <tr>
+ * <td>{@link #start(FmBand)}</td>
+ * <td>{idle}</td>
+ * <td>{starting, started, paused, scanning}</td>
+ * <td>Successful invocation of this method in a valid state transfers the
+ * object to the started state. Calling this method in an invalid state throws
+ * an IllegalStateException.</td>
+ * </tr>
+ * <tr>
+ * <td>{@link #resume()}</td>
+ * <td>{started, paused}</td>
+ * <td>{idle, starting, scanning}</td>
+ * <td>Successful invocation of this method in a valid state transfers the
+ * object to the started state. Calling this method in an invalid state throws
+ * an IllegalStateException.</td>
+ * </tr>
+ * <tr>
+ * <td>{@link #pause()}</td>
+ * <td>{started, paused}</td>
+ * <td>{idle, starting, scanning}</td>
+ * <td>Successful invocation of this method in a valid state transfers the
+ * object to the paused state. Calling this method in an invalid state throws an
+ * IllegalStateException.</td>
+ * </tr>
+ * <tr>
+ * <td>{@link #reset()}</td>
+ * <td>any</td>
+ * <td>{}</td>
+ * <td>Successful invocation of this method transfers the object to the idle
+ * state, the object is like being just created.</td>
+ * </tr>
+ * <tr>
+ * <td>{@link #getState()}</td>
+ * <td>any</td>
+ * <td>{}</td>
+ * <td>This method can be called in any state and calling it does not change the
+ * object state.</td>
+ * </tr>
+ * <tr>
+ * <td>{@link #isApiSupported(Context)}</td>
+ * <td>any</td>
+ * <td>{}</td>
+ * <td>This method can be called in any state and calling it does not change the
+ * object state.</td>
+ * </tr>
+ * <tr>
+ * <td>{@link #setFrequency(int)}</td>
+ * <td>{started, paused}</td>
+ * <td>{idle, starting, scanning}</td>
+ * <td>Successful invocation of this method in a valid state does not change the
+ * object state. Calling this method in an invalid state throws an
+ * IllegalStateException.</td>
+ * </tr>
+ * <tr>
+ * <td>{@link #getFrequency()}</td>
+ * <td>{started, paused}</td>
+ * <td>{idle, starting, scanning}</td>
+ * <td>Successful invocation of this method in a valid state does not change the
+ * object state. Calling this method in an invalid state throws an
+ * IllegalStateException.</td>
+ * </tr>
+ * <tr>
+ * <td>{@link #setRdsData(Bundle)}</td>
+ * <td>{started, paused}</td>
+ * <td>{idle, starting, scanning}</td>
+ * <td>Successful invocation of this method in a valid state does not change the
+ * object state. Calling this method in an invalid state throws an
+ * IllegalStateException.</td>
+ * </tr>
+ * <tr>
+ * <td>{@link #isBlockScanSupported()}</td>
+ * <td>any</td>
+ * <td>{}</td>
+ * <td>This method can be called in any state and calling it does not change the
+ * object state.</td>
+ * </tr>
+ * <tr>
+ * <td>{@link #startBlockScan(int, int)}</td>
+ * <td>{started, paused}</td>
+ * <td>{idle, starting, scanning}</td>
+ * <td>Successful invocation of this method in a valid state transfers the
+ * object to the scanning state. Calling this method in an invalid state throws
+ * an IllegalStateException.</td>
+ * </tr>
+ * <tr>
+ * <td>{@link #stopScan()}</td>
+ * <td>any</td>
+ * <td>{}</td>
+ * <td>Successful invocation of this method in a valid state tries to stop
+ * performing a scan operation. The hardware might continue the scan for an
+ * unspecified amount of time after this method is called. Once the scan has
+ * stopped, it will be notified via {@link OnScanListener}</td>
+ * </tr>
+ * <tr>
+ * <td>{@link #sendExtraCommand(String, String[])}</td>
+ * <td>vendor specific</td>
+ * <td>vendor specific</td>
+ * <td>vendor specific</td>
+ * </tr>
+ * </table>
+ * <a name="Examples"></a> <h3>Example code</h3>
+ * <pre>
+ * // prepare and start the FM transmitter
+ * FmTransmitter fmt = (FmTransmitter) getSystemService("fm_transmitter");
+ * fmt.start(new FmBand(FmBand.BAND_EU));
+ *
+ * // prepare and start playback
+ * MediaPlayer mp = new MediaPlayer();
+ * mp.setDataSource(PATH_TO_FILE);
+ * mp.prepare();
+ * mp.start();
+ * </pre>
+ * <a name="FMHandling"></a> <h3>FM receiving/transmission handling</h3>
+ * <p>
+ * In this API, FM radio cannot be received and transmitted at the same time,
+ * therefore the state machine is designed to prevent incorrect usage. The
+ * FmReceiver and FmTransmitter has a separate state machine and only one can be
+ * <i>active</i> (state other than idle).
+ * <ul>
+ * <li>If start is called on FmTransmitter and the FmReceiver is <i>active</i>,
+ * the FmReceiver MUST release resources and change state to idle.</li>
+ * <li>The FmReceiver will in that case be notified by
+ * {@link com.stericsson.hardware.fm.FmReceiver.OnForcedResetListener#onForcedReset(int)}.</li>
+ * </ul>
+ * </p>
+ * <a name="ErrorHandling"></a> <h3>Error handling</h3>
+ * <p>
+ * In general, it is up to the application that uses this API to keep track of
+ * events that could affect the FM radio user experience. The hardware
+ * implementation side of this API should only take actions when it is really
+ * necessary, e.g. if the hardware is forced to pause or reset, and notify the
+ * application by using the {@link OnForcedPauseListener},
+ * {@link OnForcedResetListener} or {@link OnErrorListener}.
+ * </p>
+ */
+public abstract class FmTransmitter {
+
+    /**
+     * The FmTransmitter had to be shut down due to a non-critical error,
+     * meaning that it is OK to attempt a restart immediately after this. An
+     * example is when the hardware was shut down in order to save power after
+     * being in the paused state for too long.
+     */
+    public static final int RESET_NON_CRITICAL = 0;
+
+    /**
+     * The FmTransmitter had to be shut down due to a critical error. The FM
+     * hardware it not guaranteed to work as expected after receiving this
+     * error.
+     */
+    public static final int RESET_CRITICAL = 1;
+
+    /**
+     * The FmReceiver was activated and therefore the FmTransmitter must be put
+     * in idle.
+     *
+     * @see FmReceiver#startAsync(FmBand)
+     */
+    public static final int RESET_RX_IN_USE = 2;
+
+    /**
+     * The radio is not allowed to be used, typically when flight mode is
+     * enabled.
+     */
+    public static final int RESET_RADIO_FORBIDDEN = 3;
+
+    /**
+     * Indicates that the FmTransmitter is in an idle state. No resources are
+     * allocated and power consumption is kept to a minimum.
+     */
+    public static final int STATE_IDLE = 0;
+
+    /**
+     * Indicates that the FmTransmitter is allocating resources and preparing to
+     * transmit FM radio.
+     */
+    public static final int STATE_STARTING = 1;
+
+    /**
+     * Indicates that the FmTransmitter is transmitting FM radio.
+     */
+    public static final int STATE_STARTED = 2;
+
+    /**
+     * Indicates that the FmTransmitter has allocated resources and is ready to
+     * instantly transmit FM radio.
+     */
+    public static final int STATE_PAUSED = 3;
+
+    /**
+     * Indicates that the FmTransmitter is scanning. FM radio will not be
+     * transmitted in this state.
+     */
+    public static final int STATE_SCANNING = 4;
+
+    /**
+     * Returns true if the FM transmitter API is supported by the system.
+     */
+    public static boolean isApiSupported(Context context) {
+        return context.getPackageManager().hasSystemFeature(
+                PackageManager.FEATURE_RADIO_FM_TRANSMITTER);
+    }
+
+    /**
+     * Starts reception of the FM hardware. This is an asynchronous method since
+     * different hardware can have varying startup times. When the reception is
+     * started a callback to {@link OnStartedListener#onStarted()} is made.
+     * <p>
+     * When calling this method, an FmBand parameter must be passed that
+     * describes the properties of the band that the FmTransmitter should
+     * prepare for. If the band is null, invalid or not supported, an exception
+     * will be thrown.
+     * </p>
+     * <p>
+     * If the FmReceiver is active it will be forced to reset. See
+     * {@link FmReceiver#RESET_TX_IN_USE}.
+     * </p>
+     *
+     * @param band
+     *            the band to use
+     * @throws IllegalArgumentException
+     *             if the band is null
+     * @throws UnsupportedOperationException
+     *             if the band is not supported by the hardware
+     * @throws IllegalStateException
+     *             if it is called in an invalid state
+     * @throws IOException
+     *             if the FM hardware failed to start
+     * @throws SecurityException
+     *             if the FM_RADIO_TRANSMITTER permission is not present
+     * @see FmBand
+     */
+    public abstract void startAsync(FmBand band) throws IOException;
+
+    /**
+     * Starts reception of the FM hardware. This is a synchronous method and the
+     * method call will block until the hardware is started.
+     * <p>
+     * When calling this method, an FmBand parameter must be passed that
+     * describes the properties of the band that the FmTransmitter should
+     * prepare for. If the band is null, invalid or not supported, an exception
+     * will be thrown.
+     * </p>
+     * <p>
+     * If the FmReceiver is active it will be forced to reset. See
+     * {@link FmReceiver#RESET_TX_IN_USE}.
+     * </p>
+     *
+     * @param band
+     *            the band to use
+     * @throws IllegalArgumentException
+     *             if the band is null
+     * @throws UnsupportedOperationException
+     *             if the band is not supported by the hardware
+     * @throws IllegalStateException
+     *             if it is called in an invalid state
+     * @throws IOException
+     *             if the FM hardware failed to start
+     * @throws SecurityException
+     *             if the FM_RADIO_TRANSMITTER permission is not present
+     * @see FmBand
+     */
+    public abstract void start(FmBand band) throws IOException;
+
+    /**
+     * Resumes FM transmission.
+     * <p>
+     * Calling this method when the FmTransmitter is in started state has no
+     * affect.
+     * </p>
+     *
+     * @throws IllegalStateException
+     *             if it is called in an invalid state
+     * @throws IOException
+     *             if the FM hardware failed to resume
+     * @throws SecurityException
+     *             if the FM_RADIO_TRANSMITTER permission is not present
+     */
+    public abstract void resume() throws IOException;
+
+    /**
+     * Pauses FM transmission. No signals are sent when the FmTransmitter is
+     * paused. Call {@link #resume()} to resume transmission. The hardware
+     * should be able to start transmission quickly from the paused state to
+     * give a good user experience.
+     * <p>
+     * Note that the hardware provider may choose to turn off the hardware after
+     * being paused a certain amount of time to save power. This will be
+     * reported in {@link OnForcedResetListener#onForcedReset(int)} with reason
+     * {@link #RESET_NON_CRITICAL} and the FmTransmitter will be set to the idle
+     * state.
+     * </p>
+     * <p>
+     * Calling this method when the FmTransmitter is in paused state has no
+     * affect.
+     * </p>
+     *
+     * @throws IllegalStateException
+     *             if it is called in an invalid state
+     * @throws IOException
+     *             if the FM hardware failed to pause
+     * @throws SecurityException
+     *             if the FM_RADIO_TRANSMITTER permission is not present
+     */
+    public abstract void pause() throws IOException;
+
+    /**
+     * Resets the FmTransmitter to its idle state.
+     *
+     * @throws IOException
+     *             if the FM hardware failed to reset
+     * @throws SecurityException
+     *             if the FM_RADIO_TRANSMITTER permission is not present
+     */
+    public abstract void reset() throws IOException;
+
+    /**
+     * Returns the state of the FmTransmitter.
+     *
+     * @return One of {@link #STATE_IDLE}, {@link #STATE_STARTING},
+     *         {@link #STATE_STARTED}, {@link #STATE_PAUSED},
+     *         {@link #STATE_SCANNING}
+     * @throws SecurityException
+     *             if the FM_RADIO_TRANSMITTER permission is not present
+     */
+    public abstract int getState();
+
+    /**
+     * Sets the output frequency. The frequency must be within the band that the
+     * FmTransmitter prepared for.
+     *
+     * @param frequency
+     *            the output frequency to use in kHz
+     * @throws IllegalArgumentException
+     *             if the frequency is not supported
+     * @throws IllegalStateException
+     *             if it is called in an invalid state
+     * @throws IOException
+     *             if the FM hardware failed to set frequency
+     * @throws SecurityException
+     *             if the FM_RADIO_TRANSMITTER permission is not present
+     */
+    public abstract void setFrequency(int frequency) throws IOException;
+
+    /**
+     * Returns the output frequency.
+     *
+     * @return the output frequency in kHz
+     *
+     * @throws IllegalStateException
+     *             if it is called in an invalid state
+     * @throws IOException
+     *             if the FM hardware failed to get the frequency
+     * @throws SecurityException
+     *             if the FM_RADIO_TRANSMITTER permission is not present
+     */
+    public abstract int getFrequency() throws IOException;
+
+    /**
+     * Sets the RDS data to transmit. See RDS table in FmReceiver for data that
+     * can be set.
+     *
+     * @param rdsData
+     *            the RDS data to transmit, set to null to disable RDS
+     *            transmission
+     * @throws IllegalArgumentException
+     *             if the rdsData parameter has invalid syntax
+     * @throws IllegalStateException
+     *             if it is called in an invalid state
+     * @throws SecurityException
+     *             if the FM_RADIO_TRANSMITTER permission is not present
+     */
+    public abstract void setRdsData(Bundle rdsData);
+
+    /**
+     * Returns true if the hardware/implementation supports block scan. If true
+     * the {@link FmTransmitter#startBlockScan(int, int)} will work.
+     * <p>
+     * The motivation for having this function is that an application can take
+     * this capability into account when laying out its UI.
+     * </p>
+     *
+     * @return true if block scan is supported by the FmTransmitter, false
+     *         otherwise
+     * @throws SecurityException
+     *             if the FM_RADIO_TRANSMITTER permission is not present
+     */
+    public abstract boolean isBlockScanSupported();
+
+    /**
+     * Starts a block scan. The tuner will scan the frequency band between
+     * startFrequency and endFrequency for unused frequencies. The application
+     * should register for callbacks using
+     * {@link #addOnScanListener(OnScanListener)} to receive a callback when
+     * frequencies are found.
+     * <p>
+     * If the application wants to stop the block scan, a call to
+     * {@link #stopScan()} should be made.
+     * </p>
+     *
+     * @param startFrequency
+     *            the frequency to start the block scan
+     * @param endFrequency
+     *            the frequency to end the block scan
+     * @throws IllegalArgumentException
+     *             if the startFrequency or endFrequency it not within the
+     *             currently used FmBand
+     * @throws UnsupportedOperationException
+     *             if the hardware/implementation does not supports block scan
+     * @throws IllegalStateException
+     *             if it is called in an invalid state
+     * @throws SecurityException
+     *             if the FM_RADIO_TRANSMITTER permission is not present
+     */
+    public abstract void startBlockScan(int startFrequency, int endFrequency);
+
+    /**
+     * Stops performing a scan operation. The hardware might continue the scan
+     * for an unspecified amount of time after this method is called. Once the
+     * scan has stopped, it will be notified via {@link OnScanListener}.
+     * <p>
+     * Note that this method has no affect if called in other states than the
+     * scanning state.
+     * </p>
+     *
+     * @throws SecurityException
+     *             if the FM_RADIO_TRANSMITTER permission is not present
+     */
+    public abstract void stopScan();
+
+    /**
+     * This method can be used to send vendor specific commands. These commands
+     * must not follow any common design for all vendors, and information about
+     * the commands that a vendor implements is out of scope in this API.
+     * <p>
+     * However, one command must be supported by all vendors that implements
+     * vendor specific commands, the <i>vendor_information</i> command. In the
+     * Bundle parameter in
+     * {@link OnExtraCommandListener#onExtraCommand(String, Bundle)} the FM
+     * radio device name and version can be extracted according to the table
+     * below.
+     * </p>
+     * <table border="1">
+     * <tr>
+     * <th>key name</th>
+     * <th>value type</th>
+     * </tr>
+     * <tr>
+     * <td>device_name</td>
+     * <td>string</td>
+     * </tr>
+     * <tr>
+     * <td>device_version</td>
+     * <td>string</td>
+     * </tr>
+     * </table>
+     *
+     * @param command
+     *            the command to send
+     * @param extras
+     *            extra parameters to the command
+     * @return true if the command was accepted, otherwise false
+     *
+     * @throws SecurityException
+     *             if the FM_RADIO_TRANSMITTER permission is not present
+     */
+    public abstract boolean sendExtraCommand(String command, String[] extras);
+
+    /**
+     * Register a callback to be invoked when the FmTransmitter is started.
+     *
+     * @param listener
+     *            the callback that will be run
+     * @throws SecurityException
+     *             if the FM_RADIO_TRANSMITTER permission is not present
+     */
+    public abstract void addOnStartedListener(OnStartedListener listener);
+
+    /**
+     * Unregister a callback to be invoked when the FmTransmitter is started.
+     *
+     * @param listener
+     *            the callback to remove
+     * @throws SecurityException
+     *             if the FM_RADIO_TRANSMITTER permission is not present
+     */
+    public abstract void removeOnStartedListener(OnStartedListener listener);
+
+    /**
+     * Register a callback to be invoked during a scan.
+     *
+     * @param listener
+     *            the callback that will be run
+     * @throws SecurityException
+     *             if the FM_RADIO_TRANSMITTER permission is not present
+     */
+    public abstract void addOnScanListener(OnScanListener listener);
+
+    /**
+     * Unregister a callback to be invoked during a scan.
+     *
+     * @param listener
+     *            the callback to remove
+     * @throws SecurityException
+     *             if the FM_RADIO_TRANSMITTER permission is not present
+     */
+    public abstract void removeOnScanListener(OnScanListener listener);
+
+    /**
+     * Register a callback to be invoked when an error has happened during an
+     * asynchronous operation.
+     *
+     * @param listener
+     *            the callback that will be run
+     * @throws SecurityException
+     *             if the FM_RADIO_TRANSMITTER permission is not present
+     */
+    public abstract void addOnErrorListener(OnErrorListener listener);
+
+    /**
+     * Unregister a callback to be invoked when an error has happened during an
+     * asynchronous operation.
+     *
+     * @param listener
+     *            the callback to remove
+     * @throws SecurityException
+     *             if the FM_RADIO_TRANSMITTER permission is not present
+     */
+    public abstract void removeOnErrorListener(OnErrorListener listener);
+
+    /**
+     * Register a callback to be invoked when the FmTransmitter is forced to
+     * pause due to external reasons.
+     *
+     * @param listener
+     *            the callback that will be run
+     * @throws SecurityException
+     *             if the FM_RADIO_TRANSMITTER permission is not present
+     */
+    public abstract void addOnForcedPauseListener(OnForcedPauseListener listener);
+
+    /**
+     * Unregister a callback to be invoked when the FmTransmitter is forced to
+     * pause due to external reasons.
+     *
+     * @param listener
+     *            the callback to remove
+     * @throws SecurityException
+     *             if the FM_RADIO_TRANSMITTER permission is not present
+     */
+    public abstract void removeOnForcedPauseListener(OnForcedPauseListener listener);
+
+    /**
+     * Register a callback to be invoked when the FmTransmitter is forced to
+     * reset due to external reasons.
+     *
+     * @param listener
+     *            the callback that will be run
+     * @throws SecurityException
+     *             if the FM_RADIO_TRANSMITTER permission is not present
+     */
+    public abstract void addOnForcedResetListener(OnForcedResetListener listener);
+
+    /**
+     * Unregister a callback to be invoked when the FmTransmitter is forced to
+     * reset due to external reasons.
+     *
+     * @param listener
+     *            the callback to remove
+     * @throws SecurityException
+     *             if the FM_RADIO_TRANSMITTER permission is not present
+     */
+    public abstract void removeOnForcedResetListener(OnForcedResetListener listener);
+
+    /**
+     * Register a callback to be invoked when the FmTransmitter changes state.
+     * Having a listener registered to this method may cause frequent callbacks,
+     * hence it is good practice to only have a listener registered for this
+     * when necessary.
+     *
+     * @param listener
+     *            the callback that will be run
+     * @throws SecurityException
+     *             if the FM_RADIO_TRANSMITTER permission is not present
+     */
+    public abstract void addOnStateChangedListener(OnStateChangedListener listener);
+
+    /**
+     * Unregister a callback to be invoked when the FmTransmitter changes state.
+     *
+     * @param listener
+     *            the callback to remove
+     * @throws SecurityException
+     *             if the FM_RADIO_TRANSMITTER permission is not present
+     */
+    public abstract void removeOnStateChangedListener(OnStateChangedListener listener);
+
+    /**
+     * Register a callback to be invoked when the FmTransmitter want's to invoke
+     * a vendor specific callback.
+     *
+     * @param listener
+     *            the callback that will be run
+     * @throws SecurityException
+     *             if the FM_RADIO_TRANSMITTER permission is not present
+     */
+    public abstract void addOnExtraCommandListener(OnExtraCommandListener listener);
+    /**
+     * Unregister a callback to be invoked when the FmTransmitter want's to
+     * invoke a vendor specific callback.
+     *
+     * @param listener
+     *            the callback to remove
+     * @throws SecurityException
+     *             if the FM_RADIO_TRANSMITTER permission is not present
+     */
+    public abstract void removeOnExtraCommandListener(OnExtraCommandListener listener);
+
+    /**
+     * Interface definition of a callback to be invoked when the FmTransmitter
+     * is started.
+     */
+    public interface OnStartedListener {
+        /**
+         * Called when the FmTransmitter is started. The FmTransmitter is now
+         * transmitting FM radio.
+         */
+        void onStarted();
+    }
+
+    /**
+     * Interface definition of a callback to be invoked when a scan operation is
+     * complete.
+     */
+    public interface OnScanListener {
+        /**
+         * Called when the block scan is completed.
+         * <p>
+         * If the block scan is aborted with stopScan, this will be indicated
+         * with the aborted argument.
+         * <p>
+         * If an error occurs during a block scan, it will be reported via
+         * {@link OnErrorListener#onError()} and this method callback will not
+         * be invoked.
+         * </p>
+         *
+         * @param frequency
+         *            the frequency in kHz where the channel was found
+         * @param signalStrength
+         *            the signal strength, 0-1000
+         * @param aborted
+         *            true if the block scan was aborted, false otherwise
+         */
+        void onBlockScan(int[] frequency, int[] signalStrength, boolean aborted);
+    }
+
+    /**
+     * Interface definition of a callback to be invoked when there has been an
+     * error during an asynchronous operation.
+     */
+    public interface OnErrorListener {
+        /**
+         * Called to indicate an error.
+         */
+        void onError();
+    }
+
+    /**
+     * Interface definition of a callback to be invoked when the FmTransmitter
+     * was forced to pause due to external reasons.
+     */
+    public interface OnForcedPauseListener {
+        /**
+         * Called when an external reason caused the FmTransmitter to pause.
+         * When this callback is received, the FmTransmitter is still able to
+         * resume transmission by calling {@link FmTransmitter#resume()}.
+         */
+        void onForcedPause();
+    }
+
+    /**
+     * Interface definition of a callback to be invoked when the FmTransmitter
+     * was forced to reset due to external reasons.
+     */
+    public interface OnForcedResetListener {
+        /**
+         * Called when an external reason caused the FmTransmitter to reset. The
+         * application that uses the FmTransmitter should take action according
+         * to the reason for resetting.
+         *
+         * @param reason
+         *            reason why the FmTransmitter reset:
+         *            <ul>
+         *            <li>{@link FmTransmitter#RESET_NON_CRITICAL}
+         *            <li>{@link FmTransmitter#RESET_CRITICAL}
+         *            <li>{@link FmTransmitter#RESET_RX_IN_USE}
+         *            <li>{@link FmTransmitter#RESET_RADIO_FORBIDDEN}
+         *            </ul>
+         */
+        void onForcedReset(int reason);
+    }
+
+    /**
+     * Interface definition of a callback to be invoked when the FmTransmitter
+     * changes state.
+     */
+    public interface OnStateChangedListener {
+        /**
+         * Called when the state is changed in the FmTransmitter. This is useful
+         * if an application want's to monitor the FmTransmitter state.
+         *
+         * @param oldState
+         *            the old state of the FmTransmitter
+         * @param newState
+         *            the new state of the FmTransmitter
+         */
+        void onStateChanged(int oldState, int newState);
+    }
+
+    /**
+     * Interface definition of a callback to be invoked when the FmTransmitter
+     * responds to a vendor specific command.
+     */
+    public interface OnExtraCommandListener {
+        /**
+         * Called when the FmTransmitter responds to a vendor specific command.
+         *
+         * @param response
+         *            the command the FmTransmitter responds to
+         * @param extras
+         *            extra parameters to the command
+         */
+        void onExtraCommand(String response, Bundle extras);
+    }
+}
diff --git a/fmradio/java/com/stericsson/hardware/fm/FmTransmitterImpl.java b/fmradio/java/com/stericsson/hardware/fm/FmTransmitterImpl.java
new file mode 100644
index 0000000..0dbb005
--- /dev/null
+++ b/fmradio/java/com/stericsson/hardware/fm/FmTransmitterImpl.java
@@ -0,0 +1,703 @@
+/*
+ * Copyright (C) ST-Ericsson SA 2010
+ * Copyright (C) 2010 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+ * Author: Bjorn Pileryd (bjorn.pileryd@sonyericsson.com)
+ * Author: Markus Grape (markus.grape@stericsson.com) for ST-Ericsson
+ * Author: Andreas Gustafsson (andreas.a.gustafsson@stericsson.com) for ST-Ericsson
+ */
+
+package com.stericsson.hardware.fm;
+
+import android.content.Context;
+import android.os.Bundle;
+import android.os.Handler;
+import android.os.Message;
+import android.os.RemoteException;
+import android.util.Log;
+
+import java.io.IOException;
+import java.util.HashMap;
+
+/**
+ * The implementation of the FmReceiver.
+ *
+ * @hide
+ */
+public class FmTransmitterImpl extends FmTransmitter {
+
+    private static final String TAG = "FmTransmitter";
+
+    private IFmTransmitter mService;
+
+    /**
+     * Save the FmBand used to be able to validate frequencies.
+     */
+    private FmBand mBand;
+
+    /**
+     * Map from OnStateChanged to their associated ListenerTransport objects.
+     */
+    private HashMap<OnStateChangedListener, OnStateChangedListenerTransport> mOnStateChanged =
+        new HashMap<OnStateChangedListener, OnStateChangedListenerTransport>();
+
+    /**
+     * Map from OnStarted to their associated ListenerTransport objects.
+     */
+    private HashMap<OnStartedListener, OnStartedListenerTransport> mOnStarted =
+        new HashMap<OnStartedListener, OnStartedListenerTransport>();
+
+    /**
+     * Map from OnError to their associated ListenerTransport objects.
+     */
+    private HashMap<OnErrorListener, OnErrorListenerTransport> mOnError =
+        new HashMap<OnErrorListener, OnErrorListenerTransport>();
+
+    /**
+     * Map from OnBlockScan to their associated ListenerTransport objects.
+     */
+    private HashMap<OnScanListener, OnBlockScanListenerTransport> mOnBlockScan =
+        new HashMap<OnScanListener, OnBlockScanListenerTransport>();
+
+    /**
+     * Map from OnForcedPause to their associated ListenerTransport objects.
+     */
+    private HashMap<OnForcedPauseListener, OnForcedPauseListenerTransport> mOnForcedPause =
+        new HashMap<OnForcedPauseListener, OnForcedPauseListenerTransport>();
+
+    /**
+     * Map from OnForcedReset to their associated ListenerTransport objects.
+     */
+    private HashMap<OnForcedResetListener, OnForcedResetListenerTransport> mOnForcedReset =
+        new HashMap<OnForcedResetListener, OnForcedResetListenerTransport>();
+
+    /**
+     * Map from OnExtraCommand to their associated ListenerTransport objects.
+     */
+    private HashMap<OnExtraCommandListener, OnExtraCommandListenerTransport> mOnExtraCommand =
+        new HashMap<OnExtraCommandListener, OnExtraCommandListenerTransport>();
+
+    private static class OnStateChangedListenerTransport extends IOnStateChangedListener.Stub {
+        private static final int TYPE_ON_STATE_CHANGED = 1;
+
+        private OnStateChangedListener mListener;
+        private final Handler mListenerHandler;
+
+        OnStateChangedListenerTransport(OnStateChangedListener listener) {
+            mListener = listener;
+
+            mListenerHandler = new Handler() {
+                @Override
+                public void handleMessage(Message msg) {
+                    _handleMessage(msg);
+                }
+            };
+        }
+
+        public void onStateChanged(int oldState, int newState) {
+            Message msg = Message.obtain();
+            msg.what = TYPE_ON_STATE_CHANGED;
+            Bundle b = new Bundle();
+            b.putInt("oldState", oldState);
+            b.putInt("newState", newState);
+            msg.obj = b;
+            mListenerHandler.sendMessage(msg);
+        }
+
+        private void _handleMessage(Message msg) {
+            switch (msg.what) {
+            case TYPE_ON_STATE_CHANGED:
+                Bundle b = (Bundle) msg.obj;
+                int oldState = b.getInt("oldState");
+                int newState = b.getInt("newState");
+                mListener.onStateChanged(oldState, newState);
+                break;
+            }
+        }
+    }
+
+    private static class OnStartedListenerTransport extends IOnStartedListener.Stub {
+        private static final int TYPE_ON_STARTED = 1;
+
+        private OnStartedListener mListener;
+        private final Handler mListenerHandler;
+
+        OnStartedListenerTransport(OnStartedListener listener) {
+            mListener = listener;
+
+            mListenerHandler = new Handler() {
+                @Override
+                public void handleMessage(Message msg) {
+                    _handleMessage(msg);
+                }
+            };
+        }
+
+        public void onStarted() {
+            Message msg = Message.obtain();
+            msg.what = TYPE_ON_STARTED;
+            mListenerHandler.sendMessage(msg);
+        }
+
+        private void _handleMessage(Message msg) {
+            switch (msg.what) {
+            case TYPE_ON_STARTED:
+                mListener.onStarted();
+                break;
+            }
+        }
+    }
+
+    private static class OnErrorListenerTransport extends IOnErrorListener.Stub {
+        private static final int TYPE_ON_ERROR = 1;
+
+        private OnErrorListener mListener;
+        private final Handler mListenerHandler;
+
+        OnErrorListenerTransport(OnErrorListener listener) {
+            mListener = listener;
+
+            mListenerHandler = new Handler() {
+                @Override
+                public void handleMessage(Message msg) {
+                    _handleMessage(msg);
+                }
+            };
+        }
+
+        public void onError() {
+            Message msg = Message.obtain();
+            msg.what = TYPE_ON_ERROR;
+            mListenerHandler.sendMessage(msg);
+        }
+
+        private void _handleMessage(Message msg) {
+            switch (msg.what) {
+            case TYPE_ON_ERROR:
+                mListener.onError();
+                break;
+            }
+        }
+    }
+
+    private static class OnBlockScanListenerTransport extends IOnBlockScanListener.Stub {
+        private static final int TYPE_ON_BLOCKSCAN = 1;
+
+        private OnScanListener mListener;
+        private final Handler mListenerHandler;
+
+        OnBlockScanListenerTransport(OnScanListener listener) {
+            mListener = listener;
+
+            mListenerHandler = new Handler() {
+                @Override
+                public void handleMessage(Message msg) {
+                    _handleMessage(msg);
+                }
+            };
+        }
+
+        public void onBlockScan(int[] frequency, int[] signalStrength, boolean aborted) {
+            Message msg = Message.obtain();
+            msg.what = TYPE_ON_BLOCKSCAN;
+            Bundle b = new Bundle();
+            b.putIntArray("frequency", frequency);
+            b.putIntArray("signalStrength", signalStrength);
+            b.putBoolean("aborted", aborted);
+            msg.obj = b;
+            mListenerHandler.sendMessage(msg);
+        }
+
+        private void _handleMessage(Message msg) {
+
+            switch (msg.what) {
+            case TYPE_ON_BLOCKSCAN:
+                Bundle b = (Bundle) msg.obj;
+                int[] frequency = b.getIntArray("frequency");
+                int[] signalStrengths = b.getIntArray("signalStrength");
+                boolean aborted = b.getBoolean("aborted");
+                mListener.onBlockScan(frequency, signalStrengths, aborted);
+                break;
+            }
+        }
+    }
+
+    private static class OnForcedPauseListenerTransport extends IOnForcedPauseListener.Stub {
+        private static final int TYPE_ON_FORCEDPAUSE = 1;
+
+        private OnForcedPauseListener mListener;
+        private final Handler mListenerHandler;
+
+        OnForcedPauseListenerTransport(OnForcedPauseListener listener) {
+            mListener = listener;
+
+            mListenerHandler = new Handler() {
+                @Override
+                public void handleMessage(Message msg) {
+                    _handleMessage(msg);
+                }
+            };
+        }
+
+        public void onForcedPause() {
+            Message msg = Message.obtain();
+            msg.what = TYPE_ON_FORCEDPAUSE;
+            mListenerHandler.sendMessage(msg);
+        }
+
+        private void _handleMessage(Message msg) {
+            switch (msg.what) {
+            case TYPE_ON_FORCEDPAUSE:
+                mListener.onForcedPause();
+                break;
+            }
+        }
+    }
+
+    private static class OnForcedResetListenerTransport extends IOnForcedResetListener.Stub {
+        private static final int TYPE_ON_FORCEDRESET = 1;
+
+        private OnForcedResetListener mListener;
+        private final Handler mListenerHandler;
+
+        OnForcedResetListenerTransport(OnForcedResetListener listener) {
+            mListener = listener;
+
+            mListenerHandler = new Handler() {
+                @Override
+                public void handleMessage(Message msg) {
+                    _handleMessage(msg);
+                }
+            };
+        }
+
+        public void onForcedReset(int reason) {
+            Message msg = Message.obtain();
+            msg.what = TYPE_ON_FORCEDRESET;
+            Bundle b = new Bundle();
+            b.putInt("reason", reason);
+            msg.obj = b;
+            mListenerHandler.sendMessage(msg);
+        }
+
+        private void _handleMessage(Message msg) {
+            switch (msg.what) {
+            case TYPE_ON_FORCEDRESET:
+                Bundle b = (Bundle) msg.obj;
+                int reason = b.getInt("reason");
+                mListener.onForcedReset(reason);
+                break;
+            }
+        }
+    }
+
+    private static class OnExtraCommandListenerTransport extends IOnExtraCommandListener.Stub {
+        private static final int TYPE_ON_EXTRA_COMMAND = 1;
+
+        private OnExtraCommandListener mListener;
+        private final Handler mListenerHandler;
+
+        OnExtraCommandListenerTransport(OnExtraCommandListener listener) {
+            mListener = listener;
+
+            mListenerHandler = new Handler() {
+                @Override
+                public void handleMessage(Message msg) {
+                    _handleMessage(msg);
+                }
+            };
+        }
+
+        public void onExtraCommand(String response, Bundle extras) {
+            Message msg = Message.obtain();
+            msg.what = TYPE_ON_EXTRA_COMMAND;
+            Bundle b = new Bundle();
+            b.putString("response", response);
+            b.putBundle("extras", extras);
+            msg.obj = b;
+            mListenerHandler.sendMessage(msg);
+        }
+
+        private void _handleMessage(Message msg) {
+            Bundle b;
+            boolean aborted;
+
+            switch (msg.what) {
+            case TYPE_ON_EXTRA_COMMAND:
+                b = (Bundle) msg.obj;
+                String response = b.getString("response");
+                Bundle extras = b.getBundle("extras");
+                mListener.onExtraCommand(response, extras);
+                break;
+            }
+        }
+    }
+
+    /**
+     * Creates a new FmTransmitter instance. Applications will almost always
+     * want to use {@link android.content.Context#getSystemService
+     * Context.getSystemService()} to retrieve the standard
+     * {@link android.content.Context "fm_transmitter"}.
+     *
+     * @param service
+     *            the Binder interface
+     * @hide - hide this because it takes in a parameter of type IFmReceiver,
+     *       which is a system private class.
+     */
+    public FmTransmitterImpl(IFmTransmitter service) {
+        mService = service;
+    }
+
+    @Override
+    public void startAsync(FmBand band) throws IOException {
+        if (band == null) {
+            throw new IllegalArgumentException("Band cannot be null");
+        }
+        try {
+            mService.startAsync(band);
+            mBand = band;
+        } catch (RemoteException ex) {
+            Log.e(TAG, "startAsync: RemoteException", ex);
+        }
+    }
+
+    @Override
+    public void start(FmBand band) throws IOException {
+        if (band == null) {
+            throw new IllegalArgumentException("Band cannot be null");
+        }
+        try {
+            mService.start(band);
+            mBand = band;
+        } catch (RemoteException ex) {
+            Log.e(TAG, "start: RemoteException", ex);
+        }
+    }
+
+    @Override
+    public void resume() throws IOException {
+        try {
+            mService.resume();
+        } catch (RemoteException ex) {
+            Log.e(TAG, "resume: RemoteException", ex);
+        }
+    }
+
+    @Override
+    public void pause() throws IOException {
+        try {
+            mService.pause();
+        } catch (RemoteException ex) {
+            Log.e(TAG, "pause: RemoteException", ex);
+        }
+    }
+
+    @Override
+    public void reset() throws IOException {
+        try {
+            mService.reset();
+            mBand = null;
+        } catch (RemoteException ex) {
+            Log.e(TAG, "reset: RemoteException", ex);
+        }
+    }
+
+    @Override
+    public int getState() {
+        try {
+            return mService.getState();
+        } catch (RemoteException ex) {
+            Log.e(TAG, "getState: RemoteException", ex);
+            return STATE_IDLE;
+        }
+    }
+
+    @Override
+    public void setFrequency(int frequency) throws IOException {
+        if (mBand != null && !mBand.isFrequencyValid(frequency)) {
+            throw new IllegalArgumentException(
+                    "Frequency is not valid in this band.");
+        }
+        try {
+            mService.setFrequency(frequency);
+        } catch (RemoteException ex) {
+            Log.e(TAG, "setFrequency: RemoteException", ex);
+        }
+    }
+
+    @Override
+    public int getFrequency() throws IOException {
+        try {
+            return mService.getFrequency();
+        } catch (RemoteException ex) {
+            Log.e(TAG, "getFrequency: RemoteException", ex);
+            return FmBand.FM_FREQUENCY_UNKNOWN;
+        }
+    }
+
+    @Override
+    public void setRdsData(Bundle rdsData) {
+        try {
+            mService.setRdsData(rdsData);
+        } catch (RemoteException ex) {
+            Log.e(TAG, "setRdsData: RemoteException", ex);
+        }
+    }
+
+    @Override
+    public boolean isBlockScanSupported() {
+        try {
+            return mService.isBlockScanSupported();
+        } catch (RemoteException ex) {
+            Log.e(TAG, "isBlockScanSupported: RemoteException", ex);
+            return false;
+        }
+    }
+
+    @Override
+    public void startBlockScan(int startFrequency, int endFrequency) {
+        try {
+            mService.startBlockScan(startFrequency, endFrequency);
+        } catch (RemoteException ex) {
+            Log.e(TAG, "startBlockScan: RemoteException", ex);
+        }
+    }
+
+    @Override
+    public void stopScan() {
+        try {
+            mService.stopScan();
+        } catch (RemoteException ex) {
+            Log.e(TAG, "stopScan: RemoteException", ex);
+        }
+    }
+
+    @Override
+    public boolean sendExtraCommand(String command, String[] extras) {
+        try {
+            return mService.sendExtraCommand(command, extras);
+        } catch (RemoteException ex) {
+            Log.e(TAG, "sendExtraCommand: RemoteException", ex);
+            return false;
+        }
+    }
+
+    @Override
+    public void addOnStartedListener(OnStartedListener listener) {
+        if (mOnStarted.get(listener) != null) {
+            // listener is already registered
+            return;
+        }
+        try {
+            synchronized (mOnStarted) {
+                OnStartedListenerTransport transport = new OnStartedListenerTransport(listener);
+                mService.addOnStartedListener(transport);
+                mOnStarted.put(listener, transport);
+            }
+        } catch (RemoteException ex) {
+            Log.e(TAG, "addOnStartedListener: RemoteException", ex);
+        }
+    }
+
+    @Override
+    public void removeOnStartedListener(OnStartedListener listener) {
+        try {
+            OnStartedListenerTransport transport = mOnStarted.remove(listener);
+            if (transport != null) {
+                mService.removeOnStartedListener(transport);
+            }
+        } catch (RemoteException ex) {
+            Log.e(TAG, "removeOnStartedListener: DeadObjectException", ex);
+        }
+    }
+
+    @Override
+    public void addOnScanListener(OnScanListener listener) {
+        if (mOnBlockScan.get(listener) != null) {
+            // listener is already registered
+            return;
+        }
+        try {
+            synchronized (mOnBlockScan) {
+                OnBlockScanListenerTransport transport = new OnBlockScanListenerTransport(listener);
+                mService.addOnBlockScanListener(transport);
+                mOnBlockScan.put(listener, transport);
+            }
+        } catch (RemoteException ex) {
+            Log.e(TAG, "addOnScanListener: RemoteException", ex);
+        }
+    }
+
+    @Override
+    public void removeOnScanListener(OnScanListener listener) {
+        try {
+            OnBlockScanListenerTransport transport = mOnBlockScan.remove(listener);
+            if (transport != null) {
+                mService.removeOnBlockScanListener(transport);
+            }
+        } catch (RemoteException ex) {
+            Log.e(TAG, "removeOnScanListener: DeadObjectException", ex);
+        }
+    }
+
+    @Override
+    public void addOnErrorListener(OnErrorListener listener) {
+        if (mOnError.get(listener) != null) {
+            // listener is already registered
+            return;
+        }
+        try {
+            synchronized (mOnError) {
+                OnErrorListenerTransport transport = new OnErrorListenerTransport(listener);
+                mService.addOnErrorListener(transport);
+                mOnError.put(listener, transport);
+            }
+        } catch (RemoteException ex) {
+            Log.e(TAG, "addOnErrorListener: RemoteException", ex);
+        }
+    }
+
+    @Override
+    public void removeOnErrorListener(OnErrorListener listener) {
+        try {
+            OnErrorListenerTransport transport = mOnError.remove(listener);
+            if (transport != null) {
+                mService.removeOnErrorListener(transport);
+            }
+        } catch (RemoteException ex) {
+            Log.e(TAG, "removeOnErrorListener: DeadObjectException", ex);
+        }
+    }
+
+    @Override
+    public void addOnForcedPauseListener(OnForcedPauseListener listener) {
+        if (mOnForcedPause.get(listener) != null) {
+            // listener is already registered
+            return;
+        }
+        try {
+            synchronized (mOnForcedPause) {
+                OnForcedPauseListenerTransport transport = new OnForcedPauseListenerTransport(
+                        listener);
+                mService.addOnForcedPauseListener(transport);
+                mOnForcedPause.put(listener, transport);
+            }
+        } catch (RemoteException ex) {
+            Log.e(TAG, "addOnForcedPauseListener: RemoteException", ex);
+        }
+    }
+
+    @Override
+    public void removeOnForcedPauseListener(OnForcedPauseListener listener) {
+        try {
+            OnForcedPauseListenerTransport transport = mOnForcedPause.remove(listener);
+            if (transport != null) {
+                mService.removeOnForcedPauseListener(transport);
+            }
+        } catch (RemoteException ex) {
+            Log.e(TAG, "removeOnForcedPauseListener: DeadObjectException", ex);
+        }
+    }
+
+    @Override
+    public void addOnForcedResetListener(OnForcedResetListener listener) {
+        if (mOnForcedReset.get(listener) != null) {
+            // listener is already registered
+            return;
+        }
+        try {
+            synchronized (mOnForcedReset) {
+                OnForcedResetListenerTransport transport = new OnForcedResetListenerTransport(
+                        listener);
+                mService.addOnForcedResetListener(transport);
+                mOnForcedReset.put(listener, transport);
+            }
+        } catch (RemoteException ex) {
+            Log.e(TAG, "addOnForcedResetListener: RemoteException", ex);
+        }
+    }
+
+    @Override
+    public void removeOnForcedResetListener(OnForcedResetListener listener) {
+        try {
+            OnForcedResetListenerTransport transport = mOnForcedReset.remove(listener);
+            if (transport != null) {
+                mService.removeOnForcedResetListener(transport);
+            }
+        } catch (RemoteException ex) {
+            Log.e(TAG, "removeOnForcedResetListener: DeadObjectException", ex);
+        }
+    }
+
+    @Override
+    public void addOnStateChangedListener(OnStateChangedListener listener) {
+        if (mOnStateChanged.get(listener) != null) {
+            // listener is already registered
+            return;
+        }
+        try {
+            synchronized (mOnStateChanged) {
+                OnStateChangedListenerTransport transport = new OnStateChangedListenerTransport(
+                        listener);
+                mService.addOnStateChangedListener(transport);
+                mOnStateChanged.put(listener, transport);
+            }
+        } catch (RemoteException ex) {
+            Log.e(TAG, "addOnStateChangedListener: RemoteException", ex);
+        }
+    }
+
+    @Override
+    public void removeOnStateChangedListener(OnStateChangedListener listener) {
+        try {
+            OnStateChangedListenerTransport transport = mOnStateChanged.remove(listener);
+            if (transport != null) {
+                mService.removeOnStateChangedListener(transport);
+            }
+        } catch (RemoteException ex) {
+            Log.e(TAG, "removeOnStateChangedListener: DeadObjectException", ex);
+        }
+    }
+
+    @Override
+    public void addOnExtraCommandListener(OnExtraCommandListener listener) {
+        if (mOnExtraCommand.get(listener) != null) {
+            // listener is already registered
+            return;
+        }
+        try {
+            synchronized (mOnExtraCommand) {
+                OnExtraCommandListenerTransport transport = new OnExtraCommandListenerTransport(
+                        listener);
+                mService.addOnExtraCommandListener(transport);
+                mOnExtraCommand.put(listener, transport);
+            }
+        } catch (RemoteException ex) {
+            Log.e(TAG, "addOnExtraCommandListener: RemoteException", ex);
+        }
+    }
+
+    @Override
+    public void removeOnExtraCommandListener(OnExtraCommandListener listener) {
+        try {
+            OnExtraCommandListenerTransport transport = mOnExtraCommand.remove(listener);
+            if (transport != null) {
+                mService.removeOnExtraCommandListener(transport);
+            }
+        } catch (RemoteException ex) {
+            Log.e(TAG, "removeOnExtraCommandListener: DeadObjectException", ex);
+        }
+    }
+}
diff --git a/fmradio/java/com/stericsson/hardware/fm/FmTransmitterService.java b/fmradio/java/com/stericsson/hardware/fm/FmTransmitterService.java
new file mode 100644
index 0000000..006f51c
--- /dev/null
+++ b/fmradio/java/com/stericsson/hardware/fm/FmTransmitterService.java
@@ -0,0 +1,845 @@
+/*
+ * Copyright (C) ST-Ericsson SA 2010
+ * Copyright (C) 2010 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+ * Author: Markus Grape (markus.grape@stericsson.com) for ST-Ericsson
+ */
+
+package com.stericsson.hardware.fm;
+
+import android.content.BroadcastReceiver;
+import android.content.Context;
+import android.content.Intent;
+import android.content.IntentFilter;
+import android.content.pm.PackageManager;
+import android.os.Bundle;
+import android.os.IBinder;
+import android.os.Process;
+import android.os.RemoteException;
+import android.provider.Settings;
+import android.util.Log;
+import android.util.Slog;
+
+import java.util.Collection;
+import java.util.HashMap;
+import java.util.Iterator;
+
+/**
+ * The implementation of the FM transmitter service.
+ *
+ * @hide
+ */
+
+public class FmTransmitterService extends IFmTransmitter.Stub {
+
+    private static final String TAG = "FmTransmitterService";
+
+    private Context mContext;
+
+    private final HashMap<Object, OnStateChangedReceiver> mOnStateChangedReceivers =
+        new HashMap<Object, OnStateChangedReceiver>();
+
+    private final HashMap<Object, OnStartedReceiver> mOnStartedReceivers =
+        new HashMap<Object, OnStartedReceiver>();
+
+    private final HashMap<Object, OnErrorReceiver> mOnErrorReceivers =
+        new HashMap<Object, OnErrorReceiver>();
+
+    private final HashMap<Object, OnBlockScanReceiver> mOnBlockScanReceivers =
+        new HashMap<Object, OnBlockScanReceiver>();
+
+    private final HashMap<Object, OnForcedPauseReceiver> mOnForcedPauseReceivers =
+        new HashMap<Object, OnForcedPauseReceiver>();
+
+    private final HashMap<Object, OnForcedResetReceiver> mOnForcedResetReceivers =
+        new HashMap<Object, OnForcedResetReceiver>();
+
+    private final HashMap<Object, OnExtraCommandReceiver> mOnExtraCommandReceivers =
+        new HashMap<Object, OnExtraCommandReceiver>();
+
+    private final class OnStateChangedReceiver implements IBinder.DeathRecipient {
+        final IOnStateChangedListener mListener;
+        final Object mKey;
+
+        OnStateChangedReceiver(IOnStateChangedListener listener) {
+            mListener = listener;
+            mKey = listener.asBinder();
+        }
+
+        public IOnStateChangedListener getListener() {
+            return mListener;
+        }
+
+        public boolean callOnStateChanged(int oldState, int newState) {
+            try {
+                synchronized (this) {
+                    mListener.onStateChanged(oldState, newState);
+                }
+            } catch (RemoteException ex) {
+                Log.e(TAG, "callOnStateChanged: RemoteException", ex);
+                return false;
+            }
+            return true;
+        }
+
+        public void binderDied() {
+            Log.d(TAG, "FM transmitter listener died");
+
+            synchronized (mOnStateChangedReceivers) {
+                mOnStateChangedReceivers.remove(this.mKey);
+            }
+            if (mListener != null) {
+                mListener.asBinder().unlinkToDeath(this, 0);
+            }
+        }
+    }
+
+    private final class OnStartedReceiver implements IBinder.DeathRecipient {
+        final IOnStartedListener mListener;
+        final Object mKey;
+
+        OnStartedReceiver(IOnStartedListener listener) {
+            mListener = listener;
+            mKey = listener.asBinder();
+        }
+
+        public IOnStartedListener getListener() {
+            return mListener;
+        }
+
+        public boolean callOnStarted() {
+            try {
+                synchronized (this) {
+                    mListener.onStarted();
+                }
+            } catch (RemoteException ex) {
+                Log.e(TAG, "callOnStarted: RemoteException", ex);
+                return false;
+            }
+            return true;
+        }
+
+        public void binderDied() {
+            Log.d(TAG, "FM transmitter listener died");
+
+            synchronized (mOnStartedReceivers) {
+                mOnStartedReceivers.remove(this.mKey);
+            }
+            if (mListener != null) {
+                mListener.asBinder().unlinkToDeath(this, 0);
+            }
+        }
+    }
+
+    private final class OnErrorReceiver implements IBinder.DeathRecipient {
+        final IOnErrorListener mListener;
+        final Object mKey;
+
+        OnErrorReceiver(IOnErrorListener listener) {
+            mListener = listener;
+            mKey = listener.asBinder();
+        }
+
+        public IOnErrorListener getListener() {
+            return mListener;
+        }
+
+        public boolean callOnError() {
+            try {
+                synchronized (this) {
+                    mListener.onError();
+                }
+            } catch (RemoteException ex) {
+                Log.e(TAG, "callOnError: RemoteException", ex);
+                return false;
+            }
+            return true;
+        }
+
+        public void binderDied() {
+            Log.d(TAG, "FM transmitter listener died");
+
+            synchronized (mOnErrorReceivers) {
+                mOnErrorReceivers.remove(this.mKey);
+            }
+            if (mListener != null) {
+                mListener.asBinder().unlinkToDeath(this, 0);
+            }
+        }
+    }
+
+    private final class OnBlockScanReceiver implements IBinder.DeathRecipient {
+        final IOnBlockScanListener mListener;
+
+        final Object mKey;
+
+        OnBlockScanReceiver(IOnBlockScanListener listener) {
+            mListener = listener;
+            mKey = listener.asBinder();
+        }
+
+        public IOnBlockScanListener getListener() {
+            return mListener;
+        }
+
+        public boolean callOnBlockScan(int[] frequency, int[] signalLevel, boolean aborted) {
+            try {
+                synchronized (this) {
+                    mListener.onBlockScan(frequency, signalLevel, aborted);
+                }
+            } catch (RemoteException ex) {
+                Log.e(TAG, "callOnBlockScan: RemoteException", ex);
+                return false;
+            }
+            return true;
+        }
+
+        public void binderDied() {
+            Log.d(TAG, "FM receiver listener died");
+
+            synchronized (mOnBlockScanReceivers) {
+                mOnBlockScanReceivers.remove(this.mKey);
+            }
+            if (mListener != null) {
+                mListener.asBinder().unlinkToDeath(this, 0);
+            }
+        }
+    }
+
+    private final class OnForcedPauseReceiver implements IBinder.DeathRecipient {
+        final IOnForcedPauseListener mListener;
+        final Object mKey;
+
+        OnForcedPauseReceiver(IOnForcedPauseListener listener) {
+            mListener = listener;
+            mKey = listener.asBinder();
+        }
+
+        public IOnForcedPauseListener getListener() {
+            return mListener;
+        }
+
+        public boolean callOnForcedPause() {
+            try {
+                synchronized (this) {
+                    mListener.onForcedPause();
+                }
+            } catch (RemoteException ex) {
+                Log.e(TAG, "callOnForcedPause: RemoteException", ex);
+                return false;
+            }
+            return true;
+        }
+
+        public void binderDied() {
+            Log.d(TAG, "FM transmitter listener died");
+
+            synchronized (mOnForcedPauseReceivers) {
+                mOnForcedPauseReceivers.remove(this.mKey);
+            }
+            if (mListener != null) {
+                mListener.asBinder().unlinkToDeath(this, 0);
+            }
+        }
+    }
+
+    private final class OnForcedResetReceiver implements IBinder.DeathRecipient {
+        final IOnForcedResetListener mListener;
+        final Object mKey;
+
+        OnForcedResetReceiver(IOnForcedResetListener listener) {
+            mListener = listener;
+            mKey = listener.asBinder();
+        }
+
+        public IOnForcedResetListener getListener() {
+            return mListener;
+        }
+
+        public boolean callOnForcedReset(int reason) {
+            try {
+                synchronized (this) {
+                    mListener.onForcedReset(reason);
+                }
+            } catch (RemoteException ex) {
+                Log.e(TAG, "callOnForcedReset: RemoteException", ex);
+                return false;
+            }
+            return true;
+        }
+
+        public void binderDied() {
+            Log.d(TAG, "FM transmitter listener died");
+
+            synchronized (mOnForcedResetReceivers) {
+                mOnForcedResetReceivers.remove(this.mKey);
+            }
+            if (mListener != null) {
+                mListener.asBinder().unlinkToDeath(this, 0);
+            }
+        }
+    }
+
+    private final class OnExtraCommandReceiver implements IBinder.DeathRecipient {
+        final IOnExtraCommandListener mListener;
+
+        final Object mKey;
+
+        OnExtraCommandReceiver(IOnExtraCommandListener listener) {
+            mListener = listener;
+            mKey = listener.asBinder();
+        }
+
+        public IOnExtraCommandListener getListener() {
+            return mListener;
+        }
+
+        public boolean callOnExtraCommand(String response, Bundle extras) {
+            try {
+                synchronized (this) {
+                    mListener.onExtraCommand(response, extras);
+                }
+            } catch (RemoteException ex) {
+                Log.e(TAG, "callOnExtraCommand: RemoteException", ex);
+                return false;
+            }
+            return true;
+        }
+
+        public void binderDied() {
+            Log.d(TAG, "FM receiver listener died");
+
+            synchronized (mOnExtraCommandReceivers) {
+                mOnExtraCommandReceivers.remove(this.mKey);
+            }
+            if (mListener != null) {
+                mListener.asBinder().unlinkToDeath(this, 0);
+            }
+        }
+    }
+
+    private final BroadcastReceiver mReceiver = new BroadcastReceiver() {
+
+        @Override
+        public void onReceive(Context context, Intent intent) {
+            if (intent == null) {
+                return;
+            }
+
+            String action = intent.getAction();
+            if (action.equals(Intent.ACTION_AIRPLANE_MODE_CHANGED)) {
+                Log.d(TAG, "onReceive:ACTION_AIRPLANE_MODE_CHANGED");
+
+                // check that airplane mode is off
+                if (!isAirplaneModeOn()) {
+                    return;
+                }
+
+                // power down hardware
+                if (_fm_transmitter_reset() > FmTransmitter.STATE_IDLE) {
+                    notifyOnForcedReset(FmTransmitter.RESET_RADIO_FORBIDDEN);
+                }
+            }
+        }
+
+    };
+
+    /* Returns true if airplane mode is currently on */
+    private boolean isAirplaneModeOn() {
+        return Settings.System.getInt(mContext.getContentResolver(),
+                Settings.System.AIRPLANE_MODE_ON, 0) == 1;
+    }
+
+    public FmTransmitterService(Context context) {
+        Log.i(TAG, "FmTransmitterService created");
+        mContext = context;
+
+        // Register for airplane mode
+        IntentFilter filter = new IntentFilter();
+        filter.addAction(Intent.ACTION_AIRPLANE_MODE_CHANGED);
+        filter.addAction(Intent.ACTION_DOCK_EVENT);
+
+        mContext.registerReceiver(mReceiver, filter);
+
+    }
+
+    public void start(FmBand band) {
+        if (mContext.checkCallingOrSelfPermission(android.Manifest.permission.FM_RADIO_TRANSMITTER)
+                != PackageManager.PERMISSION_GRANTED) {
+            throw new SecurityException("Requires FM_RADIO_TRANSMITTER permission");
+        }
+
+        _fm_transmitter_start(band.getMinFrequency(), band.getMaxFrequency(), band
+                .getDefaultFrequency(), band.getChannelOffset());
+    }
+
+    public void startAsync(FmBand band) {
+        if (mContext.checkCallingOrSelfPermission(android.Manifest.permission.FM_RADIO_TRANSMITTER)
+                != PackageManager.PERMISSION_GRANTED) {
+            throw new SecurityException("Requires FM_RADIO_TRANSMITTER permission");
+        }
+
+        _fm_transmitter_startAsync(band.getMinFrequency(), band.getMaxFrequency(), band
+                .getDefaultFrequency(), band.getChannelOffset());
+    }
+
+    public void reset() {
+        if (mContext.checkCallingOrSelfPermission(android.Manifest.permission.FM_RADIO_TRANSMITTER)
+                != PackageManager.PERMISSION_GRANTED) {
+            throw new SecurityException("Requires FM_RADIO_TRANSMITTER permission");
+        }
+
+        _fm_transmitter_reset();
+    }
+
+    public void pause() {
+        if (mContext.checkCallingOrSelfPermission(android.Manifest.permission.FM_RADIO_TRANSMITTER)
+                != PackageManager.PERMISSION_GRANTED) {
+            throw new SecurityException("Requires FM_RADIO_TRANSMITTER permission");
+        }
+
+        _fm_transmitter_pause();
+    }
+
+    public void resume() {
+        if (mContext.checkCallingOrSelfPermission(android.Manifest.permission.FM_RADIO_TRANSMITTER)
+                != PackageManager.PERMISSION_GRANTED) {
+            throw new SecurityException("Requires FM_RADIO_TRANSMITTER permission");
+        }
+
+        _fm_transmitter_resume();
+    }
+
+    public int getState() {
+        if (mContext.checkCallingOrSelfPermission(android.Manifest.permission.FM_RADIO_TRANSMITTER)
+                != PackageManager.PERMISSION_GRANTED) {
+            throw new SecurityException("Requires FM_RADIO_TRANSMITTER permission");
+        }
+
+        return _fm_transmitter_getState();
+    }
+
+    public void setFrequency(int frequency) {
+        if (mContext.checkCallingOrSelfPermission(android.Manifest.permission.FM_RADIO_TRANSMITTER)
+                != PackageManager.PERMISSION_GRANTED) {
+            throw new SecurityException("Requires FM_RADIO_TRANSMITTER permission");
+        }
+
+        _fm_transmitter_setFrequency(frequency);
+    }
+
+    public int getFrequency() {
+        if (mContext.checkCallingOrSelfPermission(android.Manifest.permission.FM_RADIO_TRANSMITTER)
+                != PackageManager.PERMISSION_GRANTED) {
+            throw new SecurityException("Requires FM_RADIO_TRANSMITTER permission");
+        }
+
+        return _fm_transmitter_getFrequency();
+    }
+
+    public boolean isBlockScanSupported() {
+        if (mContext.checkCallingOrSelfPermission(android.Manifest.permission.FM_RADIO_TRANSMITTER)
+                != PackageManager.PERMISSION_GRANTED) {
+            throw new SecurityException("Requires FM_RADIO_TRANSMITTER permission");
+        }
+
+        return _fm_transmitter_isBlockScanSupported();
+    }
+
+    public void startBlockScan(int startFrequency, int endFrequency) {
+        if (mContext.checkCallingOrSelfPermission(android.Manifest.permission.FM_RADIO_TRANSMITTER)
+                != PackageManager.PERMISSION_GRANTED) {
+            throw new SecurityException("Requires FM_RADIO_TRANSMITTER permission");
+        }
+
+        _fm_transmitter_startBlockScan(startFrequency, endFrequency);
+    }
+
+    public void stopScan() {
+        if (mContext.checkCallingOrSelfPermission(android.Manifest.permission.FM_RADIO_TRANSMITTER)
+                != PackageManager.PERMISSION_GRANTED) {
+            throw new SecurityException("Requires FM_RADIO_TRANSMITTER permission");
+        }
+
+        _fm_transmitter_stopScan();
+    }
+
+    public void setRdsData(Bundle rdsData) {
+        if (mContext.checkCallingOrSelfPermission(android.Manifest.permission.FM_RADIO_TRANSMITTER)
+                != PackageManager.PERMISSION_GRANTED) {
+            throw new SecurityException("Requires FM_RADIO_TRANSMITTER permission");
+        }
+
+        _fm_transmitter_setRdsData(rdsData);
+    }
+
+    public boolean sendExtraCommand(String command, String[] extras) {
+        if (mContext.checkCallingOrSelfPermission(android.Manifest.permission.FM_RADIO_TRANSMITTER)
+                != PackageManager.PERMISSION_GRANTED) {
+            throw new SecurityException("Requires FM_RADIO_TRANSMITTER permission");
+        }
+
+        return _fm_transmitter_sendExtraCommand(command, extras);
+    }
+
+    public void addOnStateChangedListener(IOnStateChangedListener listener) {
+        if (mContext.checkCallingOrSelfPermission(android.Manifest.permission.FM_RADIO_TRANSMITTER)
+                != PackageManager.PERMISSION_GRANTED) {
+            throw new SecurityException("Requires FM_RADIO_TRANSMITTER permission");
+        }
+
+        IBinder binder = listener.asBinder();
+        OnStateChangedReceiver receiver = mOnStateChangedReceivers.get(binder);
+        if (receiver == null) {
+            receiver = new OnStateChangedReceiver(listener);
+            mOnStateChangedReceivers.put(binder, receiver);
+            Log.d(TAG, "addOnStateChangedListener(), new receiver added");
+            try {
+                receiver.getListener().asBinder().linkToDeath(receiver, 0);
+            } catch (RemoteException ex) {
+                Slog.e(TAG, "linkToDeath failed:", ex);
+            }
+        }
+    }
+
+    public void removeOnStateChangedListener(IOnStateChangedListener listener) {
+        if (mContext.checkCallingOrSelfPermission(android.Manifest.permission.FM_RADIO_TRANSMITTER)
+                != PackageManager.PERMISSION_GRANTED) {
+            throw new SecurityException("Requires FM_RADIO_TRANSMITTER permission");
+        }
+
+        IBinder binder = listener.asBinder();
+        OnStateChangedReceiver receiver = mOnStateChangedReceivers.get(binder);
+        if (receiver != null) {
+            mOnStateChangedReceivers.remove(receiver.mKey);
+            Log.d(TAG, "removeOnStateChangedListener(), receiver removed");
+            receiver.getListener().asBinder().unlinkToDeath(receiver, 0);
+        }
+    }
+
+    public void addOnStartedListener(IOnStartedListener listener) {
+        if (mContext.checkCallingOrSelfPermission(android.Manifest.permission.FM_RADIO_TRANSMITTER)
+                != PackageManager.PERMISSION_GRANTED) {
+            throw new SecurityException("Requires FM_RADIO_TRANSMITTER permission");
+        }
+
+        IBinder binder = listener.asBinder();
+        OnStartedReceiver receiver = mOnStartedReceivers.get(binder);
+        if (receiver == null) {
+            receiver = new OnStartedReceiver(listener);
+            mOnStartedReceivers.put(binder, receiver);
+            Log.d(TAG, "addOnStartedListener(), new receiver added");
+            try {
+                receiver.getListener().asBinder().linkToDeath(receiver, 0);
+            } catch (RemoteException ex) {
+                Slog.e(TAG, "linkToDeath failed:", ex);
+            }
+        }
+    }
+
+    public void removeOnStartedListener(IOnStartedListener listener) {
+        if (mContext.checkCallingOrSelfPermission(android.Manifest.permission.FM_RADIO_TRANSMITTER)
+                != PackageManager.PERMISSION_GRANTED) {
+            throw new SecurityException("Requires FM_RADIO_TRANSMITTER permission");
+        }
+
+        IBinder binder = listener.asBinder();
+        OnStartedReceiver receiver = mOnStartedReceivers.get(binder);
+        if (receiver != null) {
+            mOnStartedReceivers.remove(receiver.mKey);
+            Log.d(TAG, "removeOnStartedListener(), receiver removed");
+            receiver.getListener().asBinder().unlinkToDeath(receiver, 0);
+        }
+    }
+
+    public void addOnErrorListener(IOnErrorListener listener) {
+        if (mContext.checkCallingOrSelfPermission(android.Manifest.permission.FM_RADIO_TRANSMITTER)
+                != PackageManager.PERMISSION_GRANTED) {
+            throw new SecurityException("Requires FM_RADIO_TRANSMITTER permission");
+        }
+
+        IBinder binder = listener.asBinder();
+        OnErrorReceiver receiver = mOnErrorReceivers.get(binder);
+        if (receiver == null) {
+            receiver = new OnErrorReceiver(listener);
+            mOnErrorReceivers.put(binder, receiver);
+            Log.d(TAG, "addOnErrorListener(), new receiver added");
+            try {
+                receiver.getListener().asBinder().linkToDeath(receiver, 0);
+            } catch (RemoteException ex) {
+                Slog.e(TAG, "linkToDeath failed:", ex);
+            }
+        }
+    }
+
+    public void removeOnErrorListener(IOnErrorListener listener) {
+        if (mContext.checkCallingOrSelfPermission(android.Manifest.permission.FM_RADIO_TRANSMITTER)
+                != PackageManager.PERMISSION_GRANTED) {
+            throw new SecurityException("Requires FM_RADIO_TRANSMITTER permission");
+        }
+
+        IBinder binder = listener.asBinder();
+        OnErrorReceiver receiver = mOnErrorReceivers.get(binder);
+        if (receiver != null) {
+            mOnErrorReceivers.remove(receiver.mKey);
+            Log.d(TAG, "removeOnErrorListener(), receiver removed");
+            receiver.getListener().asBinder().unlinkToDeath(receiver, 0);
+        }
+    }
+
+    public void addOnBlockScanListener(IOnBlockScanListener listener) {
+        if (mContext.checkCallingOrSelfPermission(android.Manifest.permission.FM_RADIO_TRANSMITTER)
+                != PackageManager.PERMISSION_GRANTED) {
+            throw new SecurityException("Requires FM_RADIO_TRANSMITTER permission");
+        }
+
+        IBinder binder = listener.asBinder();
+        OnBlockScanReceiver receiver = mOnBlockScanReceivers.get(binder);
+        if (receiver == null) {
+            receiver = new OnBlockScanReceiver(listener);
+            mOnBlockScanReceivers.put(binder, receiver);
+            Log.d(TAG, "addOnBlockScanListener(), new receiver added");
+            try {
+                receiver.getListener().asBinder().linkToDeath(receiver, 0);
+            } catch (RemoteException ex) {
+                Slog.e(TAG, "linkToDeath failed:", ex);
+            }
+        }
+    }
+
+    public void removeOnBlockScanListener(IOnBlockScanListener listener) {
+        if (mContext.checkCallingOrSelfPermission(android.Manifest.permission.FM_RADIO_TRANSMITTER)
+                != PackageManager.PERMISSION_GRANTED) {
+            throw new SecurityException("Requires FM_RADIO_TRANSMITTER permission");
+        }
+
+        IBinder binder = listener.asBinder();
+        OnBlockScanReceiver receiver = mOnBlockScanReceivers.get(binder);
+        if (receiver != null) {
+            mOnBlockScanReceivers.remove(receiver.mKey);
+            Log.d(TAG, "removeOnBlockScanListener(), receiver removed");
+            receiver.getListener().asBinder().unlinkToDeath(receiver, 0);
+        }
+    }
+
+    public void addOnForcedPauseListener(IOnForcedPauseListener listener) {
+        if (mContext.checkCallingOrSelfPermission(android.Manifest.permission.FM_RADIO_TRANSMITTER)
+                != PackageManager.PERMISSION_GRANTED) {
+            throw new SecurityException("Requires FM_RADIO_TRANSMITTER permission");
+        }
+
+        IBinder binder = listener.asBinder();
+        OnForcedPauseReceiver receiver = mOnForcedPauseReceivers.get(binder);
+        if (receiver == null) {
+            receiver = new OnForcedPauseReceiver(listener);
+            mOnForcedPauseReceivers.put(binder, receiver);
+            Log.d(TAG, "addOnForcedPauseListener(), new receiver added");
+            try {
+                receiver.getListener().asBinder().linkToDeath(receiver, 0);
+            } catch (RemoteException ex) {
+                Slog.e(TAG, "linkToDeath failed:", ex);
+            }
+        }
+    }
+
+    public void removeOnForcedPauseListener(IOnForcedPauseListener listener) {
+        if (mContext.checkCallingOrSelfPermission(android.Manifest.permission.FM_RADIO_TRANSMITTER)
+                != PackageManager.PERMISSION_GRANTED) {
+            throw new SecurityException("Requires FM_RADIO_TRANSMITTER permission");
+        }
+
+        IBinder binder = listener.asBinder();
+        OnForcedPauseReceiver receiver = mOnForcedPauseReceivers.get(binder);
+        if (receiver != null) {
+            mOnForcedPauseReceivers.remove(receiver.mKey);
+            Log.d(TAG, "removeOnForcedPauseListener(), receiver removed");
+            receiver.getListener().asBinder().unlinkToDeath(receiver, 0);
+        }
+    }
+
+    public void addOnForcedResetListener(IOnForcedResetListener listener) {
+        if (mContext.checkCallingOrSelfPermission(android.Manifest.permission.FM_RADIO_TRANSMITTER)
+                != PackageManager.PERMISSION_GRANTED) {
+            throw new SecurityException("Requires FM_RADIO_TRANSMITTER permission");
+        }
+
+        IBinder binder = listener.asBinder();
+        OnForcedResetReceiver receiver = mOnForcedResetReceivers.get(binder);
+        if (receiver == null) {
+            receiver = new OnForcedResetReceiver(listener);
+            mOnForcedResetReceivers.put(binder, receiver);
+            Log.d(TAG, "addOnForcedResetListener(), new receiver added");
+            try {
+                receiver.getListener().asBinder().linkToDeath(receiver, 0);
+            } catch (RemoteException ex) {
+                Slog.e(TAG, "linkToDeath failed:", ex);
+            }
+        }
+    }
+
+    public void removeOnForcedResetListener(IOnForcedResetListener listener) {
+        if (mContext.checkCallingOrSelfPermission(android.Manifest.permission.FM_RADIO_TRANSMITTER)
+                != PackageManager.PERMISSION_GRANTED) {
+            throw new SecurityException("Requires FM_RADIO_TRANSMITTER permission");
+        }
+
+        IBinder binder = listener.asBinder();
+        OnForcedResetReceiver receiver = mOnForcedResetReceivers.get(binder);
+        if (receiver != null) {
+            mOnForcedResetReceivers.remove(receiver.mKey);
+            Log.d(TAG, "removeOnForcedResetListener(), receiver removed");
+            receiver.getListener().asBinder().unlinkToDeath(receiver, 0);
+        }
+    }
+
+    public void addOnExtraCommandListener(IOnExtraCommandListener listener) {
+        if (mContext.checkCallingOrSelfPermission(android.Manifest.permission.FM_RADIO_TRANSMITTER)
+                != PackageManager.PERMISSION_GRANTED) {
+            throw new SecurityException("Requires FM_RADIO_TRANSMITTER permission");
+        }
+
+        IBinder binder = listener.asBinder();
+        OnExtraCommandReceiver receiver = mOnExtraCommandReceivers.get(binder);
+        if (receiver == null) {
+            receiver = new OnExtraCommandReceiver(listener);
+            mOnExtraCommandReceivers.put(binder, receiver);
+            Log.d(TAG, "addOnExtraCommandListener(), new receiver added");
+            try {
+                receiver.getListener().asBinder().linkToDeath(receiver, 0);
+            } catch (RemoteException ex) {
+                Slog.e(TAG, "linkToDeath failed:", ex);
+            }
+        }
+    }
+
+    public void removeOnExtraCommandListener(IOnExtraCommandListener listener) {
+        if (mContext.checkCallingOrSelfPermission(android.Manifest.permission.FM_RADIO_TRANSMITTER)
+                != PackageManager.PERMISSION_GRANTED) {
+            throw new SecurityException("Requires FM_RADIO_TRANSMITTER permission");
+        }
+
+        IBinder binder = listener.asBinder();
+        OnExtraCommandReceiver receiver = mOnExtraCommandReceivers.get(binder);
+        if (receiver != null) {
+            mOnExtraCommandReceivers.remove(receiver.mKey);
+            Log.d(TAG, "removeOnExtraCommandListener(), receiver removed");
+            receiver.getListener().asBinder().unlinkToDeath(receiver, 0);
+        }
+    }
+
+    private void notifyOnStateChanged(int oldState, int newState) {
+        synchronized (mOnStateChangedReceivers) {
+            Collection c = mOnStateChangedReceivers.values();
+            Iterator iterator = c.iterator();
+            while (iterator.hasNext()) {
+                OnStateChangedReceiver m = (OnStateChangedReceiver) iterator.next();
+                m.callOnStateChanged(oldState, newState);
+            }
+        }
+    }
+
+    private void notifyOnStarted() {
+        synchronized (mOnStartedReceivers) {
+            Collection c = mOnStartedReceivers.values();
+            Iterator iterator = c.iterator();
+            while (iterator.hasNext()) {
+                OnStartedReceiver m = (OnStartedReceiver) iterator.next();
+                m.callOnStarted();
+            }
+        }
+    }
+
+    private void notifyOnError() {
+        synchronized (mOnErrorReceivers) {
+            Collection c = mOnErrorReceivers.values();
+            Iterator iterator = c.iterator();
+            while (iterator.hasNext()) {
+                OnErrorReceiver m = (OnErrorReceiver) iterator.next();
+                m.callOnError();
+            }
+        }
+    }
+
+    private void notifyOnBlockScan(int[] frequency, int[] signalLevel, boolean aborted) {
+        synchronized (mOnBlockScanReceivers) {
+            Collection c = mOnBlockScanReceivers.values();
+            Iterator iterator = c.iterator();
+            while (iterator.hasNext()) {
+                OnBlockScanReceiver m = (OnBlockScanReceiver) iterator.next();
+                m.callOnBlockScan(frequency, signalLevel, aborted);
+            }
+        }
+    }
+
+    private void notifyOnForcedPause() {
+        synchronized (mOnForcedPauseReceivers) {
+            Collection c = mOnForcedPauseReceivers.values();
+            Iterator iterator = c.iterator();
+            while (iterator.hasNext()) {
+                OnForcedPauseReceiver m = (OnForcedPauseReceiver) iterator.next();
+                m.callOnForcedPause();
+            }
+        }
+    }
+
+    private void notifyOnForcedReset(int reason) {
+        synchronized (mOnForcedResetReceivers) {
+            Collection c = mOnForcedResetReceivers.values();
+            Iterator iterator = c.iterator();
+            while (iterator.hasNext()) {
+                OnForcedResetReceiver m = (OnForcedResetReceiver) iterator.next();
+                m.callOnForcedReset(reason);
+            }
+        }
+    }
+
+    private void notifyOnExtraCommand(String response, Bundle extras) {
+        synchronized (mOnExtraCommandReceivers) {
+            Collection c = mOnExtraCommandReceivers.values();
+            Iterator iterator = c.iterator();
+            while (iterator.hasNext()) {
+                OnExtraCommandReceiver m = (OnExtraCommandReceiver) iterator.next();
+                m.callOnExtraCommand(response, extras);
+            }
+        }
+    }
+
+    private native void _fm_transmitter_start(int minFreq, int maxFreq, int defaultFreq, int offset);
+
+    private native void _fm_transmitter_startAsync(int minFreq, int maxFreq, int defaultFreq,
+            int offset);
+
+    private native int _fm_transmitter_reset();
+
+    private native void _fm_transmitter_pause();
+
+    private native void _fm_transmitter_resume();
+
+    private native int _fm_transmitter_getState();
+
+    private native void _fm_transmitter_setFrequency(int frequency);
+
+    private native int _fm_transmitter_getFrequency();
+
+    private native boolean _fm_transmitter_isBlockScanSupported();
+
+    private native void _fm_transmitter_startBlockScan(int startFrequency, int endFrequency);
+
+    private native void _fm_transmitter_stopScan();
+
+    private native void _fm_transmitter_setRdsData(Bundle rdsData);
+
+    private native boolean _fm_transmitter_sendExtraCommand(String command, String[] extras);
+}
diff --git a/fmradio/java/com/stericsson/hardware/fm/IFmReceiver.aidl b/fmradio/java/com/stericsson/hardware/fm/IFmReceiver.aidl
new file mode 100644
index 0000000..edf168e
--- /dev/null
+++ b/fmradio/java/com/stericsson/hardware/fm/IFmReceiver.aidl
@@ -0,0 +1,84 @@
+/*
+ * Copyright (C) ST-Ericsson SA 2010
+ * Copyright (C) 2010 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+ * Author: Markus Grape (markus.grape@stericsson.com) for ST-Ericsson
+ */
+
+package com.stericsson.hardware.fm;
+
+import com.stericsson.hardware.fm.FmBand;
+import com.stericsson.hardware.fm.IOnStateChangedListener;
+import com.stericsson.hardware.fm.IOnStartedListener;
+import com.stericsson.hardware.fm.IOnErrorListener;
+import com.stericsson.hardware.fm.IOnScanListener;
+import com.stericsson.hardware.fm.IOnForcedPauseListener;
+import com.stericsson.hardware.fm.IOnForcedResetListener;
+import com.stericsson.hardware.fm.IOnRDSDataFoundListener;
+import com.stericsson.hardware.fm.IOnSignalStrengthListener;
+import com.stericsson.hardware.fm.IOnStereoListener;
+import com.stericsson.hardware.fm.IOnExtraCommandListener;
+import com.stericsson.hardware.fm.IOnAutomaticSwitchListener;
+
+/**
+ * {@hide}
+ */
+interface IFmReceiver
+{
+    void start(in FmBand band);
+    void startAsync(in FmBand band);
+    void reset();
+    void pause();
+    void resume();
+    int getState();
+    int getFrequency();
+    void setFrequency(int frequency);
+    void scanUp();
+    void scanDown();
+    void startFullScan();
+    void stopScan();
+    boolean isRDSDataSupported();
+    boolean isTunedToValidChannel();
+    void setThreshold(int threshold);
+    int getThreshold();
+    int getSignalStrength();
+    boolean isPlayingInStereo();
+    void setForceMono(boolean forceMono);
+    void setAutomaticAFSwitching(boolean automatic);
+    void setAutomaticTASwitching(boolean automatic);
+    boolean sendExtraCommand(String command, in String[] extras);
+    void addOnStateChangedListener(in IOnStateChangedListener listener);
+    void removeOnStateChangedListener(in IOnStateChangedListener listener);
+    void addOnStartedListener(in IOnStartedListener listener);
+    void removeOnStartedListener(in IOnStartedListener listener);
+    void addOnErrorListener(in IOnErrorListener listener);
+    void removeOnErrorListener(in IOnErrorListener listener);
+    void addOnScanListener(in IOnScanListener listener);
+    void removeOnScanListener(in IOnScanListener listener);
+    void addOnForcedPauseListener(in IOnForcedPauseListener listener);
+    void removeOnForcedPauseListener(in IOnForcedPauseListener listener);
+    void addOnForcedResetListener(in IOnForcedResetListener listener);
+    void removeOnForcedResetListener(in IOnForcedResetListener listener);
+    void addOnRDSDataFoundListener(in IOnRDSDataFoundListener listener);
+    void removeOnRDSDataFoundListener(in IOnRDSDataFoundListener listener);
+    void addOnSignalStrengthChangedListener(in IOnSignalStrengthListener listener);
+    void removeOnSignalStrengthChangedListener(in IOnSignalStrengthListener listener);
+    void addOnPlayingInStereoListener(in IOnStereoListener listener);
+    void removeOnPlayingInStereoListener(in IOnStereoListener listener);
+    void addOnExtraCommandListener(in IOnExtraCommandListener listener);
+    void removeOnExtraCommandListener(in IOnExtraCommandListener listener);
+    void addOnAutomaticSwitchListener(in IOnAutomaticSwitchListener listener);
+    void removeOnAutomaticSwitchListener(in IOnAutomaticSwitchListener listener);
+}
diff --git a/fmradio/java/com/stericsson/hardware/fm/IFmTransmitter.aidl b/fmradio/java/com/stericsson/hardware/fm/IFmTransmitter.aidl
new file mode 100644
index 0000000..6ca0cee
--- /dev/null
+++ b/fmradio/java/com/stericsson/hardware/fm/IFmTransmitter.aidl
@@ -0,0 +1,64 @@
+/*
+ * Copyright (C) ST-Ericsson SA 2010
+ * Copyright (C) 2010 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+ * Author: Markus Grape (markus.grape@stericsson.com) for ST-Ericsson
+ */
+
+package com.stericsson.hardware.fm;
+
+import com.stericsson.hardware.fm.FmBand;
+import com.stericsson.hardware.fm.IOnStateChangedListener;
+import com.stericsson.hardware.fm.IOnStartedListener;
+import com.stericsson.hardware.fm.IOnErrorListener;
+import com.stericsson.hardware.fm.IOnBlockScanListener;
+import com.stericsson.hardware.fm.IOnForcedPauseListener;
+import com.stericsson.hardware.fm.IOnForcedResetListener;
+import com.stericsson.hardware.fm.IOnExtraCommandListener;
+import android.os.Bundle;
+
+/**
+ * {@hide}
+ */
+interface IFmTransmitter
+{
+    void start(in FmBand band);
+    void startAsync(in FmBand band);
+    void reset();
+    void pause();
+    void resume();
+    int getState();
+    int getFrequency();
+    void setFrequency(int frequency);
+    boolean isBlockScanSupported();
+    void startBlockScan(int startFrequency, int endFrequency);
+    void stopScan();
+    void setRdsData(in Bundle rdsData);
+    boolean sendExtraCommand(String command, in String[] extras);
+    void addOnStateChangedListener(in IOnStateChangedListener listener);
+    void removeOnStateChangedListener(in IOnStateChangedListener listener);
+    void addOnStartedListener(in IOnStartedListener listener);
+    void removeOnStartedListener(in IOnStartedListener listener);
+    void addOnErrorListener(in IOnErrorListener listener);
+    void removeOnErrorListener(in IOnErrorListener listener);
+    void addOnBlockScanListener(in IOnBlockScanListener listener);
+    void removeOnBlockScanListener(in IOnBlockScanListener listener);
+    void addOnForcedPauseListener(in IOnForcedPauseListener listener);
+    void removeOnForcedPauseListener(in IOnForcedPauseListener listener);
+    void addOnForcedResetListener(in IOnForcedResetListener listener);
+    void removeOnForcedResetListener(in IOnForcedResetListener listener);
+    void addOnExtraCommandListener(in IOnExtraCommandListener listener);
+    void removeOnExtraCommandListener(in IOnExtraCommandListener listener);
+}
diff --git a/fmradio/java/com/stericsson/hardware/fm/IOnAutomaticSwitchListener.aidl b/fmradio/java/com/stericsson/hardware/fm/IOnAutomaticSwitchListener.aidl
new file mode 100644
index 0000000..8bf88ad
--- /dev/null
+++ b/fmradio/java/com/stericsson/hardware/fm/IOnAutomaticSwitchListener.aidl
@@ -0,0 +1,28 @@
+/*
+ * Copyright (C) ST-Ericsson SA 2010
+ * Copyright (C) 2010 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+ * Author: Johan Palmaeus (johan.xj.palmaeus@stericsson.com) for ST-Ericsson
+ */
+
+package com.stericsson.hardware.fm;
+
+/**
+ * {@hide}
+ */
+oneway interface IOnAutomaticSwitchListener
+{
+    void onAutomaticSwitch(int newFrequency, int reason);
+}
diff --git a/fmradio/java/com/stericsson/hardware/fm/IOnBlockScanListener.aidl b/fmradio/java/com/stericsson/hardware/fm/IOnBlockScanListener.aidl
new file mode 100644
index 0000000..ec39dea
--- /dev/null
+++ b/fmradio/java/com/stericsson/hardware/fm/IOnBlockScanListener.aidl
@@ -0,0 +1,28 @@
+/*
+ * Copyright (C) ST-Ericsson SA 2010
+ * Copyright (C) 2010 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+ * Author: Markus Grape (markus.grape@stericsson.com) for ST-Ericsson
+ */
+
+package com.stericsson.hardware.fm;
+
+/**
+ * {@hide}
+ */
+oneway interface IOnBlockScanListener
+{
+    void onBlockScan(in int[] frequency, in int[] signalLevel, boolean aborted);
+}
\ No newline at end of file
diff --git a/fmradio/java/com/stericsson/hardware/fm/IOnErrorListener.aidl b/fmradio/java/com/stericsson/hardware/fm/IOnErrorListener.aidl
new file mode 100644
index 0000000..558600b
--- /dev/null
+++ b/fmradio/java/com/stericsson/hardware/fm/IOnErrorListener.aidl
@@ -0,0 +1,28 @@
+/*
+ * Copyright (C) ST-Ericsson SA 2010
+ * Copyright (C) 2010 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+ * Author: Markus Grape (markus.grape@stericsson.com) for ST-Ericsson
+ */
+
+package com.stericsson.hardware.fm;
+
+/**
+ * {@hide}
+ */
+oneway interface IOnErrorListener
+{
+    void onError();
+}
diff --git a/fmradio/java/com/stericsson/hardware/fm/IOnExtraCommandListener.aidl b/fmradio/java/com/stericsson/hardware/fm/IOnExtraCommandListener.aidl
new file mode 100644
index 0000000..7647832
--- /dev/null
+++ b/fmradio/java/com/stericsson/hardware/fm/IOnExtraCommandListener.aidl
@@ -0,0 +1,30 @@
+/*
+ * Copyright (C) ST-Ericsson SA 2010
+ * Copyright (C) 2010 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+ * Author: Markus Grape (markus.grape@stericsson.com) for ST-Ericsson
+ */
+
+package com.stericsson.hardware.fm;
+
+import android.os.Bundle;
+
+/**
+ * {@hide}
+ */
+oneway interface IOnExtraCommandListener
+{
+    void onExtraCommand(String response, in Bundle extras);
+}
\ No newline at end of file
diff --git a/fmradio/java/com/stericsson/hardware/fm/IOnForcedPauseListener.aidl b/fmradio/java/com/stericsson/hardware/fm/IOnForcedPauseListener.aidl
new file mode 100644
index 0000000..bb8d876
--- /dev/null
+++ b/fmradio/java/com/stericsson/hardware/fm/IOnForcedPauseListener.aidl
@@ -0,0 +1,28 @@
+/*
+ * Copyright (C) ST-Ericsson SA 2010
+ * Copyright (C) 2010 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+ * Author: Markus Grape (markus.grape@stericsson.com) for ST-Ericsson
+ */
+
+package com.stericsson.hardware.fm;
+
+/**
+ * {@hide}
+ */
+oneway interface IOnForcedPauseListener
+{
+    void onForcedPause();
+}
diff --git a/fmradio/java/com/stericsson/hardware/fm/IOnForcedResetListener.aidl b/fmradio/java/com/stericsson/hardware/fm/IOnForcedResetListener.aidl
new file mode 100644
index 0000000..4514501
--- /dev/null
+++ b/fmradio/java/com/stericsson/hardware/fm/IOnForcedResetListener.aidl
@@ -0,0 +1,28 @@
+/*
+ * Copyright (C) ST-Ericsson SA 2010
+ * Copyright (C) 2010 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+ * Author: Markus Grape (markus.grape@stericsson.com) for ST-Ericsson
+ */
+
+package com.stericsson.hardware.fm;
+
+/**
+ * {@hide}
+ */
+oneway interface IOnForcedResetListener
+{
+    void onForcedReset(int reason);
+}
diff --git a/fmradio/java/com/stericsson/hardware/fm/IOnRDSDataFoundListener.aidl b/fmradio/java/com/stericsson/hardware/fm/IOnRDSDataFoundListener.aidl
new file mode 100644
index 0000000..31b4801
--- /dev/null
+++ b/fmradio/java/com/stericsson/hardware/fm/IOnRDSDataFoundListener.aidl
@@ -0,0 +1,30 @@
+/*
+ * Copyright (C) ST-Ericsson SA 2010
+ * Copyright (C) 2010 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+ * Author: Markus Grape (markus.grape@stericsson.com) for ST-Ericsson
+ */
+
+package com.stericsson.hardware.fm;
+
+import android.os.Bundle;
+
+/**
+ * {@hide}
+ */
+oneway interface IOnRDSDataFoundListener
+{
+    void onRDSDataFound(in Bundle options, int frequency);
+}
diff --git a/fmradio/java/com/stericsson/hardware/fm/IOnScanListener.aidl b/fmradio/java/com/stericsson/hardware/fm/IOnScanListener.aidl
new file mode 100644
index 0000000..9996c1a
--- /dev/null
+++ b/fmradio/java/com/stericsson/hardware/fm/IOnScanListener.aidl
@@ -0,0 +1,29 @@
+/*
+ * Copyright (C) ST-Ericsson SA 2010
+ * Copyright (C) 2010 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+ * Author: Markus Grape (markus.grape@stericsson.com) for ST-Ericsson
+ */
+
+package com.stericsson.hardware.fm;
+
+/**
+ * {@hide}
+ */
+oneway interface IOnScanListener
+{
+    void onScan(int tunedFrequency, int signalLevel, int scanDirection, boolean aborted);
+    void onFullScan(in int[] frequency, in int[] signalLevel, boolean aborted);
+}
diff --git a/fmradio/java/com/stericsson/hardware/fm/IOnSignalStrengthListener.aidl b/fmradio/java/com/stericsson/hardware/fm/IOnSignalStrengthListener.aidl
new file mode 100644
index 0000000..431952b
--- /dev/null
+++ b/fmradio/java/com/stericsson/hardware/fm/IOnSignalStrengthListener.aidl
@@ -0,0 +1,28 @@
+/*
+ * Copyright (C) ST-Ericsson SA 2010
+ * Copyright (C) 2010 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+ * Author: Markus Grape (markus.grape@stericsson.com) for ST-Ericsson
+ */
+
+package com.stericsson.hardware.fm;
+
+/**
+ * {@hide}
+ */
+oneway interface IOnSignalStrengthListener
+{
+    void onSignalStrengthChanged(int signalStrength);
+}
\ No newline at end of file
diff --git a/fmradio/java/com/stericsson/hardware/fm/IOnStartedListener.aidl b/fmradio/java/com/stericsson/hardware/fm/IOnStartedListener.aidl
new file mode 100644
index 0000000..b15ef09
--- /dev/null
+++ b/fmradio/java/com/stericsson/hardware/fm/IOnStartedListener.aidl
@@ -0,0 +1,28 @@
+/*
+ * Copyright (C) ST-Ericsson SA 2010
+ * Copyright (C) 2010 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+ * Author: Markus Grape (markus.grape@stericsson.com) for ST-Ericsson
+ */
+
+package com.stericsson.hardware.fm;
+
+/**
+ * {@hide}
+ */
+oneway interface IOnStartedListener
+{
+    void onStarted();
+}
diff --git a/fmradio/java/com/stericsson/hardware/fm/IOnStateChangedListener.aidl b/fmradio/java/com/stericsson/hardware/fm/IOnStateChangedListener.aidl
new file mode 100644
index 0000000..3a63564
--- /dev/null
+++ b/fmradio/java/com/stericsson/hardware/fm/IOnStateChangedListener.aidl
@@ -0,0 +1,28 @@
+/*
+ * Copyright (C) ST-Ericsson SA 2010
+ * Copyright (C) 2010 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+ * Author: Markus Grape (markus.grape@stericsson.com) for ST-Ericsson
+ */
+
+package com.stericsson.hardware.fm;
+
+/**
+ * {@hide}
+ */
+oneway interface IOnStateChangedListener
+{
+    void onStateChanged(int oldState, int newState);
+}
diff --git a/fmradio/java/com/stericsson/hardware/fm/IOnStereoListener.aidl b/fmradio/java/com/stericsson/hardware/fm/IOnStereoListener.aidl
new file mode 100644
index 0000000..ff2c977
--- /dev/null
+++ b/fmradio/java/com/stericsson/hardware/fm/IOnStereoListener.aidl
@@ -0,0 +1,28 @@
+/*
+ * Copyright (C) ST-Ericsson SA 2010
+ * Copyright (C) 2010 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+ * Author: Markus Grape (markus.grape@stericsson.com) for ST-Ericsson
+ */
+
+package com.stericsson.hardware.fm;
+
+/**
+ * {@hide}
+ */
+oneway interface IOnStereoListener
+{
+    void onPlayingInStereo(boolean inStereo);
+}
\ No newline at end of file
diff --git a/fmradio/java/com/stericsson/hardware/fm/package.html b/fmradio/java/com/stericsson/hardware/fm/package.html
new file mode 100644
index 0000000..13c4a07
--- /dev/null
+++ b/fmradio/java/com/stericsson/hardware/fm/package.html
@@ -0,0 +1,13 @@
+<HTML>
+<BODY>
+Provides classes to receive and transmit FM Radio.
+<p>
+<lu>
+<li>FM Radio can be received by using the FmReceiver to control the reception and the MediaPlayer
+to play the FM Radio stream.</li>
+<li>FM Radio can be transmitted by using the FmTransmitter to control the output and the MediaPlayer
+to select the audio stream that will be transmitted.</li>
+</lu>
+</p>
+</BODY>
+</HTML>
diff --git a/fmradio/jni/Android.mk b/fmradio/jni/Android.mk
new file mode 100644
index 0000000..1b2643d
--- /dev/null
+++ b/fmradio/jni/Android.mk
@@ -0,0 +1,41 @@
+LOCAL_PATH:= $(call my-dir)
+include $(CLEAR_VARS)
+
+LOCAL_SRC_FILES:= \
+        android_fmradio.cpp \
+        android_fmradio_Receiver.cpp \
+        android_fmradio_Transmitter.cpp
+
+LOCAL_C_INCLUDES += \
+        $(JNI_H_INCLUDE)\
+        $(TOP)/frameworks/base/fmradio/include \
+        $(TOP)/hardware/libhardware/include/hardware
+
+LOCAL_SHARED_LIBRARIES := \
+        libcutils \
+        libhardware \
+        libhardware_legacy \
+        libnativehelper \
+        libsystem_server \
+        libutils \
+        libdl \
+        libui \
+        libmedia \
+
+ifeq ($(TARGET_SIMULATOR),true)
+ifeq ($(TARGET_OS),linux)
+ifeq ($(TARGET_ARCH),x86)
+LOCAL_LDLIBS += -lpthread -ldl -lrt
+endif
+endif
+endif
+
+ifeq ($(WITH_MALLOC_LEAK_CHECK),true)
+        LOCAL_CFLAGS += -DMALLOC_LEAK_CHECK
+endif
+
+LOCAL_MODULE:= libanalogradiobroadcasting
+LOCAL_MODULE_TAGS := optional
+
+include $(BUILD_SHARED_LIBRARY)
+
diff --git a/fmradio/jni/android_fmradio.cpp b/fmradio/jni/android_fmradio.cpp
new file mode 100755
index 0000000..125a12e
--- /dev/null
+++ b/fmradio/jni/android_fmradio.cpp
@@ -0,0 +1,1188 @@
+/*
+ * Copyright (C) ST-Ericsson SA 2010
+ * Copyright 2010, The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+ * Author: johan.xj.palmaeus@stericsson.com for ST-Ericsson
+ */
+
+/*
+ * Native part of the generic TX-RX common FmRadio inteface
+ */
+
+
+#define LOG_TAG "FmServiceNative"
+
+// #define LOG_NDEBUG 1
+
+#include <dlfcn.h>
+#include <string.h>
+#include <stdlib.h>
+#include <pthread.h>
+#include <unistd.h>
+#include <dirent.h>
+#include <errno.h>
+
+#include <utils/Log.h>
+#include "jni.h"
+#include "JNIHelp.h"
+
+#include "android_fmradio.h"
+
+#ifndef LIBRARY_PATH
+#define LIBRARY_PATH "/system/lib/"
+#endif
+
+#ifndef LIBRARY_PREFIX
+#define LIBRARY_PREFIX "libfmradio."
+#endif
+
+#ifndef LIBRARY_SUFFIX
+#define LIBRARY_SUFFIX ".so"
+#endif
+
+#ifndef LIBRARY_SUFFIX_RX
+#define LIBRARY_SUFFIX_RX "_rx.so"
+#endif
+
+#ifndef LIBRARY_SUFFIX_TX
+#define LIBRARY_SUFFIX_TX "_tx.so"
+#endif
+
+/* structs for passing startup arguments to threads */
+
+struct FmRadioStartAsyncParameters {
+    int (*startFunc) (void **, const struct fmradio_vendor_callbacks_t*, int, int, int,
+                      int);
+    struct FmSession_t *session_p;
+    const struct fmradio_vendor_callbacks_t *callbacks_p;
+    int lowFreq;
+    int highFreq;
+    int defaultFreq;
+    int grid;
+};
+
+struct FmRadioSendExtraCommandParameters {
+    struct FmSession_t *session_p;
+    char* c_command;
+    char ** cparams;
+};
+
+
+pthread_mutex_t rx_tx_common_mutex = PTHREAD_MUTEX_INITIALIZER;
+
+jobject extraCommandRetList2Bundle(JNIEnv * env_p, struct bundle_descriptor_offsets_t
+                                   *bundleOffsets_p,
+                                   struct fmradio_extra_command_ret_item_t *itemList)
+{
+    struct fmradio_extra_command_ret_item_t *listIterator = itemList;
+
+    jobject bundle = env_p->NewObject(bundleOffsets_p->mClass,
+                                      bundleOffsets_p->mConstructor);
+
+    while (listIterator && listIterator->key != NULL) {
+        switch (listIterator->type) {
+        case FMRADIO_TYPE_INT:
+            env_p->CallVoidMethod(bundle, bundleOffsets_p->mPutInt,
+                                  env_p->NewStringUTF(listIterator->key),
+                                  listIterator->data.int_value);
+            break;
+        case FMRADIO_TYPE_STRING:
+            env_p->CallVoidMethod(bundle, bundleOffsets_p->mPutString,
+                                  env_p->NewStringUTF(listIterator->key),
+                                  env_p->NewStringUTF(listIterator->data.string_value));
+            break;
+        default:
+            LOGE("warning. Unknown command ret item type %d\n",
+                 listIterator->type);
+            break;
+        }
+
+        listIterator++;
+    }
+    return bundle;
+}
+
+void freeExtraCommandRetList(struct fmradio_extra_command_ret_item_t *itemList)
+{
+    struct fmradio_extra_command_ret_item_t *listIterator = itemList;
+
+    while (listIterator && listIterator->key != NULL) {
+        free(listIterator->key);
+        if (listIterator->type == FMRADIO_TYPE_STRING) {
+            free(listIterator->data.string_value);
+        }
+        listIterator++;
+    }
+    free(itemList);
+
+}
+
+static bool jstringArray2cstringArray(JNIEnv * env_p, jobjectArray jarray,
+                                      char ***carray_p)
+{
+    int arrayLength;
+
+    if (jarray != NULL &&
+        (arrayLength = env_p->GetArrayLength(jarray)) > 0) {
+        int d;
+
+        char **carray = (char **) calloc(arrayLength + 1, sizeof(*carray));
+
+        if (carray == NULL) {
+            LOGE("malloc failed\n");
+            return false;
+        }
+
+        for (d = 0; d < arrayLength; d++) {
+            const char *itemstr = env_p->GetStringUTFChars((jstring)
+                                                           env_p->GetObjectArrayElement
+                                                           (jarray, d),
+                                                           NULL);
+
+            carray[d] = strdup(itemstr);
+            env_p->ReleaseStringUTFChars((jstring)
+                                         env_p->GetObjectArrayElement
+                                         (jarray, d), itemstr);
+            if (carray[d] == NULL) {
+                LOGE("strdup failed\n");
+                /* free any arrays already allocated, free the array pointer
+                 * and exit */
+                while (--d >= 0) {
+                    free(carray[d]);
+                }
+                free(carray);
+                return false;
+            }
+        }
+        carray[arrayLength] = NULL;     /* to be able to detect end of array */
+        *carray_p = carray;
+    } else {
+        *carray_p = NULL;
+    }
+
+    return true;
+}
+
+static void freeCstringArray(char **cstringarray)
+{
+    if (cstringarray != NULL && *cstringarray != NULL) {
+        char **iterator = cstringarray;
+
+        while (*iterator != NULL) {
+            free(*iterator);
+            iterator++;
+        }
+        free(cstringarray);
+
+    }
+}
+
+/*
+ * Function to temporary resume a paused device for executing command
+ */
+void androidFmRadioTempResumeIfPaused(struct FmSession_t *session_p)
+{
+    if (session_p->state == FMRADIO_STATE_PAUSED) {
+        /* no need to handle error here, the main command will fail anyway */
+        (void)session_p->vendorMethods_p->resume(&session_p->vendorData_p);
+    }
+}
+
+/*
+ * Function to pause device after a temporary resume
+ */
+void androidFmRadioPauseIfTempResumed(struct FmSession_t *session_p)
+{
+    if (session_p->state == FMRADIO_STATE_PAUSED) {
+        if (session_p->vendorMethods_p->pause(&session_p->vendorData_p)
+            != FMRADIO_OK)  {
+            LOGE("androidFmRadioPauseIfTempResumed: pause failed, force "
+                 "resetting");
+            /*
+             * Failed to set pause again. Since the device is supposed to be
+             * paused we can't leave it this way, our best choice is to issue
+             * a force reset to put the device in a known idle state. Temporary
+             * drop locks since we might trigger callbacks.
+             */
+            FMRADIO_SET_STATE(session_p, FMRADIO_STATE_IDLE);
+            /* temporary drop lock to allow reset triggered callbacks */
+            pthread_mutex_unlock(session_p->dataMutex_p);
+            int retval = session_p->vendorMethods_p->reset(&session_p->vendorData_p);
+            pthread_mutex_lock(session_p->dataMutex_p);
+
+            if (retval != FMRADIO_OK) {
+                LOGE("androidFmRadioPauseIfTempResumed: CRITICAL ERROR: "
+                     "can't reset device");
+                /* if we can't even reset we have a critical problem */
+                session_p->callbacks_p->onForcedReset(FMRADIO_RESET_CRITICAL);
+            } else {
+                /* now we are in known state */
+                session_p->callbacks_p->onForcedReset(FMRADIO_RESET_NON_CRITICAL);
+            }
+
+            /* unload vendor driver */
+            androidFmRadioUnLoadFmLibrary(session_p);
+            session_p->isRegistered = false;
+        }
+    }
+}
+
+bool
+androidFmRadioIsValidEventForState(struct FmSession_t *session_p,
+                                   enum FmRadioCommand_t event)
+{
+    bool retval;
+
+    if (!session_p->isRegistered && (event != FMRADIO_EVENT_RESET) &&
+        (event != FMRADIO_EVENT_START) && (event != FMRADIO_EVENT_START_ASYNC)) {
+        LOGE("ERROR - library not loaded, only reset, start and start async are valid events");
+        retval = false;
+    } else if (session_p->ongoingReset && (event != FMRADIO_EVENT_RESET)) {
+        LOGE("ERROR - ongoing reset invalidates state changes");
+        retval = false;
+    } else if (!(*session_p->validEventsForStates_p)[event][session_p->state]) {
+        LOGE("ERROR - Invalid event %u for state %u", event,
+             session_p->state);
+        retval = false;
+    } else {
+        retval = true;
+    }
+
+    return retval;
+}
+
+void
+androidFmRadioThrowException(struct FmSession_t *session_p,
+                             const char *exception,
+                             const char *message, const char *file,
+                             int line, const char *function)
+{
+    bool reAttached = false;
+
+    JNIEnv *env;
+
+    LOGI("androidFmRadioThrowException, %s ('%s') @ %s %d (%s)\n",
+         exception, message, file, line, function);
+
+
+    if (session_p->jvm_p->GetEnv((void **) &env, JNI_VERSION_1_4) !=
+        JNI_OK) {
+        /* we are probably a subthread. Attach instead */
+        if (session_p->jvm_p->AttachCurrentThread(&env, NULL) != JNI_OK) {
+            LOGE("Error, can't attch current thread\n");
+            return;
+        }
+        reAttached = true;
+    }
+
+    jniThrowException(env, exception, message);
+
+    if (reAttached) {
+        session_p->jvm_p->DetachCurrentThread();
+    }
+
+}
+
+
+/*
+ *  Functions for loading and unloading the vendor dynamic library
+ *   (libfmradio.xxxxxx.so)
+ */
+
+static bool
+androidFmRadioGetLibraryName(enum RadioMode_t mode,
+                             char *libraryName)
+{
+    DIR *dirp;
+    struct dirent *dp;
+    char foundName[sizeof(dp->d_name)] = "";
+
+    if ((dirp = opendir(LIBRARY_PATH)) == NULL) {
+        LOGE("couldn't open path '%s'", LIBRARY_PATH);
+        return false;
+    }
+
+    errno = 0;
+
+    while ((dp = readdir(dirp)) != NULL) {
+        char *name = dp->d_name;
+        size_t nameLength = strlen(name);
+
+        /*
+         * since prefix end with . and suffix start with . we need to make sure
+         * we don't get a match on something that is shorter than the two
+         * strings concatinated
+         */
+        if (nameLength < sizeof(LIBRARY_PREFIX) + sizeof(LIBRARY_SUFFIX) - 2) {
+            continue;
+        }
+
+        if ((nameLength > sizeof(LIBRARY_SUFFIX) -1) &&
+            (strcmp(name + nameLength - sizeof(LIBRARY_SUFFIX) + 1,
+                    LIBRARY_SUFFIX) == 0)) {
+        } else {
+            continue;
+        }
+
+        if (strncmp(name, LIBRARY_PREFIX, sizeof(LIBRARY_PREFIX) - 1) != 0) {
+            /* prefix doesn't match, this is not our file */
+            continue;
+        }
+
+
+        /* check if it is RX/TX specific or general */
+
+        if ((nameLength > sizeof(LIBRARY_SUFFIX_RX) -1) &&
+            (strcmp(name + nameLength - sizeof(LIBRARY_SUFFIX_RX) + 1,
+                    LIBRARY_SUFFIX_RX) == 0)) {
+            if (mode == FMRADIO_RX) {
+                strcpy(foundName, name);
+                break;
+            }
+        } else if ((nameLength > sizeof(LIBRARY_SUFFIX_TX) -1) &&
+                   (strcmp(name + nameLength - sizeof(LIBRARY_SUFFIX_TX) + 1,
+                           LIBRARY_SUFFIX_TX) == 0)) {
+            if (mode == FMRADIO_TX) {
+                strcpy(foundName, name);
+                break;
+            }
+        } else {
+            strcpy(foundName, name);
+            /* do not break, if there is a rx/tx specific name we prefer it */
+        }
+    }
+
+    (void)closedir(dirp);
+
+    if (dp == NULL && errno != 0) {
+        LOGE("error reading directory, errno = %d\n", errno);
+        return false;
+    }
+
+    if (foundName[0] == '\0') {
+        LOGE("No matching library found in path %s\n", LIBRARY_PATH);
+        return false;
+    }
+
+    // copy name with file path
+    strcpy(libraryName, LIBRARY_PATH);
+    // add slash if not last of path
+    if (libraryName[strlen(libraryName) -1] != '/') {
+        strcat(libraryName, "/");
+    }
+    strcat(libraryName, foundName);
+    return true;
+}
+
+bool
+androidFmRadioLoadFmLibrary(struct FmSession_t * session_p,
+                            enum RadioMode_t mode)
+{
+    char fmLibName[FM_LIBRARY_NAME_MAX_LENGTH + 1] = "";
+    fmradio_reg_func_t fmRegFunc = NULL;
+    unsigned int magicVal = 0;
+    bool retval = false;
+    bool missingMandatoryFunctions = false;
+
+    // read library directory and find matching library
+
+    if (!androidFmRadioGetLibraryName(mode, fmLibName)) {
+        goto funcret;
+    }
+
+    // load the library
+    session_p->fmLibrary_p = dlopen(fmLibName, RTLD_LAZY);
+    if (session_p->fmLibrary_p == NULL) {
+        LOGI("Could not load library '%s'\n", fmLibName);
+        goto funcret;
+    } else {
+        LOGI("Loaded library %s\n", fmLibName);
+    }
+
+    // now we have loaded the library, check for function
+    fmRegFunc = (fmradio_reg_func_t) dlsym(session_p->fmLibrary_p,
+                                           FMRADIO_REGISTER_FUNC);
+
+    if (fmRegFunc == NULL) {
+        LOGE("Could not find symbol '%s' in loaded library '%s'\n",
+             FMRADIO_REGISTER_FUNC, fmLibName);
+        goto closelib;
+    }
+
+    // call function
+    if (fmRegFunc(&magicVal, session_p->vendorMethods_p) != 0) {
+        LOGE("Loaded function '%s' returned unsuccessful\n",
+             FMRADIO_REGISTER_FUNC);
+        goto closelib;
+    }
+
+    // just to make sure correct function was called
+    if (magicVal != FMRADIO_SIGNATURE) {
+        LOGE("Loaded function '%s' returned successful but failed setting magic value\n", FMRADIO_REGISTER_FUNC);
+        goto closelib;
+    }
+
+    // some methods are considered mandatory to implement, check them
+
+    if(mode == FMRADIO_RX && session_p->vendorMethods_p->rx_start == NULL) {
+        missingMandatoryFunctions = true;
+        LOGE("Mandatory method rx_start is not implemented\n");
+    }
+    if(mode == FMRADIO_TX && session_p->vendorMethods_p->tx_start == NULL) {
+        missingMandatoryFunctions = true;
+        LOGE("Mandatory method tx_start is not implemented\n");
+    }
+    if(session_p->vendorMethods_p->pause == NULL) {
+        missingMandatoryFunctions = true;
+        LOGE("Mandatory method pause is not implemented\n");
+    }
+    if(session_p->vendorMethods_p->resume == NULL) {
+        missingMandatoryFunctions = true;
+        LOGE("Mandatory method resume is not implemented\n");
+    }
+    if(session_p->vendorMethods_p->reset == NULL) {
+        missingMandatoryFunctions = true;
+        LOGE("Mandatory method reset is not implemented\n");
+    }
+    if(missingMandatoryFunctions) {
+        goto closelib;
+    }
+
+    retval = true;
+    goto funcret;
+  closelib:
+    dlclose(session_p->fmLibrary_p);
+  funcret:
+    return retval;
+}
+
+void
+androidFmRadioUnLoadFmLibrary(struct FmSession_t * session_p)
+{
+
+    if (session_p->fmLibrary_p != NULL) {
+        dlclose(session_p->fmLibrary_p);
+        free(session_p->vendorMethods_p);
+        session_p->vendorMethods_p = NULL;
+    }
+}
+
+/* methods common for both RX and TX */
+
+static bool androidFmRadioStartSyncPartner(struct FmSession_t *session_p)
+{
+    /* lock is held when entering this mehod */
+    int maxTime = 5000;    /* in ms */
+
+    /* if partner has ongoing reset await it finishing */
+    while (session_p->partnerSession_p->ongoingReset && maxTime > 0) {
+        pthread_mutex_unlock(session_p->dataMutex_p);
+        usleep(250000);
+        pthread_mutex_lock(session_p->dataMutex_p);
+        maxTime -= 250;
+    }
+
+    if (session_p->partnerSession_p->ongoingReset) {
+        LOGE("partner session stale reset");
+        return false;
+    }
+
+    /* if partner has any other state than IDLE it should be stoped */
+    if (session_p->partnerSession_p->state != FMRADIO_STATE_IDLE) {
+        /* if partner is starting it must be allowed to finish */
+
+        session_p->partnerSession_p->ongoingReset = true; /* to make sure it doesn't do anything else */
+
+        while (!session_p->ongoingReset &&
+               (session_p->partnerSession_p->state == FMRADIO_STATE_STARTING && maxTime > 0)){
+            pthread_mutex_unlock(session_p->dataMutex_p);
+            usleep(250000);
+            pthread_mutex_lock(session_p->dataMutex_p);
+            maxTime -= 250;
+        }
+
+        session_p->partnerSession_p->ongoingReset = false;
+
+        /* if we now have a ongoing reset on our own session just exit */
+
+        if (session_p->ongoingReset) {
+            return false;
+        }
+
+        /* if partner is still starting we should exist */
+        if (session_p->partnerSession_p->state == FMRADIO_STATE_STARTING) {
+            LOGE("time-out waiting for partner startup");
+            return false;
+        }
+
+        /* unless partner already is IDLE, reset and send forced reset */
+        if (session_p->partnerSession_p->state != FMRADIO_STATE_IDLE) {
+            /* temporary drop lock to allow reset triggered callbacks */
+            pthread_mutex_unlock(session_p->dataMutex_p);
+            session_p->partnerSession_p->vendorMethods_p->reset(&session_p->partnerSession_p->vendorData_p);
+            pthread_mutex_lock(session_p->dataMutex_p);
+            FMRADIO_SET_STATE(session_p->partnerSession_p, FMRADIO_STATE_IDLE);
+            session_p->partnerSession_p->callbacks_p->onForcedReset(FMRADIO_RESET_OTHER_IN_USE);
+        }
+        /* unload partner vendor driver */
+        if (session_p->partnerSession_p->isRegistered) {
+            androidFmRadioUnLoadFmLibrary(session_p->partnerSession_p);
+            session_p->partnerSession_p->isRegistered = false;
+        }
+    }
+
+    return true;
+}
+
+static void *execute_androidFmRadioStartAsync(void *args)
+{
+    struct FmRadioStartAsyncParameters *inArgs_p = (struct FmRadioStartAsyncParameters *)args;
+
+    int (*startFunc) (void **, const struct fmradio_vendor_callbacks_t *, int, int, int,
+                      int) = inArgs_p->startFunc;
+    struct FmSession_t *session_p = inArgs_p->session_p;
+
+    const struct fmradio_vendor_callbacks_t *callbacks_p = inArgs_p->callbacks_p;
+
+    int lowFreq = inArgs_p->lowFreq;
+    int highFreq = inArgs_p->highFreq;
+    int defaultFreq = inArgs_p->defaultFreq;
+    int grid = inArgs_p->grid;
+    int retval = 0;
+
+    free(inArgs_p);
+
+    pthread_mutex_lock(session_p->dataMutex_p);
+
+    /*
+     * if other session is starting should wait for them to finish unless we
+     * get a ongoing reset
+     */
+
+    if (!androidFmRadioStartSyncPartner(session_p)) {
+        retval = -1;
+        goto fix_state_and_send_retval;
+    }
+
+    pthread_mutex_unlock(session_p->dataMutex_p);
+
+    retval =
+        startFunc(&session_p->vendorData_p, callbacks_p, lowFreq, highFreq,
+                  defaultFreq, grid);
+
+    pthread_mutex_lock(session_p->dataMutex_p);
+    /* sanity check, not even reset should alter the state when starting */
+    if (session_p->state != FMRADIO_STATE_STARTING) {
+        LOGE("state not starting when going to started...");
+        retval = -1;
+    }
+
+  fix_state_and_send_retval:
+    if (retval >= 0) {
+        FMRADIO_SET_STATE(session_p, FMRADIO_STATE_STARTED);
+    } else {
+        FMRADIO_SET_STATE(session_p, FMRADIO_STATE_IDLE);
+        /* unload vendor driver */
+        androidFmRadioUnLoadFmLibrary(session_p);
+        session_p->isRegistered = false;
+    }
+
+    /*
+     * these need to be called after state is updated and after the lock
+     * has been dropped
+     */
+    if (retval >= 0) {
+        session_p->callbacks_p->onStarted();
+    } else {
+        session_p->callbacks_p->onError();
+    }
+
+    pthread_mutex_unlock(session_p->dataMutex_p);
+
+    pthread_exit(NULL);
+    return NULL;
+}
+
+int
+androidFmRadioStart(struct FmSession_t *session_p, enum RadioMode_t mode,
+                    const struct fmradio_vendor_callbacks_t *callbacks_p,
+                    bool async, int lowFreq, int highFreq, int defaultFreq,
+                    int grid)
+{
+    int retval = 0;
+
+    int (*startFunc) (void **, const struct fmradio_vendor_callbacks_t *,
+                      int, int, int, int) = NULL;
+
+    pthread_mutex_lock(session_p->dataMutex_p);
+    if (!androidFmRadioIsValidEventForState
+        (session_p, FMRADIO_EVENT_START)) {
+        retval = FMRADIO_INVALID_STATE;
+        goto drop_lock;
+    }
+    // set our state to STARTING here to make sure the partner session
+    // can't start again after it is finished
+    FMRADIO_SET_STATE(session_p, FMRADIO_STATE_STARTING);
+
+    // if we haven't registred the library yet do it
+
+    if (!session_p->isRegistered) {
+        session_p->vendorMethods_p = (fmradio_vendor_methods_t *)
+            malloc(sizeof(*session_p->vendorMethods_p));
+        if (session_p->vendorMethods_p == NULL) {
+            LOGE("malloc failed");
+            retval = FMRADIO_IO_ERROR;
+            goto early_exit;
+        } else if (androidFmRadioLoadFmLibrary(session_p, mode)) {
+            session_p->isRegistered = true;
+        } else {
+            LOGE("vendor registration failed");
+            free(session_p->vendorMethods_p);
+            retval = FMRADIO_IO_ERROR;
+            goto early_exit;
+        }
+    }
+
+    if (mode == FMRADIO_RX) {
+        startFunc = session_p->vendorMethods_p->rx_start;
+    } else if (mode == FMRADIO_TX) {
+        startFunc = session_p->vendorMethods_p->tx_start;
+    }
+
+    if (!startFunc) {
+        LOGE("androidFmRadioStart - ERROR - No valid start function found.");
+        retval = FMRADIO_UNSUPPORTED_OPERATION;
+        goto early_exit;
+    }
+
+    if (async) {
+        pthread_t execute_thread;
+
+        struct FmRadioStartAsyncParameters *args_p = (struct FmRadioStartAsyncParameters *)
+                malloc(sizeof(struct FmRadioStartAsyncParameters));    /* freed in created thread */
+
+        if (args_p == NULL) {
+            LOGE("malloc failed");
+            retval = FMRADIO_IO_ERROR;
+            goto early_exit;
+        }
+
+        args_p->startFunc = startFunc;
+        args_p->session_p = session_p;
+        args_p->callbacks_p = callbacks_p;
+        args_p->lowFreq = lowFreq;
+        args_p->highFreq = highFreq;
+        args_p->defaultFreq = defaultFreq;
+        args_p->grid = grid;
+
+        // we need to create a new thread actually executing the command
+        if (pthread_create
+            (&execute_thread, NULL, execute_androidFmRadioStartAsync,
+             (void *) args_p) != 0) {
+            LOGE("pthread_create failure...");
+            free(args_p);
+            retval = FMRADIO_IO_ERROR;
+        } else {
+            pthread_detach(execute_thread);
+        }
+    } else {
+        if (!androidFmRadioStartSyncPartner(session_p)) {
+            retval = -1;
+            goto early_exit;
+        }
+
+        /*
+         * drop lock during long time call but set state to make sure no other
+         * process tries to start while we are starting. Do not use
+         * FMRADIO_SET_STATE macro since it will trigger a onStateChanged
+         * callback
+         */
+        pthread_mutex_unlock(session_p->dataMutex_p);
+        retval =
+            startFunc(&session_p->vendorData_p, callbacks_p, lowFreq,
+                      highFreq, defaultFreq, grid);
+        /* regain lock */
+        pthread_mutex_lock(session_p->dataMutex_p);
+        /* check that nothing has happened before we regained the lock */
+        if (session_p->state != FMRADIO_STATE_STARTING) {
+            LOGE("Error, radio not in IDLE when about to set started mode");
+        }
+    }
+
+    // if successful syncronous start update state
+    if (retval == 0 && !async) {
+        FMRADIO_SET_STATE(session_p, FMRADIO_STATE_STARTED);
+    }
+
+  early_exit:
+
+    if (retval < 0) {
+        if (session_p->state != FMRADIO_STATE_IDLE) {
+            FMRADIO_SET_STATE(session_p, FMRADIO_STATE_IDLE);
+        }
+
+        if (retval != FMRADIO_INVALID_STATE && session_p->isRegistered) {
+            androidFmRadioUnLoadFmLibrary(session_p);
+            session_p->isRegistered = false;
+        }
+    }
+
+  drop_lock:
+
+    if (retval == FMRADIO_INVALID_STATE) {
+        THROW_INVALID_STATE(session_p);
+    } else if ((retval == FMRADIO_INVALID_PARAMETER) ||
+               (retval == FMRADIO_UNSUPPORTED_OPERATION)) {
+        THROW_UNSUPPORTED_OPERATION(session_p);
+    } else if (retval < 0) {
+        THROW_IO_ERROR(session_p);
+    }
+
+    pthread_mutex_unlock(session_p->dataMutex_p);
+
+    return retval;
+}
+
+int androidFmRadioPause(struct FmSession_t *session_p)
+{
+    int retval;
+
+    pthread_mutex_lock(session_p->dataMutex_p);
+    if (!androidFmRadioIsValidEventForState
+        (session_p, FMRADIO_EVENT_PAUSE)) {
+        retval = FMRADIO_INVALID_STATE;
+        goto drop_lock;
+    }
+
+    if (session_p->state == FMRADIO_STATE_PAUSED) {
+        // already paused, just return
+        retval = FMRADIO_OK;
+        goto drop_lock;
+    }
+
+
+    retval =  session_p->vendorMethods_p->pause(&session_p->vendorData_p);
+
+    if (retval == 0) {
+        FMRADIO_SET_STATE(session_p, FMRADIO_STATE_PAUSED);
+    }
+
+  drop_lock:
+    if (retval == FMRADIO_INVALID_STATE) {
+        THROW_INVALID_STATE(session_p);
+    } else if (retval < 0) {
+        THROW_IO_ERROR(session_p);
+    }
+
+    pthread_mutex_unlock(session_p->dataMutex_p);
+
+    return retval;
+}
+
+int androidFmRadioResume(struct FmSession_t *session_p)
+{
+    int retval = 0;
+
+    pthread_mutex_lock(session_p->dataMutex_p);
+
+    if (!androidFmRadioIsValidEventForState
+        (session_p, FMRADIO_EVENT_RESUME)) {
+        retval = FMRADIO_INVALID_STATE;
+        goto drop_lock;
+    }
+
+    if (session_p->state == FMRADIO_STATE_STARTED) {
+        //already started, just return
+        retval = FMRADIO_OK;
+        goto drop_lock;
+    }
+
+    retval = session_p->vendorMethods_p->resume(&session_p->vendorData_p);
+
+    // if successful update state
+    if (retval == 0) {
+        FMRADIO_SET_STATE(session_p, FMRADIO_STATE_STARTED);
+    }
+    // nothing on failure
+
+  drop_lock:
+    if (retval == FMRADIO_INVALID_STATE) {
+        THROW_INVALID_STATE(session_p);
+    } else if (retval < 0) {
+        THROW_IO_ERROR(session_p);
+    }
+
+    pthread_mutex_unlock(session_p->dataMutex_p);
+    return retval;
+}
+
+int androidFmRadioReset(struct FmSession_t *session_p)
+{
+    int retval = FMRADIO_OK;
+    int oldState = session_p->state;
+
+    pthread_mutex_lock(session_p->dataMutex_p);
+
+    if (!androidFmRadioIsValidEventForState
+        (session_p, FMRADIO_EVENT_RESET)) {
+        retval = FMRADIO_INVALID_STATE;
+        goto drop_lock;
+    }
+
+    /* Worker threads must be cleaned up before sending reset */
+    if(session_p->state == FMRADIO_STATE_SCANNING){
+        pthread_mutex_unlock(session_p->dataMutex_p);
+        androidFmRadioStopScan(session_p);
+        pthread_mutex_lock(session_p->dataMutex_p);
+        /* Waiting for worker thread to exit gracefully */
+        pthread_cond_wait(&session_p->sync_cond,
+                session_p->dataMutex_p);
+    }
+    /* idle or about to be reset, just return state */
+    if (session_p->ongoingReset || oldState == FMRADIO_STATE_IDLE) {
+        retval = oldState;
+        goto drop_lock;
+    }
+    session_p->ongoingReset = true;
+
+    /* if we are in starting state we must await the start finishing */
+    if (oldState == FMRADIO_STATE_STARTING) {
+        /* we need to await end of start before starting */
+        int maxTime = 5000;    /* in ms */
+        do {
+            pthread_mutex_unlock(session_p->dataMutex_p);
+            usleep(250000);
+            pthread_mutex_lock(session_p->dataMutex_p);
+            maxTime -= 250;
+        } while (maxTime > 0 && (session_p->state == FMRADIO_STATE_STARTING));
+    }
+
+    /* if we still are in STARTING state we must fail now */
+    if (session_p->state == FMRADIO_STATE_STARTING) {
+        retval = FMRADIO_IO_ERROR;
+        goto drop_ongoing_reset;
+    }
+
+    /*
+     * we need to temporary release lock since reset might trigger
+     * callbacks. Set flag to not allow any state changing command
+     */
+    FMRADIO_SET_STATE(session_p, FMRADIO_STATE_IDLE);
+
+    pthread_mutex_unlock(session_p->dataMutex_p);
+    retval = session_p->vendorMethods_p->
+                        reset(&session_p->vendorData_p);
+    pthread_mutex_lock(session_p->dataMutex_p);
+
+    // if successful unload vendor driver
+    if (retval >= 0) {
+        retval = oldState;
+        if (session_p->isRegistered) {
+            androidFmRadioUnLoadFmLibrary(session_p);
+            session_p->isRegistered = false;
+        }
+    } else {
+        LOGE("androidFmRadioReset failed");
+    }
+    // nothing on failure
+  drop_ongoing_reset:
+    session_p->ongoingReset = false;
+  drop_lock:
+    if (retval == FMRADIO_INVALID_STATE) {
+        THROW_INVALID_STATE(session_p);
+    } else if (retval < 0) {
+        THROW_IO_ERROR(session_p);
+    }
+
+    pthread_mutex_unlock(session_p->dataMutex_p);
+
+    return retval;
+}
+
+void
+androidFmRadioSetFrequency(struct FmSession_t *session_p, int frequency)
+{
+    int retval = 0;
+
+    pthread_mutex_lock(session_p->dataMutex_p);
+    if (!androidFmRadioIsValidEventForState
+        (session_p, FMRADIO_EVENT_SET_FREQUENCY)) {
+        retval = FMRADIO_INVALID_STATE;
+        goto drop_lock;
+    }
+
+    if (session_p->vendorMethods_p->set_frequency) {
+        /* if in pause state temporary resume */
+        androidFmRadioTempResumeIfPaused(session_p);
+
+        retval =
+            session_p->vendorMethods_p->set_frequency(&session_p->
+                                                     vendorData_p,
+                                                     frequency);
+
+        androidFmRadioPauseIfTempResumed(session_p);
+    } else {
+        retval = FMRADIO_UNSUPPORTED_OPERATION;
+    }
+
+    // no state is ever updated
+    if (retval < 0) {
+        LOGE("androidFmRadioSetFrequency failed\n");
+    }
+
+  drop_lock:
+    if (retval == FMRADIO_INVALID_STATE) {
+        THROW_INVALID_STATE(session_p);
+    } else if (retval == FMRADIO_INVALID_PARAMETER) {
+        THROW_ILLEGAL_ARGUMENT(session_p);
+    } else if (retval < 0) {
+        THROW_IO_ERROR(session_p);
+    }
+
+    pthread_mutex_unlock(session_p->dataMutex_p);
+}
+
+int androidFmRadioGetFrequency(struct FmSession_t *session_p)
+{
+    int retval = 0;
+
+    pthread_mutex_lock(session_p->dataMutex_p);
+
+    if (!androidFmRadioIsValidEventForState
+        (session_p, FMRADIO_EVENT_GET_FREQUENCY)) {
+        retval = FMRADIO_INVALID_STATE;
+        goto drop_lock;
+    }
+
+    if (session_p->vendorMethods_p->get_frequency) {
+        /* if in pause state temporary resume */
+        androidFmRadioTempResumeIfPaused(session_p);
+
+        retval =
+            session_p->vendorMethods_p->get_frequency(&session_p->
+                                                     vendorData_p);
+
+        androidFmRadioPauseIfTempResumed(session_p);
+    } else {
+        retval = FMRADIO_UNSUPPORTED_OPERATION;
+    }
+
+  drop_lock:
+    if (retval == FMRADIO_INVALID_STATE) {
+        THROW_INVALID_STATE(session_p);
+    } else if (retval < 0) {
+        THROW_IO_ERROR(session_p);
+    }
+
+    pthread_mutex_unlock(session_p->dataMutex_p);
+
+    return retval;
+}
+
+void androidFmRadioStopScan(struct FmSession_t *session_p)
+{
+    int retval = 0;
+
+    pthread_mutex_lock(session_p->dataMutex_p);
+
+    if (!androidFmRadioIsValidEventForState
+        (session_p, FMRADIO_EVENT_STOP_SCAN)) {
+        goto drop_lock;
+    }
+
+    if (session_p->state != FMRADIO_STATE_SCANNING) {
+        /* if we're not in scanning, don't attempt anything just return */
+        goto drop_lock;
+    }
+
+    if (session_p->vendorMethods_p->stop_scan) {
+        retval =
+            session_p->vendorMethods_p->stop_scan(&session_p->vendorData_p);
+    } else {
+        retval = FMRADIO_UNSUPPORTED_OPERATION;
+    }
+
+    if (retval == 0) {
+        session_p->lastScanAborted = true;
+    }
+
+    retval = FMRADIO_OK;
+  drop_lock:
+    /* note - no exceptions. Just return */
+
+    if (retval != FMRADIO_OK) {
+        LOGE("androidFmRadioStopScan failed (%d), ignored.\n", retval);
+    }
+    pthread_mutex_unlock(session_p->dataMutex_p);
+}
+
+static void *execute_androidFmRadioSendExtraCommand(void *args_p)
+{
+    struct FmRadioSendExtraCommandParameters* inArgs_p = (struct FmRadioSendExtraCommandParameters*)args_p;
+    struct FmSession_t *session_p = inArgs_p->session_p;
+    char *c_command = inArgs_p->c_command;
+    char **parameter = inArgs_p->cparams;
+    struct fmradio_extra_command_ret_item_t *returnParam = NULL;
+    int retval;
+
+    free(inArgs_p);
+
+    pthread_mutex_lock(session_p->dataMutex_p);
+
+    // we should be in state EXTRA_COMMAND
+    if (session_p->state != FMRADIO_STATE_EXTRA_COMMAND) {
+        LOGE("execute_androidFmRadioSendExtraCommand - warning, state not extra commands\n");
+    }
+
+    if (session_p->vendorMethods_p->send_extra_command != NULL) {
+        pthread_mutex_unlock(session_p->dataMutex_p);
+        retval =
+            session_p->vendorMethods_p->send_extra_command(&session_p->
+                                                         vendorData_p,
+                                                         c_command,
+                                                         parameter,
+                                                         &returnParam);
+        pthread_mutex_lock(session_p->dataMutex_p);
+        freeCstringArray(parameter);
+    } else {
+        retval = FMRADIO_UNSUPPORTED_OPERATION;
+    }
+
+    if (session_p->state != FMRADIO_STATE_EXTRA_COMMAND) {
+        LOGE("State changed while executing extra commands (state now %d), keeping\n", session_p->state);
+    } else {
+        if (session_p->pendingPause) {
+            session_p->vendorMethods_p->pause(&session_p->
+                                                  vendorData_p);
+            FMRADIO_SET_STATE(session_p, FMRADIO_STATE_PAUSED);
+        } else {
+            FMRADIO_SET_STATE(session_p, session_p->oldState);
+        }
+    }
+
+    session_p->pendingPause = false;
+
+    if (retval >= 0) {
+        session_p->callbacks_p->onSendExtraCommand(c_command, returnParam);
+    } else {
+        session_p->callbacks_p->onError();
+    }
+
+    if (returnParam != NULL) {
+        freeExtraCommandRetList(returnParam);
+    }
+
+    if (c_command != NULL) {
+        free(c_command);
+    }
+
+    pthread_mutex_unlock(session_p->dataMutex_p);
+    pthread_exit(NULL);
+    return NULL;
+}
+
+void
+androidFmRadioSendExtraCommand(struct FmSession_t *session_p,
+                               JNIEnv * env_p, jstring jcommand,
+                               jobjectArray parameter)
+{
+    int retval = FMRADIO_OK;
+    char **cparams;
+    struct FmRadioSendExtraCommandParameters *args_p = NULL;
+    pthread_t execute_thread;
+
+    pthread_mutex_lock(session_p->dataMutex_p);
+
+    if (!androidFmRadioIsValidEventForState
+        (session_p, FMRADIO_EVENT_EXTRA_COMMAND)) {
+        retval = FMRADIO_INVALID_STATE;
+        goto drop_lock;
+    }
+
+    if (!jstringArray2cstringArray(env_p, parameter, &cparams)) {
+        retval = FMRADIO_IO_ERROR;
+        goto drop_lock;
+    }
+
+    session_p->oldState = session_p->state;
+
+    args_p = (struct FmRadioSendExtraCommandParameters *) malloc(sizeof(struct FmRadioSendExtraCommandParameters));     /* freed in created thread */
+    if (args_p == NULL) {
+        LOGE("malloc failed\n");
+        retval = FMRADIO_IO_ERROR;
+    }
+
+    if (retval == FMRADIO_OK) {
+        const char* c_command = env_p->GetStringUTFChars(jcommand, 0);
+
+        args_p->session_p = session_p;
+        args_p->c_command = strdup(c_command);
+        args_p->cparams = cparams;
+
+        env_p->ReleaseStringUTFChars(jcommand, c_command);
+
+        // we need to create a new thread actually executing the command
+        if (pthread_create
+            (&execute_thread, NULL, execute_androidFmRadioSendExtraCommand,
+             args_p) != 0) {
+            LOGE("pthread_create failed\n");
+            free(args_p->c_command);
+            free(args_p);
+            retval = FMRADIO_IO_ERROR;
+        } else {
+            pthread_detach(execute_thread);
+        }
+
+    }
+
+    if (retval == FMRADIO_OK) {
+        FMRADIO_SET_STATE(session_p, FMRADIO_STATE_EXTRA_COMMAND);
+    }
+
+  drop_lock:
+
+    if (retval == FMRADIO_INVALID_STATE) {
+        THROW_INVALID_STATE(session_p);
+    } else if (retval < 0) {
+        THROW_IO_ERROR(session_p);
+    }
+
+    pthread_mutex_unlock(session_p->dataMutex_p);
+}
+
+
+namespace android {
+int registerAndroidFmRadioReceiver(JavaVM* vm, JNIEnv *env);
+int registerAndroidFmRadioTransmitter(JavaVM* vm, JNIEnv *env);
+};
+
+using namespace android;
+
+extern "C" jint JNI_OnLoad(JavaVM* vm, void* reserved)
+{
+    JNIEnv* env = NULL;
+    jint result = -1;
+
+    if (vm->GetEnv((void**) &env, JNI_VERSION_1_4) != JNI_OK) {
+        LOGE("GetEnv failed!");
+        return result;
+    }
+    LOG_ASSERT(env, "Could not retrieve the env!");
+
+    registerAndroidFmRadioReceiver(vm, env);
+    registerAndroidFmRadioTransmitter(vm, env);
+
+    return JNI_VERSION_1_4;
+}
diff --git a/fmradio/jni/android_fmradio_Receiver.cpp b/fmradio/jni/android_fmradio_Receiver.cpp
new file mode 100755
index 0000000..d8e520d
--- /dev/null
+++ b/fmradio/jni/android_fmradio_Receiver.cpp
@@ -0,0 +1,1494 @@
+/*
+ * Copyright (C) ST-Ericsson SA 2010
+ * Copyright 2010, The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+ * Authors: johan.xj.palmaeus@stericsson.com
+ *          stuart.macdonald@stericsson.com
+ *          for ST-Ericsson
+ */
+
+/*
+ * Native part of the generic RX FmRadio inteface
+ */
+
+#define LOG_TAG "FmReceiverServiceNative"
+
+// #define LOG_NDEBUG 1
+
+#include <stdio.h>
+#include <unistd.h>
+#include <errno.h>
+#include <termios.h>
+#include <string.h>
+#include <stdlib.h>
+#include <time.h>
+#include <stdarg.h>
+#include <signal.h>
+#include <pthread.h>
+#include <math.h>
+
+
+#include "jni.h"
+#include "JNIHelp.h"
+#include "android_fmradio.h"
+#include <utils/Log.h>
+
+
+/* *INDENT-OFF* */
+namespace android {
+
+
+// state machine
+
+static const ValidEventsForStates_t IsValidRxEventForState = {
+  /* this table defines valid transitions. (turn off indent, we want this easy readable) */
+             /* FMRADIO_STATE_ IDLE,STARTING,STARTED,PAUSED,SCANNING,EXTRA_COMMAND */
+
+   /* FMRADIO_EVENT_START */         {true ,false,false,false,false,false},
+   /* FMRADIO_EVENT_START_ASYNC */   {true ,false,false,false,false,false},
+   /* FMRADIO_EVENT_PAUSE */         {false,false,true, true, false,false},
+   /* FMRADIO_EVENT_RESUME */        {false,false,true, true, false,false},
+   /* FMRADIO_EVENT_RESET */         {true, true, true, true, true, true },
+   /* FMRADIO_EVENT_GET_FREQUENCY */ {false,false,true, true, false,false},
+   /* FMRADIO_EVENT_SET_FREQUENCY */ {false,false,true, true, false,false},
+   /* FMRADIO_EVENT_SET_PARAMETER */ {false,false,true, true, true, true },
+   /* FMRADIO_EVENT_STOP_SCAN */     {true, true, true, true, true, true },
+   /* FMRADIO_EVENT_EXTRA_COMMAND */ {true, true, true, true, true, true },
+   /* Rx Only */
+   /* FMRADIO_EVENT_GET_PARAMETER */ {false,false,true, true, true, true },
+   /* FMRADIO_EVENT_GET_SIGNAL_STRENGTH */{false,false,true,true,false,false},
+   /* FMRADIO_EVENT_SCAN */          {false,false,true, true, false,false},
+   /* FMRADIO_EVENT_FULL_SCAN */     {false,false,true, true, false,false},
+   // Tx Only - never allowed
+   /* FMRADIO_EVENT_BLOCK_SCAN */    {false,false,false,false,false,false},
+};
+/*  *INDENT-ON*  */
+
+/* Callbacks to java layer */
+
+static void androidFmRadioRxCallbackOnStateChanged(int oldState,
+                                                   int newState);
+static void androidFmRadioRxCallbackOnError(void);
+
+static void androidFmRadioRxCallbackOnStarted(void);
+
+static void androidFmRadioRxCallbackOnScan(int foundFreq,
+                                           int signalStrength,
+                                           int scanDirection,
+                                           bool aborted);
+static void androidFmRadioRxCallbackOnFullScan(int noItems,
+                                               int *frequencies,
+                                               int *sigStrengths,
+                                               bool aborted);
+static void androidFmRadioRxCallbackOnForcedReset(enum fmradio_reset_reason_t reason);
+
+static void androidFmRadioRxCallbackOnVendorForcedReset(enum fmradio_reset_reason_t reason);
+
+static void androidFmRadioRxCallbackOnSignalStrengthChanged(int newLevel);
+
+static void androidFmRadioRxCallbackOnRDSDataFound(struct
+                                                   fmradio_rds_bundle_t
+                                                   *t, int frequency);
+
+static void androidFmRadioRxCallbackOnPlayingInStereo(int
+                                                      isPlayingInStereo);
+
+static void androidFmRadioRxCallbackOnExtraCommand(char* command,
+                                                   struct
+                                                   fmradio_extra_command_ret_item_t
+                                                   *retItem);
+
+static void androidFmRadioRxCallbackOnAutomaticSwitch(int newFrequency, enum fmradio_switch_reason_t reason);
+
+static const FmRadioCallbacks_t FmRadioRxCallbacks = {
+    androidFmRadioRxCallbackOnStateChanged,
+    androidFmRadioRxCallbackOnError,
+    androidFmRadioRxCallbackOnStarted,
+    androidFmRadioRxCallbackOnScan,
+    androidFmRadioRxCallbackOnFullScan,
+    NULL,
+    androidFmRadioRxCallbackOnForcedReset,
+    androidFmRadioRxCallbackOnExtraCommand,
+};
+
+/* callbacks from vendor layer */
+
+static const fmradio_vendor_callbacks_t FmRadioRxVendorCallbacks = {
+    androidFmRadioRxCallbackOnPlayingInStereo,
+    androidFmRadioRxCallbackOnRDSDataFound,
+    androidFmRadioRxCallbackOnSignalStrengthChanged,
+    androidFmRadioRxCallbackOnAutomaticSwitch,
+    androidFmRadioRxCallbackOnVendorForcedReset
+};
+
+extern struct FmSession_t fmTransmitterSession;
+
+struct FmSession_t fmReceiverSession = {
+    NULL,
+    NULL,
+    false,
+    FMRADIO_STATE_IDLE,
+    NULL,
+    &IsValidRxEventForState,
+    &FmRadioRxCallbacks,
+    NULL,
+    NULL,
+    &fmTransmitterSession,
+    NULL,
+    FMRADIO_STATE_IDLE,
+    false,
+    false,
+    false,
+    &rx_tx_common_mutex,
+    PTHREAD_COND_INITIALIZER,
+    NULL,
+};
+
+// make sure we don't refer the TransmitterSession anymore from here
+#define fmTransmitterSession ERRORDONOTUSERECEIVERSESSIONINTRANSMITTER
+
+/*
+* Implementation of callbacks from within service layer. For these the
+*  mutex lock is always held on entry and need to be released before doing
+*  calls to java layer (env->Call*Method)  becasue these might trigger new
+*  calls from java and a deadlock would occure if lock was still held.
+*/
+
+static void androidFmRadioRxCallbackOnStateChanged(int oldState,
+                                                   int newState)
+{
+    jmethodID notifyOnStateChangedMethod;
+    JNIEnv *env;
+    jclass clazz;
+    bool reAttached = false;
+
+    LOGI("androidFmRadioRxCallbackOnStateChanged: Old state %d, new state %d", oldState, newState);
+
+    /* since we might be both in main thread and subthread both test getenv
+     * and attach */
+    if (fmReceiverSession.jvm_p->GetEnv((void **) &env, JNI_VERSION_1_4) !=
+        JNI_OK) {
+        reAttached = true;
+        if (fmReceiverSession.jvm_p->AttachCurrentThread(&env, NULL) != JNI_OK) {
+            LOGE("Error, can't attach current thread");
+            return;
+        }
+    }
+
+    clazz = env->GetObjectClass(fmReceiverSession.jobj);
+
+    notifyOnStateChangedMethod =
+        env->GetMethodID(clazz, "notifyOnStateChanged", "(II)V");
+    if (notifyOnStateChangedMethod != NULL) {
+        jobject jobj = fmReceiverSession.jobj;
+        pthread_mutex_unlock(fmReceiverSession.dataMutex_p);
+        env->CallVoidMethod(jobj,
+                            notifyOnStateChangedMethod, oldState,
+                            newState);
+        pthread_mutex_lock(fmReceiverSession.dataMutex_p);
+    } else {
+        LOGE("ERROR - JNI can't find java notifyOnStateChanged method");
+    }
+
+    if (reAttached) {
+        fmReceiverSession.jvm_p->DetachCurrentThread();
+    }
+}
+
+static void androidFmRadioRxCallbackOnError(void)
+{
+    jmethodID notifyMethod;
+    JNIEnv *env;
+    jclass clazz;
+
+    LOGI("androidFmRadioRxCallbackOnError");
+
+    if (fmReceiverSession.jvm_p->AttachCurrentThread(&env, NULL) != JNI_OK) {
+        LOGE("Error, can't attch current thread");
+        return;
+    }
+
+    clazz = env->GetObjectClass(fmReceiverSession.jobj);
+    notifyMethod = env->GetMethodID(clazz, "notifyOnError", "()V");
+
+    if (notifyMethod != NULL) {
+        jobject jobj = fmReceiverSession.jobj;
+        pthread_mutex_unlock(fmReceiverSession.dataMutex_p);
+        env->CallVoidMethod(jobj, notifyMethod);
+        pthread_mutex_lock(fmReceiverSession.dataMutex_p);
+    } else {
+        LOGE("ERROR - JNI can't find java notifyOnError method");
+    }
+
+    fmReceiverSession.jvm_p->DetachCurrentThread();
+}
+
+static void androidFmRadioRxCallbackOnStarted(void)
+{
+    jmethodID notifyMethod;
+    JNIEnv *env;
+    jclass clazz;
+
+    LOGI("androidFmRadioRxCallbackOnStarted");
+
+    if (fmReceiverSession.jvm_p->AttachCurrentThread(&env, NULL) != JNI_OK) {
+        LOGE("Error, can't attch current thread");
+        return;
+    }
+
+    clazz = env->GetObjectClass(fmReceiverSession.jobj);
+    notifyMethod = env->GetMethodID(clazz, "notifyOnStarted", "()V");
+
+    if (notifyMethod != NULL) {
+        jobject jobj = fmReceiverSession.jobj;
+        pthread_mutex_unlock(fmReceiverSession.dataMutex_p);
+        env->CallVoidMethod(jobj, notifyMethod);
+        pthread_mutex_lock(fmReceiverSession.dataMutex_p);
+    } else {
+        LOGE("ERROR - JNI can't find java notifyOnStarted method");
+    }
+
+    fmReceiverSession.jvm_p->DetachCurrentThread();
+}
+
+
+static void androidFmRadioRxCallbackOnScan(int foundFreq,
+                                           int signalStrength,
+                                           int scanDirection,
+                                           bool aborted)
+{
+    jmethodID notifyMethod;
+    JNIEnv *env;
+    jclass clazz;
+
+    LOGI("androidFmRadioRxCallbackOnScan: Callback foundFreq %d, signalStrength %d,"
+         " scanDirection %d, aborted %u", foundFreq, signalStrength, scanDirection,
+         aborted);
+
+    if (fmReceiverSession.jvm_p->AttachCurrentThread(&env, NULL) != JNI_OK) {
+        LOGE("Error, can't attch current thread");
+        return;
+    }
+
+    clazz = env->GetObjectClass(fmReceiverSession.jobj);
+
+    notifyMethod = env->GetMethodID(clazz, "notifyOnScan", "(IIIZ)V");
+
+    if (notifyMethod != NULL) {
+        jobject jobj = fmReceiverSession.jobj;
+        pthread_mutex_unlock(fmReceiverSession.dataMutex_p);
+        env->CallVoidMethod(jobj, notifyMethod, foundFreq, signalStrength,
+                            scanDirection, aborted);
+        pthread_mutex_lock(fmReceiverSession.dataMutex_p);
+    } else {
+        LOGE("ERROR - JNI can't find java notifyOnScan method");
+    }
+
+    fmReceiverSession.jvm_p->DetachCurrentThread();
+}
+
+static void androidFmRadioRxCallbackOnFullScan(int noItems,
+                                               int *frequencies,
+                                               int *sigStrengths,
+                                               bool aborted)
+{
+    jmethodID notifyMethod;
+    JNIEnv *env;
+    jclass clazz;
+    jintArray jFreqs;
+    jintArray jSigStrengths;
+
+    int d;
+
+    LOGI("androidFmRadioRxCallbackOnFullScan: No items %d, aborted %d",
+         noItems, aborted);
+
+    for (d = 0; d < noItems; d++) {
+        LOGI("%d -> %d", frequencies[d], sigStrengths[d]);
+    }
+
+    if (fmReceiverSession.jvm_p->AttachCurrentThread(&env, NULL) != JNI_OK) {
+        LOGE("Error, can't attch current thread");
+        return;
+    }
+
+    jFreqs = env->NewIntArray(noItems);
+    jSigStrengths = env->NewIntArray(noItems);
+    clazz = env->GetObjectClass(fmReceiverSession.jobj);
+
+    env->SetIntArrayRegion(jFreqs, 0, noItems, frequencies);
+    env->SetIntArrayRegion(jSigStrengths, 0, noItems, sigStrengths);
+
+
+    notifyMethod = env->GetMethodID(clazz, "notifyOnFullScan", "([I[IZ)V");
+
+    if (notifyMethod != NULL) {
+        jobject jobj = fmReceiverSession.jobj;
+        pthread_mutex_unlock(fmReceiverSession.dataMutex_p);
+
+        env->CallVoidMethod(jobj, notifyMethod,
+                            jFreqs, jSigStrengths, aborted);
+        pthread_mutex_lock(fmReceiverSession.dataMutex_p);
+    } else {
+        LOGE("ERROR - JNI can't find java notifyOnFullScan method");
+    }
+
+    fmReceiverSession.jvm_p->DetachCurrentThread();
+}
+
+static void androidFmRadioRxCallbackOnForcedReset(enum fmradio_reset_reason_t reason)
+{
+    jmethodID notifyMethod;
+    JNIEnv *env;
+    jclass clazz;
+    bool reAttached = false;
+
+    LOGI("androidFmRadioRxCallbackOnForcedReset");
+
+    if (fmReceiverSession.jvm_p->GetEnv((void **) &env, JNI_VERSION_1_4) !=
+        JNI_OK) {
+        reAttached = true;
+        if (fmReceiverSession.jvm_p->AttachCurrentThread(&env, NULL) != JNI_OK) {
+            LOGE("Error, can't attch current thread");
+            return;
+        }
+    }
+
+    clazz = env->GetObjectClass(fmReceiverSession.jobj);
+
+    notifyMethod = env->GetMethodID(clazz, "notifyOnForcedReset", "(I)V");
+    if (notifyMethod != NULL) {
+        jobject jobj = fmReceiverSession.jobj;
+        pthread_mutex_unlock(fmReceiverSession.dataMutex_p);
+        env->CallVoidMethod(jobj, notifyMethod,
+                            reason);
+        pthread_mutex_lock(fmReceiverSession.dataMutex_p);
+    }
+
+    if (reAttached) {
+        fmReceiverSession.jvm_p->DetachCurrentThread();
+    }
+}
+
+static void androidFmRadioRxCallbackOnVendorForcedReset(enum fmradio_reset_reason_t reason)
+{
+
+    LOGI("androidFmRadioRxCallbackOnVendorForcedReset");
+    pthread_mutex_lock(fmReceiverSession.dataMutex_p);
+    if (fmReceiverSession.state != FMRADIO_STATE_IDLE) {
+        FMRADIO_SET_STATE(&fmReceiverSession, FMRADIO_STATE_IDLE);
+        androidFmRadioUnLoadFmLibrary(&fmReceiverSession);
+        fmReceiverSession.isRegistered = false;
+    }
+    fmReceiverSession.callbacks_p->onForcedReset(reason);
+    pthread_mutex_unlock(fmReceiverSession.dataMutex_p);
+}
+
+
+static void androidFmRadioRxCallbackOnExtraCommand(char* command,
+                                                   struct
+                                                   fmradio_extra_command_ret_item_t
+                                                   *retList)
+{
+    jmethodID notifyMethod;
+    JNIEnv *env;
+    jclass clazz;
+
+    struct bundle_descriptor_offsets_t *bundle_p =
+        fmReceiverSession.bundleOffsets_p;
+
+    LOGI("androidFmRadioRxCallbackOnSendExtraCommand");
+
+    if (fmReceiverSession.jvm_p->AttachCurrentThread(&env, NULL) != JNI_OK) {
+        LOGE("Error, can't attch current thread");
+        return;
+    }
+
+    clazz = env->GetObjectClass(fmReceiverSession.jobj);
+    jobject retBundle = extraCommandRetList2Bundle(env, bundle_p, retList);
+    jstring jcommand = env->NewStringUTF(command);
+
+    notifyMethod =
+        env->GetMethodID(clazz, "notifyOnExtraCommand",
+                         "(Ljava/lang/String;Landroid/os/Bundle;)V");
+    if (notifyMethod != NULL) {
+        jobject jobj = fmReceiverSession.jobj;
+        pthread_mutex_unlock(fmReceiverSession.dataMutex_p);
+
+        env->CallVoidMethod(jobj, notifyMethod, jcommand, retBundle);
+        pthread_mutex_lock(fmReceiverSession.dataMutex_p);
+    }
+
+    fmReceiverSession.jvm_p->DetachCurrentThread();
+}
+
+/*
+* Implementation of callbacks from vendor layer. For these the  mutex lock
+* is NOT held on entry and need to be taken and released before doing
+*  calls to java layer (env->Call*Method)  becasue these might trigger new
+*  calls from java and a deadlock would occure
+*/
+
+static void
+androidFmRadioRxCallbackOnRDSDataFound(struct fmradio_rds_bundle_t *t,
+                                       int frequency)
+{
+    jmethodID notifyMethod;
+    JNIEnv *env;
+    jclass clazz;
+    jobject bundle;
+    jshortArray jsArr;
+
+    pthread_mutex_lock(fmReceiverSession.dataMutex_p);
+    struct bundle_descriptor_offsets_t *bundle_p =
+        fmReceiverSession.bundleOffsets_p;
+
+    if (fmReceiverSession.jvm_p->AttachCurrentThread(&env, NULL) != JNI_OK) {
+        LOGE("Error, can't attch current thread");
+        goto drop_lock;
+    }
+    bundle = env->NewObject(bundle_p->mClass,
+                                    bundle_p->mConstructor);
+    /* note, these calls are to predefined methods, no need to release lock */
+    env->CallVoidMethod(bundle, bundle_p->mPutShort,
+                        env->NewStringUTF("PI"), t->pi);
+    env->CallVoidMethod(bundle, bundle_p->mPutShort,
+                        env->NewStringUTF("TP"), t->tp);
+    env->CallVoidMethod(bundle, bundle_p->mPutShort,
+                        env->NewStringUTF("PTY"), t->pty);
+    env->CallVoidMethod(bundle, bundle_p->mPutShort,
+                        env->NewStringUTF("TA"), t->ta);
+    env->CallVoidMethod(bundle, bundle_p->mPutShort,
+                        env->NewStringUTF("M/S"), t->ms);
+
+    if (t->num_afs > 0 && t->num_afs < RDS_MAX_AFS) {
+        jintArray jArr = env->NewIntArray(t->num_afs);
+        env->SetIntArrayRegion(jArr, 0, t->num_afs, t->af);
+        env->CallVoidMethod(bundle, bundle_p->mPutIntArray,
+                            env->NewStringUTF("AF"), jArr);
+    }
+    env->CallVoidMethod(bundle, bundle_p->mPutString,
+                        env->NewStringUTF("PSN"),
+                        env->NewStringUTF(t->psn));
+    env->CallVoidMethod(bundle, bundle_p->mPutString,
+                        env->NewStringUTF("RT"),
+                        env->NewStringUTF(t->rt));
+    env->CallVoidMethod(bundle, bundle_p->mPutString,
+                        env->NewStringUTF("CT"),
+                        env->NewStringUTF(t->ct));
+    env->CallVoidMethod(bundle, bundle_p->mPutString,
+                        env->NewStringUTF("PTYN"),
+                        env->NewStringUTF(t->ptyn));
+
+    jsArr = env->NewShortArray(3);
+
+    env->SetShortArrayRegion(jsArr, 0, 3, t->tmc);
+    env->CallVoidMethod(bundle, bundle_p->mPutShortArray,
+                        env->NewStringUTF("TMC"), jsArr);
+
+    env->CallVoidMethod(bundle, bundle_p->mPutInt,
+                        env->NewStringUTF("TAF"), t->taf);
+
+    clazz = env->GetObjectClass(fmReceiverSession.jobj);
+
+    notifyMethod =
+        env->GetMethodID(clazz, "notifyOnRDSDataFound",
+                         "(Landroid/os/Bundle;I)V");
+    if (notifyMethod != NULL) {
+        jobject jobj = fmReceiverSession.jobj;
+        pthread_mutex_unlock(fmReceiverSession.dataMutex_p);
+        env->CallVoidMethod(jobj, notifyMethod,
+                            bundle, frequency);
+        pthread_mutex_lock(fmReceiverSession.dataMutex_p);
+    }
+    fmReceiverSession.jvm_p->DetachCurrentThread();
+
+ drop_lock:
+    pthread_mutex_unlock(fmReceiverSession.dataMutex_p);
+}
+
+static void androidFmRadioRxCallbackOnSignalStrengthChanged(int newLevel)
+{
+    jmethodID notifyMethod;
+    JNIEnv *env;
+    jclass clazz;
+
+    pthread_mutex_lock(fmReceiverSession.dataMutex_p);
+    if (fmReceiverSession.jvm_p->AttachCurrentThread(&env, NULL) != JNI_OK) {
+        LOGE("Error, can't attch current thread");
+        goto drop_lock;
+    }
+    clazz = env->GetObjectClass(fmReceiverSession.jobj);
+    notifyMethod =
+        env->GetMethodID(clazz, "notifyOnSignalStrengthChanged", "(I)V");
+    if (notifyMethod != NULL) {
+        jobject jobj = fmReceiverSession.jobj;
+        pthread_mutex_unlock(fmReceiverSession.dataMutex_p);
+        env->CallVoidMethod(jobj, notifyMethod,
+                            newLevel);
+        pthread_mutex_lock(fmReceiverSession.dataMutex_p);
+    }
+
+    fmReceiverSession.jvm_p->DetachCurrentThread();
+ drop_lock:
+    pthread_mutex_unlock(fmReceiverSession.dataMutex_p);
+}
+
+static void androidFmRadioRxCallbackOnPlayingInStereo(int
+                                                      isPlayingInStereo)
+{
+    jmethodID notifyMethod;
+    JNIEnv *env;
+    jclass clazz;
+
+    LOGI("androidFmRadioRxCallbackOnPlayingInStereo (%d)",
+         isPlayingInStereo);
+
+    pthread_mutex_lock(fmReceiverSession.dataMutex_p);
+    if (fmReceiverSession.jvm_p->AttachCurrentThread(&env, NULL) != JNI_OK) {
+        LOGE("Error, can't attch current thread");
+        goto drop_lock;
+    }
+    clazz = env->GetObjectClass(fmReceiverSession.jobj);
+    notifyMethod =
+        env->GetMethodID(clazz, "notifyOnPlayingInStereo", "(Z)V");
+    if (notifyMethod != NULL) {
+        jobject jobj = fmReceiverSession.jobj;
+        pthread_mutex_unlock(fmReceiverSession.dataMutex_p);
+        env->CallVoidMethod(jobj, notifyMethod,
+                            (bool) isPlayingInStereo);
+        pthread_mutex_lock(fmReceiverSession.dataMutex_p);
+    }
+
+    fmReceiverSession.jvm_p->DetachCurrentThread();
+ drop_lock:
+    pthread_mutex_unlock(fmReceiverSession.dataMutex_p);
+}
+
+/*
+ * currently frequency changed event is not supported by interface, to be
+ * implemented quite soon...
+ */
+
+static void androidFmRadioRxCallbackOnAutomaticSwitch(int newFrequency, enum fmradio_switch_reason_t reason)
+{
+    jmethodID notifyMethod;
+    JNIEnv *env;
+    jclass clazz;
+
+    LOGI("androidFmRadioRxCallbackOnAutomaticSwitch: new frequency %d, reason %d",
+         newFrequency, (int) reason);
+
+    pthread_mutex_lock(fmReceiverSession.dataMutex_p);
+    if (fmReceiverSession.jvm_p->AttachCurrentThread(&env, NULL) != JNI_OK) {
+        LOGE("Error, can't attch current thread");
+        goto drop_lock;
+    }
+    clazz = env->GetObjectClass(fmReceiverSession.jobj);
+    notifyMethod =
+        env->GetMethodID(clazz, "notifyOnAutomaticSwitching", "(II)V");
+    if (notifyMethod != NULL) {
+        jobject jobj = fmReceiverSession.jobj;
+        pthread_mutex_unlock(fmReceiverSession.dataMutex_p);
+        env->CallVoidMethod(jobj, notifyMethod, (jint)newFrequency,
+                            (jint)reason);
+        pthread_mutex_lock(fmReceiverSession.dataMutex_p);
+    }
+
+
+    fmReceiverSession.jvm_p->DetachCurrentThread();
+ drop_lock:
+    pthread_mutex_unlock(fmReceiverSession.dataMutex_p);
+}
+
+/*
+ *  function calls from java layer.
+ */
+
+static jint androidFmRadioRxGetState(JNIEnv * env, jobject obj)
+{
+    FmRadioState_t state;
+
+    LOGI("androidFmRadioRxGetState, state\n");
+
+    pthread_mutex_lock(fmReceiverSession.dataMutex_p);
+    state = fmReceiverSession.state;
+    pthread_mutex_unlock(fmReceiverSession.dataMutex_p);
+    return state;
+}
+
+/* common ones with tx, just forward to the generic androidFmRadioxxxxx version */
+
+static void
+androidFmRadioRxStart(JNIEnv * env, jobject obj, int lowFreq,
+                      int highFreq, int defaultFreq, int grid)
+{
+    LOGI("androidFmRadioRxStart. LowFreq %d, HighFreq %d, DefaultFreq %d, grid %d.", lowFreq, highFreq, defaultFreq, grid);
+
+    if (fmReceiverSession.jobj == NULL)
+        fmReceiverSession.jobj = env->NewGlobalRef(obj);
+    (void) androidFmRadioStart(&fmReceiverSession, FMRADIO_RX,
+                               &FmRadioRxVendorCallbacks, false, lowFreq,
+                               highFreq, defaultFreq, grid);
+}
+
+
+static void
+androidFmRadioRxStartAsync(JNIEnv * env, jobject obj, int lowFreq,
+                           int highFreq, int defaultFreq, int grid)
+{
+    LOGI("androidFmRadioRxStartAsync...");
+
+    if (fmReceiverSession.jobj == NULL)
+        fmReceiverSession.jobj = env->NewGlobalRef(obj);
+    (void) androidFmRadioStart(&fmReceiverSession, FMRADIO_RX,
+                               &FmRadioRxVendorCallbacks, true, lowFreq,
+                               highFreq, defaultFreq, grid);
+}
+
+static void androidFmRadioRxPause(JNIEnv * env, jobject obj)
+{
+    LOGI("androidFmRadioRxPause\n");
+
+    (void)androidFmRadioPause(&fmReceiverSession);
+}
+
+static void androidFmRadioRxResume(JNIEnv * env, jobject obj)
+{
+    LOGI("androidFmRadioRxResume\n");
+    (void)androidFmRadioResume(&fmReceiverSession);
+}
+
+static jint androidFmRadioRxReset(JNIEnv * env, jobject obj)
+{
+    int retval = 0;
+
+    LOGI("androidFmRadioRxReset");
+    retval = androidFmRadioReset(&fmReceiverSession);
+
+    if (retval >= 0 && fmReceiverSession.state == FMRADIO_STATE_IDLE &&
+        fmReceiverSession.jobj != NULL) {
+        env->DeleteGlobalRef(fmReceiverSession.jobj);
+        fmReceiverSession.jobj = NULL;
+    }
+
+    return retval;
+}
+
+static void
+androidFmRadioRxSetFrequency(JNIEnv * env, jobject obj, jint frequency)
+{
+    LOGI("androidFmRadioRxSetFrequency tuneTo:%d\n", (int) frequency);
+    return androidFmRadioSetFrequency(&fmReceiverSession, (int) frequency);
+}
+
+static jint androidFmRadioRxGetFrequency(JNIEnv * env, jobject obj)
+{
+    LOGI("androidFmRadioRxGetFrequency:\n");
+    return androidFmRadioGetFrequency(&fmReceiverSession);
+}
+
+static void androidFmRadioRxStopScan(JNIEnv * env, jobject obj)
+{
+    LOGI("androidFmRadioRxStopScan\n");
+    androidFmRadioStopScan(&fmReceiverSession);
+}
+
+/* the rest of the calls are specific for RX */
+
+static jint androidFmRadioRxGetSignalStrength(JNIEnv * env, jobject obj)
+{
+    int retval = SIGNAL_STRENGTH_UNKNOWN;
+
+    LOGI("androidFmRadioRxGetSignalStrength\n");
+
+    pthread_mutex_lock(fmReceiverSession.dataMutex_p);
+
+    if (!androidFmRadioIsValidEventForState
+        (&fmReceiverSession, FMRADIO_EVENT_GET_SIGNAL_STRENGTH)) {
+        goto drop_lock;
+    }
+
+    if (fmReceiverSession.vendorMethods_p->get_signal_strength) {
+        /* if in pause state temporary resume */
+        androidFmRadioTempResumeIfPaused(&fmReceiverSession);
+
+        retval =
+            fmReceiverSession.vendorMethods_p->
+            get_signal_strength(&fmReceiverSession.vendorData_p);
+
+        if (retval < 0) {
+            retval = SIGNAL_STRENGTH_UNKNOWN;
+        } else if (retval > SIGNAL_STRENGTH_MAX) {
+            retval = SIGNAL_STRENGTH_MAX;
+        }
+        androidFmRadioPauseIfTempResumed(&fmReceiverSession);
+    }
+
+  drop_lock:
+
+    pthread_mutex_unlock(fmReceiverSession.dataMutex_p);
+
+    return retval;
+}
+
+static jboolean
+androidFmRadioRxIsPlayingInStereo(JNIEnv * env, jobject obj)
+{
+    bool retval;
+
+    LOGI("androidFmRadioRxIsPlayingInStereo:\n");
+
+    pthread_mutex_lock(fmReceiverSession.dataMutex_p);
+
+    /* if we haven't register we don't know yet */
+    if (!fmReceiverSession.isRegistered) {
+        retval = false;
+        goto drop_lock;
+    }
+    // valid in all states
+    if (fmReceiverSession.vendorMethods_p->is_playing_in_stereo != NULL) {
+        retval =
+            fmReceiverSession.vendorMethods_p->
+            is_playing_in_stereo(&fmReceiverSession.vendorData_p);
+    } else {
+        retval = false;
+    }
+
+  drop_lock:
+
+    pthread_mutex_unlock(fmReceiverSession.dataMutex_p);
+
+    return retval;
+}
+
+static jboolean
+androidFmRadioRxIsRDSDataSupported(JNIEnv * env, jobject obj)
+{
+    bool retval;
+
+    LOGI("androidFmRadioRxIsRDSDataSupported:\n");
+
+    pthread_mutex_lock(fmReceiverSession.dataMutex_p);
+
+    /* if we haven't register we don't know yet */
+    if (!fmReceiverSession.isRegistered) {
+        retval = false;
+        goto drop_lock;
+    }
+    // valid in all states
+    if (fmReceiverSession.vendorMethods_p->is_rds_data_supported != NULL) {
+        retval =
+            fmReceiverSession.vendorMethods_p->
+            is_rds_data_supported(&fmReceiverSession.vendorData_p);
+    } else {
+        retval = false;
+    }
+
+  drop_lock:
+
+    pthread_mutex_unlock(fmReceiverSession.dataMutex_p);
+    return retval;
+}
+
+static jboolean
+androidFmRadioRxIsTunedToValidChannel(JNIEnv * env, jobject obj)
+{
+    bool retval;
+
+    LOGI("androidFmRadioRxIsTunedToValidChannel:\n");
+
+    pthread_mutex_lock(fmReceiverSession.dataMutex_p);
+
+    /* if we haven't register we don't know yet */
+    if (!fmReceiverSession.isRegistered) {
+        retval = false;
+        goto drop_lock;
+    }
+    // valid in all states
+    if (fmReceiverSession.vendorMethods_p->is_tuned_to_valid_channel != NULL) {
+        retval =
+            fmReceiverSession.vendorMethods_p->
+            is_tuned_to_valid_channel(&fmReceiverSession.vendorData_p);
+    } else {
+        retval = false;
+    }
+
+  drop_lock:
+
+    pthread_mutex_unlock(fmReceiverSession.dataMutex_p);
+    return retval;
+}
+
+static void *execute_androidFmRadioRxScan(void *args)
+{
+    enum fmradio_seek_direction_t scanDirection =
+        *(enum fmradio_seek_direction_t *) args;
+    int signalStrength = -1;
+    int retval;
+    enum FmRadioState_t oldState;
+
+    pthread_mutex_lock(fmReceiverSession.dataMutex_p);
+    free(args);
+    // we should still be in SCANNING mode, but we can't be 100.00 % sure since main thread released lock
+    // before we could run
+
+    if (fmReceiverSession.state != FMRADIO_STATE_SCANNING) {
+        LOGE("execute_androidFmRadioRxScan - warning, state not scanning");
+    }
+
+    /*
+     * if mode has been changed to IDLE in the mean time by main thread,
+     * exit the worker thread gracefully
+     */
+    if (fmReceiverSession.state == FMRADIO_STATE_IDLE) {
+        goto drop_lock;
+    }
+
+    oldState = fmReceiverSession.oldState;
+
+    // temporary resume chip if sleeping
+    if (oldState == FMRADIO_STATE_PAUSED) {
+        (void) fmReceiverSession.
+            vendorMethods_p->resume(&fmReceiverSession.vendorData_p);
+    }
+
+    if (pthread_cond_signal(&fmReceiverSession.sync_cond) != 0) {
+        LOGE("execute_androidFmRadioRxScan - warning, signal failed");
+    }
+    pthread_mutex_unlock(fmReceiverSession.dataMutex_p);
+
+    retval =
+        fmReceiverSession.vendorMethods_p->scan(&fmReceiverSession.
+                                                vendorData_p,
+                                                scanDirection);
+
+    pthread_mutex_lock(fmReceiverSession.dataMutex_p);
+
+    if (retval >= 0) {
+        // also get signal strength (if supported)
+        if (fmReceiverSession.vendorMethods_p->get_signal_strength)
+            signalStrength =
+                fmReceiverSession.vendorMethods_p->
+                get_signal_strength(&fmReceiverSession.vendorData_p);
+    }
+    /*
+     * if state has changed we should keep it, probably a forced reset
+     */
+    if (fmReceiverSession.state != FMRADIO_STATE_SCANNING) {
+        LOGI("State changed while scanning (state now %d), keeping",
+             fmReceiverSession.state);
+        retval = -1;
+    } else {
+        // put back to sleep if we did a temporary wake-up
+        if ((oldState == FMRADIO_STATE_PAUSED
+             || fmReceiverSession.pendingPause))
+            (void) fmReceiverSession.
+                vendorMethods_p->pause(&fmReceiverSession.vendorData_p);
+        if (fmReceiverSession.pendingPause) {
+            FMRADIO_SET_STATE(&fmReceiverSession, FMRADIO_STATE_PAUSED);
+        } else {
+            FMRADIO_SET_STATE(&fmReceiverSession, oldState);
+        }
+
+        // if we failed but we have a pending abort just read the current frequency to give a proper
+        // onScan return
+
+        if (retval < 0 && fmReceiverSession.lastScanAborted &&
+            fmReceiverSession.vendorMethods_p->get_frequency) {
+            retval = fmReceiverSession.vendorMethods_p->get_frequency(&fmReceiverSession.vendorData_p);
+        }
+    }
+
+    fmReceiverSession.pendingPause = false;
+
+    if (retval >= 0) {
+        fmReceiverSession.callbacks_p->onScan(retval,
+                                              signalStrength,
+                                              scanDirection,
+                                              fmReceiverSession.
+                                              lastScanAborted);
+    } else {
+        fmReceiverSession.callbacks_p->onError();
+    }
+    drop_lock:
+    /* Wake up the main thread if it is currently waiting on the condition variable */
+    if (pthread_cond_signal(&fmReceiverSession.sync_cond) != 0) {
+        LOGE("execute_androidFmRadioRxScan - signal failed\n");
+    }
+
+    pthread_mutex_unlock(fmReceiverSession.dataMutex_p);
+
+    pthread_exit(NULL);
+    return NULL;
+}
+
+
+static void androidFmRadioRxScan(enum fmradio_seek_direction_t scanDirection)
+{
+    int retval = 0;
+
+    pthread_mutex_lock(fmReceiverSession.dataMutex_p);
+
+    if (!androidFmRadioIsValidEventForState
+        (&fmReceiverSession, FMRADIO_EVENT_SCAN)) {
+        retval = FMRADIO_INVALID_STATE;
+        goto drop_lock;
+    }
+
+    if (fmReceiverSession.vendorMethods_p->scan) {
+        enum fmradio_seek_direction_t *scanDirectionParam_p =
+            (enum fmradio_seek_direction_t *)
+            malloc(sizeof(*scanDirectionParam_p));
+
+        pthread_t execute_thread;
+
+        // we need to create a new thread actually executing the command
+
+        fmReceiverSession.oldState = fmReceiverSession.state;
+        FMRADIO_SET_STATE(&fmReceiverSession, FMRADIO_STATE_SCANNING);
+        *scanDirectionParam_p = scanDirection;
+
+        fmReceiverSession.lastScanAborted = false;
+
+        if (pthread_create
+            (&execute_thread, NULL, execute_androidFmRadioRxScan,
+             (void *) scanDirectionParam_p) != 0) {
+
+            LOGE("pthread_create failure...\n");
+            free(scanDirectionParam_p);
+            FMRADIO_SET_STATE(&fmReceiverSession, fmReceiverSession.oldState);
+            retval = FMRADIO_IO_ERROR;
+        } else {
+            /* await thread startup, THREAD_WAIT_TIMEOUT_S sec timeout */
+            struct timespec ts;
+            clock_gettime(CLOCK_REALTIME, &ts);
+            ts.tv_sec += THREAD_WAIT_TIMEOUT_S;
+            if (pthread_cond_timedwait(&fmReceiverSession.sync_cond,
+                                       fmReceiverSession.dataMutex_p,
+                                       &ts) != 0) {
+                LOGE("androidFmRadioRxScan: warning, wait failure\n");
+            }
+            pthread_detach(execute_thread);
+
+        }
+    } else {
+        retval = FMRADIO_UNSUPPORTED_OPERATION;
+    }
+
+  drop_lock:
+    if (retval == FMRADIO_INVALID_STATE) {
+        THROW_INVALID_STATE(&fmReceiverSession);
+    } else if (retval < 0) {
+        THROW_IO_ERROR(&fmReceiverSession);
+    }
+
+    pthread_mutex_unlock(fmReceiverSession.dataMutex_p);
+
+    if (retval < 0) {
+        LOGE("androidFmRadioRxScan failed\n");
+    }
+}
+
+static void
+androidFmRadioRxScanUp(JNIEnv * env, jobject obj, jlong * frequency)
+{
+    LOGI("androidFmRadioRxScanUp\n");
+
+    androidFmRadioRxScan(FMRADIO_SEEK_UP);
+}
+
+static void
+androidFmRadioRxScanDown(JNIEnv * env, jobject obj, jlong * frequency)
+{
+    LOGI("androidFmRadioRxScanDown\n");
+
+    androidFmRadioRxScan(FMRADIO_SEEK_DOWN);
+}
+
+static void *execute_androidFmRadioRxFullScan(void *args)
+{
+    int retval;
+    enum FmRadioState_t oldState = fmReceiverSession.oldState;
+    int *frequencies_p = NULL;
+    int *rssi_p = NULL;
+
+    pthread_mutex_lock(fmReceiverSession.dataMutex_p);
+
+    // we should still be in SCANNING mode, but we can't be 100.00 % sure since main thread released lock
+    // before we could run
+
+    if (fmReceiverSession.state != FMRADIO_STATE_SCANNING) {
+        LOGE("execute_androidFmRadioRxFullScan - warning, state not scanning\n");
+    }
+
+    /*
+     * if mode has been changed to IDLE in the mean time by main thread,
+     * exit the worker thread gracefully
+     */
+    if (fmReceiverSession.state == FMRADIO_STATE_IDLE) {
+        goto drop_lock;
+    }
+    // temporary resume chip if sleeping
+    if (oldState == FMRADIO_STATE_PAUSED) {
+        (void) fmReceiverSession.
+            vendorMethods_p->resume(&fmReceiverSession.vendorData_p);
+    }
+
+    if (pthread_cond_signal(&fmReceiverSession.sync_cond) != 0) {
+        LOGE("execute_androidFmRadioRxFullScan - warning, signal failed\n");
+    }
+    pthread_mutex_unlock(fmReceiverSession.dataMutex_p);
+
+    retval =
+        fmReceiverSession.vendorMethods_p->full_scan(&fmReceiverSession.
+                                                    vendorData_p,
+                                                    &frequencies_p,
+                                                    &rssi_p);
+
+    pthread_mutex_lock(fmReceiverSession.dataMutex_p);
+
+    /*
+     * if state has changed we should keep it, probably a forced pause or
+     * forced reset
+     */
+    if (fmReceiverSession.state != FMRADIO_STATE_SCANNING) {
+        LOGI("State changed while scanning (state now %d), keeping\n",
+             fmReceiverSession.state);
+        retval = -1;
+    } else {
+        if (fmReceiverSession.pendingPause) {
+            FMRADIO_SET_STATE(&fmReceiverSession, FMRADIO_STATE_PAUSED);
+        } else {
+            FMRADIO_SET_STATE(&fmReceiverSession, oldState);
+        }
+
+        fmReceiverSession.pendingPause = false;
+    }
+
+    if (retval >= 0) {
+        fmReceiverSession.callbacks_p->onFullScan(retval,
+                                                  frequencies_p,
+                                                  rssi_p,
+                                                  fmReceiverSession.
+                                                  lastScanAborted);
+    } else {
+        fmReceiverSession.callbacks_p->onError();
+    }
+
+    if (frequencies_p != NULL) {
+        free(frequencies_p);
+    }
+
+    if (rssi_p != NULL) {
+        free(rssi_p);
+    }
+
+    drop_lock:
+    /* Wake up the main thread if it is currently waiting on the condition variable */
+    if (pthread_cond_signal(&fmReceiverSession.sync_cond) != 0) {
+        LOGE("execute_androidFmRadioRxFullScan - signal failed\n");
+    }
+    pthread_mutex_unlock(fmReceiverSession.dataMutex_p);
+
+    pthread_exit(NULL);
+    return NULL;
+}
+
+static void androidFmRadioRxStartFullScan(JNIEnv * env, jobject obj)
+{
+    LOGI("androidFmRadioRxStartFullScan\n");
+    int retval = 0;
+
+    pthread_mutex_lock(fmReceiverSession.dataMutex_p);
+
+    if (!androidFmRadioIsValidEventForState
+        (&fmReceiverSession, FMRADIO_EVENT_FULL_SCAN)) {
+        retval = FMRADIO_INVALID_STATE;
+        goto drop_lock;
+    }
+
+
+    if (fmReceiverSession.vendorMethods_p->full_scan) {
+        pthread_t execute_thread;
+
+        fmReceiverSession.oldState = fmReceiverSession.state;
+        FMRADIO_SET_STATE(&fmReceiverSession, FMRADIO_STATE_SCANNING);
+        fmReceiverSession.lastScanAborted = false;
+
+        if (pthread_create
+            (&execute_thread, NULL, execute_androidFmRadioRxFullScan,
+             NULL) != 0) {
+
+            LOGE("pthread_create failure...\n");
+            FMRADIO_SET_STATE(&fmReceiverSession, fmReceiverSession.oldState);
+            retval = FMRADIO_IO_ERROR;
+        } else {
+            /* await thread startup, THREAD_WAIT_TIMEOUT_S sec timeout */
+            struct timespec ts;
+            clock_gettime(CLOCK_REALTIME, &ts);
+            ts.tv_sec += THREAD_WAIT_TIMEOUT_S;
+            if (pthread_cond_timedwait(&fmReceiverSession.sync_cond,
+                                       fmReceiverSession.dataMutex_p,
+                                       &ts) != 0) {
+                LOGE("androidFmRadioRxStartFullScan: warning, wait failure\n");
+            }
+            pthread_detach(execute_thread);
+        }
+    } else {
+        retval = FMRADIO_UNSUPPORTED_OPERATION;
+    }
+
+  drop_lock:
+    if (retval == FMRADIO_INVALID_STATE) {
+        THROW_INVALID_STATE(&fmReceiverSession);
+    } else if (retval < 0) {
+        THROW_IO_ERROR(&fmReceiverSession);
+    }
+
+    pthread_mutex_unlock(fmReceiverSession.dataMutex_p);
+}
+
+static void androidFmRadioRxSetAutomaticAFSwitching(JNIEnv * env,
+                                                  jobject obj,
+                                                  jboolean automatic)
+{
+    int retval = -1;
+
+    LOGI("androidFmRadioRxSetAutomaticAFSwitching\n");
+
+    pthread_mutex_lock(fmReceiverSession.dataMutex_p);
+
+    if (!androidFmRadioIsValidEventForState
+        (&fmReceiverSession, FMRADIO_EVENT_SET_PARAMETER)) {
+        retval = FMRADIO_INVALID_STATE;
+        goto drop_lock;
+    }
+
+
+    if (fmReceiverSession.vendorMethods_p->set_automatic_af_switching) {
+        retval =
+            fmReceiverSession.vendorMethods_p->
+            set_automatic_af_switching(&fmReceiverSession.vendorData_p, automatic);
+    } else {
+        retval = FMRADIO_UNSUPPORTED_OPERATION;
+    }
+
+  drop_lock:
+    if (retval == FMRADIO_INVALID_STATE) {
+        THROW_INVALID_STATE(&fmReceiverSession);
+    } else if (retval < 0) {
+        THROW_IO_ERROR(&fmReceiverSession);
+    }
+
+    pthread_mutex_unlock(fmReceiverSession.dataMutex_p);
+}
+
+static void androidFmRadioRxSetAutomaticTASwitching(JNIEnv * env, jobject obj,
+                                                    jboolean automatic)
+{
+    int retval = -1;
+
+    LOGI("androidFmRadioRxSetAutomaticTASwitching\n");
+
+    pthread_mutex_lock(fmReceiverSession.dataMutex_p);
+
+    if (!androidFmRadioIsValidEventForState
+        (&fmReceiverSession, FMRADIO_EVENT_SET_PARAMETER)) {
+        retval = FMRADIO_INVALID_STATE;
+        goto drop_lock;
+    }
+
+
+    if (fmReceiverSession.vendorMethods_p->set_automatic_ta_switching) {
+        retval =
+            fmReceiverSession.vendorMethods_p->
+            set_automatic_ta_switching(&fmReceiverSession.vendorData_p, automatic);
+    } else {
+        retval = FMRADIO_UNSUPPORTED_OPERATION;
+    }
+
+  drop_lock:
+    if (retval == FMRADIO_INVALID_STATE) {
+        THROW_INVALID_STATE(&fmReceiverSession);
+    } else if (retval < 0) {
+        THROW_IO_ERROR(&fmReceiverSession);
+    }
+
+    pthread_mutex_unlock(fmReceiverSession.dataMutex_p);
+}
+
+static void androidFmRadioRxSetForceMono(JNIEnv * env, jobject obj,
+                                         jboolean forceMono)
+{
+    int retval = -1;
+
+    LOGI("androidFmRadioRxSetForceMono\n");
+
+    pthread_mutex_lock(fmReceiverSession.dataMutex_p);
+
+    if (!androidFmRadioIsValidEventForState
+        (&fmReceiverSession, FMRADIO_EVENT_SET_PARAMETER)) {
+        retval = FMRADIO_INVALID_STATE;
+        goto drop_lock;
+    }
+
+
+    if (fmReceiverSession.vendorMethods_p->set_force_mono) {
+        /* if in pause state temporary resume */
+        androidFmRadioTempResumeIfPaused(&fmReceiverSession);
+
+        retval =
+            fmReceiverSession.vendorMethods_p->
+            set_force_mono(&fmReceiverSession.vendorData_p, forceMono);
+
+        androidFmRadioPauseIfTempResumed(&fmReceiverSession);
+    } else {
+        retval = FMRADIO_UNSUPPORTED_OPERATION;
+    }
+
+  drop_lock:
+    if (retval == FMRADIO_INVALID_STATE) {
+        THROW_INVALID_STATE(&fmReceiverSession);
+    } else if (retval < 0) {
+        THROW_IO_ERROR(&fmReceiverSession);
+    }
+
+    pthread_mutex_unlock(fmReceiverSession.dataMutex_p);
+}
+
+static void
+androidFmRadioRxSetThreshold(JNIEnv * env, jobject obj, jint threshold)
+{
+    int retval;
+
+    LOGI("androidFmRadioRxSetThreshold threshold:%d\n", (int) threshold);
+
+    pthread_mutex_lock(fmReceiverSession.dataMutex_p);
+    if (!androidFmRadioIsValidEventForState
+        (&fmReceiverSession, FMRADIO_EVENT_SET_PARAMETER)) {
+        retval = FMRADIO_INVALID_STATE;
+        goto drop_lock;
+    }
+
+
+    if (fmReceiverSession.vendorMethods_p->set_threshold) {
+        /* if in pause state temporary resume */
+        androidFmRadioTempResumeIfPaused(&fmReceiverSession);
+
+        retval =
+            fmReceiverSession.
+            vendorMethods_p->set_threshold(&fmReceiverSession.vendorData_p,
+                                          threshold);
+        /* if in pause state temporary resume */
+        androidFmRadioPauseIfTempResumed(&fmReceiverSession);
+    } else {
+        retval = FMRADIO_UNSUPPORTED_OPERATION;
+    }
+
+    if (retval == FMRADIO_INVALID_STATE) {
+        THROW_INVALID_STATE(&fmReceiverSession);
+    } else if (retval < 0) {
+        THROW_IO_ERROR(&fmReceiverSession);
+    }
+
+  drop_lock:
+    pthread_mutex_unlock(fmReceiverSession.dataMutex_p);
+}
+
+static jint androidFmRadioRxGetThreshold(JNIEnv * env, jobject obj)
+{
+    int retval;
+
+    LOGI("androidFmRadioRxGetThreshold\n");
+    pthread_mutex_lock(fmReceiverSession.dataMutex_p);
+
+    if (!androidFmRadioIsValidEventForState
+        (&fmReceiverSession, FMRADIO_EVENT_GET_PARAMETER)) {
+        retval = FMRADIO_INVALID_STATE;
+        goto drop_lock;
+    }
+
+    if (fmReceiverSession.vendorMethods_p->get_threshold) {
+        /* if in pause state temporary resume */
+        androidFmRadioTempResumeIfPaused(&fmReceiverSession);
+        retval =
+            fmReceiverSession.
+            vendorMethods_p->get_threshold(&fmReceiverSession.vendorData_p);
+        androidFmRadioPauseIfTempResumed(&fmReceiverSession);
+    } else {
+        retval = FMRADIO_UNSUPPORTED_OPERATION;
+    }
+  drop_lock:
+
+    if (retval == FMRADIO_INVALID_STATE) {
+        THROW_INVALID_STATE(&fmReceiverSession);
+    } else if (retval < 0) {
+        THROW_IO_ERROR(&fmReceiverSession);
+    }
+    pthread_mutex_unlock(fmReceiverSession.dataMutex_p);
+
+    return retval;
+}
+
+static void androidFmRadioRxSetRDS(JNIEnv * env, jobject obj,
+                                   jboolean receiveRDS)
+{
+    int retval = -1;
+
+    LOGI("androidFmRadioRxSetRDS(%d)", (int)receiveRDS);
+
+    pthread_mutex_lock(fmReceiverSession.dataMutex_p);
+
+    if (!androidFmRadioIsValidEventForState
+        (&fmReceiverSession, FMRADIO_EVENT_SET_PARAMETER)) {
+        retval = FMRADIO_INVALID_STATE;
+        goto drop_lock;
+    }
+
+    if (fmReceiverSession.vendorMethods_p->set_rds_reception) {
+        /* if in pause state temporary resume */
+        androidFmRadioTempResumeIfPaused(&fmReceiverSession);
+
+        retval = fmReceiverSession.vendorMethods_p->
+            set_rds_reception(&fmReceiverSession.vendorData_p, receiveRDS);
+
+        androidFmRadioPauseIfTempResumed(&fmReceiverSession);
+    } else {
+        retval = FMRADIO_UNSUPPORTED_OPERATION;
+    }
+
+  drop_lock:
+    /*
+     * Set rds is not executed by explicit command but rather triggered
+     * on startup and on adding and removal of listeners. Because of this
+     * it should not trigger exceptions, just LOG any failure.
+     */
+
+    if (retval != FMRADIO_OK) {
+        LOGE("androidFmRadioRxSetRDS failed, retval = %d.", retval);
+    }
+
+    pthread_mutex_unlock(fmReceiverSession.dataMutex_p);
+}
+
+static jboolean androidFmRadioRxSendExtraCommand(JNIEnv * env, jobject obj,
+                                                 jstring command,
+                                                 jobjectArray parameters)
+{
+    LOGI("androidFmRadioRxSendExtraCommand");
+
+/* we need to set jobj since this might be called before start */
+
+    if (fmReceiverSession.jobj == NULL)
+        fmReceiverSession.jobj = env->NewGlobalRef(obj);
+
+    androidFmRadioSendExtraCommand(&fmReceiverSession, env, command,
+                                   parameters);
+
+    return true;
+}
+
+
+static JNINativeMethod gMethods[] = {
+    {(char *)"_fm_receiver_getState", (char *)"()I",
+     (void *) androidFmRadioRxGetState},
+    {(char *)"_fm_receiver_start", (char *)"(IIII)V",
+     (void *) androidFmRadioRxStart},
+    {(char *)"_fm_receiver_startAsync", (char *)"(IIII)V",
+     (void *) androidFmRadioRxStartAsync},
+    {(char *)"_fm_receiver_pause", (char *)"()V",
+     (void *) androidFmRadioRxPause},
+    {(char *)"_fm_receiver_resume", (char *)"()V",
+     (void *) androidFmRadioRxResume},
+    {(char *)"_fm_receiver_reset", (char *)"()I",
+     (void *) androidFmRadioRxReset},
+    {(char *)"_fm_receiver_setFrequency", (char *)"(I)V",
+     (void *) androidFmRadioRxSetFrequency},
+    {(char *)"_fm_receiver_getFrequency", (char *)"()I",
+     (void *) androidFmRadioRxGetFrequency},
+    {(char *)"_fm_receiver_getSignalStrength", (char *)"()I",
+     (void *) androidFmRadioRxGetSignalStrength},
+    {(char *)"_fm_receiver_scanUp", (char *)"()V",
+     (void *) androidFmRadioRxScanUp},
+    {(char *)"_fm_receiver_scanDown", (char *)"()V",
+     (void *) androidFmRadioRxScanDown},
+    {(char *)"_fm_receiver_startFullScan", (char *)"()V",
+     (void *) androidFmRadioRxStartFullScan},
+    {(char *)"_fm_receiver_isPlayingInStereo", (char *)"()Z",
+     (void *) androidFmRadioRxIsPlayingInStereo},
+    {(char *)"_fm_receiver_isRDSDataSupported", (char *)"()Z",
+     (void *) androidFmRadioRxIsRDSDataSupported},
+    {(char *)"_fm_receiver_isTunedToValidChannel", (char *)"()Z",
+     (void *) androidFmRadioRxIsTunedToValidChannel},
+    {(char *)"_fm_receiver_stopScan", (char *)"()V",
+     (void *) androidFmRadioRxStopScan},
+    {(char *)"_fm_receiver_setAutomaticAFSwitching", (char *)"(Z)V",
+     (void *) androidFmRadioRxSetAutomaticAFSwitching},
+    {(char *)"_fm_receiver_setAutomaticTASwitching", (char *)"(Z)V",
+     (void *) androidFmRadioRxSetAutomaticTASwitching},
+    {(char *)"_fm_receiver_setForceMono", (char *)"(Z)V",
+     (void *) androidFmRadioRxSetForceMono},
+    {(char *)"_fm_receiver_sendExtraCommand",
+     (char *)"(Ljava/lang/String;[Ljava/lang/String;)Z",
+     (void *) androidFmRadioRxSendExtraCommand},
+    {(char *)"_fm_receiver_getThreshold", (char *)"()I",
+     (void *) androidFmRadioRxGetThreshold},
+    {(char *)"_fm_receiver_setThreshold", (char *)"(I)V",
+     (void *) androidFmRadioRxSetThreshold},
+    {(char *)"_fm_receiver_setRDS", (char *)"(Z)V",
+     (void *) androidFmRadioRxSetRDS},
+};
+
+
+
+
+int registerAndroidFmRadioReceiver(JavaVM * vm, JNIEnv * env)
+{
+    LOGI("registerAndroidFmRadioReceiver\n");
+    jclass clazz;
+
+    pthread_mutex_lock(fmReceiverSession.dataMutex_p);
+    fmReceiverSession.jvm_p = vm;
+
+    struct bundle_descriptor_offsets_t *bundle_p =
+        (struct bundle_descriptor_offsets_t *)
+        malloc(sizeof(struct bundle_descriptor_offsets_t));
+
+    clazz = env->FindClass("android/os/Bundle");
+    bundle_p->mClass = (jclass) env->NewGlobalRef(clazz);
+    bundle_p->mConstructor = env->GetMethodID(clazz, "<init>", "()V");
+    bundle_p->mPutInt =
+        env->GetMethodID(clazz, "putInt", "(Ljava/lang/String;I)V");
+    bundle_p->mPutShort =
+        env->GetMethodID(clazz, "putShort", "(Ljava/lang/String;S)V");
+    bundle_p->mPutIntArray =
+        env->GetMethodID(clazz, "putIntArray", "(Ljava/lang/String;[I)V");
+    bundle_p->mPutShortArray =
+        env->GetMethodID(clazz, "putShortArray",
+                         "(Ljava/lang/String;[S)V");
+    bundle_p->mPutString =
+        env->GetMethodID(clazz, "putString",
+                         "(Ljava/lang/String;Ljava/lang/String;)V");
+
+    fmReceiverSession.bundleOffsets_p = bundle_p;
+    pthread_mutex_unlock(fmReceiverSession.dataMutex_p);
+    return jniRegisterNativeMethods(env,
+                                    "com/stericsson/hardware/fm/FmReceiverService",
+                                    gMethods, NELEM(gMethods));
+}
+
+/* *INDENT-OFF* */
+};                              // namespace android
diff --git a/fmradio/jni/android_fmradio_Transmitter.cpp b/fmradio/jni/android_fmradio_Transmitter.cpp
new file mode 100755
index 0000000..9264ce2
--- /dev/null
+++ b/fmradio/jni/android_fmradio_Transmitter.cpp
@@ -0,0 +1,1098 @@
+/*
+ * Copyright (C) ST-Ericsson SA 2010
+ * Copyright 2010, The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+ * Authors: johan.xj.palmaeus@stericsson.com
+ *          stuart.macdonald@stericsson.com
+ *          for ST-Ericsson
+ */
+
+/*
+ * Native part of the generic TX FmRadio inteface
+ */
+
+#define LOG_TAG "FmTransmitterServiceNative"
+
+// #define LOG_NDEBUG 1
+
+#include <stdio.h>
+#include <unistd.h>
+#include <termios.h>
+#include <string.h>
+#include <stdlib.h>
+#include <time.h>
+#include <stdarg.h>
+#include <pthread.h>
+#include <media/AudioSystem.h>
+#include <system/audio.h>
+
+#include "jni.h"
+#include "JNIHelp.h"
+#include "android_fmradio.h"
+#include <utils/Log.h>
+
+
+/* *INDENT-OFF* */
+namespace android {
+
+// RDS Fields
+
+static const char* rds_field_names[] = {
+    "PI",
+    "TP",
+    "PTY",
+    "TA",
+    "M/S",
+    "AF",
+    "numAFs",
+    "PSN",
+    "RT",
+    "CT",
+    "PTYN",
+    "TMC",
+    "TAF",
+    NULL
+};
+
+
+// state machine
+
+static const ValidEventsForStates_t IsValidTxEventForState = {
+/* this table defines valid transitions. (turn off indent, we want this easy readable) */
+         /* FMRADIO_STATE_  IDLE,STARTING,STARTED,PAUSED,SCANNING,EXTRA_COMMAND */
+
+   /* FMRADIO_EVENT_START */         {true, false,false,false,false,false},
+   /* FMRADIO_EVENT_START_ASYNC */   {true, false,false,false,false,false},
+   /* FMRADIO_EVENT_PAUSE */         {false,false,true, true, false,false},
+   /* FMRADIO_EVENT_RESUME */        {false,false,true, true, false,false},
+   /* FMRADIO_EVENT_RESET */         {true, true, true, true, true, true },
+   /* FMRADIO_EVENT_GET_FREQUENCY */ {false,false,true, true, false,false},
+   /* FMRADIO_EVENT_SET_FREQUENCY */ {false,false,true, true, false,false},
+   /* FMRADIO_EVENT_SET_PARAMETER */ {false,false,true, true, false,false},
+   /* FMRADIO_EVENT_STOP_SCAN */     {true, true, true, true, true, true },
+   /* FMRADIO_EVENT_EXTRA_COMMAND */ {true, true, true, true, true, true },
+   /* Rx Only - never allowed */
+   /* FMRADIO_EVENT_GET_PARAMETER */ {false,false,false,false,false,false},
+   /* FMRADIO_EVENT_GET_SIGNAL_STRENGTH */{false,false,false,false,false,false},
+   /* FMRADIO_EVENT_SCAN */          {false,false,false,false,false,false},
+   /* FMRADIO_EVENT_FULL_SCAN */     {false,false,false,false,false,false},
+   /* Tx Only */
+   /* FMRADIO_EVENT_BLOCK_SCAN */    {false,false,true, true, false,false},
+};
+/* *INDENT-ON* */
+
+static void androidFmRadioTxCallbackOnStateChanged(int oldState,
+                                                   int newState);
+
+static void androidFmRadioTxCallbackOnError(void);
+
+static void androidFmRadioTxCallbackOnStarted(void);
+
+static void androidFmRadioTxCallbackOnBlockScan(int noValues,
+                                                int *freqs,
+                                                int *sigStrengths,
+                                                bool aborted);
+static void androidFmRadioTxCallbackOnForcedReset(enum fmradio_reset_reason_t reason);
+
+static void androidFmRadioTxCallbackOnVendorForcedReset(enum fmradio_reset_reason_t reason);
+
+static void androidFmRadioTxCallbackOnExtraCommand(char* command,
+                                                   struct
+                                                   fmradio_extra_command_ret_item_t
+                                                   *retList);
+
+static const FmRadioCallbacks_t FmRadioTxCallbacks = {
+    androidFmRadioTxCallbackOnStateChanged,
+    androidFmRadioTxCallbackOnError,
+    androidFmRadioTxCallbackOnStarted,
+    NULL,
+    NULL,
+    androidFmRadioTxCallbackOnBlockScan,
+    androidFmRadioTxCallbackOnForcedReset,
+    androidFmRadioTxCallbackOnExtraCommand,
+};
+
+
+/* callbacks from vendor layer */
+
+static const fmradio_vendor_callbacks_t FmRadioTxVendorCallbacks = {
+    NULL,
+    NULL,
+    NULL,
+    NULL,
+    androidFmRadioTxCallbackOnVendorForcedReset
+};
+
+extern struct FmSession_t fmReceiverSession;
+
+struct FmSession_t fmTransmitterSession = {
+    NULL,
+    NULL,
+    false,
+    FMRADIO_STATE_IDLE,
+    NULL,
+    &IsValidTxEventForState,
+    &FmRadioTxCallbacks,
+    NULL,
+    NULL,
+    &fmReceiverSession,
+    NULL,
+    FMRADIO_STATE_IDLE,
+    false,
+    false,
+    false,
+    &rx_tx_common_mutex,
+    PTHREAD_COND_INITIALIZER,
+    NULL,
+};
+
+struct FmRadioBlockScanParameters {
+    int startFreq;
+    int endFreq;
+};
+
+// make sure we don't refere the ReceiverSession anymore from here
+#define fmReceiverSession ERRORDONOTUSERECEIVERSESSIONINTRANSMITTER
+
+/*
+* Implementation of callbacks from within service layer. For these the
+*  mutex lock is always held on entry and need to be released before doing
+*  calls to java layer (env->Call*Method)  becasue these calls might trigger
+*  new calls from java and a deadlock would occure if lock was still held.
+*/
+
+
+static void androidFmRadioTxCallbackOnStateChanged(int oldState,
+                                                   int newState)
+{
+    jmethodID notifyOnStateChangedMethod;
+    JNIEnv *env;
+    jclass clazz;
+    bool reAttached = false;
+
+    LOGI("androidFmRadioTxCallbackOnStateChanged: Old state %d, new state %d", oldState, newState);
+
+    /* since we might be both in main thread and subthread both test getenv
+     * and attach */
+    if (fmTransmitterSession.jvm_p->
+        GetEnv((void **) &env, JNI_VERSION_1_4) != JNI_OK) {
+        reAttached = true;
+        if (fmTransmitterSession.jvm_p->AttachCurrentThread(&env, NULL) != JNI_OK) {
+            LOGE("Error, can't attach current thread");
+            return;
+        }
+    }
+
+    clazz = env->GetObjectClass(fmTransmitterSession.jobj);
+
+    notifyOnStateChangedMethod =
+        env->GetMethodID(clazz, "notifyOnStateChanged", "(II)V");
+    if (notifyOnStateChangedMethod != NULL) {
+        jobject jobj = fmTransmitterSession.jobj;
+        pthread_mutex_unlock(fmTransmitterSession.dataMutex_p);
+        env->CallVoidMethod(jobj,
+                            notifyOnStateChangedMethod, oldState,
+                            newState);
+        pthread_mutex_lock(fmTransmitterSession.dataMutex_p);
+    }
+    if (reAttached) {
+        fmTransmitterSession.jvm_p->DetachCurrentThread();
+    }
+}
+
+static void androidFmRadioTxCallbackOnError(void)
+{
+    jmethodID notifyMethod;
+    JNIEnv *env;
+    jclass clazz;
+
+    LOGI("androidFmRadioTxCallbackOnError");
+
+
+    if (fmTransmitterSession.jvm_p->AttachCurrentThread(&env, NULL) != JNI_OK) {
+        LOGE("Error, can't attch current thread");
+        return;
+    }
+
+    clazz = env->GetObjectClass(fmTransmitterSession.jobj);
+    notifyMethod = env->GetMethodID(clazz, "notifyOnError", "()V");
+
+    if (notifyMethod != NULL) {
+        jobject jobj = fmTransmitterSession.jobj;
+        pthread_mutex_unlock(fmTransmitterSession.dataMutex_p);
+        env->CallVoidMethod(jobj, notifyMethod);
+        pthread_mutex_lock(fmTransmitterSession.dataMutex_p);
+    } else {
+        LOGE("ERROR - JNI can't find java notifyOnError method");
+    }
+
+    fmTransmitterSession.jvm_p->DetachCurrentThread();
+}
+
+static void androidFmRadioTxCallbackOnStarted(void)
+{
+    jmethodID notifyMethod;
+    JNIEnv *env;
+    jclass clazz;
+    status_t err;
+
+    LOGI("androidFmRadioTxCallbackOnStarted: Callback");
+
+    if (fmTransmitterSession.jvm_p->AttachCurrentThread(&env, NULL) != JNI_OK) {
+        LOGE("Error, can't attch current thread");
+        return;
+    }
+
+    clazz = env->GetObjectClass(fmTransmitterSession.jobj);
+    notifyMethod = env->GetMethodID(clazz, "notifyOnStarted", "()V");
+
+    if (notifyMethod != NULL) {
+        jobject jobj = fmTransmitterSession.jobj;
+        pthread_mutex_unlock(fmTransmitterSession.dataMutex_p);
+        env->CallVoidMethod(jobj, notifyMethod);
+        pthread_mutex_lock(fmTransmitterSession.dataMutex_p);
+    } else {
+        LOGE("ERROR - JNI can't find java notifyOnStarted method");
+    }
+
+   // err =
+        //AudioSystem::
+      //  setDeviceConnectionState(AUDIO_DEVICE_OUT_FM_TX,
+       //                          AUDIO_POLICY_DEVICE_STATE_AVAILABLE, "");
+
+    if (err != OK) {
+        LOGE("ERROR - Unable to set audio output device to FM Radio TX");
+       // AudioSystem::
+        //    setDeviceConnectionState(AUDIO_DEVICE_OUT_FM_TX,
+           //                          AUDIO_POLICY_DEVICE_STATE_UNAVAILABLE,
+           //                          "");
+    }
+
+    fmTransmitterSession.jvm_p->DetachCurrentThread();
+}
+
+static void androidFmRadioTxCallbackOnBlockScan(int noItems,
+                                                int *freqs,
+                                                int *sigStrengths,
+                                                bool aborted)
+{
+    jmethodID notifyMethod;
+    JNIEnv *env;
+    jclass clazz;
+    jintArray jFreqs;
+    jintArray jSigStrengths;
+    int d;
+
+    LOGI("androidFmRadioTxCallbackOnBlockScan: No items %d, aborted %d",
+         noItems, aborted);
+
+    for (d = 0; d < noItems; d++) {
+        LOGI("%d->%d", freqs[d], sigStrengths[d]);
+    }
+
+    if (fmTransmitterSession.jvm_p->AttachCurrentThread(&env, NULL) != JNI_OK) {
+        LOGE("Error, can't attch current thread");
+        return;
+    }
+
+    clazz = env->GetObjectClass(fmTransmitterSession.jobj);
+
+    jFreqs = env->NewIntArray(noItems);
+    jSigStrengths = env->NewIntArray(noItems);
+
+    env->SetIntArrayRegion(jFreqs, 0, noItems, freqs);
+    env->SetIntArrayRegion(jSigStrengths, 0, noItems, sigStrengths);
+
+    notifyMethod =
+        env->GetMethodID(clazz, "notifyOnBlockScan", "([I[IZ)V");
+
+
+    if (notifyMethod != NULL) {
+        jobject jobj = fmTransmitterSession.jobj;
+        pthread_mutex_unlock(fmTransmitterSession.dataMutex_p);
+        env->CallVoidMethod(jobj, notifyMethod,
+                            jFreqs, jSigStrengths, aborted);
+        pthread_mutex_lock(fmTransmitterSession.dataMutex_p);
+    } else {
+        LOGE("ERROR - JNI can't find java notifyOnBlockScan method");
+    }
+
+    fmTransmitterSession.jvm_p->DetachCurrentThread();
+}
+
+static void androidFmRadioTxCallbackOnForcedReset(enum fmradio_reset_reason_t reason)
+{
+    jmethodID notifyMethod;
+    JNIEnv *env;
+    jclass clazz;
+    bool reAttached = false;
+
+    LOGI("androidFmRadioTxCallbackOnForcedReset");
+
+    if (fmTransmitterSession.jvm_p->
+        GetEnv((void **) &env, JNI_VERSION_1_4) != JNI_OK) {
+        reAttached = true;
+        if (fmTransmitterSession.jvm_p->AttachCurrentThread(&env, NULL) != JNI_OK) {
+            LOGE("Error, can't attch current thread");
+            return;
+        }
+    }
+
+    clazz = env->GetObjectClass(fmTransmitterSession.jobj);
+
+    notifyMethod = env->GetMethodID(clazz, "notifyOnForcedReset", "(I)V");
+    if (notifyMethod != NULL) {
+        jobject jobj = fmTransmitterSession.jobj;
+        pthread_mutex_unlock(fmTransmitterSession.dataMutex_p);
+        env->CallVoidMethod(jobj, notifyMethod, reason);
+        pthread_mutex_lock(fmTransmitterSession.dataMutex_p);
+    }
+
+    //AudioSystem::
+      //  setDeviceConnectionState(AUDIO_DEVICE_OUT_FM_TX,
+         //                        AUDIO_POLICY_DEVICE_STATE_UNAVAILABLE,
+          //                       "");
+
+    if (reAttached) {
+        fmTransmitterSession.jvm_p->DetachCurrentThread();
+    }
+}
+
+static void androidFmRadioTxCallbackOnVendorForcedReset(enum fmradio_reset_reason_t reason)
+{
+    pthread_mutex_lock(fmTransmitterSession.dataMutex_p);
+    if (fmTransmitterSession.state != FMRADIO_STATE_IDLE) {
+        FMRADIO_SET_STATE(&fmTransmitterSession, FMRADIO_STATE_IDLE);
+        androidFmRadioUnLoadFmLibrary(&fmTransmitterSession);
+        fmTransmitterSession.isRegistered = false;
+    }
+    fmTransmitterSession.callbacks_p->onForcedReset(reason);
+    pthread_mutex_unlock(fmTransmitterSession.dataMutex_p);
+}
+
+static void androidFmRadioTxCallbackOnExtraCommand(char* command,
+                                                   struct
+                                                   fmradio_extra_command_ret_item_t
+                                                   *retList)
+{
+    jmethodID notifyMethod;
+
+    JNIEnv *env;
+
+    jclass clazz;
+
+    struct bundle_descriptor_offsets_t *bundle_p =
+        fmTransmitterSession.bundleOffsets_p;
+    LOGI("androidFmRadioTxCallbackOnExtraCommand");
+
+    if (fmTransmitterSession.jvm_p->AttachCurrentThread(&env, NULL) != JNI_OK) {
+        LOGE("Error, can't attch current thread");
+        return;
+    }
+
+    clazz = env->GetObjectClass(fmTransmitterSession.jobj);
+
+    jobject retBundle = extraCommandRetList2Bundle(env, bundle_p, retList);
+    jstring jcommand = env->NewStringUTF(command);
+
+    notifyMethod =
+        env->GetMethodID(clazz, "notifyOnExtraCommand",
+                         "(Ljava/lang/String;Landroid/os/Bundle;)V");
+    if (notifyMethod != NULL) {
+        jobject jobj = fmTransmitterSession.jobj;
+        pthread_mutex_unlock(fmTransmitterSession.dataMutex_p);
+        env->CallVoidMethod(jobj, notifyMethod,
+                            jcommand, retBundle);
+        pthread_mutex_lock(fmTransmitterSession.dataMutex_p);
+    }
+
+    fmTransmitterSession.jvm_p->DetachCurrentThread();
+}
+
+/*
+ *  function calls from java layer
+ */
+
+static jint androidFmRadioTxGetState(JNIEnv * env, jobject obj)
+{
+    FmRadioState_t state;
+
+    LOGI("androidFmRadioTxGetState\n");
+
+    pthread_mutex_lock(fmTransmitterSession.dataMutex_p);
+    state = fmTransmitterSession.state;
+    pthread_mutex_unlock(fmTransmitterSession.dataMutex_p);
+
+    return state;
+}
+
+/* common ones with rx, just forward to the generic androidFmRadioxxxxx version */
+
+static void
+androidFmRadioTxStart(JNIEnv * env, jobject obj, int lowFreq,
+                      int highFreq, int defaultFreq, int grid)
+{
+    int retval;
+
+    status_t err;
+
+    LOGI("androidFmRadioTxStart...");
+
+    if (fmTransmitterSession.jobj == NULL)
+        fmTransmitterSession.jobj = env->NewGlobalRef(obj);
+
+    retval =
+        androidFmRadioStart(&fmTransmitterSession, FMRADIO_TX,
+                            &FmRadioTxVendorCallbacks, false, lowFreq,
+                            highFreq, defaultFreq, grid);
+    if (retval >= 0) {
+        //err =
+        //    AudioSystem::
+           // setDeviceConnectionState(AUDIO_DEVICE_OUT_FM_TX,
+            //                         AUDIO_POLICY_DEVICE_STATE_AVAILABLE,
+             //                        "");
+
+        if (err != OK) {
+            LOGE("ERROR - Unable to set audio output device to FM Radio TX");
+           // (void) AudioSystem::setDeviceConnectionState
+            //    (AUDIO_DEVICE_OUT_FM_TX,
+             //    AUDIO_POLICY_DEVICE_STATE_UNAVAILABLE, "");
+        }
+    }
+
+}
+
+static void
+androidFmRadioTxStartAsync(JNIEnv * env, jobject obj, int lowFreq,
+                           int highFreq, int defaultFreq, int grid)
+{
+    LOGI("androidFmRadioTxStartAsync...");
+
+
+    if (fmTransmitterSession.jobj == NULL)
+        fmTransmitterSession.jobj = env->NewGlobalRef(obj);
+
+    androidFmRadioStart(&fmTransmitterSession, FMRADIO_TX,
+                        &FmRadioTxVendorCallbacks, true, lowFreq, highFreq,
+                        defaultFreq, grid);
+}
+
+static void androidFmRadioTxPause(JNIEnv * env, jobject obj)
+{
+    int retval;
+
+    LOGI("androidFmRadioTxPause\n");
+
+    retval = androidFmRadioPause(&fmTransmitterSession);
+
+    if (retval >= 0) {
+        //AudioSystem::
+           // setDeviceConnectionState(AUDIO_DEVICE_OUT_FM_TX,
+              //                       AUDIO_POLICY_DEVICE_STATE_UNAVAILABLE,
+               //                      "");
+    }
+}
+
+static void androidFmRadioTxResume(JNIEnv * env, jobject obj)
+{
+    int retval;
+
+    LOGI("androidFmResumeTxResume\n");
+    retval = androidFmRadioResume(&fmTransmitterSession);
+
+    if (retval >= 0) {
+       // status_t err =
+           // AudioSystem::
+            //setDeviceConnectionState(AUDIO_DEVICE_OUT_FM_TX,
+               //                      AUDIO_POLICY_DEVICE_STATE_AVAILABLE, "");
+
+        //if (err != OK) {
+            LOGE("ERROR - Unable to set audio output device to FM Radio TX\n");
+            //AudioSystem::
+               // setDeviceConnectionState(AUDIO_DEVICE_OUT_FM_TX,
+                    //                     AUDIO_POLICY_DEVICE_STATE_UNAVAILABLE,
+                      //                   "");
+       // }
+    }
+}
+
+static jint androidFmRadioTxReset(JNIEnv * env, jobject obj)
+{
+    int retval;
+
+    LOGI("androidFmRadioTxReset");
+
+    retval = androidFmRadioReset(&fmTransmitterSession);
+
+    if (retval >= 0) {
+        if (retval != FMRADIO_STATE_IDLE) {
+               // (void) AudioSystem::setDeviceConnectionState(AUDIO_DEVICE_OUT_FM_TX,
+                //                                     AUDIO_POLICY_DEVICE_STATE_UNAVAILABLE,
+                   //                                  "");
+        }
+
+
+        if (fmTransmitterSession.state == FMRADIO_STATE_IDLE &&
+            fmTransmitterSession.jobj != NULL) {
+            env->DeleteGlobalRef(fmTransmitterSession.jobj);
+            fmTransmitterSession.jobj = NULL;
+        }
+    }
+
+    return retval;
+}
+
+static void
+androidFmRadioTxSetFrequency(JNIEnv * env, jobject obj, jlong frequency)
+{
+    LOGI("androidFmRadioTxSetFrequency tuneTo:%d\n", (int) frequency);
+    androidFmRadioSetFrequency(&fmTransmitterSession, (int) frequency);
+}
+
+static void
+androidFmRadioTxSetRDSData(JNIEnv * env, jobject obj, jobject bundle)
+{
+    LOGI("androidFmRadioTxSetRDSData start");
+
+    pthread_mutex_lock(fmTransmitterSession.dataMutex_p);
+
+    if (!androidFmRadioIsValidEventForState
+        (&fmTransmitterSession, FMRADIO_EVENT_SET_PARAMETER)) {
+        THROW_INVALID_STATE(&fmTransmitterSession);
+        goto drop_lock;
+    }
+
+    /* if in pause state temporary resume */
+    androidFmRadioTempResumeIfPaused(&fmTransmitterSession);
+
+    if (bundle == NULL) {
+        /* just shut down RDS transmission and leave */
+        fmTransmitterSession.vendorMethods_p->
+            set_rds_data(&fmTransmitterSession.vendorData_p, NULL, NULL);
+        goto resume_and_drop_lock;
+    };
+
+    /* new block to control variable life time */
+    {
+        struct bundle_descriptor_offsets_t *bundle_p =
+            fmTransmitterSession.bundleOffsets_p;
+        jobject keys_set = env->CallObjectMethod(bundle, bundle_p->mKeySet);
+        jclass setClass = env->FindClass("java/util/Set");
+        jclass entryClass = env->FindClass("java/lang/String");
+        jmethodID iterator =
+            env->GetMethodID(setClass, "iterator", "()Ljava/util/Iterator;");
+        jobject iter = env->CallObjectMethod(keys_set, iterator);
+        jobject iter2 = env->CallObjectMethod(keys_set, iterator);
+        jclass iteratorClass = env->FindClass("java/util/Iterator");
+        jmethodID hasNext = env->GetMethodID(iteratorClass, "hasNext", "()Z");
+        jmethodID next =
+            env->GetMethodID(iteratorClass, "next", "()Ljava/lang/Object;");
+        jmethodID getString =
+            env->GetMethodID(entryClass, "toString", "()Ljava/lang/String;");
+
+        while (env->CallBooleanMethod(iter, hasNext)) {
+            int i;
+            jobject entry = env->CallObjectMethod(iter, next);
+            jstring string = (jstring) env->CallObjectMethod(entry, getString);
+            const char *str = env->GetStringUTFChars(string, NULL);
+            int found = 0;
+
+            if (!str) {             // Out of memory
+                THROW_IO_ERROR(&fmTransmitterSession); /* excecution will continue to cleanup */
+                env->DeleteLocalRef(entry);
+                env->DeleteLocalRef(string);
+                goto free_up_and_leave;
+            }
+
+            for (i = 0; rds_field_names[i] != NULL; i++) {
+                if (!strcmp(rds_field_names[i], str)) {
+                    found = 1;
+                    break;
+                }
+            }
+
+            env->DeleteLocalRef(entry);
+            env->ReleaseStringUTFChars(string, str);
+            env->DeleteLocalRef(string);
+
+            if (!found) {
+                LOGE("androidFmRadioTxSetRDSData: Error, invalid key");
+                THROW_ILLEGAL_ARGUMENT(&fmTransmitterSession); /* excecution will continue to cleanup */
+                goto free_up_and_leave;
+            }
+        }
+
+        while (env->CallBooleanMethod(iter2, hasNext)) {
+            jobject entry = env->CallObjectMethod(iter2, next);
+            jstring string = (jstring) env->CallObjectMethod(entry, getString);
+            char *str = (char *) env->GetStringUTFChars(string, NULL);
+            int rv = -1;
+
+            if (!str) {             // Out of memory
+                LOGE("androidFmRadioTxSetRDSData: out of memory");
+                THROW_IO_ERROR(&fmTransmitterSession); /* excecution will continue to cleanup */
+                rv = -2; /* not -1 since we already thrown exception */
+            } else if ((strcmp(str, "PI") == 0) ||
+                       (strcmp(str, "TP") == 0) ||
+                       (strcmp(str, "PTY") == 0) ||
+                       (strcmp(str, "TA") == 0) ||
+                       (strcmp(str, "M/S") == 0)) {
+                /* types setting numeric (short) value */
+                int passedval = 0;
+                short value = env->CallShortMethod(bundle, bundle_p->mGetShort,
+                                                   env->NewStringUTF(str));
+
+                passedval = (int) value;
+                rv = fmTransmitterSession.
+                    vendorMethods_p->set_rds_data(&fmTransmitterSession.
+                                                  vendorData_p, str,
+                                                  &passedval);
+            } else if (!strcmp(str, "TAF")) {
+                /* type setting numeric (int) value */
+                int value = env->CallIntMethod(bundle, bundle_p->mGetInt,
+                                               env->NewStringUTF(str));
+
+                rv = fmTransmitterSession.
+                    vendorMethods_p->set_rds_data(&fmTransmitterSession.
+                                                  vendorData_p, str,
+                                                  &value);
+            } else if (strcmp(str, "AF") == 0) {
+                /* type setting array of ints */
+                jintArray value = (jintArray) env->CallObjectMethod(bundle,
+                                                                    bundle_p->mGetIntArray,
+                                                                    env->NewStringUTF
+                                                                    (str));
+
+                int numInts = (value ? env->GetArrayLength(value) : 0);
+
+                if (numInts == 0) {
+                    env->DeleteLocalRef(entry);
+                    env->ReleaseStringUTFChars(string, str);
+                    env->DeleteLocalRef(string);
+                    goto free_up_and_leave;
+                }
+
+                int *temparray = env->GetIntArrayElements(value, NULL);
+                int *array = (int *) malloc((numInts + 1) * sizeof(*temparray));
+
+
+                if (array != NULL) {
+                    // Place a 0 after the final entry
+                    memcpy(array, temparray, numInts * sizeof(*temparray));
+                    array[numInts] = 0;
+                    rv = fmTransmitterSession.vendorMethods_p->
+                        set_rds_data(&fmTransmitterSession.vendorData_p, str, array);
+                    free(array);
+                } else {
+                    LOGE("android_setRdsData:malloc failed");
+                    rv = -1;
+                }
+                env->ReleaseIntArrayElements(value, temparray, 0);
+            } else if (strcmp(str, "TMC") == 0) {
+                /* type setting array of shorts */
+                jshortArray value = (jshortArray) env->CallObjectMethod(bundle,
+                                                                        bundle_p->mGetShortArray,
+                                                                        env->NewStringUTF
+                                                                        ("TMC"));
+                int numShorts = (value ? env->GetArrayLength(value) : 0);
+                short *temparray = env->GetShortArrayElements(value, NULL);
+                short *array  = (short *) malloc((numShorts + 1) * sizeof(*temparray));
+
+                if (array != NULL) {
+                    // Place a 0 after the final entry
+                    memcpy(array, temparray, numShorts * sizeof(*temparray));
+                    array[numShorts] = 0;
+                    rv = fmTransmitterSession.vendorMethods_p->
+                        set_rds_data(&fmTransmitterSession.vendorData_p, str, array);
+                    free(array);
+                } else {
+                    LOGE("android_setRdsData:malloc failed");
+                    rv = -1;
+                }
+                env->ReleaseShortArrayElements(value, temparray, 0);
+                /* types setting string */
+            } else if ((strcmp(str, "PSN") == 0) ||
+                       (strcmp(str, "RT") == 0) ||
+                       (strcmp(str, "CT") == 0) ||
+                       (strcmp(str, "PTYN") == 0)) {
+                unsigned int maxLength = 0;
+
+                if (strcmp(str, "PSN") == 0) {
+                    maxLength = RDS_PSN_MAX_LENGTH;
+                } else if (strcmp(str, "RT") == 0) {
+                    maxLength = RDS_RT_MAX_LENGTH;
+                } else if (strcmp(str, "CT") == 0) {
+                    maxLength = RDS_CT_MAX_LENGTH;
+                } else if (strcmp(str, "PTYN") == 0) {
+                    maxLength = RDS_PTYN_MAX_LENGTH;
+                }
+
+                jstring value = (jstring) env->CallObjectMethod(bundle,
+                                                                bundle_p->
+                                                                mGetString,
+                                                                env->
+                                                                NewStringUTF
+                                                                (str));
+
+                if (value == NULL) {
+                    LOGI("android_setRdsData:No key found for %s", str);
+                    rv = -1;
+                } else {
+                    const char *cvalue = env->GetStringUTFChars(value, NULL);
+
+                    // May need to add termination char
+                    if (strlen(cvalue) > maxLength) {
+                        LOGE("android_setRdsData:%s - Too long value.", str);
+                        rv = -1;
+                    } else {
+                        rv = fmTransmitterSession.vendorMethods_p->
+                            set_rds_data(&fmTransmitterSession.vendorData_p, str, (char *) cvalue);
+                    }
+                    env->ReleaseStringUTFChars(value, cvalue);
+                }
+            }
+            if (rv == FMRADIO_UNSUPPORTED_OPERATION) {
+                LOGE("android_setRdsData: key '%s' unsupported by vendor.", str);
+            } else if (rv < 0){
+                LOGE("Error processing key '%s'", str);
+                THROW_ILLEGAL_ARGUMENT(&fmTransmitterSession); /* execution will continue to cleanup */
+            }
+            env->DeleteLocalRef(entry);
+            if (str != NULL) {
+                env->ReleaseStringUTFChars(string, str);
+            }
+            env->DeleteLocalRef(string);
+            if (rv < 0 && rv != FMRADIO_UNSUPPORTED_OPERATION) {
+                break;
+            }
+        }
+    free_up_and_leave:
+        env->DeleteLocalRef(entryClass);
+        env->DeleteLocalRef(iteratorClass);
+        env->DeleteLocalRef(iter);
+        env->DeleteLocalRef(iter2);
+        env->DeleteLocalRef(setClass);
+        env->DeleteLocalRef(keys_set);
+    }
+ resume_and_drop_lock:
+    androidFmRadioPauseIfTempResumed(&fmTransmitterSession);
+ drop_lock:
+    pthread_mutex_unlock(fmTransmitterSession.dataMutex_p);
+}
+
+static jint androidFmRadioTxGetFrequency(JNIEnv * env, jobject obj)
+{
+    LOGI("androidFmRadioTxGetFrequency \n");
+    return androidFmRadioGetFrequency(&fmTransmitterSession);
+}
+
+static void androidFmRadioTxStopScan(JNIEnv * env, jobject obj)
+{
+    LOGI("androidFmRadioTxStopScan\n");
+
+    androidFmRadioStopScan(&fmTransmitterSession);
+}
+
+static jboolean
+androidFmRadioTxIsBlockScanSupported(JNIEnv * env, jobject obj)
+{
+    bool retval;
+
+    LOGI("androidFmRadioTxIsBlockScanSupported:\n");
+
+    pthread_mutex_lock(fmTransmitterSession.dataMutex_p);
+
+    /* if we haven't register we don't know yet */
+    if (!fmTransmitterSession.isRegistered) {
+        retval = false;
+        goto drop_lock;
+    }
+    // valid in all states
+    if (fmTransmitterSession.vendorMethods_p->block_scan != NULL) {
+        retval = true;
+    } else {
+        retval = false;
+    }
+
+  drop_lock:
+    pthread_mutex_unlock(fmTransmitterSession.dataMutex_p);
+    return retval;
+}
+
+static void *execute_androidFmRadioTxBlockScan(void *args_p)
+{
+    struct FmRadioBlockScanParameters *inArgs_p = (struct FmRadioBlockScanParameters *) args_p;
+    int startFreq = inArgs_p->startFreq;
+    int endFreq = inArgs_p->endFreq;
+    int retval;
+    enum FmRadioState_t oldState = fmTransmitterSession.oldState;
+    int *rssi_p = NULL;
+    int *freqs_p = NULL;
+
+    free(inArgs_p);
+
+    pthread_mutex_lock(fmTransmitterSession.dataMutex_p);
+
+    /*
+     * we should still be in SCANNING mode, but we can't be 100.00 % sure since
+     * main thread released lock before we could run
+     *
+     */
+
+    if (fmTransmitterSession.state != FMRADIO_STATE_SCANNING) {
+        LOGE("execute_androidFmRadioTxBlockScan - warning, state not scanning\n");
+    }
+
+    /*
+     * if mode has been changed to IDLE in the mean time by main thread,
+     * exit the worker thread gracefully
+     */
+    if (fmTransmitterSession.state == FMRADIO_STATE_IDLE) {
+        goto drop_lock;
+    }
+    // temporary resume chip if sleeping
+    if (oldState == FMRADIO_STATE_PAUSED) {
+        (void) fmTransmitterSession.vendorMethods_p->
+            resume(&fmTransmitterSession.vendorData_p);
+    }
+
+    if (pthread_cond_signal(&fmTransmitterSession.sync_cond) != 0) {
+        LOGE("execute_androidFmRadioTxBlockScan - warning, signal failed\n");
+    }
+    pthread_mutex_unlock(fmTransmitterSession.dataMutex_p);
+
+    retval =
+        fmTransmitterSession.
+        vendorMethods_p->block_scan(&fmTransmitterSession.vendorData_p,
+                                   startFreq, endFreq, &freqs_p, &rssi_p);
+
+    pthread_mutex_lock(fmTransmitterSession.dataMutex_p);
+
+    /*
+     * if state has changed we should keep it, probably a forced pause or
+     * forced reset
+     */
+    if (fmTransmitterSession.state != FMRADIO_STATE_SCANNING) {
+        LOGI("State changed while scanning (state now %d), keeping\n",
+             fmTransmitterSession.state);
+        retval = -1;
+    } else {
+        if (fmTransmitterSession.pendingPause) {
+            FMRADIO_SET_STATE(&fmTransmitterSession, FMRADIO_STATE_PAUSED);
+        } else {
+            FMRADIO_SET_STATE(&fmTransmitterSession, oldState);
+        }
+
+        fmTransmitterSession.pendingPause = false;
+    }
+
+    if (retval >= 0) {
+        fmTransmitterSession.callbacks_p->onBlockScan(retval, freqs_p,
+                                                      rssi_p,
+                                                      fmTransmitterSession.
+                                                      lastScanAborted);
+    } else {
+        fmTransmitterSession.callbacks_p->onError();
+    }
+
+    drop_lock:
+
+    if (rssi_p != NULL) {
+        free(rssi_p);
+    }
+
+    if (freqs_p != NULL) {
+        free(freqs_p);
+    }
+
+    /* Wake up the main thread if it is currently waiting on the condition variable */
+    if (pthread_cond_signal(&fmTransmitterSession.sync_cond) != 0) {
+            LOGE("execute_androidFmRadioTxBlockScan - signal failed\n");
+    }
+    pthread_mutex_unlock(fmTransmitterSession.dataMutex_p);
+
+    pthread_exit(NULL);
+
+    return NULL;
+}
+
+static void
+androidFmRadioTxStartBlockScan(JNIEnv * env, jobject obj,
+                               int startFreq, int endFreq)
+{
+    int retval = 0;
+
+    LOGI("androidFmRadioTxStartBlockScan, From = %d, To = %d\n",
+         startFreq, endFreq);
+
+    pthread_mutex_lock(fmTransmitterSession.dataMutex_p);
+
+    if (!androidFmRadioIsValidEventForState
+        (&fmTransmitterSession, FMRADIO_EVENT_BLOCK_SCAN)) {
+        retval = FMRADIO_INVALID_STATE;
+        goto drop_lock;
+    }
+
+    if (fmTransmitterSession.vendorMethods_p->block_scan) {
+        struct FmRadioBlockScanParameters* args_p = (struct FmRadioBlockScanParameters*) malloc(sizeof(struct FmRadioBlockScanParameters));
+
+        pthread_t execute_thread;
+
+        args_p->startFreq = startFreq;
+        args_p->endFreq = endFreq;
+
+        fmTransmitterSession.oldState = fmTransmitterSession.state;
+
+        FMRADIO_SET_STATE(&fmTransmitterSession, FMRADIO_STATE_SCANNING);
+
+        fmTransmitterSession.lastScanAborted = false;
+
+        if (pthread_create
+            (&execute_thread, NULL, execute_androidFmRadioTxBlockScan,
+             args_p) != 0) {
+
+            LOGE("pthread_create failure...\n");
+            free(args_p);
+
+            FMRADIO_SET_STATE(&fmTransmitterSession, fmTransmitterSession.oldState);
+            retval = FMRADIO_IO_ERROR;
+        } else {
+            /* await thread startup, THREAD_WAIT_TIMEOUT_S sec timeout */
+            struct timespec ts;
+            clock_gettime(CLOCK_REALTIME, &ts);
+            ts.tv_sec += THREAD_WAIT_TIMEOUT_S;
+            if (pthread_cond_timedwait(&fmTransmitterSession.sync_cond,
+                                       fmTransmitterSession.dataMutex_p,
+                                       &ts) != 0) {
+                LOGE("androidFmRadioTxStartBlockScan: warning, wait failure\n");
+            }
+            pthread_detach(execute_thread);
+        }
+    } else {
+        retval = FMRADIO_UNSUPPORTED_OPERATION;
+    }
+
+  drop_lock:
+    if (retval == FMRADIO_INVALID_STATE) {
+        THROW_INVALID_STATE(&fmTransmitterSession);
+    } else if (retval < 0) {
+        THROW_IO_ERROR(&fmTransmitterSession);
+    }
+
+    pthread_mutex_unlock(fmTransmitterSession.dataMutex_p);
+}
+
+static jboolean androidFmRadioTxSendExtraCommand(JNIEnv * env, jobject obj,
+                                             jstring command,
+                                             jobjectArray parameters)
+{
+    LOGI("androidFmRadioTxSendExtraCommand");
+
+    /* we need to set jobj since this might be called before start */
+
+
+    if (fmTransmitterSession.jobj == NULL)
+        fmTransmitterSession.jobj = env->NewGlobalRef(obj);
+
+    androidFmRadioSendExtraCommand(&fmTransmitterSession, env, command,
+                                   parameters);
+
+    return true;
+}
+
+static JNINativeMethod gMethods[] = {
+    {(char*)"_fm_transmitter_getState", (char*)"()I",
+     (void *) androidFmRadioTxGetState},
+    {(char*)"_fm_transmitter_start", (char*)"(IIII)V",
+     (void *) androidFmRadioTxStart},
+    {(char*)"_fm_transmitter_startAsync", (char*)"(IIII)V",
+     (void *) androidFmRadioTxStartAsync},
+    {(char*)"_fm_transmitter_pause", (char*)"()V",
+     (void *) androidFmRadioTxPause},
+    {(char*)"_fm_transmitter_resume", (char*)"()V",
+     (void *) androidFmRadioTxResume},
+    {(char*)"_fm_transmitter_reset", (char*)"()I",
+     (void *) androidFmRadioTxReset},
+    {(char*)"_fm_transmitter_setFrequency", (char*)"(I)V",
+     (void *) androidFmRadioTxSetFrequency},
+    {(char*)"_fm_transmitter_getFrequency", (char*)"()I",
+     (void *) androidFmRadioTxGetFrequency},
+    {(char*)"_fm_transmitter_isBlockScanSupported", (char*)"()Z",
+     (void *) androidFmRadioTxIsBlockScanSupported},
+    {(char*)"_fm_transmitter_startBlockScan", (char*)"(II)V",
+     (void *) androidFmRadioTxStartBlockScan},
+    {(char*)"_fm_transmitter_stopScan", (char*)"()V",
+     (void *) androidFmRadioTxStopScan},
+    {(char*)"_fm_transmitter_setRdsData", (char*)"(Landroid/os/Bundle;)V",
+     (void *) androidFmRadioTxSetRDSData},
+    {(char*)"_fm_transmitter_sendExtraCommand",
+     (char*)"(Ljava/lang/String;[Ljava/lang/String;)Z",
+     (void *) androidFmRadioTxSendExtraCommand},
+
+};
+
+int registerAndroidFmRadioTransmitter(JavaVM * vm, JNIEnv * env)
+{
+
+    LOGI("registerAndroidFmRadioTransmitter\n");
+    pthread_mutex_lock(fmTransmitterSession.dataMutex_p);
+    fmTransmitterSession.jvm_p = vm;
+    // setRDS bundle handling
+    jclass clazz = env->FindClass("android/os/Bundle");
+
+
+    struct bundle_descriptor_offsets_t *bundle_p =
+        (struct bundle_descriptor_offsets_t *)
+        malloc(sizeof(struct bundle_descriptor_offsets_t));
+
+    bundle_p->mSize = env->GetMethodID(clazz, "size", "()I");
+    bundle_p->mGetInt =
+        env->GetMethodID(clazz, "getInt", "(Ljava/lang/String;)I");
+    bundle_p->mGetIntArray =
+        env->GetMethodID(clazz, "getIntArray", "(Ljava/lang/String;)[I");
+    bundle_p->mGetShort =
+        env->GetMethodID(clazz, "getShort", "(Ljava/lang/String;)S");
+    bundle_p->mGetShortArray =
+        env->GetMethodID(clazz, "getShortArray", "(Ljava/lang/String;)[S");
+    bundle_p->mGetString =
+        env->GetMethodID(clazz, "getString",
+                         "(Ljava/lang/String;)Ljava/lang/String;");
+    bundle_p->mContainsKey =
+        env->GetMethodID(clazz, "containsKey", "(Ljava/lang/String;)Z");
+    bundle_p->mKeySet =
+        env->GetMethodID(clazz, "keySet", "()Ljava/util/Set;");
+    bundle_p->mClass = (jclass) env->NewGlobalRef(clazz);
+    bundle_p->mConstructor = env->GetMethodID(clazz, "<init>", "()V");
+    bundle_p->mPutInt =
+        env->GetMethodID(clazz, "putInt", "(Ljava/lang/String;I)V");
+    bundle_p->mPutIntArray =
+        env->GetMethodID(clazz, "putIntArray", "(Ljava/lang/String;[I)V");
+    bundle_p->mPutShortArray =
+        env->GetMethodID(clazz, "putShortArray",
+                         "(Ljava/lang/String;[S)V");
+    bundle_p->mPutString =
+        env->GetMethodID(clazz, "putString",
+                         "(Ljava/lang/String;Ljava/lang/String;)V");
+
+    fmTransmitterSession.bundleOffsets_p = bundle_p;
+    pthread_mutex_unlock(fmTransmitterSession.dataMutex_p);
+
+    return jniRegisterNativeMethods(env,
+                                    "com/stericsson/hardware/fm/FmTransmitterService",
+                                    gMethods, NELEM(gMethods));
+}
+
+/* *INDENT-OFF* */
+};                              // namespace android
diff --git a/include/camera/CameraParameters.h b/include/camera/CameraParameters.h
index 7cc3d4e..9f8676b 100644
--- a/include/camera/CameraParameters.h
+++ b/include/camera/CameraParameters.h
@@ -750,12 +750,26 @@ public:
     static const char SCENE_DETECT_ON[];
 #endif
     static const char PIXEL_FORMAT_YUV422SP[];
+#ifdef STE_HARDWARE
+    static const char PIXEL_FORMAT_YUV420P[]; // YV12
+#endif
     static const char PIXEL_FORMAT_YUV420SP[]; // NV21
+#ifdef STE_HARDWARE
+    static const char PIXEL_FORMAT_YUV420SPNV12[]; // NV12
+#endif
 #ifdef QCOM_HARDWARE
     static const char PIXEL_FORMAT_YUV420SP_ADRENO[]; // ADRENO
 #endif
     static const char PIXEL_FORMAT_YUV422I[]; // YUY2
+#ifndef STE_HARDWARE
     static const char PIXEL_FORMAT_YUV420P[]; // YV12
+#else
+    static const char PIXEL_FORMAT_YVU422SP[];
+    static const char PIXEL_FORMAT_YVU422P[];
+    static const char PIXEL_FORMAT_YVU420SP[];
+    static const char PIXEL_FORMAT_YVU420P[];
+    static const char PIXEL_FORMAT_YUV420MB[];
+#endif
     static const char PIXEL_FORMAT_RGB565[];
     static const char PIXEL_FORMAT_RGBA8888[];
     static const char PIXEL_FORMAT_JPEG[];
@@ -819,6 +833,11 @@ public:
     // other modes.
     static const char FOCUS_MODE_CONTINUOUS_PICTURE[];
 
+#ifdef STE_HARDWARE
+    // keys for record stride and slice height
+    static const char KEY_RECORD_STRIDE[];
+    static const char KEY_RECORD_SLICE_HEIGHT[];
+#endif
 #ifdef QCOM_HARDWARE
     static const char FOCUS_MODE_CONTINUOUS_CAMERA[];
 
diff --git a/include/gui/SurfaceTexture.h b/include/gui/SurfaceTexture.h
index 36c5b72..cba73b7 100644
--- a/include/gui/SurfaceTexture.h
+++ b/include/gui/SurfaceTexture.h
@@ -30,6 +30,9 @@
 #include <utils/Vector.h>
 #include <utils/threads.h>
 
+#ifdef STE_HARDWARE
+#include <hardware/copybit.h>
+#endif
 #define ANDROID_GRAPHICS_SURFACETEXTURE_JNI_ID "mSurfaceTexture"
 
 namespace android {
@@ -47,6 +50,9 @@ public:
     };
     enum { NUM_BUFFER_SLOTS = 32 };
     enum { NO_CONNECTED_API = 0 };
+#ifdef STE_HARDWARE
+    enum { NUM_BLIT_BUFFER_SLOTS = 2 };
+#endif
 
     struct FrameAvailableListener : public virtual RefBase {
         // onFrameAvailable() is called from queueBuffer() each time an
@@ -136,12 +142,26 @@ public:
     // connected to the specified client API.
     virtual status_t disconnect(int api);
 
+#ifndef STE_HARDWARE
     // updateTexImage sets the image contents of the target texture to that of
     // the most recently queued buffer.
     //
     // This call may only be made while the OpenGL ES context to which the
     // target texture belongs is bound to the calling thread.
     status_t updateTexImage(bool isComposition = false);
+#else
+    status_t updateTexImage();
+
+    // A surface that uses a non-native format requires conversion of
+    // its buffers. This conversion can be deferred until the layer
+    // based on this surface is drawn.
+    status_t updateTexImage(bool deferConversion);
+
+    // convert() performs the deferred texture conversion as scheduled
+    // by updateTexImage(bool deferConversion).
+    // The method returns immediately if no conversion is necessary.
+    status_t convert();
+#endif
 
     // setBufferCountServer set the buffer count. If the client has requested
     // a buffer count using setBufferCount, the server-buffer count will
@@ -267,6 +287,13 @@ private:
     EGLImageKHR createImage(EGLDisplay dpy,
             const sp<GraphicBuffer>& graphicBuffer);
 
+#ifdef STE_HARDWARE
+    // returns TRUE if buffer needs color format conversion
+    bool conversionIsNeeded(const sp<GraphicBuffer>& graphicBuffer);
+
+    // converts buffer to a suitable color format
+    status_t convert(sp<GraphicBuffer> &srcBuf, sp<GraphicBuffer> &dstBuf);
+#endif
     status_t setBufferCountServerLocked(int bufferCount);
 
     // computeCurrentTransformMatrix computes the transform matrix for the
@@ -516,6 +543,36 @@ private:
     // with the surface Texture.
     uint64_t mFrameCounter;
 
+#ifdef STE_HARDWARE
+    // mBlitEngine is the handle to the copybit device which will be used in
+    // case color transform is needed before the EGL image is created.
+    copybit_device_t* mBlitEngine;
+
+    // mBlitSlots contains several buffers which will
+    // be rendered alternately in case color transform is needed (instead
+    // of rendering the buffers in mSlots).
+    BufferSlot mBlitSlots[NUM_BLIT_BUFFER_SLOTS];
+
+    // mNextBlitSlot is the index of the blitter buffer (in mBlitSlots) which
+    // will be used in the next color transform.
+    int mNextBlitSlot;
+
+    // mConversionSrcSlot designates the slot where source buffer
+    // for the last deferred updateTexImage is located.
+    int mConversionSrcSlot;
+
+    // mConversionBltSlot designates the slot where destination buffer
+    // for the last deferred updateTexImage is located.
+    int mConversionBltSlot;
+
+    // mNeedsConversion indicates that a format conversion is necessary
+    // before the layer based on this surface is drawn.
+    // This flag is set whenever updateTexImage() with deferred conversion
+    // is called. It is cleared once the layer is drawn,
+    // or when updateTexImage() w/o deferred conversion is called.
+    bool mNeedsConversion;
+#endif
+
 #ifdef QCOM_HARDWARE
     // s3dFormat is the S3D format specified by the client.
     int mS3DFormat;
diff --git a/include/media/AudioParameter.h b/include/media/AudioParameter.h
index 79d5d82..7c9536e 100644
--- a/include/media/AudioParameter.h
+++ b/include/media/AudioParameter.h
@@ -46,6 +46,9 @@ public:
     static const char *keyChannels;
     static const char *keyFrameCount;
     static const char *keyInputSource;
+#ifdef STE_HARDWARE
+    static const char *keyLatency;
+#endif
 
     String8 toString();
 
diff --git a/include/media/AudioRecord.h b/include/media/AudioRecord.h
index 605680a..85aee28 100644
--- a/include/media/AudioRecord.h
+++ b/include/media/AudioRecord.h
@@ -385,6 +385,9 @@ private:
     uint32_t                mChannelMask;
     audio_io_handle_t       mInput;
     int                     mSessionId;
+#ifdef STE_AUDIO
+    audio_input_clients     *mpInputClientId;
+#endif
 };
 
 }; // namespace android
diff --git a/include/media/AudioSystem.h b/include/media/AudioSystem.h
index f80a8d6..8982525 100644
--- a/include/media/AudioSystem.h
+++ b/include/media/AudioSystem.h
@@ -31,6 +31,9 @@ namespace android {
 
 typedef void (*audio_error_callback)(status_t err);
 
+#ifdef STE_HARDWARE
+typedef void (*latency_update_callback)(void *cookie, audio_io_handle_t output, uint32_t latency);
+#endif
 class IAudioPolicyService;
 class String8;
 
@@ -110,6 +113,10 @@ public:
     static int newAudioSessionId();
     static void acquireAudioSessionId(int audioSession);
     static void releaseAudioSessionId(int audioSession);
+#ifdef STE_HARDWARE
+    static int registerLatencyNotificationClient(latency_update_callback cb, void *cookie);
+    static void unregisterLatencyNotificationClient(int clientId);
+#endif
 
     // types of io configuration change events received with ioConfigChanged()
     enum io_config_event {
@@ -176,7 +183,12 @@ public:
                                     uint32_t format = AUDIO_FORMAT_DEFAULT,
                                     uint32_t channels = AUDIO_CHANNEL_IN_MONO,
                                     audio_in_acoustics_t acoustics = (audio_in_acoustics_t)0,
+#ifdef STE_AUDIO
+                                    int sessionId = 0,
+                                    audio_input_clients *inputClientId = NULL);
+#else
                                     int sessionId = 0);
+#endif
     static status_t startInput(audio_io_handle_t input);
     static status_t stopInput(audio_io_handle_t input);
     static void releaseInput(audio_io_handle_t input);
@@ -234,6 +246,13 @@ private:
         virtual void binderDied(const wp<IBinder>& who);
     };
 
+#ifdef STE_HARDWARE
+    struct NotificationClient : public RefBase {
+        latency_update_callback mCb;
+        void * mCookie;
+    };
+#endif
+
     static sp<AudioFlingerClient> gAudioFlingerClient;
     static sp<AudioPolicyServiceClient> gAudioPolicyServiceClient;
     friend class AudioFlingerClient;
@@ -256,6 +275,11 @@ private:
     // list of output descriptors containing cached parameters
     // (sampling rate, framecount, channel count...)
     static DefaultKeyedVector<audio_io_handle_t, OutputDescriptor *> gOutputs;
+#ifdef STE_HARDWARE
+    static Mutex gLatencyLock;
+    static int gNextUniqueLatencyId;
+    static DefaultKeyedVector<int, sp<AudioSystem::NotificationClient> > gLatencyNotificationClients;
+#endif
 };
 
 };  // namespace android
diff --git a/include/media/AudioTrack.h b/include/media/AudioTrack.h
index f518198..1208ada 100644
--- a/include/media/AudioTrack.h
+++ b/include/media/AudioTrack.h
@@ -55,7 +55,12 @@ public:
         EVENT_LOOP_END = 2,         // Sample loop end was reached; playback restarted from loop start if loop count was not 0.
         EVENT_MARKER = 3,           // Playback head is at the specified marker position (See setMarkerPosition()).
         EVENT_NEW_POS = 4,          // Playback head is at a new position (See setPositionUpdatePeriod()).
+#ifdef STE_HARDWARE
+        EVENT_BUFFER_END = 5,       // Playback head is at the end of the buffer.
+        EVENT_LATENCY_CHANGED = 6   // Audio output has been reconfigured and latency has changed.
+#else
         EVENT_BUFFER_END = 5        // Playback head is at the end of the buffer.
+#endif
     };
 
     /* Create Buffer on the stack and pass it to obtainBuffer()
@@ -480,6 +485,10 @@ private:
             status_t setLoop_l(uint32_t loopStart, uint32_t loopEnd, int loopCount);
             audio_io_handle_t getOutput_l();
             status_t restoreTrack_l(audio_track_cblk_t*& cblk, bool fromStart);
+#ifdef STE_HARDWARE
+    static void LatencyCallbackWrapper(void *cookie, audio_io_handle_t output, uint32_t latency);
+    void latencyCallback(audio_io_handle_t output, uint32_t latency);
+#endif
 
     sp<IAudioTrack>         mAudioTrack;
     sp<IMemory>             mCblkMemory;
@@ -521,6 +530,9 @@ private:
     int                     mAuxEffectId;
     Mutex                   mLock;
     status_t                mRestoreStatus;
+#ifdef STE_HARDWARE
+    int                     mLatencyClientId;
+#endif
 };
 
 
diff --git a/include/media/IAudioFlinger.h b/include/media/IAudioFlinger.h
index 6a9d4b0..743a0de 100644
--- a/include/media/IAudioFlinger.h
+++ b/include/media/IAudioFlinger.h
@@ -151,13 +151,22 @@ public:
     virtual status_t suspendOutput(int output) = 0;
     virtual status_t restoreOutput(int output) = 0;
 
+#ifdef STE_AUDIO
+    virtual uint32_t *addInputClient(uint32_t clientId) = 0;
+    virtual status_t removeInputClient(uint32_t *pClientId) = 0;
+#endif
     virtual int openInput(uint32_t *pDevices,
                                     uint32_t *pSamplingRate,
                                     uint32_t *pFormat,
                                     uint32_t *pChannels,
+#ifdef STE_AUDIO
+                                    uint32_t acoustics,
+                                    uint32_t *pInputClientId = NULL) = 0;
+    virtual status_t closeInput(int input, uint32_t* inputClientId = NULL) = 0;
+#else
                                     uint32_t acoustics) = 0;
     virtual status_t closeInput(int input) = 0;
-
+#endif
     virtual status_t setStreamOutput(uint32_t stream, int output) = 0;
 
     virtual status_t setVoiceVolume(float volume) = 0;
@@ -191,6 +200,9 @@ public:
 #ifdef WITH_QCOM_LPA
     virtual status_t deregisterClient(const sp<IAudioFlingerClient>& client) { return false; };
 #endif
+#ifdef STE_AUDIO
+    virtual size_t readInput(uint32_t *input, uint32_t inputClientId, void *buffer, uint32_t bytes, uint32_t *pOverwrittenBytes) = 0;
+#endif
 };
 
 
diff --git a/include/media/IAudioPolicyService.h b/include/media/IAudioPolicyService.h
index b8a4621..6134ad0 100644
--- a/include/media/IAudioPolicyService.h
+++ b/include/media/IAudioPolicyService.h
@@ -75,7 +75,12 @@ public:
                                     uint32_t format = AUDIO_FORMAT_DEFAULT,
                                     uint32_t channels = 0,
                                     audio_in_acoustics_t acoustics = (audio_in_acoustics_t)0,
+#ifdef STE_AUDIO
+                                    int audioSession = 0,
+                                    audio_input_clients *inputClientId = NULL) = 0;
+#else
                                     int audioSession = 0) = 0;
+#endif
     virtual status_t startInput(audio_io_handle_t input) = 0;
     virtual status_t stopInput(audio_io_handle_t input) = 0;
     virtual void releaseInput(audio_io_handle_t input) = 0;
diff --git a/include/media/MediaPlayerInterface.h b/include/media/MediaPlayerInterface.h
index d23d2c4..9088a86 100644
--- a/include/media/MediaPlayerInterface.h
+++ b/include/media/MediaPlayerInterface.h
@@ -68,6 +68,9 @@ public:
         // Callback returns the number of bytes actually written to the buffer.
         typedef size_t (*AudioCallback)(
                 AudioSink *audioSink, void *buffer, size_t size, void *cookie);
+#ifdef STE_HARDWARE
+        typedef void (*LatencyCallback)(uint32_t latency, void *cookie);
+#endif
 
         virtual             ~AudioSink() {}
         virtual bool        ready() const = 0; // audio output is open and ready
@@ -88,7 +91,12 @@ public:
                 int format=AUDIO_FORMAT_PCM_16_BIT,
                 int bufferCount=DEFAULT_AUDIOSINK_BUFFERCOUNT,
                 AudioCallback cb = NULL,
+#ifdef STE_HARDWARE
+                void *cookie = NULL,
+                LatencyCallback latencyCb = NULL) = 0;
+#else
                 void *cookie = NULL) = 0;
+#endif
 
 #ifdef WITH_QCOM_LPA
         // API to open a routing session for tunneled audio playback
diff --git a/include/media/stagefright/AudioPlayer.h b/include/media/stagefright/AudioPlayer.h
index bb05ba3..dd09f18 100644
--- a/include/media/stagefright/AudioPlayer.h
+++ b/include/media/stagefright/AudioPlayer.h
@@ -104,6 +104,10 @@ private:
             MediaPlayerBase::AudioSink *audioSink,
             void *data, size_t size, void *me);
 
+#ifdef STE_HARDWARE
+    static void LatencyCallback(uint32_t latency, void *cookie);
+#endif
+
     size_t fillBuffer(void *data, size_t size);
 
     int64_t getRealTimeUsLocked() const;
diff --git a/include/media/stagefright/ColorConverter.h b/include/media/stagefright/ColorConverter.h
index df26f77..52654a7 100644
--- a/include/media/stagefright/ColorConverter.h
+++ b/include/media/stagefright/ColorConverter.h
@@ -74,6 +74,10 @@ private:
     status_t convertQCOMYUV420SemiPlanar(
             const BitmapParams &src, const BitmapParams &dst);
 
+#ifdef STE_HARDWARE
+    status_t convertSTEYUV420PackedSemiPlanarMB(
+            const BitmapParams &src, const BitmapParams &dst);
+#endif
     status_t convertYUV420SemiPlanar(
             const BitmapParams &src, const BitmapParams &dst);
 
diff --git a/include/media/stagefright/FMRadioDataSource.h b/include/media/stagefright/FMRadioDataSource.h
new file mode 100644
index 0000000..9673555
--- /dev/null
+++ b/include/media/stagefright/FMRadioDataSource.h
@@ -0,0 +1,73 @@
+/*
+ * Copyright (C) ST-Ericsson SA 2010
+ * Copyright (C) 2010 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+ * Author: Andreas Gustafsson (andreas.a.gustafsson@stericsson.com)
+ *         for ST-Ericsson
+ */
+
+#ifndef FMRADIO_DATA_SOURCE_H_
+
+#define FMRADIO_DATA_SOURCE_H_
+
+#include <stdio.h>
+
+#include <media/stagefright/DataSource.h>
+#include <media/stagefright/MediaErrors.h>
+#include <utils/threads.h>
+#include <hardware_legacy/AudioHardwareInterface.h>
+#include <media/AudioSystem.h>
+#include <system/audio.h>
+#include <hardware_legacy/AudioSystemLegacy.h>
+
+namespace android {
+
+class FMRadioDataSource : public DataSource {
+public:
+    FMRadioDataSource();
+
+    virtual status_t initCheck() const;
+
+    virtual ssize_t readAt(off64_t offset, void *data, size_t size);
+
+    virtual status_t getSize(off64_t *size);
+
+    virtual uint32_t getBufferSize();
+
+    virtual uint32_t getNumChannels();
+
+    virtual uint32_t getSampleRate();
+
+    virtual uint32_t getFormat();
+
+protected:
+    virtual ~FMRadioDataSource();
+
+private:
+    android_audio_legacy::AudioStreamIn *mStream;
+    sp<IAudioFlinger> mAudioFlinger;
+    FMRadioDataSource(const FMRadioDataSource &);
+    FMRadioDataSource &operator=(const FMRadioDataSource &);
+    audio_input_clients mInputClientId;
+    uint32_t mFormat;
+    uint32_t mChannels;
+    uint32_t mSampleRate;
+    uint32_t mOverwrittenBytes;
+    uint32_t mFlags;
+};
+
+}  // namespace android
+
+#endif  // FMRADIO_DATA_SOURCE_H_
diff --git a/include/media/stagefright/MediaDefs.h b/include/media/stagefright/MediaDefs.h
index 9559083..1704cc5 100755
--- a/include/media/stagefright/MediaDefs.h
+++ b/include/media/stagefright/MediaDefs.h
@@ -27,8 +27,14 @@ extern const char *MEDIA_MIMETYPE_VIDEO_VPX;
 extern const char *MEDIA_MIMETYPE_VIDEO_AVC;
 extern const char *MEDIA_MIMETYPE_VIDEO_MPEG4;
 extern const char *MEDIA_MIMETYPE_VIDEO_H263;
+#ifdef STE_HARDWARE
+extern const char *MEDIA_MIMETYPE_VIDEO_H263_SW;
+#endif
 extern const char *MEDIA_MIMETYPE_VIDEO_MPEG2;
 extern const char *MEDIA_MIMETYPE_VIDEO_RAW;
+#ifdef STE_HARDWARE
+extern const char *MEDIA_MIMETYPE_VIDEO_VC1;
+#endif
 
 extern const char *MEDIA_MIMETYPE_AUDIO_AMR_NB;
 extern const char *MEDIA_MIMETYPE_AUDIO_AMR_WB;
diff --git a/include/media/stagefright/OMXCodec.h b/include/media/stagefright/OMXCodec.h
index e338ba4..5b8051f 100755
--- a/include/media/stagefright/OMXCodec.h
+++ b/include/media/stagefright/OMXCodec.h
@@ -156,6 +156,9 @@ private:
         kAvoidMemcopyInputRecordingFrames     = 2048,
         kRequiresLargerEncoderOutputBuffer    = 4096,
         kOutputBuffersAreUnreadable           = 8192,
+#ifdef STE_HARDWARE
+        kRequiresStoreMetaDataBeforeIdle      = 16384,
+#endif
 #ifdef QCOM_HARDWARE
         kStoreMetaDataInInputVideoBuffers     = 16384,
         kRequiresGlobalFlush                  = 0x20000000, // 2^29
diff --git a/include/media/stagefright/foundation/ABitReader.h b/include/media/stagefright/foundation/ABitReader.h
index 5510b12..5f3285a 100644
--- a/include/media/stagefright/foundation/ABitReader.h
+++ b/include/media/stagefright/foundation/ABitReader.h
@@ -31,6 +31,10 @@ struct ABitReader {
     uint32_t getBits(size_t n);
     void skipBits(size_t n);
 
+#ifdef STE_HARDWARE
+    void rewindBits(size_t n);
+#endif
+
     void putBits(uint32_t x, size_t n);
 
     size_t numBitsLeft() const;
@@ -39,7 +43,13 @@ struct ABitReader {
 
 private:
     const uint8_t *mData;
+#ifdef STE_HARDWARE
+    const uint8_t *mOriginalData;
+#endif
     size_t mSize;
+#ifdef STE_HARDWARE
+    size_t mOriginalSize;
+#endif
 
     uint32_t mReservoir;  // left-aligned bits
     size_t mNumBitsLeft;
diff --git a/include/media/stagefright/openmax/OMX_IVCommon.h b/include/media/stagefright/openmax/OMX_IVCommon.h
index 7391e56..121a8a3 100644
--- a/include/media/stagefright/openmax/OMX_IVCommon.h
+++ b/include/media/stagefright/openmax/OMX_IVCommon.h
@@ -158,6 +158,9 @@ typedef enum OMX_COLOR_FORMATTYPE {
      * */
     OMX_COLOR_FormatAndroidOpaque = 0x7F000789,
     OMX_TI_COLOR_FormatYUV420PackedSemiPlanar = 0x7F000100,
+#ifdef STE_HARDWARE
+    OMX_STE_COLOR_FormatYUV420PackedSemiPlanarMB = 0x7FA00000,
+#endif
 #ifndef QCOM_HARDWARE
     OMX_QCOM_COLOR_FormatYVU420SemiPlanar = 0x7FA30C00,
 #endif
diff --git a/include/surfaceflinger/ISurfaceComposer.h b/include/surfaceflinger/ISurfaceComposer.h
index c96f88a..cb55adb 100644
--- a/include/surfaceflinger/ISurfaceComposer.h
+++ b/include/surfaceflinger/ISurfaceComposer.h
@@ -136,6 +136,10 @@ public:
     //External display specific functions
     virtual void enableExternalDisplay(int disp_type, int enable) = 0;
 #endif
+#ifdef STE_HDMI
+    //External display specific functions
+    virtual int setHDMIParameter(int disp_type, int enable) = 0;
+#endif
 
 };
 
@@ -160,6 +164,9 @@ public:
 #ifdef QCOM_HDMI_OUT
         EXTERNAL_DISPLAY,
 #endif
+#ifdef STE_HDMI
+        SET_HDMI_PARAMETER,
+#endif
     };
 
     virtual status_t    onTransact( uint32_t code,
diff --git a/include/surfaceflinger/SurfaceComposerClient.h b/include/surfaceflinger/SurfaceComposerClient.h
index c853d6a..7048180 100644
--- a/include/surfaceflinger/SurfaceComposerClient.h
+++ b/include/surfaceflinger/SurfaceComposerClient.h
@@ -139,6 +139,10 @@ public:
     //HDMI SPecific functions
     static void enableExternalDisplay(int disp_type, int enable);
 #endif
+#ifdef STE_HDMI
+    //HDMI SPecific functions
+    static int setHDMIParameter(int disp_type, int enable);
+#endif
 
     status_t    hide(SurfaceID id);
     status_t    show(SurfaceID id, int32_t layer = -1);
diff --git a/include/ui/PixelFormat.h b/include/ui/PixelFormat.h
index 848c5a1..704959b 100644
--- a/include/ui/PixelFormat.h
+++ b/include/ui/PixelFormat.h
@@ -72,6 +72,14 @@ enum {
 
     // New formats can be added if they're also defined in
     // pixelflinger/format.h
+
+#ifdef STE_HARDWARE
+    // Added Support for YUV42XMBN,
+    // Required for Copybit CC acceleration
+    PIXEL_FORMAT_YCBCR42XMBN = HAL_PIXEL_FORMAT_YCBCR42XMBN,
+    PIXEL_FORMAT_YCbCr_420_SP = HAL_PIXEL_FORMAT_YCbCr_420_SP,
+    PIXEL_FORMAT_YCbCr_420_P = HAL_PIXEL_FORMAT_YCbCr_420_P,
+#endif
 };
 
 typedef int32_t PixelFormat;
diff --git a/include/ui/Region.h b/include/ui/Region.h
index 6c9a620..d6b612a 100644
--- a/include/ui/Region.h
+++ b/include/ui/Region.h
@@ -24,6 +24,10 @@
 
 #include <ui/Rect.h>
 
+#ifdef STE_HARDWARE
+#include <hardware/copybit.h>
+#endif
+
 namespace android {
 // ---------------------------------------------------------------------------
 
@@ -181,6 +185,29 @@ Region& Region::operator -= (const Region& rhs) {
 Region& Region::operator += (const Point& pt) {
     return translateSelf(pt.x, pt.y);
 }
+
+
+#ifdef STE_HARDWARE
+// ---------------------------------------------------------------------------
+
+struct region_iterator : public copybit_region_t {
+    region_iterator(const Region& region)
+        : b(region.begin()), e(region.end()) {
+        this->next = iterate;
+    }
+private:
+    static int iterate(copybit_region_t const * self, copybit_rect_t* rect) {
+        region_iterator const* me = static_cast<region_iterator const*>(self);
+        if (me->b != me->e) {
+            *reinterpret_cast<Rect*>(rect) = *me->b++;
+            return 1;
+        }
+        return 0;
+    }
+    mutable Region::const_iterator b;
+    Region::const_iterator const e;
+};
+#endif
 // ---------------------------------------------------------------------------
 }; // namespace android
 
diff --git a/libs/camera/CameraParameters.cpp b/libs/camera/CameraParameters.cpp
index 6ed7a25..ee768ae 100644
--- a/libs/camera/CameraParameters.cpp
+++ b/libs/camera/CameraParameters.cpp
@@ -248,12 +248,26 @@ const char CameraParameters::SCENE_DETECT_ON[] = "on";
 
 // Formats for setPreviewFormat and setPictureFormat.
 const char CameraParameters::PIXEL_FORMAT_YUV422SP[] = "yuv422sp";
+#ifdef STE_HARDWARE
+const char CameraParameters::PIXEL_FORMAT_YUV420P[] = "yuv420p";
+#endif
 const char CameraParameters::PIXEL_FORMAT_YUV420SP[] = "yuv420sp";
+#ifdef STE_HARDWARE
+const char CameraParameters::PIXEL_FORMAT_YUV420SPNV12[] = "yuv420spnv12";
+#endif
 #ifdef QCOM_HARDWARE
 const char CameraParameters::PIXEL_FORMAT_YUV420SP_ADRENO[] = "yuv420sp-adreno";
 #endif
 const char CameraParameters::PIXEL_FORMAT_YUV422I[] = "yuv422i-yuyv";
+#ifndef STE_HARDWARE
 const char CameraParameters::PIXEL_FORMAT_YUV420P[]  = "yuv420p";
+#else
+const char CameraParameters::PIXEL_FORMAT_YUV420MB[] = "yuv420mb";
+const char CameraParameters::PIXEL_FORMAT_YVU422SP[] = "yvu422sp";
+const char CameraParameters::PIXEL_FORMAT_YVU422P[] = "yvu422p";
+const char CameraParameters::PIXEL_FORMAT_YVU420SP[] = "yvu420sp";
+const char CameraParameters::PIXEL_FORMAT_YVU420P[]  = "yvu420p";
+#endif
 const char CameraParameters::PIXEL_FORMAT_RGB565[] = "rgb565";
 const char CameraParameters::PIXEL_FORMAT_RGBA8888[] = "rgba8888";
 const char CameraParameters::PIXEL_FORMAT_JPEG[] = "jpeg";
@@ -395,6 +409,11 @@ void CameraParameters::setOrientation(int orientation)
 }
 #endif
 
+#ifdef STE_HARDWARE
+// keys for record stride and sliceheight
+const char CameraParameters::KEY_RECORD_STRIDE[] = "record-stride";
+const char CameraParameters::KEY_RECORD_SLICE_HEIGHT[] = "record-slice-height";
+#endif
 
 CameraParameters::CameraParameters()
                 : mMap()
diff --git a/libs/gui/ISurfaceComposer.cpp b/libs/gui/ISurfaceComposer.cpp
index 1b18d4f..be16f65 100644
--- a/libs/gui/ISurfaceComposer.cpp
+++ b/libs/gui/ISurfaceComposer.cpp
@@ -185,6 +185,17 @@ public:
         remote()->transact(BnSurfaceComposer::EXTERNAL_DISPLAY, data, &reply);
     }
 #endif
+#ifdef STE_HDMI
+    virtual int setHDMIParameter(int disp_type, int enable)
+    {
+        Parcel data, reply;
+        data.writeInterfaceToken(ISurfaceComposer::getInterfaceDescriptor());
+        data.writeInt32(disp_type);
+        data.writeInt32(enable);
+        remote()->transact(BnSurfaceComposer::SET_HDMI_PARAMETER, data, &reply);
+        return reply.readInt32();
+    }
+#endif
 
 };
 
@@ -274,6 +285,15 @@ status_t BnSurfaceComposer::onTransact(
             enableExternalDisplay(disp_type, enable);
         } break;
 #endif
+#ifdef STE_HDMI
+        case SET_HDMI_PARAMETER: {
+            CHECK_INTERFACE(ISurfaceComposer, data, reply);
+            int disp_type = data.readInt32();
+            int enable = data.readInt32();
+            int32_t result = setHDMIParameter(disp_type, enable);
+            reply->writeInt32(result);
+        } break;
+#endif
         default:
             return BBinder::onTransact(code, data, reply, flags);
     }
diff --git a/libs/gui/SurfaceComposerClient.cpp b/libs/gui/SurfaceComposerClient.cpp
index 4e570e8..fb50b50 100644
--- a/libs/gui/SurfaceComposerClient.cpp
+++ b/libs/gui/SurfaceComposerClient.cpp
@@ -287,6 +287,13 @@ void SurfaceComposerClient::enableExternalDisplay(int disp_type, int enable)
     return sm->enableExternalDisplay(disp_type, enable);
 }
 #endif
+#ifdef STE_HDMI
+int SurfaceComposerClient::setHDMIParameter(int disp_type, int enable)
+{
+    sp<ISurfaceComposer> sm(getComposerService());
+    return sm->setHDMIParameter(disp_type, enable);
+}
+#endif
 
 status_t Composer::setOrientation(int orientation) {
     Mutex::Autolock _l(mLock);
diff --git a/libs/gui/SurfaceTexture.cpp b/libs/gui/SurfaceTexture.cpp
index 6a26e6a..8f628ac 100644
--- a/libs/gui/SurfaceTexture.cpp
+++ b/libs/gui/SurfaceTexture.cpp
@@ -142,6 +142,10 @@ SurfaceTexture::SurfaceTexture(GLuint tex, bool allowSynchronousMode,
     mUseFenceSync(false),
 #endif
     mTexTarget(texTarget),
+#ifdef STE_HARDWARE
+    mNextBlitSlot(0),
+    mNeedsConversion(false),
+#endif
 #ifdef QCOM_HARDWARE
     mS3DFormat(0),
 #endif
@@ -160,11 +164,30 @@ SurfaceTexture::SurfaceTexture(GLuint tex, bool allowSynchronousMode,
     mNextBufferInfo.height = 0;
     mNextBufferInfo.format = 0;
 #endif
+#ifdef STE_HARDWARE
+
+    for (int i = 0; i < NUM_BLIT_BUFFER_SLOTS; i++) {
+        mBlitSlots[i].mEglImage = EGL_NO_IMAGE_KHR;
+        mBlitSlots[i].mEglDisplay = EGL_NO_DISPLAY;
+    }
+
+    hw_module_t const* module;
+    mBlitEngine = 0;
+    if (hw_get_module(COPYBIT_HARDWARE_MODULE_ID, &module) == 0) {
+        copybit_open(module, &mBlitEngine);
+    }
+    LOGE_IF(!mBlitEngine, "\nCannot open copybit mBlitEngine=%p", mBlitEngine);
+#endif
 }
 
 SurfaceTexture::~SurfaceTexture() {
     ST_LOGV("~SurfaceTexture");
     freeAllBuffersLocked();
+#ifdef STE_HARDWARE
+    if (mBlitEngine) {
+        copybit_close(mBlitEngine);
+    }
+#endif
 }
 
 status_t SurfaceTexture::setBufferCountServerLocked(int bufferCount) {
@@ -482,6 +505,7 @@ status_t SurfaceTexture::dequeueBuffer(int *outBuf, uint32_t w, uint32_t h,
         mSlots[buf].mBufferState = BufferSlot::DEQUEUED;
 
         const sp<GraphicBuffer>& buffer(mSlots[buf].mGraphicBuffer);
+#ifndef STE_HARDWARE
 #ifdef QCOM_HARDWARE
 	qBufGeometry currentGeometry;
 	if (buffer != NULL)
@@ -511,6 +535,14 @@ status_t SurfaceTexture::dequeueBuffer(int *outBuf, uint32_t w, uint32_t h,
                 mGraphicBufferAlloc->freeGraphicBufferAtIndex(buf);
             }
 #endif
+#else
+        if ((buffer == NULL) ||
+            (uint32_t(buffer->width)  != w) ||
+            (uint32_t(buffer->height) != h) ||
+            (uint32_t(buffer->format) != format) ||
+            ((uint32_t(buffer->usage) & usage) != usage))
+        {
+#endif
             usage |= GraphicBuffer::USAGE_HW_TEXTURE;
             status_t error;
             sp<GraphicBuffer> graphicBuffer(
@@ -849,7 +881,16 @@ status_t SurfaceTexture::setScalingMode(int mode) {
     return OK;
 }
 
+#ifndef STE_HARDWARE
 status_t SurfaceTexture::updateTexImage(bool isComposition) {
+#else
+status_t SurfaceTexture::updateTexImage() {
+    return updateTexImage(false);
+}
+
+#define STE_DEFERDBG 0
+status_t SurfaceTexture::updateTexImage(bool deferConversion) {
+#endif
     ST_LOGV("updateTexImage");
     Mutex::Autolock lock(mMutex);
 
@@ -865,6 +906,7 @@ status_t SurfaceTexture::updateTexImage(bool isComposition) {
         int buf = *front;
 
         // Update the GL texture object.
+#ifndef STE_HARDWARE
         EGLImageKHR image = mSlots[buf].mEglImage;
         EGLDisplay dpy = eglGetCurrentDisplay();
 #ifdef QCOM_HARDWARE
@@ -894,6 +936,101 @@ status_t SurfaceTexture::updateTexImage(bool isComposition) {
                 // NOTE: if dpy was invalid, createImage() is guaranteed to
                 // fail. so we'd end up here.
                 return -EINVAL;
+#else
+        EGLImageKHR image;
+        EGLDisplay dpy = eglGetCurrentDisplay();
+        sp<GraphicBuffer> graphicBuffer;
+        if (conversionIsNeeded(mSlots[buf].mGraphicBuffer)) {
+            mNeedsConversion = deferConversion;
+            // If color conversion is needed we can't use the graphic buffers
+            // located in mSlots for the textures (wrong color format). Instead
+            // color convert it into a buffer in mBlitSlots and use that instead.
+            image = mBlitSlots[mNextBlitSlot].mEglImage;
+
+            // If there exists an image already, make sure that
+            // the dimensions match the current source buffer.
+            // Otherwise, destroy the buffer and let a new one be allocated.
+            if (image != EGL_NO_IMAGE_KHR &&
+                    mSlots[buf].mGraphicBuffer != NULL &&
+                    mBlitSlots[mNextBlitSlot].mGraphicBuffer != NULL) {
+                sp<GraphicBuffer> &srcBuf = mSlots[buf].mGraphicBuffer;
+                sp<GraphicBuffer> &bltBuf =
+                    mBlitSlots[mNextBlitSlot].mGraphicBuffer;
+                if (srcBuf->getWidth() != bltBuf->getWidth() ||
+                        srcBuf->getHeight() != bltBuf->getHeight()) {
+                    eglDestroyImageKHR(mBlitSlots[mNextBlitSlot].mEglDisplay,
+                        image);
+                    mBlitSlots[mNextBlitSlot].mEglImage = EGL_NO_IMAGE_KHR;
+                    mBlitSlots[mNextBlitSlot].mGraphicBuffer = NULL;
+                    image = EGL_NO_IMAGE_KHR;
+                }
+            }
+            if (image == EGL_NO_IMAGE_KHR) {
+                sp<GraphicBuffer> &srcBuf = mSlots[buf].mGraphicBuffer;
+                status_t res = 0;
+
+                sp<GraphicBuffer> blitBuffer(
+                        mGraphicBufferAlloc->createGraphicBuffer(
+                                srcBuf->getWidth(), srcBuf->getHeight(),
+                                PIXEL_FORMAT_RGBA_8888, srcBuf->getUsage(),
+                                &res));
+                if (blitBuffer == 0) {
+                    ST_LOGE("updateTexImage: SurfaceComposer::createGraphicBuffer failed");
+                    return NO_MEMORY;
+                }
+                if (res != NO_ERROR) {
+                    ST_LOGW("updateTexImage: SurfaceComposer::createGraphicBuffer error=%#04x", res);
+                }
+                mBlitSlots[mNextBlitSlot].mGraphicBuffer = blitBuffer;
+
+                EGLDisplay dpy = eglGetCurrentDisplay();
+                image = createImage(dpy, blitBuffer);
+                mBlitSlots[mNextBlitSlot].mEglImage = image;
+                mBlitSlots[mNextBlitSlot].mEglDisplay = dpy;
+            }
+
+            if (deferConversion) {
+                graphicBuffer = mSlots[buf].mGraphicBuffer;
+                mConversionSrcSlot = buf;
+                mConversionBltSlot = mNextBlitSlot;
+                // At this point graphicBuffer and image do not point
+                // at matching buffers. This is intentional as this
+                // surface might end up being taken care of by HWComposer,
+                // which needs access to the original buffer.
+                // GL however, is fed an EGLImage that is created from
+                // a conversion buffer. It will have its
+                // content updated once the surface is actually drawn
+                // in Layer::onDraw()
+            } else {
+                if (convert(mSlots[buf].mGraphicBuffer,
+                        mBlitSlots[mNextBlitSlot].mGraphicBuffer) != OK) {
+                    LOGE("updateTexImage: convert failed");
+                    return UNKNOWN_ERROR;
+                }
+                graphicBuffer = mBlitSlots[mNextBlitSlot].mGraphicBuffer;
+            }
+            // mBlitSlots contains several buffers (NUM_BLIT_BUFFER_SLOTS),
+            // advance (potentially wrap) the index
+            mNextBlitSlot = (mNextBlitSlot + 1) % NUM_BLIT_BUFFER_SLOTS;
+        } else {
+            mNeedsConversion = false;
+            image = mSlots[buf].mEglImage;
+            graphicBuffer = mSlots[buf].mGraphicBuffer;
+            if (image == EGL_NO_IMAGE_KHR) {
+                EGLDisplay dpy = eglGetCurrentDisplay();
+                if (graphicBuffer == 0) {
+                    ST_LOGE("buffer at slot %d is null", buf);
+                    return BAD_VALUE;
+                }
+                image = createImage(dpy, graphicBuffer);
+                mSlots[buf].mEglImage = image;
+                mSlots[buf].mEglDisplay = dpy;
+                if (image == EGL_NO_IMAGE_KHR) {
+                    // NOTE: if dpy was invalid, createImage() is guaranteed to
+                    // fail. so we'd end up here.
+                    return -EINVAL;
+                }
+#endif
             }
         }
 
@@ -947,7 +1084,11 @@ status_t SurfaceTexture::updateTexImage(bool isComposition) {
 
         // Update the SurfaceTexture state.
         mCurrentTexture = buf;
+#ifndef STE_HARDWARE
         mCurrentTextureBuf = mSlots[buf].mGraphicBuffer;
+#else
+        mCurrentTextureBuf = graphicBuffer;
+#endif
         mCurrentCrop = mSlots[buf].mCrop;
         mCurrentTransform = mSlots[buf].mTransform;
         mCurrentScalingMode = mSlots[buf].mScalingMode;
@@ -973,8 +1114,18 @@ bool SurfaceTexture::isExternalFormat(uint32_t format)
     case HAL_PIXEL_FORMAT_YV12:
     // Legacy/deprecated YUV formats
     case HAL_PIXEL_FORMAT_YCbCr_422_SP:
+#ifndef STE_HARDWARE
     case HAL_PIXEL_FORMAT_YCrCb_420_SP:
+#else
+    case HAL_PIXEL_FORMAT_YCbCr_420_SP:
+#endif
     case HAL_PIXEL_FORMAT_YCbCr_422_I:
+#ifdef STE_HARDWARE
+    case HAL_PIXEL_FORMAT_YCrCb_422_SP:
+    case HAL_PIXEL_FORMAT_YCrCb_422_P:
+    case HAL_PIXEL_FORMAT_YCrCb_420_SP:
+    case HAL_PIXEL_FORMAT_YCrCb_420_P:
+#endif
         return true;
     }
 
@@ -1119,6 +1270,16 @@ void SurfaceTexture::freeAllBuffersLocked() {
 #ifdef QCOM_HARDWARE
     mGraphicBufferAlloc->freeAllGraphicBuffersExcept(-1);
 #endif
+#ifdef STE_HARDWARE
+    for (int i = 0; i < NUM_BLIT_BUFFER_SLOTS; i++) {
+        mBlitSlots[i].mGraphicBuffer = 0;
+        if (mBlitSlots[i].mEglImage != EGL_NO_IMAGE_KHR) {
+            eglDestroyImageKHR(mBlitSlots[i].mEglDisplay, mBlitSlots[i].mEglImage);
+            mBlitSlots[i].mEglImage = EGL_NO_IMAGE_KHR;
+            mBlitSlots[i].mEglDisplay = EGL_NO_DISPLAY;
+        }
+    }
+#endif
 }
 
 void SurfaceTexture::freeAllBuffersExceptHeadLocked() {
@@ -1331,6 +1492,84 @@ void SurfaceTexture::dump(String8& result, const char* prefix,
     }
 }
 
+#ifdef STE_HARDWARE
+bool SurfaceTexture::conversionIsNeeded(const sp<GraphicBuffer>& graphicBuffer) {
+    int fmt = graphicBuffer->getPixelFormat();
+    return (fmt == PIXEL_FORMAT_YCBCR42XMBN) || (fmt == PIXEL_FORMAT_YCbCr_420_P);
+}
+
+status_t SurfaceTexture::convert() {
+    if (!mNeedsConversion)
+        return NO_ERROR;
+
+    if (mConversionBltSlot < 0 ||
+            mConversionBltSlot >= NUM_BLIT_BUFFER_SLOTS ||
+            mConversionSrcSlot < 0 ||
+            mConversionSrcSlot >= NUM_BUFFER_SLOTS) {
+        LOGE_IF(STE_DEFERDBG, "%s: Incorrect setup for deferred "
+            "texture conversion:\n"
+            "mConversionSrcSlot=%d mConversionBltSlot=%d", __FUNCTION__,
+            mConversionSrcSlot, mConversionBltSlot);
+        return BAD_VALUE;
+    }
+
+    if (mSlots[mConversionSrcSlot].mGraphicBuffer == NULL) {
+        LOGI_IF(STE_DEFERDBG, "%s: NULL source for deferred texture conversion.",
+            __FUNCTION__);
+        return OK;
+    }
+
+    if (mBlitSlots[mConversionBltSlot].mGraphicBuffer == NULL) {
+        LOGI_IF(STE_DEFERDBG, "%s: NULL destination for deferred "
+            "texture conversion.", __FUNCTION__);
+        return OK;
+    }
+
+    return convert(mSlots[mConversionSrcSlot].mGraphicBuffer,
+        mBlitSlots[mConversionBltSlot].mGraphicBuffer);
+}
+
+status_t SurfaceTexture::convert(sp<GraphicBuffer> &srcBuf, sp<GraphicBuffer> &dstBuf) {
+    copybit_image_t dstImg;
+    dstImg.w = dstBuf->getWidth();
+    dstImg.h = dstBuf->getHeight();
+    dstImg.format = dstBuf->getPixelFormat();
+    dstImg.handle = (native_handle_t*) dstBuf->getNativeBuffer()->handle;
+
+    copybit_image_t srcImg;
+    srcImg.w = srcBuf->getWidth();
+    srcImg.h = srcBuf->getHeight();
+    srcImg.format = srcBuf->getPixelFormat();
+    srcImg.base = NULL;
+    srcImg.handle = (native_handle_t*) srcBuf->getNativeBuffer()->handle;
+
+    copybit_rect_t dstCrop;
+    dstCrop.l = 0;
+    dstCrop.t = 0;
+    dstCrop.r = dstBuf->getWidth();
+    dstCrop.b = dstBuf->getHeight();
+
+    copybit_rect_t srcCrop;
+    srcCrop.l = 0;
+    srcCrop.t = 0;
+    srcCrop.r = srcBuf->getWidth();
+    srcCrop.b = srcBuf->getHeight();
+
+    region_iterator clip(Region(Rect(dstCrop.r, dstCrop.b)));
+    mBlitEngine->set_parameter(mBlitEngine, COPYBIT_TRANSFORM, 0);
+    mBlitEngine->set_parameter(mBlitEngine, COPYBIT_PLANE_ALPHA, 0xFF);
+    mBlitEngine->set_parameter(mBlitEngine, COPYBIT_DITHER, COPYBIT_ENABLE);
+
+    int err = mBlitEngine->stretch(
+            mBlitEngine, &dstImg, &srcImg, &dstCrop, &srcCrop, &clip);
+    if (err != 0) {
+        LOGE("\nError: Blit stretch operation failed (err:%d)\n", err);
+        return UNKNOWN_ERROR;
+    }
+    return OK;
+}
+#endif
+
 static void mtxMul(float out[16], const float a[16], const float b[16]) {
     out[0] = a[0]*b[0] + a[4]*b[1] + a[8]*b[2] + a[12]*b[3];
     out[1] = a[1]*b[0] + a[5]*b[1] + a[9]*b[2] + a[13]*b[3];
diff --git a/libs/ui/PixelFormat.cpp b/libs/ui/PixelFormat.cpp
index ee186c8..b34cd91 100644
--- a/libs/ui/PixelFormat.cpp
+++ b/libs/ui/PixelFormat.cpp
@@ -59,11 +59,29 @@ status_t getPixelFormatInfo(PixelFormat format, PixelFormatInfo* info)
     // YUV format from the HAL are handled here
     switch (format) {
     case HAL_PIXEL_FORMAT_YCbCr_422_SP:
+#ifdef STE_HARDWARE
+    case HAL_PIXEL_FORMAT_YCrCb_422_SP:
+    case HAL_PIXEL_FORMAT_YCbCr_422_P:
+#endif
     case HAL_PIXEL_FORMAT_YCbCr_422_I:
+#ifdef STE_HARDWARE
+    case HAL_PIXEL_FORMAT_CbYCrY_422_I:
+#endif
         info->bitsPerPixel = 16;
         goto done;
+#ifdef STE_HARDWARE
+    case HAL_PIXEL_FORMAT_YCbCr_420_SP:
+#endif
     case HAL_PIXEL_FORMAT_YCrCb_420_SP:
     case HAL_PIXEL_FORMAT_YV12:
+#ifdef STE_HARDWARE
+    case HAL_PIXEL_FORMAT_YCbCr_420_SP_TILED:
+    case HAL_PIXEL_FORMAT_YCrCb_420_SP_TILED:
+    case HAL_PIXEL_FORMAT_YCbCr_420_P:
+    case HAL_PIXEL_FORMAT_YCbCr_420_I:
+    case HAL_PIXEL_FORMAT_CbYCrY_420_I:
+    case HAL_PIXEL_FORMAT_YCBCR42XMBN:
+#endif
         info->bitsPerPixel = 12;
      done:
         info->format = format;
diff --git a/media/java/android/media/MediaPlayer.java b/media/java/android/media/MediaPlayer.java
index 8d71dcf..b8ed9ed 100644
--- a/media/java/android/media/MediaPlayer.java
+++ b/media/java/android/media/MediaPlayer.java
@@ -808,7 +808,8 @@ public class MediaPlayer
     }
 
     /**
-     * Sets the data source (file-path or http/rtsp URL) to use.
+     * Sets the data source (file-path or http/rtsp URL) to use. To select FM Radio as the data
+     * source, set the path to "fmradio://rx".
      *
      * @param path the path of the file, or the http/rtsp URL of the stream you want to play
      * @throws IllegalStateException if it is called in an invalid state
diff --git a/media/java/android/media/MediaRecorder.java b/media/java/android/media/MediaRecorder.java
index 9dda80e..945bbb0 100644
--- a/media/java/android/media/MediaRecorder.java
+++ b/media/java/android/media/MediaRecorder.java
@@ -175,6 +175,9 @@ public class MediaRecorder
          *  is applied.
          */
         public static final int VOICE_COMMUNICATION = 7;
+        /** FM Radio Rx audio source */
+        /**@hide */
+        public static final int FM_RADIO_RX = 8;
     }
 
     /**
diff --git a/media/libmedia/AudioParameter.cpp b/media/libmedia/AudioParameter.cpp
index 59ccfd0..60046e4 100644
--- a/media/libmedia/AudioParameter.cpp
+++ b/media/libmedia/AudioParameter.cpp
@@ -29,6 +29,9 @@ const char *AudioParameter::keyFormat = "format";
 const char *AudioParameter::keyChannels = "channels";
 const char *AudioParameter::keyFrameCount = "frame_count";
 const char *AudioParameter::keyInputSource = "input_source";
+#ifdef STE_HARDWARE
+const char *AudioParameter::keyLatency = "latency";
+#endif
 
 AudioParameter::AudioParameter(const String8& keyValuePairs)
 {
diff --git a/media/libmedia/AudioRecord.cpp b/media/libmedia/AudioRecord.cpp
index de3e6af..be64635 100644
--- a/media/libmedia/AudioRecord.cpp
+++ b/media/libmedia/AudioRecord.cpp
@@ -81,7 +81,17 @@ status_t AudioRecord::getMinFrameCount(
 
 AudioRecord::AudioRecord()
     : mStatus(NO_INIT), mSessionId(0)
+#ifdef STE_AUDIO
+      , mpInputClientId(NULL)
+#endif
 {
+#ifdef STE_AUDIO
+    const sp<IAudioFlinger>& audioFlinger = AudioSystem::get_audio_flinger();
+    if (audioFlinger != 0) {
+        mpInputClientId = (audio_input_clients*)audioFlinger->addInputClient(
+                                                 (uint32_t)AUDIO_INPUT_CLIENT_RECORD);
+    }
+#endif
 }
 
 AudioRecord::AudioRecord(
@@ -96,7 +106,18 @@ AudioRecord::AudioRecord(
         int notificationFrames,
         int sessionId)
     : mStatus(NO_INIT), mSessionId(0)
+#ifdef STE_AUDIO
+      , mpInputClientId(NULL)
+#endif
 {
+#ifdef STE_AUDIO
+    const sp<IAudioFlinger>& audioFlinger = AudioSystem::get_audio_flinger();
+    if (audioFlinger != 0) {
+        mpInputClientId = (audio_input_clients*)audioFlinger->addInputClient(
+                                                 (uint32_t)AUDIO_INPUT_CLIENT_RECORD);
+    }
+#endif
+
     mStatus = set(inputSource, sampleRate, format, channelMask,
             frameCount, flags, cbf, user, notificationFrames, sessionId);
 }
@@ -148,6 +169,12 @@ AudioRecord::~AudioRecord()
         IPCThreadState::self()->flushCommands();
         AudioSystem::releaseAudioSessionId(mSessionId);
     }
+#ifdef STE_AUDIO
+    const sp<IAudioFlinger>& audioFlinger = AudioSystem::get_audio_flinger();
+    if (audioFlinger != 0) {
+        audioFlinger->removeInputClient((uint32_t*)mpInputClientId);
+    }
+#endif
 }
 
 status_t AudioRecord::set(
@@ -207,7 +234,12 @@ status_t AudioRecord::set(
                                                     format,
                                                     channelMask,
                                                     (audio_in_acoustics_t)flags,
+#ifdef STE_AUDIO
+                                                    mSessionId,
+                                                    mpInputClientId);
+#else
                                                     mSessionId);
+#endif
     if (input == 0) {
         LOGE("Could not get audio input for record source %d", inputSource);
         return BAD_VALUE;
diff --git a/media/libmedia/AudioSystem.cpp b/media/libmedia/AudioSystem.cpp
index 8a77d4d..dc4ad4d 100644
--- a/media/libmedia/AudioSystem.cpp
+++ b/media/libmedia/AudioSystem.cpp
@@ -45,6 +45,13 @@ int AudioSystem::gPrevInChannelCount = 1;
 size_t AudioSystem::gInBuffSize = 0;
 
 
+#ifdef STE_HARDWARE
+// Clients for receiving latency update notifications
+Mutex AudioSystem::gLatencyLock;
+int AudioSystem::gNextUniqueLatencyId = 0;
+DefaultKeyedVector<int, sp<AudioSystem::NotificationClient> > AudioSystem::gLatencyNotificationClients(0);
+#endif
+
 // establish binder interface to AudioFlinger service
 const sp<IAudioFlinger>& AudioSystem::get_audio_flinger()
 {
@@ -370,9 +377,32 @@ void AudioSystem::releaseAudioSessionId(int audioSession) {
     }
 }
 
+#ifdef STE_HARDWARE
+int AudioSystem::registerLatencyNotificationClient(latency_update_callback cb, void *cookie) {
+    Mutex::Autolock _l(gLatencyLock);
+
+    sp<NotificationClient> notificationClient = new NotificationClient();
+    notificationClient->mCb = cb;
+    notificationClient->mCookie = cookie;
+
+    gNextUniqueLatencyId++;
+    gLatencyNotificationClients.add(gNextUniqueLatencyId, notificationClient);
+    return gNextUniqueLatencyId;
+}
+
+void AudioSystem::unregisterLatencyNotificationClient(int clientId) {
+    Mutex::Autolock _l(gLatencyLock);
+    gLatencyNotificationClients.removeItem(clientId);
+}
 // ---------------------------------------------------------------------------
+#endif
 
 void AudioSystem::AudioFlingerClient::binderDied(const wp<IBinder>& who) {
+#ifdef STE_HARDWARE
+    gLatencyLock.lock();
+    AudioSystem::gLatencyNotificationClients.clear();
+    gLatencyLock.unlock();
+#endif
     Mutex::Autolock _l(AudioSystem::gLock);
 
     AudioSystem::gAudioFlinger.clear();
@@ -445,9 +475,27 @@ void AudioSystem::AudioFlingerClient::ioConfigChanged(int event, int ioHandle, v
                 ioHandle, desc->samplingRate, desc->format,
                 desc->channels, desc->frameCount, desc->latency);
         OutputDescriptor *outputDesc = gOutputs.valueAt(index);
+#ifdef STE_HARDWARE
+        uint32_t oldLatency = outputDesc->latency;
+#endif
         delete outputDesc;
         outputDesc =  new OutputDescriptor(*desc);
         gOutputs.replaceValueFor(ioHandle, outputDesc);
+#ifdef STE_HARDWARE
+        if (oldLatency == outputDesc->latency) {
+            break;
+        }
+        uint32_t newLatency = outputDesc->latency;
+        gLock.unlock();
+        gLatencyLock.lock();
+        size_t size = gLatencyNotificationClients.size();
+        for (size_t i = 0; i < size; i++) {
+            sp<NotificationClient> client = gLatencyNotificationClients.valueAt(i);
+            (*client->mCb)(client->mCookie, ioHandle, newLatency);
+        }
+        gLatencyLock.unlock();
+        gLock.lock();
+#endif
     } break;
     case INPUT_OPENED:
     case INPUT_CLOSED:
@@ -670,11 +718,20 @@ audio_io_handle_t AudioSystem::getInput(int inputSource,
                                     uint32_t format,
                                     uint32_t channels,
                                     audio_in_acoustics_t acoustics,
+#ifdef STE_AUDIO
+                                    int sessionId,
+                                    audio_input_clients *inputClientId)
+#else
                                     int sessionId)
+#endif
 {
     const sp<IAudioPolicyService>& aps = AudioSystem::get_audio_policy_service();
     if (aps == 0) return 0;
+#ifdef STE_AUDIO
+    return aps->getInput(inputSource, samplingRate, format, channels, acoustics, sessionId, inputClientId);
+#else
     return aps->getInput(inputSource, samplingRate, format, channels, acoustics, sessionId);
+#endif
 }
 
 status_t AudioSystem::startInput(audio_io_handle_t input)
diff --git a/media/libmedia/AudioTrack.cpp b/media/libmedia/AudioTrack.cpp
index a9ab982..938aea8 100644
--- a/media/libmedia/AudioTrack.cpp
+++ b/media/libmedia/AudioTrack.cpp
@@ -78,7 +78,6 @@ status_t AudioTrack::getMinFrameCount(
     if (AudioSystem::getOutputLatency(&afLatency, streamType) != NO_ERROR) {
         return NO_INIT;
     }
-
     // Ensure that buffer depth covers at least audio hardware latency
     uint32_t minBufCount = afLatency / ((1000 * afFrameCount) / afSampleRate);
     if (minBufCount < 2) minBufCount = 2;
@@ -215,6 +214,9 @@ AudioTrack::~AudioTrack()
         AudioSystem::releaseAudioSessionId(mSessionId);
 #endif
     }
+#ifdef STE_HARDWARE
+    AudioSystem::unregisterLatencyNotificationClient(mLatencyClientId);
+#endif
 }
 
 status_t AudioTrack::set(
@@ -345,6 +347,10 @@ status_t AudioTrack::set(
 #endif
     AudioSystem::acquireAudioSessionId(mSessionId);
     mRestoreStatus = NO_ERROR;
+#ifdef STE_HARDWARE
+    mLatencyClientId = AudioSystem::registerLatencyNotificationClient(
+                                    &AudioTrack::LatencyCallbackWrapper, this);
+#endif
     return NO_ERROR;
 }
 
@@ -1479,6 +1485,30 @@ status_t AudioTrack::dump(int fd, const Vector<String16>& args) const
     return NO_ERROR;
 }
 
+#ifdef STE_HARDWARE
+// static
+void AudioTrack::LatencyCallbackWrapper(void *cookie, audio_io_handle_t output, uint32_t latency)
+{
+    static_cast<AudioTrack *>(cookie)->latencyCallback(output, latency);
+}
+
+void AudioTrack::latencyCallback(audio_io_handle_t output, uint32_t latency)
+{
+    audio_io_handle_t myOutput = getOutput();
+    if (output != myOutput) {
+        return;
+    }
+
+    uint32_t oldLatency = mLatency;
+    mLatency = latency + (1000*mCblk->frameCount) / mCblk->sampleRate;
+    LOGV("new latency for output %d (old latency %d, new latency %d)", output, oldLatency, mLatency);
+
+    if (mCbf != NULL) {
+        mCbf(EVENT_LATENCY_CHANGED, mUserData, &mLatency);
+    }
+}
+#endif
+
 // =========================================================================
 
 AudioTrack::AudioTrackThread::AudioTrackThread(AudioTrack& receiver, bool bCanCallJava)
diff --git a/media/libmedia/IAudioFlinger.cpp b/media/libmedia/IAudioFlinger.cpp
index 9aa0d65..fd4c66c 100644
--- a/media/libmedia/IAudioFlinger.cpp
+++ b/media/libmedia/IAudioFlinger.cpp
@@ -67,6 +67,10 @@ enum {
 #endif
     SUSPEND_OUTPUT,
     RESTORE_OUTPUT,
+#ifdef STE_AUDIO
+    ADD_INPUT_CLIENT,
+    REMOVE_INPUT_CLIENT,
+#endif
     OPEN_INPUT,
     CLOSE_INPUT,
     SET_STREAM_OUTPUT,
@@ -81,6 +85,9 @@ enum {
     GET_EFFECT_DESCRIPTOR,
     CREATE_EFFECT,
     MOVE_EFFECTS,
+#ifdef STE_AUDIO
+    READ_INPUT,
+#endif
 #ifdef WITH_QCOM_LPA
     SET_FM_VOLUME,
     CREATE_SESSION,
@@ -567,11 +574,35 @@ public:
         return reply.readInt32();
     }
 
+#ifdef STE_AUDIO
+    virtual uint32_t *addInputClient(uint32_t clientId)
+    {
+        Parcel data, reply;
+        data.writeInterfaceToken(IAudioFlinger::getInterfaceDescriptor());
+        data.writeInt32(clientId);
+        remote()->transact(ADD_INPUT_CLIENT, data, &reply);
+        return (uint32_t*) reply.readIntPtr();
+    }
+
+    virtual status_t removeInputClient(uint32_t *pClientId)
+    {
+        Parcel data, reply;
+        data.writeInterfaceToken(IAudioFlinger::getInterfaceDescriptor());
+        data.writeIntPtr((intptr_t)pClientId);
+        remote()->transact(REMOVE_INPUT_CLIENT, data, &reply);
+        return reply.readInt32();
+    }
+#endif
     virtual int openInput(uint32_t *pDevices,
                             uint32_t *pSamplingRate,
                             uint32_t *pFormat,
                             uint32_t *pChannels,
+#ifdef STE_AUDIO
+                            uint32_t acoustics,
+                            uint32_t *pInputClientId)
+#else
                             uint32_t acoustics)
+#endif
     {
         Parcel data, reply;
         uint32_t devices = pDevices ? *pDevices : 0;
@@ -585,6 +616,9 @@ public:
         data.writeInt32(format);
         data.writeInt32(channels);
         data.writeInt32(acoustics);
+#ifdef STE_AUDIO
+        data.writeIntPtr((intptr_t)pInputClientId);
+#endif
         remote()->transact(OPEN_INPUT, data, &reply);
         int input = reply.readInt32();
         devices = reply.readInt32();
@@ -598,6 +632,17 @@ public:
         return input;
     }
 
+#ifdef STE_AUDIO
+    virtual status_t closeInput(int input, uint32_t *inputClientId)
+    {
+        Parcel data, reply;
+        data.writeInterfaceToken(IAudioFlinger::getInterfaceDescriptor());
+        data.writeInt32(input);
+        data.writeIntPtr((intptr_t) inputClientId);
+        remote()->transact(CLOSE_INPUT, data, &reply);
+        return reply.readInt32();
+    }
+#else
     virtual status_t closeInput(int input)
     {
         Parcel data, reply;
@@ -606,7 +651,7 @@ public:
         remote()->transact(CLOSE_INPUT, data, &reply);
         return reply.readInt32();
     }
-
+#endif
     virtual status_t setStreamOutput(uint32_t stream, int output)
     {
         Parcel data, reply;
@@ -655,6 +700,20 @@ public:
         return reply.readInt32();
     }
 
+#ifdef STE_AUDIO
+    virtual size_t readInput(uint32_t *input, uint32_t inputClientId, void *buffer, uint32_t bytes, uint32_t *pOverwrittenBytes)
+    {
+        Parcel data, reply;
+        data.writeInterfaceToken(IAudioFlinger::getInterfaceDescriptor());
+        data.writeIntPtr((intptr_t) input);
+        data.writeInt32(inputClientId);
+        data.writeIntPtr((intptr_t) buffer);
+        data.writeInt32(bytes);
+        data.writeIntPtr((intptr_t) pOverwrittenBytes);
+        remote()->transact(READ_INPUT, data, &reply);
+        return reply.readInt32();
+    }
+#endif
     virtual int newAudioSessionId()
     {
         Parcel data, reply;
@@ -1092,6 +1151,20 @@ status_t BnAudioFlinger::onTransact(
             reply->writeInt32(restoreOutput(data.readInt32()));
             return NO_ERROR;
         } break;
+#ifdef STE_AUDIO
+        case ADD_INPUT_CLIENT: {
+            CHECK_INTERFACE(IAudioFlinger, data, reply);
+            uint32_t clientId = data.readInt32();
+            reply->writeIntPtr((intptr_t)addInputClient(clientId));
+            return NO_ERROR;
+        } break;
+        case REMOVE_INPUT_CLIENT: {
+            CHECK_INTERFACE(IAudioFlinger, data, reply);
+            uint32_t *pClientId = (uint32_t*) data.readIntPtr();
+            reply->writeInt32(removeInputClient(pClientId));
+            return NO_ERROR;
+        } break;
+#endif
         case OPEN_INPUT: {
             CHECK_INTERFACE(IAudioFlinger, data, reply);
             uint32_t devices = data.readInt32();
@@ -1099,12 +1172,19 @@ status_t BnAudioFlinger::onTransact(
             uint32_t format = data.readInt32();
             uint32_t channels = data.readInt32();
             uint32_t acoutics = data.readInt32();
-
+#ifdef STE_AUDIO
+            uint32_t *inputClientId = (uint32_t*) data.readIntPtr();
+#endif
             int input = openInput(&devices,
                                      &samplingRate,
                                      &format,
                                      &channels,
+#ifdef STE_AUDIO
+                                     acoutics,
+                                     inputClientId);
+#else
                                      acoutics);
+#endif
             reply->writeInt32(input);
             reply->writeInt32(devices);
             reply->writeInt32(samplingRate);
@@ -1114,7 +1194,13 @@ status_t BnAudioFlinger::onTransact(
         } break;
         case CLOSE_INPUT: {
             CHECK_INTERFACE(IAudioFlinger, data, reply);
+#ifdef STE_AUDIO
+            uint32_t input = data.readInt32();
+            uint32_t *inputClientId = (uint32_t*) data.readIntPtr();
+            reply->writeInt32(closeInput(input, inputClientId));
+#else
             reply->writeInt32(closeInput(data.readInt32()));
+#endif
             return NO_ERROR;
         } break;
         case SET_STREAM_OUTPUT: {
@@ -1227,6 +1313,18 @@ status_t BnAudioFlinger::onTransact(
             reply->writeInt32(moveEffects(session, srcOutput, dstOutput));
             return NO_ERROR;
         } break;
+#ifdef STE_AUDIO
+        case READ_INPUT: {
+            CHECK_INTERFACE(IAudioFlinger, data, reply);
+            uint32_t* input = (uint32_t*) data.readIntPtr();
+            uint32_t inputClientId = data.readInt32();
+            void* buffer = (void*) data.readIntPtr();
+            uint32_t bytes = data.readInt32();
+            uint32_t *pOverwrittenBytes = (uint32_t*) data.readIntPtr();
+            reply->writeInt32(readInput(input, inputClientId, buffer, bytes, pOverwrittenBytes));
+            return NO_ERROR;
+        } break;
+#endif
         default:
             return BBinder::onTransact(code, data, reply, flags);
     }
diff --git a/media/libmedia/IAudioPolicyService.cpp b/media/libmedia/IAudioPolicyService.cpp
index 8aa8771..bbb041a 100644
--- a/media/libmedia/IAudioPolicyService.cpp
+++ b/media/libmedia/IAudioPolicyService.cpp
@@ -238,7 +238,12 @@ public:
                                     uint32_t format,
                                     uint32_t channels,
                                     audio_in_acoustics_t acoustics,
+#ifdef STE_AUDIO
+                                    int audioSession,
+                                    audio_input_clients *inputClientId)
+#else
                                     int audioSession)
+#endif
     {
         Parcel data, reply;
         data.writeInterfaceToken(IAudioPolicyService::getInterfaceDescriptor());
@@ -247,6 +252,9 @@ public:
         data.writeInt32(static_cast <uint32_t>(format));
         data.writeInt32(channels);
         data.writeInt32(static_cast <uint32_t>(acoustics));
+#ifdef STE_AUDIO
+        data.writeIntPtr((intptr_t)inputClientId);
+#endif
         data.writeInt32(audioSession);
         remote()->transact(GET_INPUT, data, &reply);
         return static_cast <audio_io_handle_t> (reply.readInt32());
@@ -569,13 +577,22 @@ status_t BnAudioPolicyService::onTransact(
             uint32_t channels = data.readInt32();
             audio_in_acoustics_t acoustics =
                     static_cast <audio_in_acoustics_t>(data.readInt32());
+#ifdef STE_AUDIO
+            audio_input_clients *inputClientId =
+                    (audio_input_clients*) data.readIntPtr();
+#endif
             int audioSession = data.readInt32();
             audio_io_handle_t input = getInput(inputSource,
                                                samplingRate,
                                                format,
                                                channels,
                                                acoustics,
+#ifdef STE_AUDIO
+                                               audioSession,
+                                               inputClientId);
+#else
                                                audioSession);
+#endif
             reply->writeInt32(static_cast <int>(input));
             return NO_ERROR;
         } break;
diff --git a/media/libmediaplayerservice/MediaPlayerService.cpp b/media/libmediaplayerservice/MediaPlayerService.cpp
index 2888888..17216d0 100644
--- a/media/libmediaplayerservice/MediaPlayerService.cpp
+++ b/media/libmediaplayerservice/MediaPlayerService.cpp
@@ -321,7 +321,11 @@ status_t MediaPlayerService::AudioOutput::dump(int fd, const Vector<String16>& a
             mStreamType, mLeftVolume, mRightVolume);
     result.append(buffer);
     snprintf(buffer, 255, "  msec per frame(%f), latency (%d)\n",
+#ifdef STE_HARDWARE
+            mMsecsPerFrame, mLatency);
+#else
             mMsecsPerFrame, (mTrack != 0) ? mTrack->latency() : -1);
+#endif
     result.append(buffer);
     snprintf(buffer, 255, "  aux effect id(%d), send level (%f)\n",
             mAuxEffectId, mSendLevel);
@@ -1269,6 +1273,9 @@ MediaPlayerService::AudioOutput::AudioOutput(int sessionId)
     mStreamType = AUDIO_STREAM_MUSIC;
     mLeftVolume = 1.0;
     mRightVolume = 1.0;
+#ifdef STE_HARDWARE
+    mLatency = 0;
+#endif
     mMsecsPerFrame = 0;
     mAuxEffectId = 0;
     mSendLevel = 0.0;
@@ -1330,8 +1337,12 @@ ssize_t MediaPlayerService::AudioOutput::frameSize() const
 
 uint32_t MediaPlayerService::AudioOutput::latency () const
 {
+#ifdef STE_HARDWARE
+    return mLatency;
+#else
     if (mTrack == 0) return 0;
     return mTrack->latency();
+#endif
 }
 
 float MediaPlayerService::AudioOutput::msecsPerFrame() const
@@ -1380,10 +1391,17 @@ status_t MediaPlayerService::AudioOutput::openSession(
 
 status_t MediaPlayerService::AudioOutput::open(
         uint32_t sampleRate, int channelCount, int format, int bufferCount,
+#ifdef STE_HARDWARE
+        AudioCallback cb, void *cookie, LatencyCallback latencyCb)
+#else
         AudioCallback cb, void *cookie)
+#endif
 {
     mCallback = cb;
     mCallbackCookie = cookie;
+#ifdef STE_HARDWARE
+    mLatencyCallback = latencyCb;
+#endif
 
     // Check argument "bufferCount" against the mininum buffer count
     if (bufferCount < mMinBufferCount) {
@@ -1443,6 +1461,9 @@ status_t MediaPlayerService::AudioOutput::open(
     t->setVolume(mLeftVolume, mRightVolume);
 
     mMsecsPerFrame = 1.e3 / (float) sampleRate;
+#ifdef STE_HARDWARE
+    mLatency = t->latency();
+#endif
     mTrack = t;
 
     t->setAuxEffectSendLevel(mSendLevel);
@@ -1494,10 +1515,15 @@ void MediaPlayerService::AudioOutput::pause()
 void MediaPlayerService::AudioOutput::close()
 {
     LOGV("close");
+#ifdef STE_HARDWARE
+    delete mTrack;
+    mTrack = 0;
+#else
     if(mTrack != NULL) {
         delete mTrack;
         mTrack = 0;
     }
+#endif
 }
 #ifdef WITH_QCOM_LPA
 void MediaPlayerService::AudioOutput::closeSession()
@@ -1568,10 +1594,13 @@ status_t MediaPlayerService::AudioOutput::attachAuxEffect(int effectId)
 void MediaPlayerService::AudioOutput::CallbackWrapper(
         int event, void *cookie, void *info) {
     //LOGV("callbackwrapper");
+#ifdef STE_HARDWARE
+    if (event == AudioTrack::EVENT_MORE_DATA) {
+#else
     if (event != AudioTrack::EVENT_MORE_DATA) {
         return;
     }
-
+#endif
     AudioOutput *me = (AudioOutput *)cookie;
     AudioTrack::Buffer *buffer = (AudioTrack::Buffer *)info;
 
@@ -1587,6 +1616,17 @@ void MediaPlayerService::AudioOutput::CallbackWrapper(
     }
 
     buffer->size = actualSize;
+#ifdef STE_HARDWARE
+    } else if (event == AudioTrack::EVENT_LATENCY_CHANGED) {
+        AudioOutput *me = (AudioOutput *)cookie;
+
+        uint32_t *newLatency = (uint32_t *)info;
+        me->mLatency = *newLatency;
+        if (me->mLatencyCallback != NULL) {
+            (*me->mLatencyCallback)(*newLatency, me->mCallbackCookie);
+        }
+    }
+#endif
 }
 
 int MediaPlayerService::AudioOutput::getSessionId()
@@ -1687,7 +1727,11 @@ bool CallbackThread::threadLoop() {
 
 status_t MediaPlayerService::AudioCache::open(
         uint32_t sampleRate, int channelCount, int format, int bufferCount,
+#ifdef STE_HARDWARE
+        AudioCallback cb, void *cookie, LatencyCallback latencyCb)
+#else
         AudioCallback cb, void *cookie)
+#endif
 {
     LOGV("open(%u, %d, %d, %d)", sampleRate, channelCount, format, bufferCount);
     if (mHeap->getHeapID() < 0) {
diff --git a/media/libmediaplayerservice/MediaPlayerService.h b/media/libmediaplayerservice/MediaPlayerService.h
index 24a8d09..4bde518 100644
--- a/media/libmediaplayerservice/MediaPlayerService.h
+++ b/media/libmediaplayerservice/MediaPlayerService.h
@@ -84,7 +84,12 @@ class MediaPlayerService : public BnMediaPlayerService
         virtual status_t        open(
                 uint32_t sampleRate, int channelCount,
                 int format, int bufferCount,
+#ifdef STE_HARDWARE
+                AudioCallback cb, void *cookie,
+                LatencyCallback latencyCb = NULL);
+#else
                 AudioCallback cb, void *cookie);
+#endif
 #ifdef WITH_QCOM_LPA
         virtual status_t        openSession(
                 int format, int sessionId, uint32_t sampleRate, int channels);
@@ -124,10 +129,16 @@ class MediaPlayerService : public BnMediaPlayerService
 #endif
         AudioCallback           mCallback;
         void *                  mCallbackCookie;
+#ifdef STE_HARDWARE
+        LatencyCallback         mLatencyCallback;
+#endif
         int                     mStreamType;
         float                   mLeftVolume;
         float                   mRightVolume;
         float                   mMsecsPerFrame;
+#ifdef STE_HARDWARE
+        uint32_t                mLatency;
+#endif
         int                     mSessionId;
         float                   mSendLevel;
         int                     mAuxEffectId;
@@ -156,7 +167,12 @@ class MediaPlayerService : public BnMediaPlayerService
         virtual status_t        open(
                 uint32_t sampleRate, int channelCount, int format,
                 int bufferCount = 1,
+#ifdef STE_HARDWARE
+                AudioCallback cb = NULL, void *cookie = NULL,
+                LatencyCallback latencyCb = NULL);
+#else
                 AudioCallback cb = NULL, void *cookie = NULL);
+#endif
 
         virtual void            start();
         virtual ssize_t         write(const void* buffer, size_t size);
diff --git a/media/libstagefright/Android.mk b/media/libstagefright/Android.mk
index 4cb0895..e364d4a 100644
--- a/media/libstagefright/Android.mk
+++ b/media/libstagefright/Android.mk
@@ -103,6 +103,11 @@ endif
 endif
 endif
 
+ifeq ($(BOARD_USES_STE_FM),true)
+LOCAL_SRC_FILES+=        PCMExtractor.cpp \
+                         FMRadioDataSource.cpp
+endif
+
 LOCAL_C_INCLUDES+= \
 	$(JNI_H_INCLUDE) \
         $(TOP)/frameworks/base/include/media/stagefright/openmax \
diff --git a/media/libstagefright/AudioPlayer.cpp b/media/libstagefright/AudioPlayer.cpp
index ea04288..290e562 100644
--- a/media/libstagefright/AudioPlayer.cpp
+++ b/media/libstagefright/AudioPlayer.cpp
@@ -124,7 +124,12 @@ status_t AudioPlayer::start(bool sourceAlreadyStarted) {
         status_t err = mAudioSink->open(
                 mSampleRate, numChannels, AUDIO_FORMAT_PCM_16_BIT,
                 DEFAULT_AUDIOSINK_BUFFERCOUNT,
+#ifdef STE_HARDWARE
+                &AudioPlayer::AudioSinkCallback, this,
+                &AudioPlayer::LatencyCallback);
+#else
                 &AudioPlayer::AudioSinkCallback, this);
+#endif
         if (err != OK) {
             if (mFirstBuffer != NULL) {
                 mFirstBuffer->release();
@@ -275,6 +280,16 @@ void AudioPlayer::AudioCallback(int event, void *user, void *info) {
     static_cast<AudioPlayer *>(user)->AudioCallback(event, info);
 }
 
+#ifdef STE_HARDWARE
+// static
+void AudioPlayer::LatencyCallback(uint32_t latency, void *cookie) {
+    AudioPlayer *me = (AudioPlayer *)cookie;
+    int64_t oldLatency = me->mLatencyUs;
+    me->mLatencyUs = (int64_t)latency * 1000;
+    LOGI("Audio output latency updated from %lldus to %lldus", oldLatency, me->mLatencyUs);
+}
+#endif
+
 bool AudioPlayer::isSeeking() {
     Mutex::Autolock autoLock(mLock);
     return mSeeking;
@@ -298,14 +313,26 @@ size_t AudioPlayer::AudioSinkCallback(
 }
 
 void AudioPlayer::AudioCallback(int event, void *info) {
+#ifdef STE_HARDWARE
+    if (event == AudioTrack::EVENT_MORE_DATA) {
+#else
     if (event != AudioTrack::EVENT_MORE_DATA) {
         return;
     }
+#endif
 
     AudioTrack::Buffer *buffer = (AudioTrack::Buffer *)info;
     size_t numBytesWritten = fillBuffer(buffer->raw, buffer->size);
 
     buffer->size = numBytesWritten;
+#ifdef STE_HARDWARE
+    } else if (event == AudioTrack::EVENT_LATENCY_CHANGED) {
+        uint32_t *newLatency = (uint32_t *)info;
+        int64_t oldLatency = mLatencyUs;
+        mLatencyUs = (int64_t)*newLatency * 1000;
+        LOGI("Audio output latency updated from %lldus to %lldus", oldLatency, mLatencyUs);
+    }
+#endif
 }
 
 uint32_t AudioPlayer::getNumFramesPendingPlayout() const {
diff --git a/media/libstagefright/AwesomePlayer.cpp b/media/libstagefright/AwesomePlayer.cpp
index 6da986a..68a2cf3 100644
--- a/media/libstagefright/AwesomePlayer.cpp
+++ b/media/libstagefright/AwesomePlayer.cpp
@@ -43,6 +43,9 @@
 #endif
 #include <media/stagefright/DataSource.h>
 #include <media/stagefright/FileSource.h>
+#ifdef STE_FM
+#include <media/stagefright/FMRadioDataSource.h>
+#endif
 #include <media/stagefright/MediaBuffer.h>
 #include <media/stagefright/MediaDefs.h>
 #include <media/stagefright/MediaExtractor.h>
@@ -2133,6 +2136,9 @@ status_t AwesomePlayer::prepareAsync_l() {
 status_t AwesomePlayer::finishSetDataSource_l() {
     sp<DataSource> dataSource;
 
+#ifdef STE_FM
+    char *mime = NULL;
+#endif
     bool isWidevineStreaming = false;
     if (!strncasecmp("widevine://", mUri.string(), 11)) {
         isWidevineStreaming = true;
@@ -2271,6 +2277,17 @@ status_t AwesomePlayer::finishSetDataSource_l() {
                 return UNKNOWN_ERROR;
             }
         }
+#ifdef STE_FM
+    } else if (!strncasecmp("fmradio://rx", mUri.string(), 12)) {
+
+        mime = (char*) MEDIA_MIMETYPE_AUDIO_RAW;
+        // HACK: Removed the line below since it causes problems. Add it back if you want FM-Radio.
+        dataSource = new FMRadioDataSource();
+        status_t err = dataSource->initCheck();
+        if (err != OK) {
+            return err;
+        }
+#endif
     } else {
         dataSource = DataSource::CreateFromURI(mUri.string(), &mUriHeaders);
     }
@@ -2297,9 +2314,12 @@ status_t AwesomePlayer::finishSetDataSource_l() {
         mWVMExtractor->setAdaptiveStreamingMode(true);
         extractor = mWVMExtractor;
     } else {
+#ifdef STE_FM
+        extractor = MediaExtractor::Create(dataSource, mime);
+#else
         extractor = MediaExtractor::Create(
                 dataSource, sniffedMIME.empty() ? NULL : sniffedMIME.c_str());
-
+#endif
         if (extractor == NULL) {
             return UNKNOWN_ERROR;
         }
diff --git a/media/libstagefright/CameraSource.cpp b/media/libstagefright/CameraSource.cpp
index d79df77..173b641 100755
--- a/media/libstagefright/CameraSource.cpp
+++ b/media/libstagefright/CameraSource.cpp
@@ -120,6 +120,12 @@ static int32_t getColorFormat(const char* colorFormat) {
        return OMX_TI_COLOR_FormatYUV420PackedSemiPlanar;
     }
 
+#ifdef STE_HARDWARE
+    if (!strcmp(colorFormat, CameraParameters::PIXEL_FORMAT_YUV420MB)) {
+       return OMX_STE_COLOR_FormatYUV420PackedSemiPlanarMB;
+    }
+#endif
+
     LOGE("Uknown color format (%s), please add it to "
          "CameraSource::getColorFormat", colorFormat);
 
@@ -560,13 +566,23 @@ status_t CameraSource::initWithCameraAccess(
 
     // XXX: query camera for the stride and slice height
     // when the capability becomes available.
+#ifdef STE_HARDWARE
+    int stride = newCameraParams.getInt(CameraParameters::KEY_RECORD_STRIDE);
+    int sliceHeight = newCameraParams.getInt(CameraParameters::KEY_RECORD_SLICE_HEIGHT);
+#endif
+
     mMeta = new MetaData;
     mMeta->setCString(kKeyMIMEType,  MEDIA_MIMETYPE_VIDEO_RAW);
     mMeta->setInt32(kKeyColorFormat, mColorFormat);
     mMeta->setInt32(kKeyWidth,       mVideoSize.width);
     mMeta->setInt32(kKeyHeight,      mVideoSize.height);
+#ifndef STE_HARDWARE
     mMeta->setInt32(kKeyStride,      mVideoSize.width);
     mMeta->setInt32(kKeySliceHeight, mVideoSize.height);
+#else
+    mMeta->setInt32(kKeyStride,      stride != -1 ? stride : mVideoSize.width);
+    mMeta->setInt32(kKeySliceHeight, sliceHeight != -1 ? sliceHeight : mVideoSize.height);
+#endif
     mMeta->setInt32(kKeyFrameRate,   mVideoFrameRate);
 #ifdef QCOM_HARDWARE
     mMeta->setInt32(kKeyHFR, hfr);
diff --git a/media/libstagefright/DataSource.cpp b/media/libstagefright/DataSource.cpp
index 66a16c1..10a96a8 100755
--- a/media/libstagefright/DataSource.cpp
+++ b/media/libstagefright/DataSource.cpp
@@ -21,6 +21,9 @@
 #include "include/WAVExtractor.h"
 #include "include/OggExtractor.h"
 #include "include/MPEG2PSExtractor.h"
+#ifdef STE_HARDWARE
+#include "include/PCMExtractor.h"
+#endif
 #include "include/MPEG2TSExtractor.h"
 #include "include/NuCachedSource2.h"
 #include "include/HTTPBase.h"
@@ -40,6 +43,9 @@
 #include <media/stagefright/foundation/AMessage.h>
 #include <media/stagefright/DataSource.h>
 #include <media/stagefright/FileSource.h>
+#ifdef STE_HARDWARE
+#include <media/stagefright/FMRadioDataSource.h>
+#endif
 #include <media/stagefright/MediaErrors.h>
 #include <utils/String8.h>
 
diff --git a/media/libstagefright/FMRadioDataSource.cpp b/media/libstagefright/FMRadioDataSource.cpp
new file mode 100644
index 0000000..09780f2
--- /dev/null
+++ b/media/libstagefright/FMRadioDataSource.cpp
@@ -0,0 +1,100 @@
+/*
+ * Copyright (C) ST-Ericsson SA 2010
+ * Copyright (C) 2010 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+ * Author: Andreas Gustafsson (andreas.a.gustafsson@stericsson.com)
+ *         for ST-Ericsson
+ */
+
+#define LOG_TAG "FMRadioDataSource"
+#include <utils/Log.h>
+
+#include <media/stagefright/FMRadioDataSource.h>
+#include <media/stagefright/MediaDebug.h>
+#include <media/AudioSystem.h>
+#include <media/IAudioPolicyService.h>
+#include <binder/IServiceManager.h>
+#include <media/AudioSystem.h>
+#include <media/mediarecorder.h>
+#include <media/IAudioFlinger.h>
+#include <system/audio.h>
+
+
+namespace android {
+
+FMRadioDataSource::FMRadioDataSource() {
+
+    mFormat = android_audio_legacy::AudioSystem::PCM_16_BIT;
+    mChannels = android_audio_legacy::AudioSystem::CHANNEL_IN_STEREO;
+    mSampleRate = 48000;
+    mFlags = 0;
+    mOverwrittenBytes = 0;
+    mInputClientId = AUDIO_INPUT_CLIENT_PLAYBACK;
+    int inputSource = AUDIO_SOURCE_FM_RADIO_RX;
+
+    mStream = (android_audio_legacy::AudioStreamIn*) AudioSystem::getInput(inputSource,mSampleRate, mFormat, mChannels,
+                                              (audio_in_acoustics_t)mFlags,0,&mInputClientId);
+    if (mStream != NULL) {
+        AudioSystem::startInput((audio_io_handle_t) mStream);
+    }
+}
+
+FMRadioDataSource::~FMRadioDataSource() {
+
+    if (mStream != NULL) {
+        AudioSystem::stopInput((audio_io_handle_t) mStream);
+        AudioSystem::releaseInput((audio_io_handle_t) mStream);
+    }
+}
+
+status_t FMRadioDataSource::initCheck() const {
+    return mStream != NULL ? OK : NO_INIT;
+}
+
+ssize_t FMRadioDataSource::readAt(off64_t offset, void *data, size_t size) {
+    if(mStream != NULL) {
+       const sp<IAudioFlinger>& af = AudioSystem::get_audio_flinger();
+       return af->readInput((uint32_t*)mStream, mInputClientId, data, size, &mOverwrittenBytes);
+    }
+    return 0;
+}
+
+status_t FMRadioDataSource::getSize(off64_t *size) {
+    *size = 0;
+    return OK;
+}
+
+uint32_t FMRadioDataSource::getBufferSize() {
+    return mStream->bufferSize();
+}
+
+uint32_t FMRadioDataSource::getNumChannels() {
+    return android_audio_legacy::AudioSystem::popCount(mChannels);
+}
+
+uint32_t FMRadioDataSource::getSampleRate() {
+    return mSampleRate;
+}
+
+uint32_t FMRadioDataSource::getFormat() {
+    if (mFormat == android_audio_legacy::AudioSystem::PCM_16_BIT) {
+        return 16;
+    } else if (mFormat == android_audio_legacy::AudioSystem::PCM_8_BIT) {
+        return 8;
+    }
+    return 0;
+}
+
+}  // namespace android
diff --git a/media/libstagefright/MediaDefs.cpp b/media/libstagefright/MediaDefs.cpp
index d022b6e..beb5eb1 100755
--- a/media/libstagefright/MediaDefs.cpp
+++ b/media/libstagefright/MediaDefs.cpp
@@ -25,8 +25,14 @@ const char *MEDIA_MIMETYPE_VIDEO_VPX = "video/x-vnd.on2.vp8";
 const char *MEDIA_MIMETYPE_VIDEO_AVC = "video/avc";
 const char *MEDIA_MIMETYPE_VIDEO_MPEG4 = "video/mp4v-es";
 const char *MEDIA_MIMETYPE_VIDEO_H263 = "video/3gpp";
+#ifdef STE_HARDWARE
+const char *MEDIA_MIMETYPE_VIDEO_H263_SW = "video/3gpp-sw";
+#endif
 const char *MEDIA_MIMETYPE_VIDEO_MPEG2 = "video/mpeg2";
 const char *MEDIA_MIMETYPE_VIDEO_RAW = "video/raw";
+#ifdef STE_HARDWARE
+const char *MEDIA_MIMETYPE_VIDEO_VC1 = "video/vc1";
+#endif
 
 const char *MEDIA_MIMETYPE_AUDIO_AMR_NB = "audio/3gpp";
 const char *MEDIA_MIMETYPE_AUDIO_AMR_WB = "audio/amr-wb";
diff --git a/media/libstagefright/MediaExtractor.cpp b/media/libstagefright/MediaExtractor.cpp
index 0969d16..1caaff5 100755
--- a/media/libstagefright/MediaExtractor.cpp
+++ b/media/libstagefright/MediaExtractor.cpp
@@ -25,6 +25,9 @@
 #include "include/WAVExtractor.h"
 #include "include/OggExtractor.h"
 #include "include/MPEG2PSExtractor.h"
+#ifdef STE_FM
+#include "include/PCMExtractor.h"
+#endif
 #include "include/MPEG2TSExtractor.h"
 #include "include/DRMExtractor.h"
 #include "include/WVMExtractor.h"
@@ -119,6 +122,10 @@ sp<MediaExtractor> MediaExtractor::Create(
         ret = new AACExtractor(source);
     } else if (!strcasecmp(mime, MEDIA_MIMETYPE_CONTAINER_MPEG2PS)) {
         ret = new MPEG2PSExtractor(source);
+#ifdef STE_FM
+    } else if (!strcasecmp(mime, MEDIA_MIMETYPE_AUDIO_RAW)) {
+        ret = new PCMExtractor(source);
+#endif
     }
 
     if (ret != NULL) {
diff --git a/media/libstagefright/OMXCodec.cpp b/media/libstagefright/OMXCodec.cpp
index 60ea9df..8a43039 100644
--- a/media/libstagefright/OMXCodec.cpp
+++ b/media/libstagefright/OMXCodec.cpp
@@ -234,6 +234,9 @@ static const CodecInfo kDecoderInfo[] = {
     { MEDIA_MIMETYPE_VIDEO_VPX, "OMX.SEC.vp8.dec" },
 #endif
     { MEDIA_MIMETYPE_IMAGE_JPEG, "OMX.TI.JPEG.decode" },
+#ifdef STE_HARDWARE
+    { MEDIA_MIMETYPE_AUDIO_MPEG, "OMX.ST.mp3.decoder" },
+#endif
 //    { MEDIA_MIMETYPE_AUDIO_MPEG, "OMX.TI.MP3.decode" },
     { MEDIA_MIMETYPE_AUDIO_MPEG, "OMX.google.mp3.decoder" },
 #ifdef WITH_QCOM_LPA
@@ -246,6 +249,9 @@ static const CodecInfo kDecoderInfo[] = {
 //    { MEDIA_MIMETYPE_AUDIO_AMR_NB, "OMX.Nvidia.amrwb.decoder" },
     { MEDIA_MIMETYPE_AUDIO_AMR_WB, "OMX.TI.WBAMR.decode" },
     { MEDIA_MIMETYPE_AUDIO_AMR_WB, "OMX.google.amrwb.decoder" },
+#ifdef STE_HARDWARE
+    { MEDIA_MIMETYPE_AUDIO_AAC, "OMX.ST.aac.decoder" }, 
+#endif
 //    { MEDIA_MIMETYPE_AUDIO_AAC, "OMX.Nvidia.aac.decoder" },
     { MEDIA_MIMETYPE_AUDIO_AAC, "OMX.TI.AAC.decode" },
     { MEDIA_MIMETYPE_AUDIO_AAC, "OMX.google.aac.decoder" },
@@ -254,6 +260,9 @@ static const CodecInfo kDecoderInfo[] = {
 #endif
     { MEDIA_MIMETYPE_AUDIO_G711_ALAW, "OMX.google.g711.alaw.decoder" },
     { MEDIA_MIMETYPE_AUDIO_G711_MLAW, "OMX.google.g711.mlaw.decoder" },
+#ifdef STE_HARDWARE
+    { MEDIA_MIMETYPE_VIDEO_MPEG4, "OMX.ST.VFM.MPEG4Dec" },
+#endif
     { MEDIA_MIMETYPE_VIDEO_MPEG4, "OMX.TI.DUCATI1.VIDEO.DECODER" },
     { MEDIA_MIMETYPE_VIDEO_MPEG4, "OMX.Nvidia.mp4.decode" },
     { MEDIA_MIMETYPE_VIDEO_MPEG4, "OMX.qcom.7x30.video.decoder.mpeg4" },
@@ -261,12 +270,19 @@ static const CodecInfo kDecoderInfo[] = {
     { MEDIA_MIMETYPE_VIDEO_MPEG4, "OMX.TI.Video.Decoder" },
     { MEDIA_MIMETYPE_VIDEO_MPEG4, "OMX.SEC.MPEG4.Decoder" },
     { MEDIA_MIMETYPE_VIDEO_MPEG4, "OMX.google.mpeg4.decoder" },
+#ifdef STE_HARDWARE
+    { MEDIA_MIMETYPE_VIDEO_H263, "OMX.ST.VFM.MPEG4Dec" },
+#endif
     { MEDIA_MIMETYPE_VIDEO_H263, "OMX.TI.DUCATI1.VIDEO.DECODER" },
     { MEDIA_MIMETYPE_VIDEO_H263, "OMX.Nvidia.h263.decode" },
     { MEDIA_MIMETYPE_VIDEO_H263, "OMX.qcom.7x30.video.decoder.h263" },
     { MEDIA_MIMETYPE_VIDEO_H263, "OMX.qcom.video.decoder.h263" },
     { MEDIA_MIMETYPE_VIDEO_H263, "OMX.SEC.H263.Decoder" },
     { MEDIA_MIMETYPE_VIDEO_H263, "OMX.google.h263.decoder" },
+#ifdef STE_HARDWARE
+    { MEDIA_MIMETYPE_VIDEO_H263_SW, "OMX.ST.VFM.MPEG4HostDec" },
+    { MEDIA_MIMETYPE_VIDEO_AVC, "OMX.ST.VFM.H264Dec" },
+#endif
     { MEDIA_MIMETYPE_VIDEO_AVC, "OMX.TI.DUCATI1.VIDEO.DECODER" },
     { MEDIA_MIMETYPE_VIDEO_AVC, "OMX.Nvidia.h264.decode" },
     { MEDIA_MIMETYPE_VIDEO_AVC, "OMX.qcom.7x30.video.decoder.avc" },
@@ -280,6 +296,9 @@ static const CodecInfo kDecoderInfo[] = {
     { MEDIA_MIMETYPE_VIDEO_VPX, "OMX.SEC.VP8.Decoder" },
     { MEDIA_MIMETYPE_VIDEO_VPX, "OMX.google.vpx.decoder" },
     { MEDIA_MIMETYPE_VIDEO_MPEG2, "OMX.Nvidia.mpeg2v.decode" },
+#ifdef STE_HARDWARE
+    { MEDIA_MIMETYPE_VIDEO_VC1, "OMX.ST.VFM.VC1Dec" },
+#endif
 #ifdef QCOM_HARDWARE
     { MEDIA_MIMETYPE_VIDEO_DIVX, "OMX.qcom.video.decoder.divx"},
     { MEDIA_MIMETYPE_VIDEO_DIVX311, "OMX.qcom.video.decoder.divx311"},
@@ -312,6 +331,9 @@ static const CodecInfo kEncoderInfo[] = {
     { MEDIA_MIMETYPE_AUDIO_AAC, "OMX.TI.AAC.encode" },
     { MEDIA_MIMETYPE_AUDIO_AAC, "OMX.qcom.audio.encoder.aac" },
     { MEDIA_MIMETYPE_AUDIO_AAC, "AACEncoder" },
+#ifdef STE_HARDWARE
+    { MEDIA_MIMETYPE_VIDEO_MPEG4, "OMX.ST.VFM.MPEG4Enc" },
+#endif
     { MEDIA_MIMETYPE_VIDEO_MPEG4, "OMX.TI.DUCATI1.VIDEO.MPEG4E" },
     { MEDIA_MIMETYPE_VIDEO_MPEG4, "OMX.qcom.7x30.video.encoder.mpeg4" },
 #ifdef QCOM_HARDWARE
@@ -323,6 +345,9 @@ static const CodecInfo kEncoderInfo[] = {
     { MEDIA_MIMETYPE_VIDEO_MPEG4, "OMX.Nvidia.mp4.encoder" },
     { MEDIA_MIMETYPE_VIDEO_MPEG4, "OMX.SEC.MPEG4.Encoder" },
     { MEDIA_MIMETYPE_VIDEO_MPEG4, "M4vH263Encoder" },
+#ifdef STE_HARDWARE
+    { MEDIA_MIMETYPE_VIDEO_H263, "OMX.ST.VFM.MPEG4Enc" },
+#endif
     { MEDIA_MIMETYPE_VIDEO_H263, "OMX.TI.DUCATI1.VIDEO.MPEG4E" },
     { MEDIA_MIMETYPE_VIDEO_H263, "OMX.qcom.7x30.video.encoder.h263" },
     { MEDIA_MIMETYPE_VIDEO_H263, "OMX.qcom.video.encoder.h263" },
@@ -330,6 +355,9 @@ static const CodecInfo kEncoderInfo[] = {
     { MEDIA_MIMETYPE_VIDEO_H263, "OMX.Nvidia.h263.encoder" },
     { MEDIA_MIMETYPE_VIDEO_H263, "OMX.SEC.H263.Encoder" },
     { MEDIA_MIMETYPE_VIDEO_H263, "M4vH263Encoder" },
+#ifdef STE_HARDWARE
+    { MEDIA_MIMETYPE_VIDEO_AVC, "OMX.ST.VFM.H264Enc" },
+#endif
     { MEDIA_MIMETYPE_VIDEO_AVC, "OMX.TI.DUCATI1.VIDEO.H264E" },
     { MEDIA_MIMETYPE_VIDEO_AVC, "OMX.qcom.7x30.video.encoder.avc" },
     { MEDIA_MIMETYPE_VIDEO_AVC, "OMX.qcom.video.encoder.avc" },
@@ -445,6 +473,20 @@ static int CompareSoftwareCodecsFirst(
     return 0;
 }
 
+#ifdef STE_HARDWARE
+static uint32_t OmxToHALFormat(OMX_COLOR_FORMATTYPE omxValue) {
+    switch (omxValue) {
+        case OMX_STE_COLOR_FormatYUV420PackedSemiPlanarMB:
+            return HAL_PIXEL_FORMAT_YCBCR42XMBN;
+        case OMX_COLOR_FormatYUV420Planar:
+            return HAL_PIXEL_FORMAT_YCbCr_420_P;
+        default:
+            LOGI("Unknown OMX pixel format (0x%X), passing it on unchanged", omxValue);
+            return omxValue;
+    }
+}
+#endif
+
 // static
 uint32_t OMXCodec::getComponentQuirks(
         const char *componentName, bool isEncoder) {
@@ -567,6 +609,19 @@ uint32_t OMXCodec::getComponentQuirks(
     }
 #endif
 
+#ifdef STE_HARDWARE
+    if (!isEncoder && !strncmp(componentName, "OMX.ST.VFM.", 11)) {
+        quirks |= kRequiresAllocateBufferOnInputPorts;
+        quirks |= kRequiresAllocateBufferOnOutputPorts;
+    }
+
+    if (!strncmp(componentName, "OMX.ST.VFM.MPEG4Enc", 19) ||
+            !strncmp(componentName, "OMX.ST.VFM.H264Enc", 18)) {
+        quirks |= kRequiresAllocateBufferOnOutputPorts;
+        quirks |= kRequiresStoreMetaDataBeforeIdle;
+    }
+#endif
+
     return quirks;
 }
 
@@ -1276,6 +1331,9 @@ static size_t getFrameSize(
         case OMX_COLOR_FormatYUV420Planar:
         case OMX_COLOR_FormatYUV420SemiPlanar:
         case OMX_TI_COLOR_FormatYUV420PackedSemiPlanar:
+#ifdef STE_HARDWARE
+        case OMX_STE_COLOR_FormatYUV420PackedSemiPlanarMB:
+#endif
         /*
         * FIXME: For the Opaque color format, the frame size does not
         * need to be (w*h*3)/2. It just needs to
@@ -1933,7 +1991,11 @@ status_t OMXCodec::setVideoOutputFormat(
                || format.eColorFormat == OMX_COLOR_FormatYUV420SemiPlanar
                || format.eColorFormat == OMX_COLOR_FormatCbYCrY
                || format.eColorFormat == OMX_TI_COLOR_FormatYUV420PackedSemiPlanar
+#ifndef STE_HARDWARE
                || format.eColorFormat == OMX_QCOM_COLOR_FormatYVU420SemiPlanar
+#else
+               || format.eColorFormat == OMX_STE_COLOR_FormatYUV420PackedSemiPlanarMB
+#endif
 #ifdef QCOM_HARDWARE
                || format.eColorFormat == QOMX_COLOR_FormatYUV420PackedSemiPlanar64x32Tile2m8ka
 #endif
@@ -2106,6 +2168,10 @@ void OMXCodec::setComponentRole(
             "video_decoder.mpeg4", "video_encoder.mpeg4" },
         { MEDIA_MIMETYPE_VIDEO_H263,
             "video_decoder.h263", "video_encoder.h263" },
+#ifdef STE_HARDWARE
+        { MEDIA_MIMETYPE_VIDEO_VC1,
+            "video_decoder.vc1", "video_encoder.vc1" },
+#endif
 #ifdef QCOM_HARDWARE
         { MEDIA_MIMETYPE_VIDEO_DIVX,
             "video_decoder.divx", NULL },
@@ -2183,6 +2249,17 @@ status_t OMXCodec::init() {
     CHECK_EQ((int)mState, (int)LOADED);
 
     status_t err;
+#ifdef STE_HARDWARE
+    if ((mQuirks & kRequiresStoreMetaDataBeforeIdle)
+            && (mFlags & kStoreMetaDataInVideoBuffers)) {
+        err = mOMX->storeMetaDataInBuffers(mNode, kPortIndexInput, OMX_TRUE);
+        if (err != OK) {
+            LOGE("Storing meta data in video buffers is not supported");
+            return err;
+        }
+    }
+#endif
+
     if (!(mQuirks & kRequiresLoadedToIdleAfterAllocation)) {
         err = mOMX->sendCommand(mNode, OMX_CommandStateSet, OMX_StateIdle);
         CHECK_EQ(err, (status_t)OK);
@@ -2246,7 +2323,12 @@ status_t OMXCodec::allocateBuffersOnPort(OMX_U32 portIndex) {
     }
 
     status_t err = OK;
+#ifndef STE_HARDWARE
     if ((mFlags & kStoreMetaDataInVideoBuffers)
+#else
+    if (!(mQuirks & kRequiresStoreMetaDataBeforeIdle)
+            && (mFlags & kStoreMetaDataInVideoBuffers)
+#endif
             && portIndex == kPortIndexInput) {
         LOGW("Trying to enable metadata mode on encoder");
         err = mOMX->storeMetaDataInBuffers(mNode, kPortIndexInput, OMX_TRUE);
@@ -2462,7 +2544,11 @@ status_t OMXCodec::allocateOutputBuffersFromNativeWindow() {
 #else
             def.format.video.nFrameWidth,
             def.format.video.nFrameHeight,
+#ifndef STE_HARDWARE
             def.format.video.eColorFormat);
+#else
+           OmxToHALFormat(def.format.video.eColorFormat));
+#endif
 #endif
 #else
     OMX_COLOR_FORMATTYPE eColorFormat;
@@ -5351,6 +5437,9 @@ static const char *videoCompressionFormatString(OMX_VIDEO_CODINGTYPE type) {
         "OMX_VIDEO_CodingRV",
         "OMX_VIDEO_CodingAVC",
         "OMX_VIDEO_CodingMJPEG",
+#ifdef STE_HARDWARE
+        "OMX_VIDEO_CodingVC1",
+#endif
     };
 
     size_t numNames = sizeof(kNames) / sizeof(kNames[0]);
diff --git a/media/libstagefright/PCMExtractor.cpp b/media/libstagefright/PCMExtractor.cpp
new file mode 100644
index 0000000..d85af33
--- /dev/null
+++ b/media/libstagefright/PCMExtractor.cpp
@@ -0,0 +1,276 @@
+/*
+ * Copyright (C) ST-Ericsson SA 2010
+ * Copyright (C) 2010 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+ * Author: Andreas Gustafsson (andreas.a.gustafsson@stericsson.com)
+ *         for ST-Ericsson
+ */
+
+//#define LOG_NDEBUG 0
+#define LOG_TAG "PCMExtractor"
+#include <utils/Log.h>
+
+#include "include/PCMExtractor.h"
+
+#include <media/stagefright/DataSource.h>
+#include <media/stagefright/MediaBufferGroup.h>
+#include <media/stagefright/MediaDebug.h>
+#include <media/stagefright/MediaDefs.h>
+#include <media/stagefright/MediaErrors.h>
+#include <media/stagefright/MetaData.h>
+#include <utils/String8.h>
+
+namespace android {
+
+static const uint16_t kDefaultNumChannels = 2;
+static const uint32_t kDefaultSampleRate = 48000;
+static const uint16_t kDefaultFormat = 16;
+
+struct PCMSource : public MediaSource {
+    PCMSource(
+            const sp<DataSource> &dataSource,
+            const sp<MetaData> &meta,
+            int32_t bitsPerSample,
+            off_t offset, size_t size);
+
+    virtual status_t start(MetaData *params = NULL);
+    virtual status_t stop();
+    virtual sp<MetaData> getFormat();
+
+    virtual status_t read(
+            MediaBuffer **buffer, const ReadOptions *options = NULL);
+
+protected:
+    virtual ~PCMSource();
+
+private:
+    static const size_t kMaxFrameSize;
+
+    sp<DataSource> mDataSource;
+    sp<MetaData> mMeta;
+    int32_t mSampleRate;
+    int32_t mNumChannels;
+    int32_t mBitsPerSample;
+    off_t mOffset;
+    size_t mSize;
+    bool mStarted;
+    MediaBufferGroup *mGroup;
+    off_t mCurrentPos;
+    uint32_t mBufferSize;
+
+    PCMSource(const PCMSource &);
+    PCMSource &operator=(const PCMSource &);
+};
+
+PCMExtractor::PCMExtractor(const sp<DataSource> &source)
+    : mDataSource(source),
+      mValidFormat(false) {
+    mInitCheck = init();
+}
+
+PCMExtractor::~PCMExtractor() {
+}
+
+sp<MetaData> PCMExtractor::getMetaData() {
+    sp<MetaData> meta = new MetaData;
+
+    if (mInitCheck != OK) {
+        return meta;
+    }
+
+    meta->setCString(kKeyMIMEType, "audio/raw");
+
+    return meta;
+}
+
+size_t PCMExtractor::countTracks() {
+    return mInitCheck == OK ? 1 : 0;
+}
+
+sp<MediaSource> PCMExtractor::getTrack(size_t index) {
+    if (mInitCheck != OK || index > 0) {
+        return NULL;
+    }
+
+    return new PCMSource(
+            mDataSource, mTrackMeta,
+            mBitsPerSample, mDataOffset, mDataSize);
+}
+
+sp<MetaData> PCMExtractor::getTrackMetaData(
+        size_t index, uint32_t flags) {
+    if (mInitCheck != OK || index > 0) {
+        return NULL;
+    }
+
+    return mTrackMeta;
+}
+
+status_t PCMExtractor::init() {
+    mNumChannels = kDefaultNumChannels;
+    mSampleRate = kDefaultSampleRate;
+    mBitsPerSample = kDefaultFormat;
+    mDataOffset = 0;
+    mDataSize = 0;
+    mValidFormat = true;
+    mTrackMeta = new MetaData;mTrackMeta->setCString(kKeyMIMEType, MEDIA_MIMETYPE_AUDIO_RAW);
+    mTrackMeta->setInt32(kKeyChannelCount, mNumChannels);
+    mTrackMeta->setInt32(kKeySampleRate, mSampleRate);
+    return OK;
+}
+
+const size_t PCMSource::kMaxFrameSize = 4800;
+
+PCMSource::PCMSource(
+        const sp<DataSource> &dataSource,
+        const sp<MetaData> &meta,
+        int32_t bitsPerSample,
+        off_t offset, size_t size)
+    : mDataSource(dataSource),
+      mMeta(meta),
+      mSampleRate(0),
+      mNumChannels(0),
+      mBitsPerSample(bitsPerSample),
+      mOffset(offset),
+      mSize(size),
+      mStarted(false),
+      mGroup(NULL),
+      mBufferSize(0) {
+    CHECK(mMeta->findInt32(kKeySampleRate, &mSampleRate));
+    CHECK(mMeta->findInt32(kKeyChannelCount, &mNumChannels));
+}
+
+PCMSource::~PCMSource() {
+    if (mStarted) {
+        stop();
+    }
+}
+
+status_t PCMSource::start(MetaData *params) {
+    CHECK(!mStarted);
+
+    mBufferSize = kMaxFrameSize;
+    mGroup = new MediaBufferGroup;
+    mGroup->add_buffer(new MediaBuffer(mBufferSize));
+
+    if (mBitsPerSample == 8) {
+        // As a temporary buffer for 8->16 bit conversion.
+        mGroup->add_buffer(new MediaBuffer(mBufferSize));
+    }
+
+    mCurrentPos = mOffset;
+
+    mStarted = true;
+    return OK;
+}
+
+status_t PCMSource::stop() {
+
+    CHECK(mStarted);
+    delete mGroup;
+    mGroup = NULL;
+
+    mStarted = false;
+    return OK;
+}
+
+sp<MetaData> PCMSource::getFormat() {
+   return mMeta;
+}
+
+status_t PCMSource::read(
+        MediaBuffer **out, const ReadOptions *options) {
+    *out = NULL;
+    int64_t seekTimeUs;
+    ReadOptions::SeekMode seek = ReadOptions::SEEK_CLOSEST_SYNC;
+    if (options != NULL && options->getSeekTo(&seekTimeUs,&seek)) {
+        int64_t pos = (seekTimeUs * mSampleRate) / 1000000 * mNumChannels * 2;
+        if (pos > mSize) {
+            pos = mSize;
+        }
+        mCurrentPos = pos + mOffset;
+    }
+
+    MediaBuffer *buffer;
+    status_t err = mGroup->acquire_buffer(&buffer);
+    if (err != OK) {
+        return err;
+    }
+
+    ssize_t n = mDataSource->readAt(
+            mCurrentPos, buffer->data(), mBufferSize);
+    if (n <= 0) {
+        buffer->release();
+        buffer = NULL;
+        return ERROR_END_OF_STREAM;
+    }
+
+    mCurrentPos += n;
+
+    buffer->set_range(0, n);
+
+    if (mBitsPerSample == 8) {
+        // Convert 8-bit unsigned samples to 16-bit signed.
+
+        MediaBuffer *tmp;
+        CHECK_EQ(mGroup->acquire_buffer(&tmp), OK);
+
+        // The new buffer holds the sample number of samples, but each
+        // one is 2 bytes wide.
+        tmp->set_range(0, 2 * n);
+
+        int16_t *dst = (int16_t *)tmp->data();
+        const uint8_t *src = (const uint8_t *)buffer->data();
+        while (n-- > 0) {
+            *dst++ = ((int16_t)(*src) - 128) * 256;
+            ++src;
+        }
+
+        buffer->release();
+        buffer = tmp;
+    } else if (mBitsPerSample == 24) {
+        // Convert 24-bit signed samples to 16-bit signed.
+
+        const uint8_t *src =
+            (const uint8_t *)buffer->data() + buffer->range_offset();
+        int16_t *dst = (int16_t *)src;
+
+        size_t numSamples = buffer->range_length() / 3;
+        for (size_t i = 0; i < numSamples; ++i) {
+            int32_t x = (int32_t)(src[0] | src[1] << 8 | src[2] << 16);
+            x = (x << 8) >> 8;  // sign extension
+
+            x = x >> 8;
+            *dst++ = (int16_t)x;
+            src += 3;
+        }
+
+        buffer->set_range(buffer->range_offset(), 2 * numSamples);
+    }
+
+    size_t bytesPerSample = mBitsPerSample >> 3;
+
+    buffer->meta_data()->setInt64(
+            kKeyTime,
+            1000000LL * (mCurrentPos - mOffset)
+                / (mNumChannels * bytesPerSample) / mSampleRate);
+
+
+    *out = buffer;
+
+    return OK;
+}
+
+}  // namespace android
diff --git a/media/libstagefright/colorconversion/ColorConverter.cpp b/media/libstagefright/colorconversion/ColorConverter.cpp
index 5bda1f6..cdbe810 100644
--- a/media/libstagefright/colorconversion/ColorConverter.cpp
+++ b/media/libstagefright/colorconversion/ColorConverter.cpp
@@ -54,6 +54,9 @@ bool ColorConverter::isValid() const {
         case OMX_QCOM_COLOR_FormatYVU420SemiPlanar:
         case OMX_COLOR_FormatYUV420SemiPlanar:
         case OMX_TI_COLOR_FormatYUV420PackedSemiPlanar:
+#ifdef STE_HARDWARE
+        case OMX_STE_COLOR_FormatYUV420PackedSemiPlanarMB:
+#endif
 #ifdef QCOM_HARDWARE
         case QOMX_COLOR_FormatYUV420PackedSemiPlanar64x32Tile2m8ka:
 #endif
@@ -555,6 +558,145 @@ status_t ColorConverter::convertTIYUV420PackedSemiPlanar(
     return OK;
 }
 
+#ifdef STE_HARDWARE
+status_t ColorConverter::convertSTEYUV420PackedSemiPlanarMB(
+        const BitmapParams &src, const BitmapParams &dst) {
+
+    if (!((dst.mWidth & 1) == 0
+            && src.mCropLeft == 0
+            && src.mCropTop == 0
+            && src.cropWidth() == dst.cropWidth()
+            && src.cropHeight() == dst.cropHeight())) {
+        return ERROR_UNSUPPORTED;
+    }
+
+    OMX_U32 mx = src.mWidth / 16;
+    OMX_U32 my = src.mHeight / 16;
+    OMX_U32 lx, ly;
+    OMX_U32 *pChroma, *pLuma = (OMX_U32 *)src.mBits;
+
+    pChroma = (OMX_U32 *)src.mBits + mx * my * 64;
+    for (ly = 0; ly < my; ly++) {
+        for (lx = 0; lx < mx; lx++) {
+            OMX_U32 col, row, lumaWord, chromaWord1 = 0, rgbWord, i;
+            OMX_U8 y[4], cb[4], cr[4], r[4], g[4], b[4];
+            OMX_U32 *dstBuf, *locBuf;
+            OMX_U32 *pBurstLuma = 0, *pBurstChroma = 0;
+            OMX_U32 *pWordLuma = 0, *pWordChroma = 0;
+            OMX_U8 nbOfBlock;
+
+            dstBuf = ((OMX_U32 *)dst.mBits) + (ly * 16) * dst.mWidth / 2;
+            dstBuf += (lx * 16) / 2;
+
+            pBurstLuma = pLuma;
+            pBurstChroma = pChroma;
+
+            for (col = 0; col < 2; col++) {
+                // conversion of a macroblock
+                for (nbOfBlock = 0; nbOfBlock < 2; nbOfBlock++) {
+                    locBuf = dstBuf + 4 * col + 2 * nbOfBlock;
+                    OMX_U32 dstRowOrigo = ly * 16 * dst.mWidth;
+
+                    switch (nbOfBlock) {
+                    case 0:
+                        pWordLuma = pBurstLuma;
+                        pWordChroma = pBurstChroma;
+                        break;
+                    case 1:
+                        pWordLuma = pBurstLuma + 1;
+                        pWordChroma = pBurstChroma + 1;
+                        break;
+                    }
+                    for (row = 0; row < 16; row++) {
+
+                        // Check for cropping on the y axis
+                        if (ly * 16 + row >= dst.mHeight) {
+                            break;
+                        }
+
+                        lumaWord = *pWordLuma;
+                        pWordLuma += 2;
+                        if (row % 2 == 0) {
+                            chromaWord1 = *pWordChroma;
+                            pWordChroma += 2;
+                        }
+
+                        y[3] = ((lumaWord >> 24) & 0xff);
+                        y[2] = ((lumaWord >> 16) & 0xff);
+                        y[1] = ((lumaWord >>  8) & 0xff);
+                        y[0] = ((lumaWord >>  0) & 0xff);
+
+                        cb[0] = cb[1] = ((chromaWord1 >>  0) & 0xff);
+                        cb[2] = cb[3] = ((chromaWord1 >> 16) & 0xff);
+                        cr[0] = cr[1] = ((chromaWord1 >>  8) & 0xff);
+                        cr[2] = cr[3] = ((chromaWord1 >> 24) & 0xff);
+
+                        for (i = 0; i < 4; i++) {
+
+                            int32_t rW,gW,bW;
+
+                            rW = 298 * y[i] + 408 * cr[i] - 57059;
+                            gW = 298 * y[i] - 100 * cb[i] - 208 * cr[i] + 34713;
+                            bW = 298 * y[i] + 516 * cb[i] - 70887;
+
+                            if (rW < 0) {
+                                r[i] = 0;
+                            } else if (rW >= 65536) {
+                                r[i] = 255;
+                            } else {
+                                r[i] = (rW >> 8);
+                            }
+                            if (gW < 0) {
+                                g[i] = 0;
+                            } else if (gW >= 65536) {
+                                g[i] = 255;
+                            } else {
+                                g[i] = (gW >> 8);
+                            }
+                            if (bW < 0) {
+                                b[i] = 0;
+                            } else if (bW >= 65536) {
+                                b[i] = 255;
+                            } else {
+                                b[i] = (bW >> 8);
+                            }
+                            r[i] >>= 3;
+                            g[i] >>= 2;
+                            b[i] >>= 3;
+                        }
+                        for (i = 0; i < 4; i += 2) {
+
+                            // Check for cropping on the x axis
+                            OMX_U32 rowPos = (locBuf - (OMX_U32 *)dst.mBits) * 2 - dstRowOrigo;
+                            if (rowPos >= dst.mWidth) {
+                                locBuf++;
+                                continue;
+                            }
+
+                            rgbWord = (r[i + 1] << 27) +
+                                (g[i + 1] << 21) +
+                                (b[i + 1] << 16) +
+                                (r[i] << 11) +
+                                (g[i] << 5) +
+                                (b[i] << 0);
+                            *locBuf++ = rgbWord;
+                        }
+                        locBuf += dst.mWidth / 2 - 2;
+                        dstRowOrigo += dst.mWidth;
+                    } //end of for 16 loop
+                }  //end of 2 block loop
+                pBurstLuma += 32;
+                pBurstChroma += 16;
+            } // end of 2 col loop
+            pLuma   += 64;
+            pChroma += 32;
+        }
+    }
+
+    return OK;
+}
+#endif
+
 uint8_t *ColorConverter::initClip() {
     static const signed kClipMin = -278;
     static const signed kClipMax = 535;
diff --git a/media/libstagefright/foundation/ABitReader.cpp b/media/libstagefright/foundation/ABitReader.cpp
index 5499c32..10df728 100644
--- a/media/libstagefright/foundation/ABitReader.cpp
+++ b/media/libstagefright/foundation/ABitReader.cpp
@@ -22,7 +22,13 @@ namespace android {
 
 ABitReader::ABitReader(const uint8_t *data, size_t size)
     : mData(data),
+#ifdef STE_HARDWARE
+      mOriginalData(data),
+#endif
       mSize(size),
+#ifdef STE_HARDWARE
+      mOriginalSize(size),
+#endif
       mReservoir(0),
       mNumBitsLeft(0) {
 }
@@ -78,6 +84,21 @@ void ABitReader::skipBits(size_t n) {
     }
 }
 
+#ifdef STE_HARDWARE
+void ABitReader::rewindBits(size_t n) {
+    CHECK_GE(mOriginalSize * 8 - numBitsLeft(), n);
+
+    size_t bitsLeft = numBitsLeft();
+
+    mData = mOriginalData;
+    mSize = mOriginalSize;
+    mReservoir = 0;
+    mNumBitsLeft = 0;
+
+    skipBits(mOriginalSize * 8 - bitsLeft - n);
+}
+#endif
+
 void ABitReader::putBits(uint32_t x, size_t n) {
     CHECK_LE(n, 32u);
 
diff --git a/media/libstagefright/include/PCMExtractor.h b/media/libstagefright/include/PCMExtractor.h
new file mode 100644
index 0000000..eec7232
--- /dev/null
+++ b/media/libstagefright/include/PCMExtractor.h
@@ -0,0 +1,68 @@
+/*
+ * Copyright (C) ST-Ericsson SA 2010
+ * Copyright (C) 2010 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+ * Author: Andreas Gustafsson (andreas.a.gustafsson@stericsson.com)
+ *         for ST-Ericsson
+ */
+
+#ifndef PCM_EXTRACTOR_H_
+
+#define PCM_EXTRACTOR_H_
+
+#include <media/stagefright/MediaSource.h>
+#include <media/stagefright/MediaExtractor.h>
+
+using namespace android;
+
+namespace android {
+
+class DataSource;
+class String8;
+
+class PCMExtractor : public MediaExtractor {
+public:
+    // Extractor assumes ownership of "source".
+    PCMExtractor(const sp<DataSource> &source);
+
+    virtual size_t countTracks();
+    virtual sp<MediaSource> getTrack(size_t index);
+    virtual sp<MetaData> getTrackMetaData(size_t index, uint32_t flags);
+
+    virtual sp<MetaData> getMetaData();
+
+protected:
+    virtual ~PCMExtractor();
+
+private:
+    sp<DataSource> mDataSource;
+    status_t mInitCheck;
+    bool mValidFormat;
+    uint16_t mNumChannels;
+    uint32_t mSampleRate;
+    uint16_t mBitsPerSample;
+    off_t mDataOffset;
+    size_t mDataSize;
+    sp<MetaData> mTrackMeta;
+
+    status_t init();
+
+    PCMExtractor(const PCMExtractor &);
+    PCMExtractor &operator=(const PCMExtractor &);
+};
+
+}  // namespace android
+
+#endif  // PCM_EXTRACTOR_H_
diff --git a/media/libstagefright/omx/SoftOMXPlugin.cpp b/media/libstagefright/omx/SoftOMXPlugin.cpp
index 1e33f05..bc89092 100644
--- a/media/libstagefright/omx/SoftOMXPlugin.cpp
+++ b/media/libstagefright/omx/SoftOMXPlugin.cpp
@@ -34,6 +34,9 @@ static const struct {
     const char *mRole;
 
 } kComponents[] = {
+#ifdef STE_HARDWARE
+    { "OMX.ST.aac.decoder", "ste_aacdec", "audio_decoder.aac" },
+#endif
     { "OMX.google.aac.decoder", "aacdec", "audio_decoder.aac" },
     { "OMX.google.amrnb.decoder", "amrdec", "audio_decoder.amrnb" },
     { "OMX.google.amrwb.decoder", "amrdec", "audio_decoder.amrwb" },
@@ -42,6 +45,9 @@ static const struct {
     { "OMX.google.g711.mlaw.decoder", "g711dec", "audio_decoder.g711mlaw" },
     { "OMX.google.h263.decoder", "mpeg4dec", "video_decoder.h263" },
     { "OMX.google.mpeg4.decoder", "mpeg4dec", "video_decoder.mpeg4" },
+#ifdef STE_HARDWARE
+    { "OMX.ST.mp3.decoder", "ste_mp3dec", "audio_decoder.mp3" },
+#endif
     { "OMX.google.mp3.decoder", "mp3dec", "audio_decoder.mp3" },
     { "OMX.google.vorbis.decoder", "vorbisdec", "audio_decoder.vorbis" },
     { "OMX.google.vpx.decoder", "vpxdec", "video_decoder.vpx" },
diff --git a/media/libstagefright/rtsp/AMPEG4AudioAssembler.cpp b/media/libstagefright/rtsp/AMPEG4AudioAssembler.cpp
index 11d9c22..1e4fd55 100644
--- a/media/libstagefright/rtsp/AMPEG4AudioAssembler.cpp
+++ b/media/libstagefright/rtsp/AMPEG4AudioAssembler.cpp
@@ -201,6 +201,9 @@ static status_t parseAudioSpecificConfig(ABitReader *bits, sp<ABuffer> *asc) {
             CHECK_EQ(parseAudioObjectType(bits, &extensionAudioObjectType),
                      (status_t)OK);
 
+#ifdef STE_HARDWARE
+            if (extensionAudioObjectType == 5) {
+#endif
             sbrPresent = bits->getBits(1);
 
             if (sbrPresent == 1) {
@@ -208,6 +211,28 @@ static status_t parseAudioSpecificConfig(ABitReader *bits, sp<ABuffer> *asc) {
                 if (extensionSamplingFreqIndex == 0x0f) {
                     /* unsigned extensionSamplingFrequency = */bits->getBits(24);
                 }
+#ifdef STE_HARDWARE
+                    if (bits->numBitsLeft() >= 12) {
+                        syncExtensionType = bits->getBits(11);
+                        if (syncExtensionType == 0x548) {
+                            /* unsigned psPresent */bits->getBits(1);
+                        } else {
+                            // Rewind bitstream so that the reading of second
+                            // syncExtensionType has no effect
+                            bits->rewindBits(11);
+                        }
+                    }
+                }
+            } else if (extensionAudioObjectType == 22) {
+                sbrPresent = bits->getBits(1);
+                if (sbrPresent == 1) {
+                    unsigned extensionSamplingFreqIndex = bits->getBits(4);
+                    if (extensionSamplingFreqIndex == 0x0f) {
+                        /* unsigned extensionSamplingFrequency = */bits->getBits(24);
+                    }
+                }
+                /* unsigned extensionChannelConfiguration = */bits->getBits(4);
+#endif
             }
 
             size_t numBitsInExtension =
@@ -223,7 +248,12 @@ static status_t parseAudioSpecificConfig(ABitReader *bits, sp<ABuffer> *asc) {
                 bits->skipBits(8 - (numBitsInExtension & 7));
             }
         } else {
+#ifdef STE_HARDWARE
+            bits->rewindBits(11);
+#else
             bits->putBits(syncExtensionType, 11);
+#endif
+
         }
     }
 
@@ -335,11 +365,18 @@ static status_t parseStreamMuxConfig(
             break;
     }
 
+#ifdef STE_HARDWARE
+    status_t parseResult = OK;
+#endif
     *otherDataPresent = bits->getBits(1);
     *otherDataLenBits = 0;
     if (*otherDataPresent) {
         if (audioMuxVersion == 1) {
             TRESPASS();  // XXX to be implemented
+#ifdef STE_HARDWARE
+        } else if (bits->numBitsLeft() < 9) {
+            parseResult = ERROR_MALFORMED;
+#endif
         } else {
             *otherDataLenBits = 0;
 
@@ -349,14 +386,57 @@ static status_t parseStreamMuxConfig(
                 otherDataLenEsc = bits->getBits(1);
                 unsigned otherDataLenTmp = bits->getBits(8);
                 (*otherDataLenBits) += otherDataLenTmp;
+#ifdef STE_HARDWARE
+            } while (otherDataLenEsc && bits->numBitsLeft() >= 9);
+
+            if (otherDataLenEsc) {
+                parseResult = ERROR_MALFORMED;
+            }
+        }
+    }
+
+    if (parseResult == OK && bits->numBitsLeft() >= 1) {
+        unsigned crcCheckPresent = bits->getBits(1);
+        if (crcCheckPresent && bits->numBitsLeft() >= 8) {
+            /* unsigned crcCheckSum = */bits->getBits(8);
+        } else if (crcCheckPresent && bits->numBitsLeft() < 8) {
+            parseResult = ERROR_MALFORMED;
+        }
+    } else {
+        parseResult = ERROR_MALFORMED;
+    }
+
+    // Verify that only bits are left for byte aligning and that
+    // any remaining bits are 0
+    if (bits->numBitsLeft() / 8 > 0) {
+        parseResult = ERROR_MALFORMED;
+    } else {
+        unsigned remainder = bits->getBits(bits->numBitsLeft());
+        if (remainder != 0) {
+            parseResult = ERROR_MALFORMED;
+#else
             } while (otherDataLenEsc);
+#endif
         }
     }
 
+#ifdef STE_HARDWARE
+    // Check if config string parsing has failed (then probably due to a
+    // malformed AudioSpecificConfig) and if so, assume most common
+    // configuration for the variables after AudioSpecificConfig.
+    if (parseResult != OK) {
+        LOGW("LATM config string parsing has failed, assuming most common case "
+             "of frameLengthType=0, otherDataPresent=0, and otherDataLenBits=0");
+        *frameLengthType = 0;
+        *otherDataPresent = 0;
+        *otherDataLenBits = 0;
+    }
+#else
     unsigned crcCheckPresent = bits->getBits(1);
     if (crcCheckPresent) {
         /* unsigned crcCheckSum = */bits->getBits(8);
     }
+#endif
 
     return OK;
 }
diff --git a/opengl/include/GLES2/gl2ext.h b/opengl/include/GLES2/gl2ext.h
index 82befc2..3bc017a 100644
--- a/opengl/include/GLES2/gl2ext.h
+++ b/opengl/include/GLES2/gl2ext.h
@@ -195,6 +195,19 @@ typedef void* GLeglImageOES;
 #define GL_Z400_BINARY_AMD                                      0x8740
 #endif
 
+#ifdef STE_HARDWARE
+/*------------------------------------------------------------------------*
+ * ARM extension tokens
+ *------------------------------------------------------------------------*/
+
+/* GL_ARM_mali_shader_binary */
+#ifndef GL_ARM_mali_shader_binary
+#define GL_MALI_SHADER_BINARY_ARM                               0x8F60
+#endif
+/* GL_ARM_rgba8 */
+/* No new tokens introduced by this extension. */
+#endif
+
 /*------------------------------------------------------------------------*
  * EXT extension tokens
  *------------------------------------------------------------------------*/
@@ -610,6 +623,22 @@ typedef void (GL_APIENTRYP PFNGLGETPERFMONITORCOUNTERDATAAMDPROC) (GLuint monito
 #define GL_AMD_program_binary_Z400 1
 #endif
 
+
+#ifdef STE_hARDWARE
+/*------------------------------------------------------------------------*
+ * ARM extension functions
+ *------------------------------------------------------------------------*/
+
+/* GL_ARM_mali_shader_binary */
+#ifndef GL_ARM_mali_shader_binary
+#define GL_ARM_mali_shader_binary 1
+#endif
+
+/* GL_ARM_rgba8 */
+#ifndef GL_ARM_rgba8
+#define GL_ARM_rgba8 1
+#endif
+#endif
 /*------------------------------------------------------------------------*
  * EXT extension functions
  *------------------------------------------------------------------------*/
diff --git a/preloaded-classes b/preloaded-classes
index c29ba15..2cd3e15 100644
--- a/preloaded-classes
+++ b/preloaded-classes
@@ -652,6 +652,10 @@ android.provider.Settings$NameValueCache
 android.provider.Settings$NameValueTable
 android.provider.Settings$Secure
 android.provider.Settings$System
+# BEGIN privacy-added
+android.privacy.PrivacySettingsManager
+android.privacy.PrivacySettings
+# END privacy-added
 android.renderscript.RenderScript
 android.server.BluetoothA2dpService
 android.server.BluetoothEventLoop
diff --git a/privacy/java/android/privacy/IPrivacySettingsManager.aidl b/privacy/java/android/privacy/IPrivacySettingsManager.aidl
new file mode 100644
index 0000000..97f4837
--- /dev/null
+++ b/privacy/java/android/privacy/IPrivacySettingsManager.aidl
@@ -0,0 +1,18 @@
+package android.privacy;
+import android.privacy.PrivacySettings;
+
+/** {@hide} */
+interface IPrivacySettingsManager
+{
+    PrivacySettings getSettings(String packageName);
+    boolean saveSettings(in PrivacySettings settings);
+    boolean deleteSettings(String packageName);
+    void notification(String packageName, byte accessMode, String dataType, String output);
+    void registerObservers();
+    void addObserver(String packageName);
+    boolean purgeSettings();
+    double getVersion();
+    boolean setEnabled(boolean enable);
+    boolean setNotificationsEnabled(boolean enable);
+    void setBootCompleted();
+}
diff --git a/privacy/java/android/privacy/PrivacyFileObserver.java b/privacy/java/android/privacy/PrivacyFileObserver.java
new file mode 100644
index 0000000..ce83468
--- /dev/null
+++ b/privacy/java/android/privacy/PrivacyFileObserver.java
@@ -0,0 +1,89 @@
+package android.privacy;
+
+import android.os.FileObserver;
+import android.util.Log;
+
+import java.io.File;
+import java.util.HashMap;
+import java.util.StringTokenizer;
+
+/** {@hide} */
+public class PrivacyFileObserver extends FileObserver {
+    
+    public static final String TAG = "PrivacyFileObserver";
+    
+    public static final int PACKAGE_PATH_INDEX = 3;
+    
+    public String absolutePath;
+    
+    private PrivacySettingsManagerService pSetManServ;
+    
+    public HashMap<String, PrivacyFileObserver> children; 
+    
+    public PrivacyFileObserver(String path, PrivacySettingsManagerService pSetManServ) {
+        super(path, FileObserver.ALL_EVENTS);
+        this.absolutePath = path;
+        this.pSetManServ = pSetManServ;
+        
+        this.children = new HashMap<String, PrivacyFileObserver>();
+        File thisFile = new File(absolutePath);
+        if (thisFile.isDirectory()) {
+            File[] subfiles = thisFile.listFiles();
+            for (File file : subfiles) {
+                String observePath = file.getAbsolutePath();
+                PrivacyFileObserver child = new PrivacyFileObserver(observePath, pSetManServ);
+                children.put(observePath, child);
+                // don't watch directories, only the settings files
+                if (file.isFile()) child.startWatching();
+            }
+        }
+        
+    }
+
+    @Override
+    public void onEvent(int event, String path) {
+        if ((FileObserver.ACCESS & event) != 0) { // data was read from a file
+//            Log.d(TAG, "onEvent - file accessed: " + absolutePath);
+            StringTokenizer tokenizer = new StringTokenizer(absolutePath, "/");
+            for (int i = 0; i < PACKAGE_PATH_INDEX && tokenizer.hasMoreElements(); i++) {
+                tokenizer.nextToken();
+            }
+            
+            // get the package and UID of accessing application
+            String packageName = tokenizer.nextToken();
+//            int uid = 0;
+//            try {
+//                uid = Integer.parseInt(tokenizer.nextToken());
+//            } catch (NumberFormatException e) {
+//                Log.e(TAG, "onEvent - could not get the UID of accessing application", e);
+//                // we still can continue, UID is optional here
+//            }
+            
+            // read the setting
+            PrivacySettings pSet = pSetManServ.getSettings(packageName);
+            pSetManServ.notification(packageName, pSet.getSystemLogsSetting(), PrivacySettings.DATA_SYSTEM_LOGS, null);
+        }
+        
+    }
+    
+    public void addObserver(String relativePath) {
+        String observePath = absolutePath + "/" + relativePath;
+        // remove existing observer(s) if any
+        children.remove(observePath); // child observers should be destroyed at next GC
+        // create new observer(s)
+        PrivacyFileObserver child = new PrivacyFileObserver(observePath, pSetManServ);
+        children.put(observePath, child);
+    }
+
+    @Override
+    public void startWatching() {
+//        Log.d("PrivacyFileObserver", "PrivacyFileObserver - observing directory: " + absolutePath);
+        super.startWatching();
+    }
+    
+//    public void verifyObserver() {
+//        Log.d(TAG, "verifyObservers - observer path: " + absolutePath);
+//        for (PrivacyFileObserver obs : children.values()) obs.verifyObserver();
+//    }
+    
+}
\ No newline at end of file
diff --git a/privacy/java/android/privacy/PrivacyPersistenceAdapter.java b/privacy/java/android/privacy/PrivacyPersistenceAdapter.java
new file mode 100644
index 0000000..8e0ed44
--- /dev/null
+++ b/privacy/java/android/privacy/PrivacyPersistenceAdapter.java
@@ -0,0 +1,792 @@
+package android.privacy;
+
+import android.content.ContentValues;
+import android.content.Context;
+import android.content.pm.ApplicationInfo;
+import android.content.pm.PackageManager;
+import android.database.Cursor;
+import android.database.SQLException;
+import android.database.sqlite.SQLiteDatabase;
+import android.database.sqlite.SQLiteException;
+import android.os.FileUtils;
+import android.util.Log;
+
+import java.io.File;
+import java.io.FileOutputStream;
+import java.io.IOException;
+import java.io.OutputStreamWriter;
+import java.util.ArrayList;
+import java.util.List;
+
+/**
+ * Responsible for persisting privacy settings to built-in memory
+ * @author Svyatoslav Hresyk
+ * {@hide}
+ */
+public class PrivacyPersistenceAdapter {
+
+    private static final String TAG = "PrivacyPersistenceAdapter";
+    
+    private static final int RETRY_QUERY_COUNT = 5;
+
+    private static final String DATABASE_FILE = "/data/system/privacy.db";
+    
+    private static final int DATABASE_VERSION = 3;
+    
+    public static final int DUMMY_UID = -1;
+    
+    /**
+     * Number of threads currently reading the database
+     */
+    public static Integer readingThreads = 0;
+    
+    /**
+     * Used to save settings for access from core libraries
+     */
+    public static final String SETTINGS_DIRECTORY = "/data/system/privacy";
+
+    private static final String TABLE_SETTINGS = "settings";
+    
+    private static final String TABLE_MAP = "map";
+    
+    private static final String TABLE_ALLOWED_CONTACTS = "allowed_contacts";
+    
+    private static final String TABLE_VERSION = "version";
+    
+    private static final String CREATE_TABLE_SETTINGS = 
+        "CREATE TABLE IF NOT EXISTS " + TABLE_SETTINGS + " ( " + 
+        " _id INTEGER PRIMARY KEY AUTOINCREMENT, " + 
+        " packageName TEXT, " + 
+        " uid INTEGER, " + 
+        " deviceIdSetting INTEGER, " + 
+        " deviceId TEXT, " + 
+        " line1NumberSetting INTEGER, " + 
+        " line1Number TEXT, " + 
+        " locationGpsSetting INTEGER, " + 
+        " locationGpsLat TEXT, " + 
+        " locationGpsLon TEXT, " + 
+        " locationNetworkSetting INTEGER, " + 
+        " locationNetworkLat TEXT, " + 
+        " locationNetworkLon TEXT, " + 
+        " networkInfoSetting INTEGER, " + 
+        " simInfoSetting INTEGER, " + 
+        " simSerialNumberSetting INTEGER, " + 
+        " simSerialNumber TEXT, " + 
+        " subscriberIdSetting INTEGER, " + 
+        " subscriberId TEXT, " + 
+        " accountsSetting INTEGER, " + 
+        " accountsAuthTokensSetting INTEGER, " + 
+        " outgoingCallsSetting INTEGER, " + 
+        " incomingCallsSetting INTEGER, " + 
+        " contactsSetting INTEGER, " + 
+        " calendarSetting INTEGER, " + 
+        " mmsSetting INTEGER, " + 
+        " smsSetting INTEGER, " + 
+        " callLogSetting INTEGER, " + 
+        " bookmarksSetting INTEGER, " + 
+        " systemLogsSetting INTEGER, " + 
+        " externalStorageSetting INTEGER, " + 
+        " cameraSetting INTEGER, " + 
+        " recordAudioSetting INTEGER, " + 
+        " notificationSetting INTEGER, " + 
+        " intentBootCompletedSetting INTEGER" + 
+        ");";
+    
+    private static final String CREATE_TABLE_MAP = 
+        "CREATE TABLE IF NOT EXISTS " + TABLE_MAP + " ( name TEXT PRIMARY KEY, value TEXT );";
+    
+    private static final String CREATE_TABLE_ALLOWED_CONTACTS = 
+        "CREATE TABLE IF NOT EXISTS " + TABLE_ALLOWED_CONTACTS + " ( settings_id, contact_id, PRIMARY KEY(settings_id, contact_id) );";
+    
+    private static final String INSERT_VERSION = 
+        "INSERT OR REPLACE INTO " + TABLE_MAP + " (name, value) " + "VALUES (\"db_version\", " + DATABASE_VERSION + ");";
+    
+    private static final String INSERT_ENABLED = 
+        "INSERT OR REPLACE INTO " + TABLE_MAP + " (name, value) " + "VALUES (\"enabled\", \"1\");";
+    
+    private static final String INSERT_NOTIFICATIONS_ENABLED = 
+        "INSERT OR REPLACE INTO " + TABLE_MAP + " (name, value) " + "VALUES (\"notifications_enabled\", \"1\");";
+    
+    private static final String[] DATABASE_FIELDS = new String[] { "_id", "packageName", "uid", 
+        "deviceIdSetting", "deviceId", "line1NumberSetting", "line1Number", "locationGpsSetting", 
+        "locationGpsLat", "locationGpsLon", "locationNetworkSetting", "locationNetworkLat", 
+        "locationNetworkLon", "networkInfoSetting", "simInfoSetting", "simSerialNumberSetting", 
+        "simSerialNumber", "subscriberIdSetting", "subscriberId", "accountsSetting", "accountsAuthTokensSetting", 
+        "outgoingCallsSetting", "incomingCallsSetting", "contactsSetting", "calendarSetting", 
+        "mmsSetting", "smsSetting", "callLogSetting", "bookmarksSetting", "systemLogsSetting", 
+        "externalStorageSetting", "cameraSetting", "recordAudioSetting", "notificationSetting", 
+        "intentBootCompletedSetting" };
+    
+    public static final String SETTING_ENABLED = "enabled";
+    public static final String SETTING_NOTIFICATIONS_ENABLED = "notifications_enabled";
+    public static final String SETTING_DB_VERSION = "db_version";
+    public static final String VALUE_TRUE = "1";
+    public static final String VALUE_FALSE = "0";
+
+    private SQLiteDatabase db;
+    
+    private Context context;
+
+    public PrivacyPersistenceAdapter(Context context) {
+        this.context = context;
+        // check write permission for /data/system/
+        boolean canWrite = new File("/data/system/").canWrite();
+//        Log.d(TAG, "Constructing " + TAG + " for package: " +  context.getPackageName() + 
+//                " UID: " + Binder.getCallingUid() + "; Write permission for /data/system/: " + canWrite);
+        // create the database and settings directory if we have write permission and they do not exist
+        if (canWrite) {
+            if (!new File(DATABASE_FILE).exists()) createDatabase();
+            if (!new File(SETTINGS_DIRECTORY).exists()) createSettingsDir();
+            // upgrade if needed
+            int currentVersion = getDbVersion();
+//            Log.d(TAG, "PrivacyPersistenceAdapter - current DB version: " + currentVersion);
+            if (currentVersion < DATABASE_VERSION) upgradeDatabase(currentVersion);
+        }
+    }
+
+    private synchronized void upgradeDatabase(int currentVersion) {
+        Log.i(TAG, "upgradeDatabase - upgrading DB from version " + currentVersion + " to " + DATABASE_VERSION);
+        
+        // backup current database file
+        File dbFile = new File(DATABASE_FILE);
+        File dbBackupFile = new File(DATABASE_FILE + ".bak");
+        // remove old backup
+        try {
+            dbBackupFile.delete();
+        } catch (SecurityException e) {
+            Log.w(TAG, "upgradeDatabase - could not remove old backup");
+        }
+        // backup current DB file
+        FileUtils.copyFile(dbFile, dbBackupFile);
+        // make sure a backup was created
+        if (System.currentTimeMillis() - dbBackupFile.lastModified() > 2000) {
+            Log.e(TAG, "upgradeDatabase - could not create a database backup, aborting...");
+            return;
+        }
+        
+        SQLiteDatabase db = getWritableDatabase();
+        db.beginTransaction();
+        
+        switch (currentVersion) {
+            case 1:
+            case 2:
+                try {
+                    if (db != null && db.isOpen()) {
+                        db.execSQL("DROP TABLE IF EXISTS " + TABLE_VERSION + ";");
+                        db.execSQL(CREATE_TABLE_ALLOWED_CONTACTS); 
+                        db.execSQL(CREATE_TABLE_MAP);
+                        db.execSQL(INSERT_VERSION);
+                        db.execSQL(INSERT_ENABLED);
+                        db.execSQL(INSERT_NOTIFICATIONS_ENABLED);
+                        
+                        // remove uid dirs from the settings directory
+                        File settingsDir = new File(SETTINGS_DIRECTORY);
+                        for (File packageDir : settingsDir.listFiles()) {
+                            for (File uidDir : packageDir.listFiles()) {
+                                if (uidDir.isDirectory()) {
+                                    File[] settingsFiles = uidDir.listFiles();
+                                    // copy the first found (most likely the only one) one level up
+                                    if (settingsFiles[0] != null) {
+                                        File newPath = new File(packageDir + "/" + settingsFiles[0].getName());
+                                        newPath.delete();
+                                        settingsFiles[0].renameTo(newPath);
+                                        deleteRecursive(uidDir);
+                                    }
+                                }
+                            }
+                        }
+                        
+                        db.setTransactionSuccessful();
+                    }
+                } catch (Exception e) {
+                    if (db != null && db.isOpen()) {
+                        db.endTransaction();
+                        db.close();
+                    }
+                    Log.w(TAG, "upgradeDatabase - could not upgrade DB; will restore backup", e);
+                    FileUtils.copyFile(dbBackupFile, dbFile);
+                    dbBackupFile.delete();
+                }
+                
+                
+                break;
+                
+            case 3:
+                // most current version, do nothing
+                Log.w(TAG, "upgradeDatabase - trying to upgrade most current DB version");
+                break;
+        }
+        
+        if (db != null && db.isOpen()) {
+            db.endTransaction();
+            db.close();
+        } else {
+            Log.e(TAG, "upgradeDatabase - database is null or closed; cant call endTransaction()");
+        }
+        
+        purgeSettings();
+    }
+    
+    private int getDbVersion() {
+        int version = -1;
+        // check if the table "map" exists; if it doesn't -> return version 1
+        readingThreads++;
+        SQLiteDatabase db = getReadableDatabase();
+        try {
+            Cursor c = rawQuery(db, "SELECT name FROM sqlite_master WHERE type='table' AND name='" + TABLE_MAP + "';");
+            if (c != null) {
+                if (c.getCount() == 0) {
+                    // table map does not exist
+                    version = 1;
+                }
+                c.close();
+                synchronized (readingThreads) {
+                    readingThreads--;
+                    // only close DB if no other threads are reading
+                    if (readingThreads == 0 && db != null && db.isOpen()) {
+                        db.close();
+                    }
+                }
+            } else {
+                Log.e(TAG, "getDbVersion - failed to check if table map exists (cursor is null)");
+            }
+        } catch (Exception e) {
+            Log.e(TAG, "getDbVersion - failed to check if table map exists (exception)");
+        }
+        if (version == 1) return version;
+        
+        String versionString = getValue(SETTING_DB_VERSION);
+        if (versionString == null) return 1;
+        
+        int versionNum;
+        try {
+            versionNum = Integer.parseInt(versionString);
+        } catch (Exception e) {
+            Log.e(TAG, "getDbVersion - failed to parse database version; returning 1");
+            return 1;
+        }
+        
+        return versionNum;
+    }
+    
+    public String getValue(String name) {
+        readingThreads++;
+        SQLiteDatabase db = getReadableDatabase();
+        Cursor c;
+        String output = null;
+        
+        try {
+            c = query(db, TABLE_MAP, new String[] { "value" }, "name=?", 
+                    new String[] { name }, null, null, null, null);
+            if (c != null && c.getCount() > 0 && c.moveToFirst()) {
+                output = c.getString(c.getColumnIndex("value"));
+                c.close();
+            } else {
+                Log.w(TAG, "getValue - could not get value for name: " + name);
+            }
+        } catch (Exception e) {
+            Log.w(TAG, "getValue - could not get value for name: " + name, e);
+        }
+        
+        synchronized (readingThreads) {
+            readingThreads--;
+            // only close DB if no other threads are reading
+            if (readingThreads == 0 && db != null && db.isOpen()) {
+                db.close();
+            }
+        }
+        return output;
+    }
+    
+    public synchronized boolean setValue(String name, String value) {
+        Log.e(TAG, "setValue - name " + name + " value " + value);
+        ContentValues values = new ContentValues();
+        values.put("name", name);
+        values.put("value", value);
+        SQLiteDatabase db = getWritableDatabase();
+        boolean success = db.replace(TABLE_MAP, null, values) != -1;
+        if (readingThreads == 0 && db != null && db.isOpen()) db.close();
+        return success;
+    }
+    
+    public synchronized PrivacySettings getSettings(String packageName, boolean forceCloseDB) {
+        PrivacySettings s = null;
+        
+        if (packageName == null) {
+            Log.e(TAG, "getSettings - insufficient application identifier - package name is required");
+            return s;
+        }
+        
+        // indicate that the DB is being read to prevent closing by other threads
+        readingThreads++;
+//        Log.d(TAG, "getSettings - settings request for package: " + packageName + " readingThreads: " + readingThreads);
+        
+        SQLiteDatabase db;
+        try {
+            db = getReadableDatabase();
+        } catch (SQLiteException e) {
+            Log.e(TAG, "getSettings - database could not be opened", e);
+            readingThreads--;
+            return s;
+        }
+            
+        Cursor c = null;
+
+        try {
+            c = query(db, TABLE_SETTINGS, DATABASE_FIELDS, "packageName=?", new String[] { packageName }, null, null, null, null);
+
+            if (c != null && c.moveToFirst()) {
+                s = new PrivacySettings(c.getInt(0), c.getString(1), c.getInt(2), (byte)c.getShort(3), c.getString(4), 
+                        (byte)c.getShort(5), c.getString(6), (byte)c.getShort(7), c.getString(8), c.getString(9), (byte)c.getShort(10), 
+                        c.getString(11), c.getString(12), (byte)c.getShort(13), (byte)c.getShort(14), (byte)c.getShort(15), 
+                        c.getString(16), (byte)c.getShort(17), c.getString(18), (byte)c.getShort(19), (byte)c.getShort(20), 
+                        (byte)c.getShort(21), (byte)c.getShort(22), (byte)c.getShort(23), (byte)c.getShort(24), (byte)c.getShort(25), 
+                        (byte)c.getShort(26), (byte)c.getShort(27), (byte)c.getShort(28), (byte)c.getShort(29), (byte)c.getShort(30), 
+                        (byte)c.getShort(31), (byte)c.getShort(32), (byte)c.getShort(33), (byte)c.getShort(34), null);
+                
+                // get allowed contacts IDs if necessary
+//                Log.d(TAG, "getSettings - looking for allowed contacts for " + s.get_id());
+//                c = query(db, TABLE_ALLOWED_CONTACTS, null, 
+//                        "settings_id=?", new String[] { Integer.toString(s.get_id()) }, null, null, null, null);
+                c = rawQuery(db, "SELECT * FROM allowed_contacts WHERE settings_id=" + Integer.toString(s.get_id()) + ";");
+                
+                if (c != null && c.getCount() > 0) {
+//                    Log.d(TAG, "getSettings - found allowed contacts");
+                    int[] allowedContacts = new int[c.getCount()];
+                    while (c.moveToNext()) allowedContacts[c.getPosition()] = c.getInt(1);
+                    s.setAllowedContacts(allowedContacts);
+                }
+//                    Log.d(TAG, "getSettings - found settings entry for package: " + packageName + " UID: " + uid);
+            } 
+//            else {
+//                Log.e(TAG, "getSettings - no settings found for package: " + packageName);
+//            }
+        } catch (Exception e) {
+            Log.e(TAG, "getSettings - failed to get settings for package: " + packageName, e);
+            e.printStackTrace();
+            if (c != null) c.close();
+        } finally {
+            if (c != null) c.close();
+//            if (forceCloseDB && db != null && db.isOpen()) {
+//                db.close();
+//            } else {
+            synchronized (readingThreads) {
+                readingThreads--;
+                // only close DB if no other threads are reading
+                if (readingThreads == 0 && db != null && db.isOpen()) {
+                    db.close();
+                }
+            }
+//            }
+        }
+        
+//        Log.d(TAG, "getSettings - returning settings: " + s);
+        return s;
+    }
+    
+    /**
+     * Saves the settings object fields into DB and into plain text files where applicable. 
+     * The DB changes will not be made persistent if saving settings to plain text files
+     * fails.
+     * @param s settings object
+     * @return true if settings were saved successfully, false otherwise
+     */
+    public synchronized boolean saveSettings(PrivacySettings s) {
+        boolean result = true;
+        String packageName = s.getPackageName();
+//        Integer uid = s.getUid();
+//        Log.d(TAG, "saveSettings - settings save request : " + s);
+        
+        if (packageName == null || packageName.isEmpty()/* || uid == null*/) {
+            Log.e(TAG, "saveSettings - either package name, UID or both is missing");
+            return false;
+        }
+
+        ContentValues values = new ContentValues();
+        values.put("packageName", packageName);
+//        values.put("uid", uid);
+        values.put("uid", DUMMY_UID);
+        
+        values.put("deviceIdSetting", s.getDeviceIdSetting());
+        values.put("deviceId", s.getDeviceId());
+        
+        values.put("line1NumberSetting", s.getLine1NumberSetting());
+        values.put("line1Number", s.getLine1Number());
+        
+        values.put("locationGpsSetting", s.getLocationGpsSetting());
+        values.put("locationGpsLat", s.getLocationGpsLat());
+        values.put("locationGpsLon", s.getLocationGpsLon());
+        
+        values.put("locationNetworkSetting", s.getLocationNetworkSetting());
+        values.put("locationNetworkLat", s.getLocationNetworkLat());
+        values.put("locationNetworkLon", s.getLocationNetworkLon());
+        
+        values.put("networkInfoSetting", s.getNetworkInfoSetting());        
+        values.put("simInfoSetting", s.getSimInfoSetting());
+        
+        values.put("simSerialNumberSetting", s.getSimSerialNumberSetting());        
+        values.put("simSerialNumber", s.getSimSerialNumber());
+        values.put("subscriberIdSetting", s.getSubscriberIdSetting());        
+        values.put("subscriberId", s.getSubscriberId());
+        
+        values.put("accountsSetting", s.getAccountsSetting());
+        values.put("accountsAuthTokensSetting", s.getAccountsAuthTokensSetting());
+        values.put("outgoingCallsSetting", s.getOutgoingCallsSetting());
+        values.put("incomingCallsSetting", s.getIncomingCallsSetting());
+        
+        values.put("contactsSetting", s.getContactsSetting());
+        values.put("calendarSetting", s.getCalendarSetting());
+        values.put("mmsSetting", s.getMmsSetting());
+        values.put("smsSetting", s.getSmsSetting());
+        values.put("callLogSetting", s.getCallLogSetting());
+        values.put("bookmarksSetting", s.getBookmarksSetting());
+        values.put("systemLogsSetting", s.getSystemLogsSetting());
+        values.put("notificationSetting", s.getNotificationSetting());
+        values.put("intentBootCompletedSetting", s.getIntentBootCompletedSetting());
+//        values.put("externalStorageSetting", s.getExternalStorageSetting());
+//        values.put("cameraSetting", s.getCameraSetting());
+//        values.put("recordAudioSetting", s.getRecordAudioSetting());
+        
+        readingThreads++;
+        SQLiteDatabase db = getWritableDatabase();
+        db.beginTransaction(); // make sure this ends up in a consistent state (DB and plain text files)
+        Cursor c = null;
+        try {
+            // save settings to the DB
+//            Log.d(TAG, "saveSettings - checking if entry exists already");
+            Integer id = s.get_id();
+            if (id != null) { // existing entry -> update
+//                Log.d(TAG, "saveSettings - updating existing entry");
+                if (db.update(TABLE_SETTINGS, values, "_id=?", new String[] { id.toString() }) < 1) {
+                    throw new Exception("saveSettings - failed to update database entry");
+                }
+                
+                db.delete(TABLE_ALLOWED_CONTACTS, "settings_id=?", new String[] { id.toString() });
+                int[] allowedContacts = s.getAllowedContacts();
+                if (allowedContacts != null) {
+                    ContentValues contactsValues = new ContentValues();
+                    for (int i = 0; i < allowedContacts.length; i++) {
+                        contactsValues.put("settings_id", id);
+                        contactsValues.put("contact_id", allowedContacts[i]);
+                        if (db.insert(TABLE_ALLOWED_CONTACTS, null, contactsValues) == -1)
+                            throw new Exception("saveSettings - failed to update database entry (contacts)");
+                    }
+                }
+
+            } else { // new entry -> insert if no duplicates exist
+//                Log.d(TAG, "saveSettings - new entry; verifying if duplicates exist");
+                c = db.query(TABLE_SETTINGS, new String[] { "_id" }, "packageName=?", 
+                        new String[] { s.getPackageName() }, null, null, null);
+                
+                if (c != null) {
+                    if (c.getCount() == 1) { // exactly one entry
+                        // exists -> update
+//                        Log.d(TAG, "saveSettings - updating existing entry");
+                        if (db.update(TABLE_SETTINGS, values, "packageName=?", 
+                                new String[] { s.getPackageName() }) < 1) {
+                            throw new Exception("saveSettings - failed to update database entry");
+                        }
+                        
+                        if (c.moveToFirst()) {
+                            Integer idAlt = c.getInt(0); // id of the found duplicate entry
+                            db.delete(TABLE_ALLOWED_CONTACTS, "settings_id=?", new String[] { idAlt.toString() });
+                            int[] allowedContacts = s.getAllowedContacts();
+                            if (allowedContacts != null) {
+                                ContentValues contactsValues = new ContentValues();
+                                for (int i = 0; i < allowedContacts.length; i++) {
+                                    contactsValues.put("settings_id", idAlt);
+                                    contactsValues.put("contact_id", allowedContacts[i]);
+                                    if (db.insert(TABLE_ALLOWED_CONTACTS, null, contactsValues) == -1)
+                                        throw new Exception("saveSettings - failed to update database entry (contacts)");
+                                }
+                            }    
+                        }
+                    } else if (c.getCount() == 0) { // no entries -> insert
+//                        Log.d(TAG, "saveSettings - inserting new entry");
+                        long rowId = db.insert(TABLE_SETTINGS, null, values);
+                        if (rowId == -1) {
+                            throw new Exception("saveSettings - failed to insert new record into DB");
+                        }
+                        
+                        db.delete(TABLE_ALLOWED_CONTACTS, "settings_id=?", new String[] { Long.toString(rowId) });
+                        int[] allowedContacts = s.getAllowedContacts();
+                        if (allowedContacts != null) {
+                            ContentValues contactsValues = new ContentValues();
+                            for (int i = 0; i < allowedContacts.length; i++) {
+                                contactsValues.put("settings_id", rowId);
+                                contactsValues.put("contact_id", allowedContacts[i]);
+                                if (db.insert(TABLE_ALLOWED_CONTACTS, null, contactsValues) == -1)
+                                    throw new Exception("saveSettings - failed to update database entry (contacts)");
+                            }
+                        }                        
+                    } else { // something went totally wrong and there are multiple entries for same identifier
+                        result = false;
+                        throw new Exception("saveSettings - duplicate entries in the privacy.db");
+                    }
+                } else {
+                    result = false;
+                    // jump to catch block to avoid marking transaction as successful
+                    throw new Exception("saveSettings - cursor is null, database access failed");
+                }
+            }
+            
+            // save settings to plain text file (for access from core libraries)
+//            Log.d(TAG, "saveSettings - saving to plain text file");
+//            File settingsUidDir = new File("/data/system/privacy/" + packageName + "/" + uid + "/");
+            File settingsPackageDir = new File("/data/system/privacy/" + packageName + "/");
+            File systemLogsSettingFile = new File("/data/system/privacy/" + packageName + "/" + "/systemLogsSetting");
+            try {
+                // create all parent directories on the file path
+//                settingsUidDir.mkdirs();
+                // make the directory readable (requires it to be executable as well)
+//                settingsUidDir.setReadable(true, false);
+//                settingsUidDir.setExecutable(true, false);
+                // make the parent directory readable (requires it to be executable as well)
+                settingsPackageDir.mkdirs();
+                settingsPackageDir.setReadable(true, false);
+                settingsPackageDir.setExecutable(true, false);
+                // create the setting files and make them readable
+                systemLogsSettingFile.createNewFile();
+                systemLogsSettingFile.setReadable(true, false);
+                // write settings to files
+//                Log.d(TAG, "saveSettings - writing to file");
+                OutputStreamWriter writer = new OutputStreamWriter(new FileOutputStream(systemLogsSettingFile));
+                writer.append(s.getSystemLogsSetting() + "");
+                writer.flush();
+                writer.close();
+            } catch (IOException e) {
+                result = false;
+                // jump to catch block to avoid marking transaction as successful
+                throw new Exception("saveSettings - could not write settings to file", e);
+            }
+            // mark DB transaction successful (commit the changes)
+            db.setTransactionSuccessful();
+//            Log.d(TAG, "saveSettings - completing transaction");
+        } catch (Exception e) {
+            result = false;
+//            Log.d(TAG, "saveSettings - could not save settings", e);
+        } finally {
+            db.endTransaction();
+            if (c != null) c.close();
+            synchronized (readingThreads) {
+                readingThreads--;
+                // only close DB if no other threads are reading
+                if (readingThreads == 0 && db != null && db.isOpen()) {
+                    db.close();
+                }
+            }
+        }
+
+        return result;
+    }
+    
+    /**
+     * Deletes a settings entry from the DB
+     * @return true if settings were deleted successfully, false otherwise
+     */
+    public synchronized boolean deleteSettings(String packageName) {
+        boolean result = true;
+        
+        SQLiteDatabase db = getWritableDatabase();
+        db.beginTransaction(); // make sure this ends up in a consistent state (DB and plain text files)
+        try {
+//            Log.d(TAG, "deleteSettings - deleting database entry for " + packageName + " (" + uid + ")");
+            // try deleting contacts allowed entries; do not fail if deletion not possible
+            Cursor c = db.query(TABLE_SETTINGS, new String[] { "_id" }, "packageName=?", 
+                    new String[] { packageName }, null, null, null);
+            if (c != null && c.getCount() > 0 && c.moveToFirst()) {
+                int id = c.getInt(0);
+                db.delete(TABLE_ALLOWED_CONTACTS, "settings_id=?", new String[] { Integer.toString(id) });
+                c.close();
+            }
+            
+            if (db.delete(TABLE_SETTINGS, "packageName=?", new String[] { packageName }) == 0) {
+                Log.e(TAG, "deleteSettings - database entry for " + packageName + " not found");
+                return false;
+            }
+            
+            // delete settings from plain text file (for access from core libraries)
+//            File settingsUidDir = new File("/data/system/privacy/" + packageName + "/" + uid + "/");
+            File settingsPackageDir = new File("/data/system/privacy/" + packageName + "/");
+            File systemLogsSettingFile = new File("/data/system/privacy/" + packageName + "/systemLogsSetting");
+            // delete the setting files
+            systemLogsSettingFile.delete();
+            // delete the parent directories
+//            settingsUidDir.delete();
+            if (settingsPackageDir.list() == null || settingsPackageDir.list().length == 0) settingsPackageDir.delete();
+            // mark DB transaction successful (commit the changes)
+            db.setTransactionSuccessful();
+        } catch (Exception e) {
+            result = false;
+            Log.e(TAG, "deleteSettings - could not delete settings", e);
+        } finally {
+            db.endTransaction();
+            if (db != null && db.isOpen()) db.close();
+        }
+        
+        return result;
+    }
+    
+    private Cursor query(SQLiteDatabase db, String table, String[] columns, String selection, 
+            String[] selectionArgs, String groupBy, String having, String orderBy, String limit) throws Exception {
+        Cursor c = null;
+        // make sure getting settings does not fail because of IllegalStateException (db already closed)
+        boolean success = false;
+        for (int i = 0; success == false && i < RETRY_QUERY_COUNT; i++) {
+            try {
+                if (c != null) c.close();
+                c = db.query(table, columns, selection, selectionArgs, groupBy, having, orderBy, limit);
+                success = true;
+            } catch (IllegalStateException e) {
+                success = false;
+                if (db != null && db.isOpen()) db.close();
+                db = getReadableDatabase();
+            }
+        }
+        if (success == false) throw new Exception("query - failed to execute query on the DB");
+        return c;
+    }
+    
+    private Cursor rawQuery(SQLiteDatabase db, String sql) throws Exception {
+        Cursor c = null;
+        // make sure getting settings does not fail because of IllegalStateException (db already closed)
+        boolean success = false;
+        for (int i = 0; success == false && i < RETRY_QUERY_COUNT; i++) {
+            try {
+                if (c != null) c.close();
+                c = db.rawQuery(sql, null);
+                success = true;
+            } catch (IllegalStateException e) {
+                success = false;
+                if (db != null && db.isOpen()) db.close();
+                db = getReadableDatabase();
+            }
+        }
+        if (success == false) throw new Exception("query - failed to execute query on the DB");
+        return c;
+    }
+    
+    /**
+     * Removes obsolete entries from the DB and file system. Should not be used in methods, which rely on the DB
+     * being open after this method has finished. It will close the DB if no other threads has increased
+     * the readingThread count.
+     * @return true if purge was successful, false otherwise.
+     */
+    public boolean purgeSettings() {
+        boolean result = true;
+//        Log.d(TAG, "purgeSettings - begin purging settings");
+        // get installed apps
+        List<String> apps = new ArrayList<String>();
+        PackageManager pMan = context.getPackageManager();
+        List<ApplicationInfo> installedApps = pMan.getInstalledApplications(PackageManager.GET_META_DATA);
+        for (ApplicationInfo appInfo : installedApps) { 
+            apps.add(appInfo.packageName);
+        }
+        
+//        Log.d(TAG, "purgeSettings - purging directories");
+        // delete obsolete settings directories
+        File settingsDir = new File(SETTINGS_DIRECTORY);
+        for (File packageDir : settingsDir.listFiles()) {
+            String packageName = packageDir.getName();
+//            Log.d(TAG, "purgeSettings - checking package directory " + packageName);
+            
+            if (!apps.contains(packageName)) { // remove package dir if no such app installed
+//                Log.d(TAG, "purgeSettings - deleting " + packageName);
+                deleteRecursive(packageDir);
+            } 
+        }
+        
+//        Log.d(TAG, "purgeSettings - purging database");
+        // delete obsolete entries from DB and update outdated entries
+        readingThreads++;
+        SQLiteDatabase db = getReadableDatabase();
+        Cursor c = null;
+        try {
+            c = query(db, TABLE_SETTINGS, new String[] {"packageName"}, null, null, null, null, null, null);
+//            Log.d(TAG, "purgeSettings - found " + c.getCount() + " entries in the DB");
+            List<String> appsInDb = new ArrayList<String>();
+            while (c.moveToNext()) {
+                String packageName = c.getString(0);
+                if (!apps.contains(packageName)) {
+                    deleteSettings(packageName);
+                } else {
+                    if (appsInDb.contains(packageName)) { // if duplicate entry, remove all duplicates and keep only one
+                        PrivacySettings pSetTmp = getSettings(packageName, false);
+                        deleteSettings(packageName);
+                        saveSettings(pSetTmp);
+                    } else {
+                        appsInDb.add(packageName);
+                    }
+                }
+            }
+        } catch (Exception e) {
+            Log.e(TAG, "purgeSettings - purging DB failed", e);
+            result = false;
+        } finally {
+            if (c != null) c.close();
+            synchronized (readingThreads) {
+                readingThreads--;
+                // only close DB if no other threads are reading
+                if (readingThreads == 0 && db != null && db.isOpen()) {
+                    db.close();
+                }
+            }
+        }
+        return result;
+    }
+    
+    private void deleteRecursive(File fileOrDirectory) {
+        if (fileOrDirectory.isDirectory()) {
+            for (File child : fileOrDirectory.listFiles()) deleteRecursive(child);
+        }
+        fileOrDirectory.delete();
+    }
+    
+    private synchronized void createDatabase() {
+        Log.i(TAG, "createDatabase - creating privacy database file");
+        try {
+            SQLiteDatabase db = 
+                SQLiteDatabase.openDatabase(DATABASE_FILE, null, SQLiteDatabase.OPEN_READWRITE | 
+                        SQLiteDatabase.CREATE_IF_NECESSARY);
+            Log.i(TAG, "createDatabase - creating privacy database");
+            db.execSQL(CREATE_TABLE_SETTINGS);
+            db.execSQL(CREATE_TABLE_ALLOWED_CONTACTS);
+            db.execSQL(CREATE_TABLE_MAP);
+            db.execSQL(INSERT_VERSION);
+            db.execSQL(INSERT_ENABLED);
+            db.execSQL(INSERT_NOTIFICATIONS_ENABLED);
+    //        Log.d(TAG, "createDatabase - closing connection to privacy.db");
+            if (db != null && db.isOpen()) db.close();
+        } catch (SQLException e) {
+            Log.e(TAG, "createDatabase - failed to create privacy database", e);
+        }
+    }
+    
+    private synchronized void createSettingsDir() {
+        // create settings directory (for settings accessed from core libraries)
+        File settingsDir = new File("/data/system/privacy/");
+        settingsDir.mkdirs();
+        // make it readable for everybody
+        settingsDir.setReadable(true, false);
+        settingsDir.setExecutable(true, false);
+    }
+    
+    private synchronized SQLiteDatabase getReadableDatabase() {
+        if (db != null && db.isOpen()) return db;
+        
+        db = SQLiteDatabase.openDatabase(DATABASE_FILE, null, SQLiteDatabase.OPEN_READONLY);
+        
+        return db;
+    }
+
+    private synchronized SQLiteDatabase getWritableDatabase() {
+        // create the database if it does not exist
+        if (!new File(DATABASE_FILE).exists()) createDatabase();
+        
+        if (db != null && db.isOpen() && !db.isReadOnly()) return db;
+        
+        db = SQLiteDatabase.openDatabase(DATABASE_FILE, null, SQLiteDatabase.OPEN_READWRITE);
+
+        return db;
+    }
+}
diff --git a/privacy/java/android/privacy/PrivacySettings.aidl b/privacy/java/android/privacy/PrivacySettings.aidl
new file mode 100644
index 0000000..59d1899
--- /dev/null
+++ b/privacy/java/android/privacy/PrivacySettings.aidl
@@ -0,0 +1,4 @@
+package android.privacy;
+
+/** {@hide} */
+parcelable PrivacySettings;
diff --git a/privacy/java/android/privacy/PrivacySettings.java b/privacy/java/android/privacy/PrivacySettings.java
new file mode 100644
index 0000000..f970d4a
--- /dev/null
+++ b/privacy/java/android/privacy/PrivacySettings.java
@@ -0,0 +1,665 @@
+package android.privacy;
+
+import android.os.Parcel;
+import android.os.Parcelable;
+import android.util.Log;
+
+import java.math.BigDecimal;
+import java.util.List;
+import java.util.Random;
+
+/**
+ * Holds privacy settings for access to all private data types for a single application
+ * @author Svyatoslav Hresyk 
+ * {@hide} 
+ */
+public final class PrivacySettings implements Parcelable {
+    
+    /**
+     * Real value, provided by the unmodified Android framework.
+     */
+    public static final byte REAL = 0;
+    
+    /**
+     * Empty or unavailable, depending on setting type. For String settings, it is
+     * setter method caller's responsibility to make sure that the corresponding 
+     * setting field will contain an empty String.
+     */
+    public static final byte EMPTY = 1;
+    
+    /**
+     * Custom specified output, appropriate for relevant setting. For String settings, 
+     * it is setter method caller's responsibility to make sure that the corresponding 
+     * setting field will contain a custom String.
+     */
+    public static final byte CUSTOM = 2;
+    
+    /**
+     * Random output, appropriate for relevant setting. When this option is set, the
+     * corresponding getter methods will generate appropriate random values automatically.
+     * 
+     * Device ID: a random string consisting of 15 numeric digits preceded by a "+"
+     * Line1Number: a random string consisting of 13 numeric digits
+     */
+    public static final byte RANDOM = 3;
+    
+    public static final byte SETTING_NOTIFY_OFF = 0;
+    public static final byte SETTING_NOTIFY_ON = 1;
+    
+    // constants for identification of data types transmitted in the notification intent
+    public static final String DATA_DEVICE_ID = "deviceID";
+    public static final String DATA_LINE_1_NUMBER = "line1Number";
+    public static final String DATA_LOCATION_GPS = "locationGPS";
+    public static final String DATA_LOCATION_NETWORK = "locationNetwork";
+    public static final String DATA_NETWORK_INFO_CURRENT = "networkInfoCurrent";
+    public static final String DATA_NETWORK_INFO_SIM = "networkInfoSIM";
+    public static final String DATA_SIM_SERIAL = "simSerial";
+    public static final String DATA_SUBSCRIBER_ID = "subscriberID";
+    public static final String DATA_ACCOUNTS_LIST = "accountsList";
+    public static final String DATA_AUTH_TOKENS = "authTokens";
+    public static final String DATA_OUTGOING_CALL = "outgoingCall";
+    public static final String DATA_INCOMING_CALL = "incomingCall";
+    public static final String DATA_CONTACTS = "contacts";
+    public static final String DATA_CALENDAR = "calendar";
+    public static final String DATA_MMS = "mms";
+    public static final String DATA_SMS = "sms";
+    public static final String DATA_MMS_SMS = "mmsSms";
+    public static final String DATA_CALL_LOG = "callLog";
+    public static final String DATA_BOOKMARKS = "bookmarks";
+    public static final String DATA_SYSTEM_LOGS = "systemLogs";
+    public static final String DATA_INTENT_BOOT_COMPLETED = "intentBootCompleted";
+//    public static final String DATA_EXTERNAL_STORAGE = "externalStorage";
+//    public static final String DATA_CAMERA = "camera";
+//    public static final String DATA_RECORD_AUDIO = "recordAudio";
+    
+    // Database entry ID
+    private final Integer _id;
+    
+    // Application identifiers
+    private String packageName;
+    private int uid;
+    
+    //
+    // Privacy settings
+    //
+    
+    private byte deviceIdSetting;
+    private String deviceId;
+    
+    // Phone and Voice Mailbox Number
+    private byte line1NumberSetting; 
+    private String line1Number;
+    
+    private byte locationGpsSetting;
+    private String locationGpsLat;
+    private String locationGpsLon;
+    private byte locationNetworkSetting;
+    private String locationNetworkLat;
+    private String locationNetworkLon;
+    
+    // CountryIso, Operator Code, Operator Name
+    private byte networkInfoSetting;
+    private byte simInfoSetting;
+    
+    private byte simSerialNumberSetting;
+    private String simSerialNumber;
+    private byte subscriberIdSetting;
+    private String subscriberId;
+    
+    private byte accountsSetting;
+    private byte accountsAuthTokensSetting;
+    private byte outgoingCallsSetting;
+    private byte incomingCallsSetting;
+    
+    private byte contactsSetting;
+    private byte calendarSetting;
+    private byte mmsSetting;
+    private byte smsSetting;
+    private byte callLogSetting;
+    private byte bookmarksSetting; // browser bookmarks and history
+    
+    private byte systemLogsSetting;
+    
+    private byte notificationSetting;
+    
+    private byte intentBootCompletedSetting;
+//    private byte externalStorageSetting;
+//    private byte cameraSetting;
+//    private byte recordAudioSetting;
+    
+    private int[] allowedContacts;
+
+    public PrivacySettings(Integer _id, String packageName, int uid) {
+        this._id = _id;
+        
+        this.packageName = packageName;
+        this.uid = uid;
+        
+        this.deviceIdSetting = REAL;
+        this.deviceId = null;
+        this.line1NumberSetting = REAL;
+        this.line1Number = null;
+        this.locationGpsSetting = REAL;
+        this.locationGpsLat = null;
+        this.locationGpsLon = null;
+        this.locationNetworkSetting = REAL;
+        this.locationNetworkLat = null;
+        this.locationNetworkLon = null;
+        this.networkInfoSetting = REAL;
+        this.simInfoSetting = REAL;
+        this.simSerialNumberSetting = REAL;
+        this.simSerialNumber = null;
+        this.subscriberIdSetting = REAL;
+        this.subscriberId = null;
+        this.accountsSetting = REAL;
+        this.accountsAuthTokensSetting = REAL;
+        this.outgoingCallsSetting = REAL;
+        this.incomingCallsSetting = REAL;
+        this.contactsSetting = REAL;
+        this.calendarSetting = REAL;
+        this.mmsSetting = REAL;
+        this.smsSetting = REAL;
+        this.callLogSetting = REAL;
+        this.bookmarksSetting = REAL;
+        this.systemLogsSetting = REAL;
+        this.notificationSetting = SETTING_NOTIFY_OFF;
+        this.intentBootCompletedSetting = REAL;
+//        this.externalStorageSetting = REAL;
+//        this.cameraSetting = REAL;
+//        this.recordAudioSetting = REAL;
+        this.allowedContacts = null;
+    }
+    
+    public PrivacySettings(Integer id, String packageName, int uid, byte deviceIdSetting, String deviceId,
+            byte line1NumberSetting, String line1Number, byte locationGpsSetting, String locationGpsLat,
+            String locationGpsLon, byte locationNetworkSetting, String locationNetworkLat, 
+            String locationNetworkLon, byte networkInfoSetting, byte simInfoSetting, byte simSerialNumberSetting,
+            String simSerialNumber, byte subscriberIdSetting, String subscriberId, byte accountsSetting, 
+            byte accountsAuthTokensSetting, byte outgoingCallsSetting, byte incomingCallsSetting, byte contactsSetting,
+            byte calendarSetting, byte mmsSetting, byte smsSetting, byte callLogSetting, byte bookmarksSetting, 
+            byte systemLogsSetting, byte externalStorageSetting, byte cameraSetting, byte recordAudioSetting, 
+            byte notificationSetting, byte intentBootCompletedSetting, int[] allowedContacts) {
+        this._id = id;
+        
+        this.packageName = packageName;
+        this.uid = uid;
+        
+        this.deviceIdSetting = deviceIdSetting;
+        this.deviceId = deviceId;
+        this.line1NumberSetting = line1NumberSetting;
+        this.line1Number = line1Number;
+        this.locationGpsSetting = locationGpsSetting;
+        this.locationGpsLat = locationGpsLat;
+        this.locationGpsLon = locationGpsLon;
+        this.locationNetworkSetting = locationNetworkSetting;
+        this.locationNetworkLat = locationNetworkLat;
+        this.locationNetworkLon = locationNetworkLon;
+        this.networkInfoSetting = networkInfoSetting;
+        this.simInfoSetting = simInfoSetting;
+        this.simSerialNumberSetting = simSerialNumberSetting;
+        this.simSerialNumber = simSerialNumber;
+        this.subscriberIdSetting = subscriberIdSetting;
+        this.subscriberId = subscriberId;
+        this.accountsSetting = accountsSetting;
+        this.accountsAuthTokensSetting = accountsAuthTokensSetting;
+        this.outgoingCallsSetting = outgoingCallsSetting;
+        this.incomingCallsSetting = incomingCallsSetting;
+        this.contactsSetting = contactsSetting;
+        this.calendarSetting = calendarSetting;
+        this.mmsSetting = mmsSetting;
+        this.smsSetting = smsSetting;
+        this.callLogSetting = callLogSetting;
+        this.bookmarksSetting = bookmarksSetting;
+        this.systemLogsSetting = systemLogsSetting;
+        this.notificationSetting = notificationSetting;
+        this.intentBootCompletedSetting = intentBootCompletedSetting;
+//        this.externalStorageSetting = externalStorageSetting;
+//        this.cameraSetting = cameraSetting;
+//        this.recordAudioSetting = recordAudioSetting;
+        this.allowedContacts = allowedContacts;
+    }
+
+    public Integer get_id() {
+        return _id;
+    }
+
+    public String getPackageName() {
+        return packageName;
+    }
+    
+    public void setPackageName(String packageName) {
+        this.packageName = packageName;
+    }
+    
+    public int getUid() {
+        return uid;
+    }
+
+    public void setUid(int uid) {
+        this.uid = uid;
+    }
+
+    public byte getDeviceIdSetting() {
+        return deviceIdSetting;
+    }
+
+    public void setDeviceIdSetting(byte deviceIdSetting) {
+        this.deviceIdSetting = deviceIdSetting;
+    }
+
+    public String getDeviceId() {
+        if (deviceIdSetting == EMPTY) return "";
+        if (deviceIdSetting == RANDOM) {
+            Random rnd = new Random();
+            String rndId = Math.abs(rnd.nextLong()) + "";
+            return rndId.substring(0, 15);
+        }
+        return deviceId;
+    }
+
+    public void setDeviceId(String deviceId) {
+        this.deviceId = deviceId;
+    }
+
+    public byte getLine1NumberSetting() {
+        return line1NumberSetting;
+    }
+
+    public void setLine1NumberSetting(byte line1NumberSetting) {
+        this.line1NumberSetting = line1NumberSetting;
+    }
+
+    public String getLine1Number() {
+        if (line1NumberSetting == EMPTY) return "";
+        if (line1NumberSetting == RANDOM) {
+            Random rnd = new Random();
+            String rndId = "+" + Math.abs(rnd.nextLong()) + "";
+            return rndId.substring(0, 13);
+        }
+        return line1Number;
+    }
+
+    public void setLine1Number(String line1Number) {
+        this.line1Number = line1Number;
+    }
+
+    public byte getLocationGpsSetting() {
+        return locationGpsSetting;
+    }
+
+    public void setLocationGpsSetting(byte locationGpsSetting) {
+        this.locationGpsSetting = locationGpsSetting;
+    }
+    
+    public String getLocationGpsLat() {
+        if (locationGpsSetting == EMPTY) return "";
+        if (locationGpsSetting == RANDOM) return getRandomLat();
+        return locationGpsLat;
+    }
+
+    public void setLocationGpsLat(String locationGpsLat) {
+        this.locationGpsLat = locationGpsLat;
+    }
+
+    public String getLocationGpsLon() {
+        if (locationGpsSetting == EMPTY) return "";        
+        if (locationGpsSetting == RANDOM) return getRandomLon();
+        return locationGpsLon;
+    }
+
+    public void setLocationGpsLon(String locationGpsLon) {
+        this.locationGpsLon = locationGpsLon;
+    }
+
+    public byte getLocationNetworkSetting() {
+        return locationNetworkSetting;
+    }
+
+    public void setLocationNetworkSetting(byte locationNetworkSetting) {
+        this.locationNetworkSetting = locationNetworkSetting;
+    }
+
+    public String getLocationNetworkLat() {
+        if (locationNetworkSetting == EMPTY) return "";
+        if (locationNetworkSetting == RANDOM) return getRandomLat();  
+        return locationNetworkLat;
+    }
+
+    public void setLocationNetworkLat(String locationNetworkLat) {
+        this.locationNetworkLat = locationNetworkLat;
+    }
+
+    public String getLocationNetworkLon() {
+        if (locationNetworkSetting == EMPTY) return "";
+        if (locationNetworkSetting == RANDOM) return getRandomLon();
+        return locationNetworkLon;
+    }
+
+    public void setLocationNetworkLon(String locationNetworkLon) {
+        this.locationNetworkLon = locationNetworkLon;
+    }
+
+    public byte getNetworkInfoSetting() {
+        return networkInfoSetting;
+    }
+
+    public void setNetworkInfoSetting(byte networkInfoSetting) {
+        this.networkInfoSetting = networkInfoSetting;
+    }
+
+    public byte getSimInfoSetting() {
+        return simInfoSetting;
+    }
+
+    public void setSimInfoSetting(byte simInfoSetting) {
+        this.simInfoSetting = simInfoSetting;
+    }
+
+    public byte getSimSerialNumberSetting() {
+        return simSerialNumberSetting;
+    }
+
+    public void setSimSerialNumberSetting(byte simSerialNumberSetting) {
+        this.simSerialNumberSetting = simSerialNumberSetting;
+    }
+
+    public String getSimSerialNumber() {
+        if (simSerialNumberSetting == EMPTY) return "";
+        if (simSerialNumberSetting == RANDOM) {
+            Random rnd = new Random();
+            return Math.abs(rnd.nextLong()) + "";
+        }
+        return simSerialNumber;
+    }
+
+    public void setSimSerialNumber(String simSerialNumber) {
+        this.simSerialNumber = simSerialNumber;
+    }
+
+    public byte getSubscriberIdSetting() {
+        return subscriberIdSetting;
+    }
+
+    public void setSubscriberIdSetting(byte subscriberIdSetting) {
+        this.subscriberIdSetting = subscriberIdSetting;
+    }
+
+    public String getSubscriberId() {
+        if (subscriberIdSetting == EMPTY) return "";
+        if (subscriberIdSetting == RANDOM) {
+            Random rnd = new Random();
+            String rndId = Math.abs(rnd.nextLong()) + "";
+            return rndId.substring(0, 15);
+        }
+        return subscriberId;
+    }
+
+    public void setSubscriberId(String subscriberId) {
+        this.subscriberId = subscriberId;
+    }
+
+    public byte getAccountsSetting() {
+        return accountsSetting;
+    }
+
+    public void setAccountsSetting(byte accountsSetting) {
+        this.accountsSetting = accountsSetting;
+    }
+
+    public byte getAccountsAuthTokensSetting() {
+        return accountsAuthTokensSetting;
+    }
+
+    public void setAccountsAuthTokensSetting(byte accountsAuthTokensSetting) {
+        this.accountsAuthTokensSetting = accountsAuthTokensSetting;
+    }
+
+    public byte getOutgoingCallsSetting() {
+        return outgoingCallsSetting;
+    }
+
+    public void setOutgoingCallsSetting(byte outgoingCallsSetting) {
+        this.outgoingCallsSetting = outgoingCallsSetting;
+    }
+    
+    public byte getIncomingCallsSetting() {
+        return incomingCallsSetting;
+    }
+    
+    public void setIncomingCallsSetting(byte incomingCallsSetting) {
+        this.incomingCallsSetting = incomingCallsSetting;
+    }
+
+    public byte getContactsSetting() {
+        return contactsSetting;
+    }
+
+    public void setContactsSetting(byte contactsSetting) {
+        this.contactsSetting = contactsSetting;
+    }
+
+    public byte getCalendarSetting() {
+        return calendarSetting;
+    }
+
+    public void setCalendarSetting(byte calendarSetting) {
+        this.calendarSetting = calendarSetting;
+    }
+
+    public byte getMmsSetting() {
+        return mmsSetting;
+    }
+
+    public void setMmsSetting(byte mmsSetting) {
+        this.mmsSetting = mmsSetting;
+    }
+
+    public byte getSmsSetting() {
+        return smsSetting;
+    }
+
+    public void setSmsSetting(byte smsSetting) {
+        this.smsSetting = smsSetting;
+    }
+
+    public byte getCallLogSetting() {
+        return callLogSetting;
+    }
+
+    public void setCallLogSetting(byte callLogSetting) {
+        this.callLogSetting = callLogSetting;
+    }
+
+    public byte getBookmarksSetting() {
+        return bookmarksSetting;
+    }
+
+    public void setBookmarksSetting(byte bookmarksSetting) {
+        this.bookmarksSetting = bookmarksSetting;
+    }
+
+    public byte getSystemLogsSetting() {
+        return systemLogsSetting;
+    }
+
+    public void setSystemLogsSetting(byte systemLogsSetting) {
+        this.systemLogsSetting = systemLogsSetting;
+    }
+
+    public byte getIntentBootCompletedSetting() {
+        return intentBootCompletedSetting;
+    }
+
+    public void setIntentBootCompletedSetting(byte intentBootCompletedSetting) {
+        this.intentBootCompletedSetting = intentBootCompletedSetting;
+    }
+
+    public byte getNotificationSetting() {
+        return notificationSetting;
+    }
+
+    public void setNotificationSetting(byte notificationSetting) {
+        this.notificationSetting = notificationSetting;
+    }
+    
+    public int[] getAllowedContacts() {
+        return allowedContacts;
+    }
+
+    public void setAllowedContacts(int[] allowedContacts) {
+        this.allowedContacts = allowedContacts;
+    }
+
+    @Override
+    public String toString() {
+        return "PrivacySettings [_id=" + _id + ", accountsAuthTokensSetting=" + accountsAuthTokensSetting
+                + ", accountsSetting=" + accountsSetting + ", bookmarksSetting=" + bookmarksSetting
+                + ", calendarSetting=" + calendarSetting + ", callLogSetting=" + callLogSetting + ", contactsSetting="
+                + contactsSetting + ", deviceId=" + deviceId + ", deviceIdSetting=" + deviceIdSetting
+                + ", incomingCallsSetting=" + incomingCallsSetting + ", intentBootCompletedSetting="
+                + intentBootCompletedSetting + ", line1Number=" + line1Number + ", line1NumberSetting="
+                + line1NumberSetting + ", locationGpsLat=" + locationGpsLat + ", locationGpsLon=" + locationGpsLon
+                + ", locationGpsSetting=" + locationGpsSetting + ", locationNetworkLat=" + locationNetworkLat
+                + ", locationNetworkLon=" + locationNetworkLon + ", locationNetworkSetting=" + locationNetworkSetting
+                + ", mmsSetting=" + mmsSetting + ", networkInfoSetting=" + networkInfoSetting
+                + ", notificationSetting=" + notificationSetting + ", outgoingCallsSetting=" + outgoingCallsSetting
+                + ", packageName=" + packageName + ", simInfoSetting=" + simInfoSetting + ", simSerialNumber="
+                + simSerialNumber + ", simSerialNumberSetting=" + simSerialNumberSetting + ", smsSetting=" + smsSetting
+                + ", subscriberId=" + subscriberId + ", subscriberIdSetting=" + subscriberIdSetting
+                + ", systemLogsSetting=" + systemLogsSetting + ", uid=" + uid + "]";
+    }
+
+    /**
+     * Util methods
+     */
+    
+    private String getRandomLat() {
+        BigDecimal latitude;
+        double lat = Math.random() * 180;
+        if (lat > 90) latitude = new BigDecimal(lat - 90);
+        else latitude = new BigDecimal(-lat);
+        return latitude.setScale(6, BigDecimal.ROUND_HALF_UP) + "";
+    }
+    
+    private String getRandomLon() {
+        BigDecimal longitude;
+        double lon = Math.random() * 360;
+        if (lon > 180) longitude = new BigDecimal(lon - 180);
+        else longitude = new BigDecimal(-lon);
+        return longitude.setScale(6, BigDecimal.ROUND_HALF_UP) + "";
+    }
+
+    /**
+     * Parcelable implementation
+     */
+
+    public static final Parcelable.Creator<PrivacySettings> CREATOR = new
+            Parcelable.Creator<PrivacySettings>() {
+                public PrivacySettings createFromParcel(Parcel in) {
+                    return new PrivacySettings(in);
+                }
+
+                public PrivacySettings[] newArray(int size) {
+                    return new PrivacySettings[size];
+                }
+            };
+    
+    public PrivacySettings(Parcel in) {
+        int _id = in.readInt();
+        this._id = (_id == -1) ? null : _id;
+        
+        this.packageName = in.readString();
+        this.uid = in.readInt();
+        
+        this.deviceIdSetting = in.readByte();
+        this.deviceId = in.readString();
+        this.line1NumberSetting = in.readByte();
+        this.line1Number = in.readString();
+        this.locationGpsSetting = in.readByte();
+        this.locationGpsLat = in.readString();
+        this.locationGpsLon = in.readString();
+        this.locationNetworkSetting = in.readByte();
+        this.locationNetworkLat = in.readString();
+        this.locationNetworkLon = in.readString();
+        this.networkInfoSetting = in.readByte();
+        this.simInfoSetting = in.readByte();
+        this.simSerialNumberSetting = in.readByte();
+        this.simSerialNumber = in.readString();
+        this.subscriberIdSetting = in.readByte();
+        this.subscriberId = in.readString();
+        this.accountsSetting = in.readByte();
+        this.accountsAuthTokensSetting = in.readByte();
+        this.outgoingCallsSetting = in.readByte();
+        this.incomingCallsSetting = in.readByte();
+        this.contactsSetting = in.readByte();
+        this.calendarSetting = in.readByte();
+        this.mmsSetting = in.readByte();
+        this.smsSetting = in.readByte();
+        this.callLogSetting = in.readByte();
+        this.bookmarksSetting = in.readByte();
+        this.systemLogsSetting = in.readByte();
+        this.notificationSetting = in.readByte();
+        this.intentBootCompletedSetting = in.readByte();
+//        this.externalStorageSetting = in.readByte();
+//        this.cameraSetting = in.readByte();
+//        this.recordAudioSetting = in.readByte();
+//        int[] buffer = in.createIntArray();
+//        if (buffer != null && buffer.length > 0) {
+//            in.readIntArray(buffer);
+//            int count = 0;
+//            for (int i = 0; i < buffer.length; i++) if (buffer[i] != 0) count++; else break;
+//            this.allowedContacts = new int[count];
+//            System.arraycopy(buffer, 0, allowedContacts, 0, count);
+//        } // else it will be null
+        
+        this.allowedContacts = in.createIntArray();
+    }
+    
+    @Override
+    public void writeToParcel(Parcel dest, int flags) {
+        dest.writeInt((_id == null) ? -1 : _id);
+        
+        dest.writeString(packageName);
+        dest.writeInt(uid);
+        
+        dest.writeByte(deviceIdSetting);
+        dest.writeString(deviceId);
+        dest.writeByte(line1NumberSetting);
+        dest.writeString(line1Number);
+        dest.writeByte(locationGpsSetting);
+        dest.writeString(locationGpsLat);
+        dest.writeString(locationGpsLon);
+        dest.writeByte(locationNetworkSetting);
+        dest.writeString(locationNetworkLat);
+        dest.writeString(locationNetworkLon);
+        dest.writeByte(networkInfoSetting);
+        dest.writeByte(simInfoSetting);
+        dest.writeByte(simSerialNumberSetting);
+        dest.writeString(simSerialNumber);
+        dest.writeByte(subscriberIdSetting);
+        dest.writeString(subscriberId);
+        dest.writeByte(accountsSetting);
+        dest.writeByte(accountsAuthTokensSetting);
+        dest.writeByte(outgoingCallsSetting);
+        dest.writeByte(incomingCallsSetting);
+        dest.writeByte(contactsSetting);
+        dest.writeByte(calendarSetting);
+        dest.writeByte(mmsSetting);
+        dest.writeByte(smsSetting);
+        dest.writeByte(callLogSetting);
+        dest.writeByte(bookmarksSetting);
+        dest.writeByte(systemLogsSetting);
+        dest.writeByte(notificationSetting);
+        dest.writeByte(intentBootCompletedSetting);
+//        dest.writeByte(externalStorageSetting);
+//        dest.writeByte(cameraSetting);
+//        dest.writeByte(recordAudioSetting);
+        dest.writeIntArray(allowedContacts);
+    }
+    
+    @Override
+    public int describeContents() {
+        return 0;
+    }
+    
+}
diff --git a/privacy/java/android/privacy/PrivacySettingsManager.java b/privacy/java/android/privacy/PrivacySettingsManager.java
new file mode 100644
index 0000000..5d77767
--- /dev/null
+++ b/privacy/java/android/privacy/PrivacySettingsManager.java
@@ -0,0 +1,198 @@
+package android.privacy;
+
+import android.content.Context;
+import android.os.RemoteException;
+import android.util.Log;
+
+/**
+ * Provides API access to the privacy settings
+ * @author Svyatoslav Hresyk
+ * TODO: selective contacts access
+ * {@hide}
+ */
+public class PrivacySettingsManager {
+
+    private static final String TAG = "PrivacySettingsManager";
+    
+    public static final String ACTION_PRIVACY_NOTIFICATION = "com.privacy.pdroid.PRIVACY_NOTIFICATION";
+    
+    private IPrivacySettingsManager service;
+    
+    /**
+     * @hide - this should be instantiated through Context.getSystemService
+     * @param context
+     */
+    public PrivacySettingsManager(Context context, IPrivacySettingsManager service) {
+//        Log.d(TAG, "PrivacySettingsManager - initializing for package: " + context.getPackageName() + 
+//                " UID:" + Binder.getCallingUid());
+        this.service = service;
+    }
+
+    public PrivacySettings getSettings(String packageName, int uid) {
+        return getSettings(packageName);
+    }
+    
+    public PrivacySettings getSettings(String packageName) {
+        try {
+//            Log.d(TAG, "getSettings for package: " + packageName + " UID: " + uid);
+            if (service != null) {
+                return service.getSettings(packageName);
+            } else {
+                Log.e(TAG, "getSettings - PrivacySettingsManagerService is null");
+                return null;
+            }
+        } catch (RemoteException e) {
+            e.printStackTrace();
+            return null;
+        }
+    }
+
+    public boolean saveSettings(PrivacySettings settings) {
+        try {
+//            Log.d(TAG, "saveSettings - " + settings);
+            if (service != null) {            
+                return service.saveSettings(settings);
+            } else {
+                Log.e(TAG, "saveSettings - PrivacySettingsManagerService is null");
+                return false;
+            }
+        } catch (RemoteException e) {
+            Log.e(TAG, "RemoteException in saveSettings: ", e);
+            return false;
+        }
+    }
+    
+    public boolean deleteSettings(String packageName) {
+        return deleteSettings(packageName);
+    }
+    
+    public boolean deleteSettings(String packageName, int uid) {
+        try {
+//            Log.d(TAG, "deleteSettings - "  + packageName + " UID: " + uid);
+            if (service != null) {
+                return service.deleteSettings(packageName);
+            } else {
+                Log.e(TAG, "deleteSettings - PrivacySettingsManagerService is null");
+                return false;
+            }
+        } catch (RemoteException e) {
+            Log.e(TAG, "RemoteException in deleteSettings: ", e);
+            return false;
+        }
+    }
+    
+    /**
+     * Checks whether the PrivacySettingsManagerService is available. For some reason,
+     * occasionally it appears to be null. In this case it should be initialized again.
+     */
+    public boolean isServiceAvailable() {
+        if (service != null) return true;
+        return false;
+    }
+    
+    public void notification(String packageName, int uid, byte accessMode, String dataType, String output, PrivacySettings pSet) {
+        notification(packageName, accessMode, dataType, output, pSet);
+    }
+    
+    public void notification(String packageName, byte accessMode, String dataType, String output, PrivacySettings pSet) {
+//        if (pSet != null && pSet.getNotificationSetting() == PrivacySettings.SETTING_NOTIFY_ON) {
+            try {
+                if (service != null) {
+                    service.notification(packageName, accessMode, dataType, output);
+                } else {
+                    Log.e(TAG, "deleteSettings - PrivacySettingsManagerService is null");
+                }            
+            } catch (RemoteException e) {
+                Log.e(TAG, "RemoteException in notification: ", e);
+            }
+//        }
+    }
+    
+    public void registerObservers() {
+        try {
+            if (service != null) {
+                service.registerObservers();
+            } else {
+                Log.e(TAG, "deleteSettings - PrivacySettingsManagerService is null");
+            }
+        } catch (RemoteException e) {
+            Log.e(TAG, "RemoteException in registerObservers: ", e);
+        }
+    }
+    
+    public void addObserver(String packageName) {
+        try {
+            if (service != null) {
+                service.addObserver(packageName);
+            } else {
+                Log.e(TAG, "deleteSettings - PrivacySettingsManagerService is null");
+            }
+        } catch (RemoteException e) {
+            Log.e(TAG, "RemoteException in addObserver: ", e);
+        }
+    }
+    
+    public boolean purgeSettings() {
+        try {
+            if (service != null) {
+                return service.purgeSettings();
+            } else {
+                Log.e(TAG, "deleteSettings - PrivacySettingsManagerService is null");
+            }
+        } catch (RemoteException e) {
+            Log.e(TAG, "RemoteException in purgeSettings: ", e);
+        }
+        return false;
+    }
+    
+    public double getVersion() {
+        try {
+            if (service != null) {
+                return service.getVersion();
+            } else {
+                Log.e(TAG, "getVersion - PrivacySettingsManagerService is null");
+            }
+        } catch (RemoteException e) {
+            Log.e(TAG, "RemoteException in getVersion: ", e);
+        }
+        return 0;
+    }
+    
+    public boolean setEnabled(boolean enable) {
+        try {
+            if (service != null) {
+                return service.setEnabled(enable);
+            } else {
+                Log.e(TAG, "setEnabled - PrivacySettingsManagerService is null");
+            }
+        } catch (RemoteException e) {
+            Log.e(TAG, "RemoteException in setEnabled: ", e);
+        }
+        return false;
+    }
+    
+    public boolean setNotificationsEnabled(boolean enable) {
+        try {
+            if (service != null) {
+                return service.setNotificationsEnabled(enable);
+            } else {
+                Log.e(TAG, "setNotificationsEnabled - PrivacySettingsManagerService is null");
+            }
+        } catch (RemoteException e) {
+            Log.e(TAG, "RemoteException in setNotificationsEnabled: ", e);
+        }
+        return false;
+    }
+    
+    public void setBootCompleted() {
+        try {
+            if (service != null) {
+                service.setBootCompleted();
+            } else {
+                Log.e(TAG, "setBootCompleted - PrivacySettingsManagerService is null");
+            }
+        } catch (RemoteException e) {
+            Log.e(TAG, "RemoteException in setBootCompleted: ", e);
+        }
+    }
+}
diff --git a/privacy/java/android/privacy/PrivacySettingsManagerService.java b/privacy/java/android/privacy/PrivacySettingsManagerService.java
new file mode 100644
index 0000000..44a2672
--- /dev/null
+++ b/privacy/java/android/privacy/PrivacySettingsManagerService.java
@@ -0,0 +1,142 @@
+package android.privacy;
+
+import android.content.Context;
+import android.content.Intent;
+import android.os.Binder;
+import android.util.Log;
+
+import java.io.File;
+
+/**
+ * PrivacySettingsManager's counterpart running in the system process, which
+ * allows write access to /data/
+ * @author Svyatoslav Hresyk
+ * TODO: add selective contact access management API
+ * {@hide}
+ */
+public class PrivacySettingsManagerService extends IPrivacySettingsManager.Stub {
+
+    private static final String TAG = "PrivacySettingsManagerService";
+    
+    private static final String WRITE_PRIVACY_SETTINGS = "android.privacy.WRITE_PRIVACY_SETTINGS";
+
+    private PrivacyPersistenceAdapter persistenceAdapter;
+
+    private Context context;
+    
+    public static PrivacyFileObserver obs;
+    
+    private boolean enabled;
+    private boolean notificationsEnabled;
+    private boolean bootCompleted;
+    
+    private static final double VERSION = 1.32;
+    
+    /**
+     * @hide - this should be instantiated through Context.getSystemService
+     * @param context
+     */
+    public PrivacySettingsManagerService(Context context) {
+        Log.i(TAG, "PrivacySettingsManagerService - initializing for package: " + context.getPackageName() + 
+                " UID: " + Binder.getCallingUid());
+        this.context = context;
+        
+        persistenceAdapter = new PrivacyPersistenceAdapter(context);
+        obs = new PrivacyFileObserver("/data/system/privacy", this);
+        
+        enabled = persistenceAdapter.getValue(PrivacyPersistenceAdapter.SETTING_ENABLED).equals(PrivacyPersistenceAdapter.VALUE_TRUE);
+        notificationsEnabled = persistenceAdapter.getValue(PrivacyPersistenceAdapter.SETTING_NOTIFICATIONS_ENABLED).equals(PrivacyPersistenceAdapter.VALUE_TRUE);
+        bootCompleted = false;
+    }
+    
+    public PrivacySettings getSettings(String packageName) {
+//        Log.d(TAG, "getSettings - " + packageName);
+        if (enabled || context.getPackageName().equals("com.privacy.pdroid")) 
+            return persistenceAdapter.getSettings(packageName, false);
+        else return null;
+    }
+
+    public boolean saveSettings(PrivacySettings settings) {
+        Log.d(TAG, "saveSettings - checking if caller (UID: " + Binder.getCallingUid() + ") has sufficient permissions");
+        // check permission if not being called by the system process
+        if (Binder.getCallingUid() != 1000) 
+            context.enforceCallingPermission(WRITE_PRIVACY_SETTINGS, "Requires WRITE_PRIVACY_SETTINGS");
+        Log.d(TAG, "saveSettings - " + settings);
+        boolean result = persistenceAdapter.saveSettings(settings);
+        if (result == true) obs.addObserver(settings.getPackageName());
+        return result;
+    }
+    
+    public boolean deleteSettings(String packageName) {
+//        Log.d(TAG, "deleteSettings - " + packageName + " UID: " + uid + " " +
+//        		"checking if caller (UID: " + Binder.getCallingUid() + ") has sufficient permissions");
+        // check permission if not being called by the system process
+        if (Binder.getCallingUid() != 1000)
+            context.enforceCallingPermission(WRITE_PRIVACY_SETTINGS, "Requires WRITE_PRIVACY_SETTINGS");
+        boolean result = persistenceAdapter.deleteSettings(packageName);
+        // update observer if directory exists
+        String observePath = PrivacyPersistenceAdapter.SETTINGS_DIRECTORY + "/" + packageName;
+        if (new File(observePath).exists() && result == true) {
+            obs.addObserver(observePath);
+        } else if (result == true) {
+            obs.children.remove(observePath);
+        }
+        return result;
+    }
+    
+    public double getVersion() {
+        return VERSION;
+    }
+    
+    public void notification(final String packageName, final byte accessMode, final String dataType, final String output) {
+        if (bootCompleted && notificationsEnabled) {
+            Intent intent = new Intent();
+            intent.setAction(PrivacySettingsManager.ACTION_PRIVACY_NOTIFICATION);
+            intent.putExtra("packageName", packageName);
+            intent.putExtra("uid", PrivacyPersistenceAdapter.DUMMY_UID);
+            intent.putExtra("accessMode", accessMode);
+            intent.putExtra("dataType", dataType);
+            intent.putExtra("output", output);
+            context.sendBroadcast(intent);
+        }
+    }
+    
+    public void registerObservers() {
+        context.enforceCallingPermission(WRITE_PRIVACY_SETTINGS, "Requires WRITE_PRIVACY_SETTINGS");        
+        obs = new PrivacyFileObserver("/data/system/privacy", this);
+    }
+    
+    public void addObserver(String packageName) {
+        context.enforceCallingPermission(WRITE_PRIVACY_SETTINGS, "Requires WRITE_PRIVACY_SETTINGS");        
+        obs.addObserver(packageName);
+    }
+    
+    public boolean purgeSettings() {
+        return persistenceAdapter.purgeSettings();
+    }
+    
+    public void setBootCompleted() {
+        bootCompleted = true;
+    }
+    
+    public boolean setNotificationsEnabled(boolean enable) {
+        String value = enable ? PrivacyPersistenceAdapter.VALUE_TRUE : PrivacyPersistenceAdapter.VALUE_FALSE;
+        if (persistenceAdapter.setValue(PrivacyPersistenceAdapter.SETTING_NOTIFICATIONS_ENABLED, value)) {
+            this.notificationsEnabled = true;
+            this.bootCompleted = true;
+            return true;
+        } else {
+            return false;
+        }
+    }
+    
+    public boolean setEnabled(boolean enable) {
+        String value = enable ? PrivacyPersistenceAdapter.VALUE_TRUE : PrivacyPersistenceAdapter.VALUE_FALSE;
+        if (persistenceAdapter.setValue(PrivacyPersistenceAdapter.SETTING_ENABLED, value)) {
+            this.enabled = true;
+            return true;
+        } else {
+            return false;
+        }
+    }
+}
diff --git a/privacy/java/android/privacy/surrogate/PrivacyAccountManager.java b/privacy/java/android/privacy/surrogate/PrivacyAccountManager.java
new file mode 100644
index 0000000..ae9c804
--- /dev/null
+++ b/privacy/java/android/privacy/surrogate/PrivacyAccountManager.java
@@ -0,0 +1,285 @@
+package android.privacy.surrogate;
+
+import android.accounts.Account;
+import android.accounts.AccountManager;
+import android.accounts.AccountManagerCallback;
+import android.accounts.AccountManagerFuture;
+import android.accounts.AuthenticatorException;
+import android.accounts.IAccountManager;
+import android.accounts.OperationCanceledException;
+import android.app.Activity;
+import android.content.Context;
+import android.os.Binder;
+import android.os.Bundle;
+import android.os.Handler;
+import android.os.ServiceManager;
+import android.privacy.IPrivacySettingsManager;
+import android.privacy.PrivacySettings;
+import android.privacy.PrivacySettingsManager;
+import android.util.Log;
+
+import java.io.IOException;
+import java.util.concurrent.TimeUnit;
+
+/**
+ * Provides privacy handling for {@link android.accounts.AccountManager}
+ * @author Svyatoslav Hresyk
+ * {@hide}
+ */
+public final class PrivacyAccountManager extends AccountManager {
+    
+    private static final String TAG = "PrivacyAccountManager";
+    
+    private Context context;
+    
+    private PrivacySettingsManager pSetMan;
+
+    /** {@hide} */
+    public PrivacyAccountManager(Context context, IAccountManager service) {
+        super(context, service);
+        this.context = context;
+//        pSetMan = (PrivacySettingsManager) context.getSystemService("privacy");
+        pSetMan = new PrivacySettingsManager(context, IPrivacySettingsManager.Stub.asInterface(ServiceManager.getService("privacy")));  
+    }
+
+    /** {@hide} */
+    public PrivacyAccountManager(Context context, IAccountManager service, Handler handler) {
+        super(context, service, handler);
+        this.context = context;
+//        pSetMan = (PrivacySettingsManager) context.getSystemService("privacy");
+        pSetMan = new PrivacySettingsManager(context, IPrivacySettingsManager.Stub.asInterface(ServiceManager.getService("privacy")));        
+    }
+
+    /**
+     * GET_ACCOUNTS
+     */
+    
+    @Override
+    public Account[] getAccounts() {
+        String packageName = context.getPackageName();
+        int uid = Binder.getCallingUid();
+        PrivacySettings pSet = pSetMan.getSettings(packageName, uid);
+        String output_label;
+        Account[] output;
+        
+        if (pSet != null && pSet.getAccountsSetting() != PrivacySettings.REAL) {
+            output_label = "[empty accounts list]";
+            output = new Account[0];
+            pSetMan.notification(packageName, uid, PrivacySettings.EMPTY, PrivacySettings.DATA_ACCOUNTS_LIST, null, pSet);
+        } else {
+            output_label = "[real value]";
+            output = super.getAccounts(); 
+            pSetMan.notification(packageName, uid, PrivacySettings.REAL, PrivacySettings.DATA_ACCOUNTS_LIST, null, pSet);
+        }
+        
+//        Log.d(TAG, "getAccounts - " + context.getPackageName() + " (" + Binder.getCallingUid() + ") output: " + output_label);        
+        return output;
+    }
+
+    @Override
+    public Account[] getAccountsByType(String type) {
+        String packageName = context.getPackageName();
+        int uid = Binder.getCallingUid();        
+        PrivacySettings pSet = pSetMan.getSettings(packageName, uid);
+        String output_label;
+        Account[] output;
+        
+        if (pSet != null && pSet.getAccountsSetting() != PrivacySettings.REAL) {
+            output_label = "[empty accounts list]";
+            output = new Account[0];
+            pSetMan.notification(packageName, uid, PrivacySettings.EMPTY, PrivacySettings.DATA_ACCOUNTS_LIST, null, pSet);
+        } else {
+            output_label = "[real value]";
+            output = super.getAccountsByType(type);
+            pSetMan.notification(packageName, uid, PrivacySettings.REAL, PrivacySettings.DATA_ACCOUNTS_LIST, null, pSet);
+        }
+        
+//        Log.d(TAG, "getAccountsByType - " + context.getPackageName() + " (" + Binder.getCallingUid() + ") output: " + output_label);        
+        return output;
+    }
+    
+    @Override
+    public AccountManagerFuture<Boolean> hasFeatures(Account account, String[] features,
+            AccountManagerCallback<Boolean> callback, Handler handler) {
+        String packageName = context.getPackageName();
+        int uid = Binder.getCallingUid();        
+        PrivacySettings pSet = pSetMan.getSettings(packageName, uid);        
+        String output_label;
+        AccountManagerFuture<Boolean> output;
+        
+        if (pSet != null && pSet.getAccountsSetting() != PrivacySettings.REAL) {
+            output_label = "[false]";
+            output = new PrivacyAccountManagerFuture<Boolean>(false);
+            pSetMan.notification(packageName, uid, PrivacySettings.EMPTY, PrivacySettings.DATA_ACCOUNTS_LIST, null, pSet);      
+        } else {
+            output_label = "[real value]";
+            output = super.hasFeatures(account, features, callback, handler);
+            pSetMan.notification(packageName, uid, PrivacySettings.REAL, PrivacySettings.DATA_ACCOUNTS_LIST, null, pSet);            
+        }
+        
+//        Log.d(TAG, "hasFeatures - " + context.getPackageName() + " (" + Binder.getCallingUid() + ") output: " + output_label);        
+        return output;
+    }
+
+    @Override
+    public AccountManagerFuture<Account[]> getAccountsByTypeAndFeatures(String type, String[] features,
+            AccountManagerCallback<Account[]> callback, Handler handler) {
+        String packageName = context.getPackageName();
+        int uid = Binder.getCallingUid();        
+        PrivacySettings pSet = pSetMan.getSettings(packageName, uid);       
+        String output_label;
+        AccountManagerFuture<Account[]> output;
+        
+        if (pSet != null && pSet.getAccountsSetting() != PrivacySettings.REAL) {
+            output_label = "[false]";
+            output = new PrivacyAccountManagerFuture<Account[]>(new Account[0]);
+            pSetMan.notification(packageName, uid, PrivacySettings.EMPTY, PrivacySettings.DATA_ACCOUNTS_LIST, null, pSet);      
+        } else {
+            output_label = "[real value]";
+            output = super.getAccountsByTypeAndFeatures(type, features, callback, handler);
+            pSetMan.notification(packageName, uid, PrivacySettings.REAL, PrivacySettings.DATA_ACCOUNTS_LIST, null, pSet);            
+        }
+        
+//        Log.d(TAG, "getAccountsByTypeAndFeatures - " + context.getPackageName() + " (" + Binder.getCallingUid() + ") output: " + output_label);           
+        return output;
+    }
+    
+    /**
+     * USE_CREDENTIALS
+     */
+    
+    @Override
+    public String blockingGetAuthToken(Account account, String authTokenType, boolean notifyAuthFailure)
+            throws OperationCanceledException, IOException, AuthenticatorException {
+        String packageName = context.getPackageName();
+        int uid = Binder.getCallingUid();        
+        PrivacySettings pSet = pSetMan.getSettings(packageName, uid);    
+        String output;
+        
+        if (pSet != null && pSet.getAccountsAuthTokensSetting() != PrivacySettings.REAL) {
+            output = null;
+            pSetMan.notification(packageName, uid, PrivacySettings.EMPTY, PrivacySettings.DATA_AUTH_TOKENS, null, pSet);      
+        } else {
+            output = super.blockingGetAuthToken(account, authTokenType, notifyAuthFailure);
+            pSetMan.notification(packageName, uid, PrivacySettings.REAL, PrivacySettings.DATA_AUTH_TOKENS, null, pSet);      
+        }
+        
+//        Log.d(TAG, "blockingGetAuthToken - " + context.getPackageName() + " (" + Binder.getCallingUid() + ") output: " 
+//                + (output == null ? "[null]" : output));
+        return output;
+    }
+
+    @Override
+    public AccountManagerFuture<Bundle> getAuthToken(Account account, String authTokenType, boolean notifyAuthFailure,
+            AccountManagerCallback<Bundle> callback, Handler handler) {
+        String packageName = context.getPackageName();
+        int uid = Binder.getCallingUid();        
+        PrivacySettings pSet = pSetMan.getSettings(packageName, uid);   
+        String output_label;
+        AccountManagerFuture<Bundle> output;
+        
+        if (pSet != null && pSet.getAccountsAuthTokensSetting() != PrivacySettings.REAL) {
+            output_label = "[empty]";
+            output = new PrivacyAccountManagerFuture<Bundle>(new Bundle());
+            pSetMan.notification(packageName, uid, PrivacySettings.EMPTY, PrivacySettings.DATA_AUTH_TOKENS, null, pSet);      
+        } else {
+            output_label = "[real value]";
+            output = super.getAuthToken(account, authTokenType, notifyAuthFailure, callback, handler);
+            pSetMan.notification(packageName, uid, PrivacySettings.REAL, PrivacySettings.DATA_AUTH_TOKENS, null, pSet);      
+        }
+        
+//        Log.d(TAG, "getAuthToken - " + context.getPackageName() + " (" + Binder.getCallingUid() + ") output: " + output_label);           
+        return output;
+    }
+
+    @Override
+    public AccountManagerFuture<Bundle> getAuthToken(Account account, String authTokenType, Bundle options,
+            Activity activity, AccountManagerCallback<Bundle> callback, Handler handler) {
+        String packageName = context.getPackageName();
+        int uid = Binder.getCallingUid();        
+        PrivacySettings pSet = pSetMan.getSettings(packageName, uid);   
+        String output_label;
+        AccountManagerFuture<Bundle> output;
+        
+        if (pSet != null && pSet.getAccountsAuthTokensSetting() != PrivacySettings.REAL) {
+            output_label = "[empty]";
+            output = new PrivacyAccountManagerFuture<Bundle>(new Bundle());
+            pSetMan.notification(packageName, uid, PrivacySettings.EMPTY, PrivacySettings.DATA_AUTH_TOKENS, null, pSet);      
+        } else {
+            output_label = "[real value]";
+            output = super.getAuthToken(account, authTokenType, options, activity, callback, handler);
+            pSetMan.notification(packageName, uid, PrivacySettings.REAL, PrivacySettings.DATA_AUTH_TOKENS, null, pSet);      
+        }
+        
+//        Log.d(TAG, "getAuthToken - " + context.getPackageName() + " (" + Binder.getCallingUid() + ") output: " + output_label);           
+        return output;
+    }
+
+    /**
+     * MANAGE_ACCOUNTS
+     */
+    
+    @Override
+    public AccountManagerFuture<Bundle> getAuthTokenByFeatures(String accountType, String authTokenType,
+            String[] features, Activity activity, Bundle addAccountOptions, Bundle getAuthTokenOptions,
+            AccountManagerCallback<Bundle> callback, Handler handler) {
+        String packageName = context.getPackageName();
+        int uid = Binder.getCallingUid();        
+        PrivacySettings pSet = pSetMan.getSettings(packageName, uid);   
+        String output_label;
+        AccountManagerFuture<Bundle> output;
+        
+        if (pSet != null && pSet.getAccountsAuthTokensSetting() != PrivacySettings.REAL) {
+            output_label = "[empty]";
+            output = new PrivacyAccountManagerFuture<Bundle>(new Bundle());
+            pSetMan.notification(packageName, uid, PrivacySettings.EMPTY, PrivacySettings.DATA_AUTH_TOKENS, null, pSet);      
+        } else {
+            output_label = "[real value]";
+            output = super.getAuthTokenByFeatures(accountType, authTokenType, features, activity, addAccountOptions,
+                    getAuthTokenOptions, callback, handler);
+            pSetMan.notification(packageName, uid, PrivacySettings.REAL, PrivacySettings.DATA_AUTH_TOKENS, null, pSet);      
+        }
+        
+//        Log.d(TAG, "getAuthTokenByFeatures - " + context.getPackageName() + " (" + Binder.getCallingUid() + ") output: " + output_label);           
+        return output;
+    }
+    
+    /**
+     * Helper class. Used for returning custom values to AccountManager callers.
+     */
+    private class PrivacyAccountManagerFuture<V> implements AccountManagerFuture<V> {
+        
+        private V result;
+        
+        public PrivacyAccountManagerFuture(V result) {
+            this.result = result;
+        }
+
+        @Override
+        public boolean cancel(boolean mayInterruptIfRunning) {
+            return false;
+        }
+
+        @Override
+        public V getResult() throws OperationCanceledException, IOException, AuthenticatorException {
+            return result;
+        }
+
+        @Override
+        public V getResult(long timeout, TimeUnit unit) throws OperationCanceledException, IOException,
+                AuthenticatorException {
+            return result;
+        }
+
+        @Override
+        public boolean isCancelled() {
+            return false;
+        }
+
+        @Override
+        public boolean isDone() {
+            return true;
+        }
+        
+    }
+}
diff --git a/privacy/java/android/privacy/surrogate/PrivacyActivityManagerService.java b/privacy/java/android/privacy/surrogate/PrivacyActivityManagerService.java
new file mode 100644
index 0000000..3c8799a
--- /dev/null
+++ b/privacy/java/android/privacy/surrogate/PrivacyActivityManagerService.java
@@ -0,0 +1,272 @@
+package android.privacy.surrogate;
+
+import android.content.Context;
+import android.content.Intent;
+import android.privacy.PrivacySettings;
+import android.privacy.PrivacySettingsManager;
+import android.privacy.PrivacySettingsManagerService;
+import android.provider.Telephony;
+import android.telephony.TelephonyManager;
+import android.util.Log;
+
+/**
+ * Provides privacy handling for {@link com.android.server.am.ActivityManagerService}
+ * @author Svyatoslav Hresyk
+ * {@hide}
+ */
+public final class PrivacyActivityManagerService {
+    
+    private static final String TAG = "PrivacyActivityManagerService";
+    
+    private static PrivacySettingsManager pSetMan;
+    
+    private static Intent tmpIn;
+    private static long tmpInHash = 0;
+    private static int tmpInReceivers = 0;
+    
+    private static Intent tmpOut;
+    private static long tmpOutHash = 0;
+    private static int tmpOutReceivers = 0;
+    
+    private static Intent tmpSms;
+    private static long tmpSmsHash = 0;
+    private static int tmpSmsReceivers = 0;
+    
+    private static Intent tmpMms;
+    private static long tmpMmsHash = 0;
+    private static int tmpMmsReceivers = 0;
+    
+    private static long tmpPackageAddedHash = 0;
+    
+    /**
+     * Intercepts broadcasts and replaces the broadcast contents according to 
+     * privacy permissions
+     * @param packageName may not be null
+     * @param uid must be >= 0
+     * @param intent intent.getAction() may not return null
+     */
+    public static void enforcePrivacyPermission(String packageName, int uid, Intent intent, Context context, int receivers) {
+        if (pSetMan == null) pSetMan = (PrivacySettingsManager) context.getSystemService("privacy");
+        PrivacySettings pSet;
+        String action = intent.getAction();
+        String output;
+        // outgoing call
+        if (action.equals(Intent.ACTION_NEW_OUTGOING_CALL)) {
+            pSet = pSetMan.getSettings(packageName, uid);
+            output = intent.getStringExtra(Intent.EXTRA_PHONE_NUMBER);
+            
+            // store the original version to supply real values to trusted applications
+            // since Android sends the same intent to multiple receivers
+            if (tmpOutHash != hashCode(intent)) {
+                tmpOut = (Intent)intent.clone();
+                tmpOutHash = hashCode(intent);
+                tmpOutReceivers = receivers;
+            }
+            
+            try {
+                if (pSet != null && pSet.getOutgoingCallsSetting() != PrivacySettings.REAL) {
+                    output = "";
+                    intent.putExtra(Intent.EXTRA_PHONE_NUMBER, output);
+                    pSetMan.notification(packageName, uid, PrivacySettings.EMPTY, PrivacySettings.DATA_OUTGOING_CALL, null, pSet);
+                } else if (tmpOutHash == hashCode(intent)) {
+                    // if this intent was stored before, get the real value since it could have been modified
+                    output = tmpOut.getStringExtra(Intent.EXTRA_PHONE_NUMBER);
+                    intent.putExtra(Intent.EXTRA_PHONE_NUMBER, output);
+                    pSetMan.notification(packageName, uid, PrivacySettings.REAL, PrivacySettings.DATA_OUTGOING_CALL, null, pSet);
+                }
+            } catch (Exception e) {
+                Log.e(TAG, "failed to enforce intent broadcast permission", e);
+            }
+            
+            if (tmpOutReceivers > 1) {
+                tmpOutReceivers--;
+            } else { // free memory after all receivers have been served
+                tmpOut = null;
+            }
+            
+//            Log.d(TAG, "broadcasting intent " + action + " - " + packageName + " (" + uid + ") output: " + output);
+        // incoming call
+        } else if (action.equals(TelephonyManager.ACTION_PHONE_STATE_CHANGED)
+                // the EXTRA_INCOMING_NUMBER is NOT only present when state is EXTRA_STATE_RINGING
+                // Android documentation is WRONG; the EXTRA_INCOMING_NUMBER will also be there when hanging up (IDLE?)
+                /* && intent.getStringExtra(TelephonyManager.EXTRA_STATE).equals(TelephonyManager.EXTRA_STATE_RINGING)*/) {
+            output = intent.getStringExtra(TelephonyManager.EXTRA_INCOMING_NUMBER);
+            // don't do anything if no incoming phone number is broadcasted
+            if (output == null || output.isEmpty()) return;
+            
+            pSet = pSetMan.getSettings(packageName, uid);
+            
+            if (tmpInHash != hashCode(intent)) {
+                tmpIn = (Intent)intent.clone();
+                tmpInHash = hashCode(intent);
+                tmpInReceivers = receivers;
+            }
+            
+            try {
+                if (pSet != null && pSet.getIncomingCallsSetting() != PrivacySettings.REAL) {
+                    output = "";
+                    intent.putExtra(TelephonyManager.EXTRA_INCOMING_NUMBER, output);
+                    pSetMan.notification(packageName, uid, PrivacySettings.EMPTY, PrivacySettings.DATA_INCOMING_CALL, null, pSet);
+                } else if (tmpInHash == hashCode(intent)) {
+                    output = tmpIn.getStringExtra(TelephonyManager.EXTRA_INCOMING_NUMBER);
+                    intent.putExtra(TelephonyManager.EXTRA_INCOMING_NUMBER, output);
+                    pSetMan.notification(packageName, uid, PrivacySettings.REAL, PrivacySettings.DATA_INCOMING_CALL, null, pSet);
+                }
+            } catch (Exception e) {
+                Log.e(TAG, "failed to enforce intent broadcast permission", e);
+            }
+            
+            if (tmpInReceivers > 1) {
+                tmpInReceivers--;
+            } else { // free memory after all receivers have been served
+                tmpIn = null;
+            }
+            
+//            Log.d(TAG, "broadcasting intent " + action + " - " + packageName + " (" + uid + ") output: " + output);
+        // incoming SMS
+        } else if (action.equals(Telephony.Sms.Intents.SMS_RECEIVED_ACTION)) {
+            pSet = pSetMan.getSettings(packageName, uid);
+            output = "[real]";
+//            Log.d(TAG, "package: " + packageName + " uid: " + uid);
+            
+            Object[] o = ((Object[])intent.getSerializableExtra("pdus"));
+            byte[] b = o != null ? (byte[])o[0] : null;
+            
+            if (tmpSmsHash != hashCode(intent)) {
+                tmpSms = (Intent)intent.clone();
+                tmpSmsHash = hashCode(intent);
+                tmpSmsReceivers = receivers;
+//                Log.d(TAG, "new intent; saving copy: receivers: " + receivers + " hash: " + tmpSmsHash + " " + 
+//                        "pdu number: " + (o != null ? o.length : "null") + " " + 
+//                        "1st pdu length: " + (b != null ? b.length : "null"));
+            } else {
+//                Log.d(TAG, "known intent; hash: " + hashCode(intent) + " remaining receivers: " + tmpSmsReceivers);
+            }
+            
+            try {
+                if (pSet != null && pSet.getSmsSetting() != PrivacySettings.REAL) {
+                    output = "[empty]";
+                    
+                    Object[] emptypdusObj = new Object[1];
+                    emptypdusObj[0] = (Object) new byte[] {0,32,1,-127,-16,0,0,17,-112,1,48,34,34,-128,1,32};
+                    intent.putExtra("pdus", emptypdusObj);
+                    
+//                    Log.d(TAG, "permission denied, replaced pdu; pdu number: " + 
+//                            (o != null ? o.length : "null") + " " +
+//                        "1st pdu length:" + (b != null ? b.length : "null"));
+                    pSetMan.notification(packageName, uid, PrivacySettings.EMPTY, PrivacySettings.DATA_SMS, null, pSet);
+                } else if (tmpSmsHash == hashCode(intent)) {
+                    intent.putExtra("pdus", tmpSms.getSerializableExtra("pdus"));
+                    
+                    o = ((Object[])intent.getSerializableExtra("pdus"));
+                    b = o != null ? (byte[])o[0] : null;
+//                    Log.d(TAG, "permission granted, inserting saved pdus; pdu number: " + 
+//                            (o != null ? o.length : "null") + " " +
+//                            "1st pdu length:" + (b != null ? b.length : "null"));
+                    pSetMan.notification(packageName, uid, PrivacySettings.REAL, PrivacySettings.DATA_SMS, null, pSet);
+                }
+            } catch (Exception e) {
+                Log.e(TAG, "failed to enforce intent broadcast permission", e);
+            }
+            
+            if (tmpSmsReceivers > 1) {
+                tmpSmsReceivers--;
+            } else { // free memory after all receivers have been served
+//                Log.d(TAG, "removing intent with hash: " + tmpSmsHash);
+                tmpSms = null;
+            }            
+            
+//            Log.d(TAG, "broadcasting intent " + action + " - " + packageName + " (" + uid + ") output: " + output);
+        // incoming MMS
+        } else if (action.equals(Telephony.Sms.Intents.WAP_PUSH_RECEIVED_ACTION) ||
+                action.equals(Telephony.Sms.Intents.DATA_SMS_RECEIVED_ACTION)) {
+            pSet = pSetMan.getSettings(packageName, uid);
+            output = "[real]";
+            
+            Object[] o = ((Object[])intent.getSerializableExtra("pdus"));
+            byte[] b = o != null ? (byte[])o[0] : null;
+            
+            // TODO: remove unnecessary receivers count
+            if (tmpMmsHash != hashCode(intent)) {
+                tmpMms = (Intent)intent.clone();
+                tmpMmsHash = hashCode(intent);
+                tmpMmsReceivers = receivers;
+//                Log.d(TAG, "new intent; saving copy: receivers: " + receivers + " hash: " + tmpMmsHash + " " + 
+//                        "pdu number: " + (o != null ? o.length : "null") + " " + 
+//                        "1st pdu length: " + (b != null ? b.length : "null"));
+            } else {
+//                Log.d(TAG, "known intent; hash: " + hashCode(intent) + " remaining receivers: " + tmpMmsReceivers);
+            }
+            
+            try {
+                if (pSet != null && pSet.getMmsSetting() != PrivacySettings.REAL) {
+                    output = "[empty]";
+                    
+                    Object[] emptypdusObj = new Object[1];
+                    emptypdusObj[0] = (Object) new byte[] {0,32,1,-127,-16,0,0,17,-112,1,48,34,34,-128,1,32};
+                    intent.putExtra("pdus", emptypdusObj);
+                    pSetMan.notification(packageName, uid, PrivacySettings.EMPTY, PrivacySettings.DATA_MMS, null, pSet);
+                } else if (tmpMmsHash == hashCode(intent)) {
+                    intent.putExtra("pdus", tmpMms.getSerializableExtra("pdus"));
+                    
+                    o = ((Object[])intent.getSerializableExtra("pdus"));
+                    b = o != null ? (byte[])o[0] : null;
+//                    Log.d(TAG, "permission granted, inserting saved pdus; pdu number: " + 
+//                            (o != null ? o.length : "null") + " " +
+//                            "1st pdu length:" + (b != null ? b.length : "null"));
+                    pSetMan.notification(packageName, uid, PrivacySettings.REAL, PrivacySettings.DATA_MMS, null, pSet);
+                }
+            } catch (Exception e) {
+                Log.e(TAG, "failed to enforce intent broadcast permission", e);
+            }
+            
+            if (tmpMmsReceivers > 1) {
+                tmpMmsReceivers--;
+            } else { // free memory after all receivers have been served
+//                Log.d(TAG, "removing intent with hash: " + tmpMmsHash);
+                tmpMms = null;
+            }
+            
+//            Log.d(TAG, "broadcasting intent " + action + " - " + packageName + " (" + uid + ") output: " + output);
+        } else if (action.equals(Intent.ACTION_BOOT_COMPLETED)) {
+            pSetMan.setBootCompleted();
+            
+//            if (pSet != null && pSet.getIntentBootCompletedSetting() != PrivacySettings.REAL) {
+                // no notification since all applications will receive this -> spam
+//                intent.setAction("empty");
+//                pSetMan.notification(packageName, uid, PrivacySettings.EMPTY, PrivacySettings.DATA_INTENT_BOOT_COMPLETED, null, pSet);
+//            } else {
+//                intent.setAction(Intent.ACTION_BOOT_COMPLETED);
+//                pSetMan.notification(packageName, uid, PrivacySettings.REAL, PrivacySettings.DATA_INTENT_BOOT_COMPLETED, null, pSet);
+//            }
+        } else if (action.equals(Intent.ACTION_PACKAGE_ADDED)) {
+//            Log.d(TAG, "enforcePrivacyPermission - ACTION_PACKAGE_ADDED; receivers: " + receivers);
+            
+            // update privacy settings; only do this once for a single Intent
+            if (tmpPackageAddedHash != hashCode(intent)) {
+                tmpPackageAddedHash = hashCode(intent);
+                
+                String addedPackageName = intent.getData().getSchemeSpecificPart();
+                int addedUid = intent.getExtras().getInt(Intent.EXTRA_UID);
+//                Log.d(TAG, "enforcePrivacyPermission - installed package " + addedPackageName + " " + addedUid);
+                pSet = pSetMan.getSettings(addedPackageName, addedUid);
+                // the settings in the privacy DB contain a different UID
+                if (pSet != null && pSet.getUid() != addedUid) { // update the UID
+//                    Log.i(TAG, "installed package UID (" + addedUid + ") doesn't match privacy settings UID (" + pSet.getUid() + "); updating...");
+                    pSet.setUid(addedUid);
+                    /*boolean updateSuccess = */pSetMan.saveSettings(pSet);
+//                    if (!updateSuccess) Log.w(TAG, "could not update privacy settings UID; purge needed");
+                }
+            }
+        }
+    }
+    
+    private static long hashCode(Intent intent) {
+        long privacyHash = intent.getLongExtra("privacy_hash", 0);
+        if (privacyHash == 0) {
+            privacyHash = intent.filterHashCode() + System.currentTimeMillis();
+            intent.putExtra("privacy_hash", privacyHash);
+        }
+        return privacyHash;
+    }
+}
diff --git a/privacy/java/android/privacy/surrogate/PrivacyContentResolver.java b/privacy/java/android/privacy/surrogate/PrivacyContentResolver.java
new file mode 100644
index 0000000..8542cc7
--- /dev/null
+++ b/privacy/java/android/privacy/surrogate/PrivacyContentResolver.java
@@ -0,0 +1,171 @@
+package android.privacy.surrogate;
+
+import android.content.Context;
+import android.content.IContentProvider;
+import android.database.Cursor;
+import android.net.Uri;
+import android.os.Binder;
+import android.os.RemoteException;
+import android.privacy.PrivacySettings;
+import android.privacy.PrivacySettingsManager;
+import android.provider.Browser;
+import android.provider.CalendarContract;
+import android.provider.CallLog;
+import android.provider.ContactsContract;
+import android.provider.Telephony.Mms;
+import android.provider.Telephony.MmsSms;
+import android.provider.Telephony.Sms;
+import android.util.Log;
+
+/**
+ * Provides privacy handling for {@link android.content.ContentResolver}
+ * @author Svyatoslav Hresyk 
+ * {@hide}
+ */
+public final class PrivacyContentResolver {
+    
+    private static final String TAG = "PrivacyContentResolver";
+    
+    private static PrivacySettingsManager pSetMan;
+    
+    /**
+     * Returns a dummy database cursor if access is restricted by privacy settings
+     * @param uri
+     * @param context
+     * @param realCursor
+     */
+    public static Cursor enforcePrivacyPermission(Uri uri, String[] projection, Context context, Cursor realCursor) throws RemoteException {
+//    public static Cursor enforcePrivacyPermission(Uri uri, Context context, Cursor realCursor) {
+        if (uri != null) {
+            if (pSetMan == null) pSetMan = (PrivacySettingsManager) context.getSystemService("privacy");
+            String packageName = context.getPackageName();
+            int uid = Binder.getCallingUid();
+            PrivacySettings pSet = pSetMan.getSettings(packageName, uid);
+            String auth = uri.getAuthority();
+            String output_label = "[real]";
+            Cursor output = realCursor;
+            if (auth != null) {
+                if (auth.equals(android.provider.Contacts.AUTHORITY) || auth.equals(ContactsContract.AUTHORITY)) {
+
+                    if (pSet != null) {
+                        if (pSet.getContactsSetting() == PrivacySettings.EMPTY) {
+                            output_label = "[empty]";
+                            output = new PrivacyCursor();
+                            pSetMan.notification(packageName, uid, PrivacySettings.EMPTY, PrivacySettings.DATA_CONTACTS, null, pSet);
+                        } else if (pSet.getContactsSetting() == PrivacySettings.CUSTOM && 
+                                uri.toString().contains(ContactsContract.Contacts.CONTENT_URI.toString())) {
+//                            Log.d(TAG, "enforcePrivacyPermission - URI: " + uri.toString() + " " + uri.getAuthority() + " " + uri.getEncodedAuthority() + " " + uri.getEncodedFragment() + " " + uri.getEncodedPath() + " " + uri.getEncodedQuery() + " " + uri.getEncodedSchemeSpecificPart() + " " + uri.getEncodedUserInfo() + " " + uri.getFragment() + " " + uri.getPath());
+//                            Log.d(TAG, "enforcePrivacyPermission - projection: " + arrayToString(projection) + " selection: " + selection + " selectionArgs: " + arrayToString(selectionArgs));
+//                            Log.d(TAG, "enforcePrivacyPermission - cursor entries: " + output.getCount());
+                            
+                            boolean idFound = false;
+                            if (projection != null) {
+                                for (String p : projection) {
+                                    if (p.equals(ContactsContract.Contacts._ID)) {
+                                        idFound = true;
+                                        break;
+                                    }
+                                }
+                                
+//                                if (!idFound) { // add ID to projection
+//                                    String[] newProjection = new String[projection.length + 1];
+//                                    System.arraycopy(projection, 0, newProjection, 0, projection.length);
+//                                    newProjection[projection.length] = ContactsContract.Contacts._ID;
+//                                    projection = newProjection;
+//                                }
+                            }
+                            
+                            if (!idFound) {
+                                output = new PrivacyCursor();
+                            } else {
+//                            Log.d(TAG, "enforcePrivacyPermission - new projection: " + arrayToString(projection) + " selection: " + selection + " selectionArgs: " + arrayToString(selectionArgs));
+                            
+                            // re-query
+//                            output = provider.query(uri, projection, selection, selectionArgs, sortOrder);
+//                            Log.d(TAG, "enforcePrivacyPermission - new cursor entries: " + output.getCount());
+                                output = new PrivacyCursor(output, pSet.getAllowedContacts());
+                            }
+                            pSetMan.notification(packageName, uid, PrivacySettings.CUSTOM, PrivacySettings.DATA_CONTACTS, null, pSet);
+                        } else { // REAL
+                            pSetMan.notification(packageName, uid, PrivacySettings.REAL, PrivacySettings.DATA_CONTACTS, null, pSet);
+                        }
+                    }
+                    
+                } else if (auth.equals(CalendarContract.AUTHORITY)) {
+                    
+                    if (pSet != null && pSet.getCalendarSetting() == PrivacySettings.EMPTY) {
+                        output_label = "[empty]";
+                        output = new PrivacyCursor();
+                        pSetMan.notification(packageName, uid, PrivacySettings.EMPTY, PrivacySettings.DATA_CALENDAR, null, pSet);
+                    } else {
+                        pSetMan.notification(packageName, uid, PrivacySettings.REAL, PrivacySettings.DATA_CALENDAR, null, pSet);
+                    }
+                    
+                } else if (auth.equals(Mms.CONTENT_URI.getAuthority())) {
+                    
+                    if (pSet != null && pSet.getMmsSetting() == PrivacySettings.EMPTY) {
+                        output_label = "[empty]";
+                        output = new PrivacyCursor();
+                        pSetMan.notification(packageName, uid, PrivacySettings.EMPTY, PrivacySettings.DATA_MMS, null, pSet);
+                    } else {
+                        pSetMan.notification(packageName, uid, PrivacySettings.REAL, PrivacySettings.DATA_MMS, null, pSet);
+                    }
+                    
+                } else if (auth.equals(Sms.CONTENT_URI.getAuthority())) {
+                    
+                    if (pSet != null && pSet.getSmsSetting() == PrivacySettings.EMPTY) {
+                        output_label = "[empty]";
+                        output = new PrivacyCursor();
+                        pSetMan.notification(packageName, uid, PrivacySettings.EMPTY, PrivacySettings.DATA_SMS, null, pSet);
+                    } else {
+                        pSetMan.notification(packageName, uid, PrivacySettings.REAL, PrivacySettings.DATA_SMS, null, pSet);
+                    }
+                // all messages, sms and mms
+                } else if (auth.equals(MmsSms.CONTENT_URI.getAuthority()) || 
+                        auth.equals("mms-sms-v2") /* htc specific, accessed by system messages application */) { 
+                    
+                    // deny access if access to either sms, mms or both is restricted by privacy settings
+                    if (pSet != null && (pSet.getMmsSetting() == PrivacySettings.EMPTY || 
+                            pSet.getSmsSetting() == PrivacySettings.EMPTY)) {
+                        output_label = "[empty]";
+                        output = new PrivacyCursor();
+                        pSetMan.notification(packageName, uid, PrivacySettings.EMPTY, PrivacySettings.DATA_MMS_SMS, null, pSet);
+                    } else {
+                        pSetMan.notification(packageName, uid, PrivacySettings.REAL, PrivacySettings.DATA_MMS_SMS, null, pSet);
+                    }
+
+                } else if (auth.equals(CallLog.AUTHORITY)) {
+                    
+                    if (pSet != null && pSet.getCallLogSetting() == PrivacySettings.EMPTY) {
+                        output_label = "[empty]";
+                        output = new PrivacyCursor();
+                        pSetMan.notification(packageName, uid, PrivacySettings.EMPTY, PrivacySettings.DATA_CALL_LOG, null, pSet);
+                    } else {
+                        pSetMan.notification(packageName, uid, PrivacySettings.REAL, PrivacySettings.DATA_CALL_LOG, null, pSet);
+                    }
+
+                } else if (auth.equals(Browser.BOOKMARKS_URI.getAuthority())) {
+                    
+                    if (pSet != null && pSet.getBookmarksSetting() == PrivacySettings.EMPTY) {
+                        output_label = "[empty]";
+                        output = new PrivacyCursor();
+                        pSetMan.notification(packageName, uid, PrivacySettings.EMPTY, PrivacySettings.DATA_BOOKMARKS, null, pSet);
+                    } else {
+                        pSetMan.notification(packageName, uid, PrivacySettings.REAL, PrivacySettings.DATA_BOOKMARKS, null, pSet);
+                    }
+                    
+                }
+            }
+//            Log.d(TAG, "query - " + packageName + " (" + uid + ") auth: " + auth + " output: " + output_label);
+            return output;
+        }
+        return realCursor;
+    }
+    
+    private static String arrayToString(String[] array) {
+        StringBuffer sb = new StringBuffer();
+        if (array != null) for (String bla : array) sb.append("[" + bla + "]");
+        else return "";
+        return sb.toString();
+    }
+}
diff --git a/privacy/java/android/privacy/surrogate/PrivacyCursor.java b/privacy/java/android/privacy/surrogate/PrivacyCursor.java
new file mode 100644
index 0000000..fdb4913
--- /dev/null
+++ b/privacy/java/android/privacy/surrogate/PrivacyCursor.java
@@ -0,0 +1,404 @@
+package android.privacy.surrogate;
+
+import android.content.ContentResolver;
+import android.database.CharArrayBuffer;
+import android.database.ContentObserver;
+import android.database.Cursor;
+import android.database.DataSetObserver;
+import android.net.Uri;
+import android.os.Bundle;
+import android.provider.ContactsContract;
+import android.util.Log;
+
+import java.util.Map;
+
+/**
+ * Dummy database cursor. Used by {@link android.privacy.surrogate.PrivacyContentResolver} 
+ * when access should be blocked without crashing the calling application (for this purpose none 
+ * of the methods returns null) or for fine-granular control of access to individual database entries.
+ * The latter may produce inconsistencies from the applicatin point of view based on getPosition()
+ * and moveToPosition().
+ * {@hide}
+ */
+public class PrivacyCursor implements Cursor {
+    
+    private Cursor realCursor;
+    
+    private int[] allowedIds;
+    
+    private int[] allowedIdMapping;
+    
+    private final static String TAG = "PrivacyCursor";
+    
+    public PrivacyCursor() {
+    }
+    
+    /**
+     * 
+     * @param realCursor may not be null
+     * @param allowedIds
+     */
+    public PrivacyCursor(Cursor realCursor, int[] allowedIds) {
+        this.realCursor = (allowedIds == null || allowedIds.length == 0) ? null : realCursor;
+        this.allowedIds = allowedIds;
+        if (this.realCursor != null) {
+            int currentPos = this.realCursor.getPosition();
+            this.allowedIdMapping = new int[allowedIds.length];
+            int i = 0;
+            while (this.realCursor.moveToNext()) {
+                if (isAllowed(this.realCursor)) {
+                    allowedIdMapping[i] = this.realCursor.getPosition();
+                    i++;
+                }
+            }
+            this.realCursor.moveToPosition(currentPos);
+        }
+    }
+
+    @Override
+    public void close() {
+//        Log.d(TAG, new Exception().getStackTrace()[0].getMethodName());
+        if (realCursor != null) realCursor.close();
+    }
+
+    @Override
+    public void copyStringToBuffer(int columnIndex, CharArrayBuffer buffer) {
+//        Log.d(TAG, new Exception().getStackTrace()[0].getMethodName());
+        if (realCursor != null) realCursor.copyStringToBuffer(columnIndex, buffer);
+    }
+
+    @Override
+    public void deactivate() {
+//        Log.d(TAG, new Exception().getStackTrace()[0].getMethodName());
+        if (realCursor != null) realCursor.deactivate();
+    }
+
+    @Override
+    public byte[] getBlob(int columnIndex) {
+//        Log.d(TAG, new Exception().getStackTrace()[0].getMethodName());
+        if (realCursor != null) return realCursor.getBlob(columnIndex);
+        return new byte[0];
+    }
+
+    @Override
+    public int getColumnCount() {
+//        Log.d(TAG, new Exception().getStackTrace()[0].getMethodName());
+        if (realCursor != null) return realCursor.getColumnCount();
+        return 0;
+    }
+
+    @Override
+    public int getColumnIndex(String columnName) {
+//        Log.d(TAG, new Exception().getStackTrace()[0].getMethodName());
+        if (realCursor != null) return realCursor.getColumnIndex(columnName);
+        return -1;
+    }
+
+    @Override
+    public int getColumnIndexOrThrow(String columnName) throws IllegalArgumentException {
+//        Log.d(TAG, new Exception().getStackTrace()[0].getMethodName());
+        if (realCursor != null) return realCursor.getColumnIndexOrThrow(columnName);
+        return -1;
+    }
+
+    @Override
+    public String getColumnName(int columnIndex) {
+//        Log.d(TAG, new Exception().getStackTrace()[0].getMethodName());
+        if (realCursor != null) return realCursor.getColumnName(columnIndex);
+        return "";
+    }
+
+    @Override
+    public String[] getColumnNames() {
+//        Log.d(TAG, new Exception().getStackTrace()[0].getMethodName());
+        if (realCursor != null) return realCursor.getColumnNames();
+        return new String[] { "" };
+    }
+
+    @Override
+    public int getCount() {
+//        Log.d(TAG, new Exception().getStackTrace()[0].getMethodName());
+        if (realCursor != null) {
+            Log.d(TAG, "getCount: " + allowedIdMapping.length);
+            return allowedIdMapping.length;
+        }
+        return 0;
+    }
+
+    @Override
+    public double getDouble(int columnIndex) {
+//        Log.d(TAG, new Exception().getStackTrace()[0].getMethodName());
+        if (realCursor != null) return realCursor.getDouble(columnIndex);
+        return 0;
+    }
+
+    @Override
+    public Bundle getExtras() {
+//        Log.d(TAG, new Exception().getStackTrace()[0].getMethodName());
+        if (realCursor != null) return realCursor.getExtras();
+        return new Bundle();
+    }
+
+    @Override
+    public float getFloat(int columnIndex) {
+//        Log.d(TAG, new Exception().getStackTrace()[0].getMethodName());
+        if (realCursor != null) return realCursor.getFloat(columnIndex);
+        return 0;
+    }
+
+    @Override
+    public int getInt(int columnIndex) {
+        if (realCursor != null) {
+            int result = realCursor.getInt(columnIndex);
+//            Log.d(TAG, "getInt - columnIndex: " + columnIndex + " name: " + realCursor.getColumnName(columnIndex) + " result: " + result);
+            return result;
+        }
+        return 0;
+    }
+
+    @Override
+    public long getLong(int columnIndex) {
+//        Log.d(TAG, new Exception().getStackTrace()[0].getMethodName());
+        if (realCursor != null) return realCursor.getLong(columnIndex);
+        return 0;
+    }
+
+    @Override
+    public int getPosition() {
+//        Log.d(TAG, new Exception().getStackTrace()[0].getMethodName());
+        if (realCursor != null) {
+            int result = getMappedPos(realCursor.getPosition());
+            Log.d(TAG, "getPosition - mapped position: " + result + " real position: " + realCursor.getPosition());
+            return result;
+        }
+        return -1;
+    }
+
+    @Override
+    public short getShort(int columnIndex) {
+//        Log.d(TAG, new Exception().getStackTrace()[0].getMethodName());
+        if (realCursor != null) return realCursor.getShort(columnIndex);
+        return 0;
+    }
+
+    @Override
+    public String getString(int columnIndex) {
+//        Log.d(TAG, new Exception().getStackTrace()[0].getMethodName());
+        if (realCursor != null) return realCursor.getString(columnIndex);
+        return "";
+    }
+
+    @Override
+    public int getType(int columnIndex) {
+//        Log.d(TAG, new Exception().getStackTrace()[0].getMethodName());
+        if (realCursor != null) return realCursor.getType(columnIndex);
+        return realCursor.FIELD_TYPE_NULL;
+    }
+
+    @Override
+    public boolean getWantsAllOnMoveCalls() {
+//        Log.d(TAG, new Exception().getStackTrace()[0].getMethodName());
+        if (realCursor != null) return realCursor.getWantsAllOnMoveCalls();
+        return false;
+    }
+
+    @Override
+    public boolean isAfterLast() {
+//        Log.d(TAG, new Exception().getStackTrace()[0].getMethodName());
+        if (realCursor != null) return realCursor.isAfterLast();
+        return false;
+    }
+
+    @Override
+    public boolean isBeforeFirst() {
+//        Log.d(TAG, new Exception().getStackTrace()[0].getMethodName());
+        if (realCursor != null) return realCursor.isBeforeFirst();
+        return false;
+    }
+
+    @Override
+    public boolean isClosed() {
+//        Log.d(TAG, new Exception().getStackTrace()[0].getMethodName());
+        if (realCursor != null) return realCursor.isClosed();
+        return false;
+    }
+
+    @Override
+    public boolean isFirst() {
+        if (realCursor != null) {
+//            Log.d(TAG, "isFirst");
+            if (realCursor.getPosition() == allowedIdMapping[0]) return true;
+        }
+        return false;
+    }
+
+    @Override
+    public boolean isLast() {
+        if (realCursor != null) {
+//            Log.d(TAG, "isLast");
+            if (realCursor.getPosition() == allowedIdMapping[allowedIdMapping.length - 1]) return true;
+        }
+        return false;
+    }
+
+    @Override
+    public boolean isNull(int columnIndex) {
+//        Log.d(TAG, new Exception().getStackTrace()[0].getMethodName());
+        if (realCursor != null) return realCursor.isNull(columnIndex);
+        return false;
+    }
+
+    @Override
+    public boolean move(int offset) {
+        if (realCursor != null) {
+            Log.d(TAG, "move - offset: " + offset);
+            try {
+                int realPos = allowedIdMapping[getMappedPos(realCursor.getPosition()) + offset];
+                boolean result = realCursor.moveToPosition(realPos);
+//                Log.d(TAG, "move - position: " + realCursor.getPosition() + " result: " + result);
+                return result;
+            } catch (ArrayIndexOutOfBoundsException e) {
+                return false;
+            }
+        }
+        return false;
+    }
+
+    @Override
+    public boolean moveToFirst() {
+        if (realCursor != null) {
+            boolean result = realCursor.moveToPosition(allowedIdMapping[0]); 
+//            Log.d(TAG, "moveToFirst - position: " + allowedIdMapping[0] + " result: " + result);
+            return result;
+        }
+        return false;
+    }
+
+    @Override
+    public boolean moveToLast() {
+        if (realCursor != null) {
+            boolean result = realCursor.moveToPosition(allowedIdMapping[allowedIdMapping.length - 1]);
+//            Log.d(TAG, "moveToLast - real position: " + realCursor.getPosition() + " result: " + result);
+            return result;
+        }
+        return false;
+    }
+
+    @Override
+    public boolean moveToNext() {
+        if (realCursor != null) {
+            if (!realCursor.moveToNext()) return false;
+            boolean result = true;
+            while (result == true && !isAllowed(realCursor)) result = realCursor.moveToNext();
+//            Log.d(TAG, "moveToNext - real position: " + realCursor.getPosition() + " result: " + result);
+            return result;
+        }
+        return false;
+    }
+
+    @Override
+    public boolean moveToPosition(int position) {
+        if (realCursor != null) {
+            try {
+                boolean result = realCursor.moveToPosition(allowedIdMapping[position]);
+//                Log.d(TAG, "moveToPosition - real position: " + realCursor.getPosition() + " result: " + result);
+                return result;
+            } catch (ArrayIndexOutOfBoundsException e) {
+                return false;
+            }
+        }
+        return false;
+    }
+
+    @Override
+    public boolean moveToPrevious() {
+        if (realCursor != null) {
+            if (!realCursor.moveToPrevious()) return false;
+            boolean result = true;
+            while (result == true && !isAllowed(realCursor)) result = realCursor.moveToPrevious();
+//            Log.d(TAG, "moveToPrevious - real position: " + realCursor.getPosition() + " result: " + result);
+            return result;
+        }        
+        return false;
+    }
+
+    @Override
+    public void registerContentObserver(ContentObserver observer) {
+//        Log.d(TAG, new Exception().getStackTrace()[0].getMethodName());
+        if (realCursor != null) realCursor.registerContentObserver(observer);        
+    }
+
+    @Override
+    public void registerDataSetObserver(DataSetObserver observer) {
+//        Log.d(TAG, new Exception().getStackTrace()[0].getMethodName());
+        if (realCursor != null) realCursor.registerDataSetObserver(observer);        
+    }
+
+    @Override
+    public boolean requery() {
+//        Log.d(TAG, new Exception().getStackTrace()[0].getMethodName());
+        if (realCursor != null) return realCursor.requery();
+        return false;
+    }
+
+    @Override
+    public Bundle respond(Bundle extras) {
+//        Log.d(TAG, new Exception().getStackTrace()[0].getMethodName());
+        if (realCursor != null) return realCursor.respond(extras);        
+        return new Bundle();
+    }
+
+    @Override
+    public void setNotificationUri(ContentResolver cr, Uri uri) {
+//        Log.d(TAG, new Exception().getStackTrace()[0].getMethodName());
+        if (realCursor != null) realCursor.setNotificationUri(cr, uri);        
+    }
+
+    @Override
+    public void unregisterContentObserver(ContentObserver observer) {
+//        Log.d(TAG, new Exception().getStackTrace()[0].getMethodName());
+        if (realCursor != null) realCursor.unregisterContentObserver(observer);        
+    }
+
+    @Override
+    public void unregisterDataSetObserver(DataSetObserver observer) {
+//        Log.d(TAG, new Exception().getStackTrace()[0].getMethodName());
+        if (realCursor != null) realCursor.unregisterDataSetObserver(observer);
+    }
+
+    private int getContactId(Cursor c) {
+        int colIndex = c.getColumnIndex(ContactsContract.Contacts._ID);
+        int result = -1;
+        if (colIndex != -1) result = c.getInt(colIndex); 
+//        Log.d(TAG, "getContactId - colIndex: " + colIndex + " id: " + result);
+        return result;
+    }
+    
+    private boolean isAllowed(int id) {
+        boolean result = false;
+        for (int i : allowedIds) {
+            if (id == i) {
+                result = true;
+                break;
+            }
+        }
+//        Log.d(TAG, "isAllowed - id: " + id + " result: " + result);
+        return result;
+    }
+    
+    private boolean isAllowed(Cursor realCursor) {
+        return isAllowed(getContactId(realCursor));
+    }
+    
+    /**
+     * TODO: switch to HashMap etc to speed this up?
+     * @param realPos
+     * @return
+     */
+    private int getMappedPos(int realPos) {
+        for (int i = 0; i < allowedIdMapping.length; i++) {
+            if (allowedIdMapping[i] == realPos) return i;
+        }
+        return -1;
+    }
+}
diff --git a/privacy/java/android/privacy/surrogate/PrivacyLocationManager.java b/privacy/java/android/privacy/surrogate/PrivacyLocationManager.java
new file mode 100644
index 0000000..1c0aa68
--- /dev/null
+++ b/privacy/java/android/privacy/surrogate/PrivacyLocationManager.java
@@ -0,0 +1,520 @@
+package android.privacy.surrogate;
+
+import android.app.PendingIntent;
+import android.content.Context;
+import android.location.Criteria;
+import android.location.ILocationManager;
+import android.location.Location;
+import android.location.LocationListener;
+import android.location.LocationManager;
+import android.location.LocationProvider;
+import android.location.GpsStatus.NmeaListener;
+import android.os.Binder;
+import android.os.Looper;
+import android.os.ServiceManager;
+import android.privacy.IPrivacySettingsManager;
+import android.privacy.PrivacySettings;
+import android.privacy.PrivacySettingsManager;
+import android.util.Log;
+
+/**
+ * Provides privacy handling for {@link android.location.LocationManager}
+ * @author Svyatoslav Hresyk
+ * {@hide}
+ */
+public final class PrivacyLocationManager extends LocationManager {
+
+    private static final String TAG = "PrivacyLocationManager";
+    
+    private static final int CUSTOM_LOCATION_UPDATE_COUNT = 5;
+    
+    private Context context;
+    
+    private PrivacySettingsManager pSetMan;
+    
+    private Object lock = new Object();
+    
+    /** {@hide} */
+    public PrivacyLocationManager(ILocationManager service, Context context) {
+        super(service);
+        this.context = context;
+//        pSetMan = (PrivacySettingsManager) context.getSystemService("privacy");
+        pSetMan = new PrivacySettingsManager(context, IPrivacySettingsManager.Stub.asInterface(ServiceManager.getService("privacy")));        
+    }
+
+    @Override
+    public boolean addNmeaListener(NmeaListener listener) {
+        // only blocks if access is not allowed
+        // custom and random values not implemented due to Decimal Degrees->NMEA conversion complexity
+        String packageName = context.getPackageName();
+        int uid = Binder.getCallingUid();
+        PrivacySettings pSet = pSetMan.getSettings(packageName, uid);
+        
+        if (pSet != null && pSet.getLocationGpsSetting() != PrivacySettings.REAL) {
+            pSetMan.notification(packageName, uid, PrivacySettings.EMPTY, PrivacySettings.DATA_LOCATION_GPS, null, pSet);
+            return false;
+        } else {
+            pSetMan.notification(packageName, uid, PrivacySettings.REAL, PrivacySettings.DATA_LOCATION_GPS, null, pSet);
+        }
+//        Log.d(TAG, "addNmeaListener - " + context.getPackageName() + " (" + Binder.getCallingUid() + ") output: [real value]");
+        return super.addNmeaListener(listener);
+    }
+
+    @Override
+    public Location getLastKnownLocation(String provider) {
+        if (provider == null) return super.getLastKnownLocation(provider);
+        
+        String packageName = context.getPackageName();
+        int uid = Binder.getCallingUid();
+        PrivacySettings pSet = pSetMan.getSettings(packageName, uid);
+        Location output = null;
+        
+        if (pSet != null) {
+            if (provider.equals(LocationManager.GPS_PROVIDER)) {
+                switch (pSet.getLocationGpsSetting()) {
+                    case PrivacySettings.REAL:
+                        output = super.getLastKnownLocation(provider);
+                        pSetMan.notification(packageName, uid, PrivacySettings.REAL, PrivacySettings.DATA_LOCATION_GPS, 
+                                (output != null ? "Lat: " + output.getLatitude() + " Lon: " + output.getLongitude() : null), pSet);
+                        break;
+                    case PrivacySettings.EMPTY:
+                        pSetMan.notification(packageName, uid, PrivacySettings.EMPTY, PrivacySettings.DATA_LOCATION_GPS, null, pSet);
+                        break;
+                    case PrivacySettings.CUSTOM:
+                        output = new Location(provider);
+                        output.setLatitude(Double.parseDouble(pSet.getLocationGpsLat()));
+                        output.setLongitude(Double.parseDouble(pSet.getLocationGpsLon()));
+                        pSetMan.notification(packageName, uid, PrivacySettings.CUSTOM, PrivacySettings.DATA_LOCATION_GPS, 
+                                "Lat: " + output.getLatitude() + " Lon: " + output.getLongitude(), pSet);
+                        break;
+                    case PrivacySettings.RANDOM:
+                        output = new Location(provider);
+                        output.setLatitude(Double.parseDouble(pSet.getLocationGpsLat()));
+                        output.setLongitude(Double.parseDouble(pSet.getLocationGpsLon()));
+                        pSetMan.notification(packageName, uid, PrivacySettings.RANDOM, PrivacySettings.DATA_LOCATION_GPS, 
+                                "Lat: " + output.getLatitude() + " Lon: " + output.getLongitude(), pSet);
+                        break;
+                }
+            } else if (provider.equals(LocationManager.NETWORK_PROVIDER)) {
+                switch (pSet.getLocationNetworkSetting()) {
+                    case PrivacySettings.REAL:
+                        output = super.getLastKnownLocation(provider);
+                        pSetMan.notification(packageName, uid, PrivacySettings.REAL, PrivacySettings.DATA_LOCATION_NETWORK, 
+                                output != null ? "Lat: " + output.getLatitude() + " Lon: " + output.getLongitude() : null, pSet);
+                        break;
+                    case PrivacySettings.EMPTY:
+                        pSetMan.notification(packageName, uid, PrivacySettings.EMPTY, PrivacySettings.DATA_LOCATION_NETWORK, null, pSet);
+                        break;
+                    case PrivacySettings.CUSTOM:
+                        output = new Location(provider);
+                        output.setLatitude(Double.parseDouble(pSet.getLocationNetworkLat()));
+                        output.setLongitude(Double.parseDouble(pSet.getLocationNetworkLon()));
+                        pSetMan.notification(packageName, uid, PrivacySettings.CUSTOM, PrivacySettings.DATA_LOCATION_NETWORK, 
+                                "Lat: " + output.getLatitude() + " Lon: " + output.getLongitude(), pSet);
+                        break;
+                    case PrivacySettings.RANDOM:
+                        output = new Location(provider);
+                        output.setLatitude(Double.parseDouble(pSet.getLocationNetworkLat()));
+                        output.setLongitude(Double.parseDouble(pSet.getLocationNetworkLon()));
+                        pSetMan.notification(packageName, uid, PrivacySettings.RANDOM, PrivacySettings.DATA_LOCATION_NETWORK, 
+                                "Lat: " + output.getLatitude() + " Lon: " + output.getLongitude(), pSet);
+                        break;
+                }
+            } else if (provider.equals(LocationManager.PASSIVE_PROVIDER) && 
+                    pSet.getLocationGpsSetting() == PrivacySettings.REAL && 
+                            pSet.getLocationNetworkSetting() == PrivacySettings.REAL) {
+                // only output real location if both gps and network are allowed
+                output = super.getLastKnownLocation(provider);
+                pSetMan.notification(packageName, uid, PrivacySettings.REAL, PrivacySettings.DATA_LOCATION_GPS, 
+                        output != null ? "Lat: " + output.getLatitude() + " Lon: " + output.getLongitude() : null, pSet);
+            }
+        } else {
+            output = super.getLastKnownLocation(provider);
+            if (provider.equals(LocationManager.NETWORK_PROVIDER)) {
+                pSetMan.notification(packageName, uid, PrivacySettings.REAL, PrivacySettings.DATA_LOCATION_NETWORK, 
+                    output != null ? "Lat: " + output.getLatitude() + " Lon: " + output.getLongitude() : null, pSet);
+            } else { // including GPS and passive providers
+                pSetMan.notification(packageName, uid, PrivacySettings.REAL, PrivacySettings.DATA_LOCATION_GPS, 
+                        output != null ? "Lat: " + output.getLatitude() + " Lon: " + output.getLongitude() : null, pSet);
+            }
+        }
+        
+//        Log.d(TAG, "getLastKnownLocation - " + context.getPackageName() + " (" + Binder.getCallingUid() + 
+//                ") output: " + output);
+        return output;
+    }
+
+    @Override
+    public LocationProvider getProvider(String name) {
+        if (name == null) return super.getProvider(name);
+        
+        PrivacySettings pSet = pSetMan.getSettings(context.getPackageName(), Binder.getCallingUid());
+        LocationProvider output = null;
+        
+        if (pSet != null) {
+            if (name.equals(LocationManager.GPS_PROVIDER)) {
+                switch (pSet.getLocationGpsSetting()) {
+                    case PrivacySettings.REAL:
+                    case PrivacySettings.CUSTOM:
+                    case PrivacySettings.RANDOM:
+                        output = super.getProvider(name);
+                        break;
+                    case PrivacySettings.EMPTY:
+                        break;
+                }
+            } else if (name.equals(LocationManager.NETWORK_PROVIDER)) {
+                switch (pSet.getLocationNetworkSetting()) {
+                    case PrivacySettings.REAL:
+                    case PrivacySettings.CUSTOM:
+                    case PrivacySettings.RANDOM:
+                        output = super.getProvider(name);
+                        break;
+                    case PrivacySettings.EMPTY:
+                        break;
+                }
+            } else if (name.equals(LocationManager.PASSIVE_PROVIDER)) { // could get location from any of above
+                if (pSet.getLocationGpsSetting() == PrivacySettings.REAL || 
+                        pSet.getLocationNetworkSetting() == PrivacySettings.REAL) {
+                    output = super.getProvider(name);
+                }
+            }
+        } else {
+            output = super.getProvider(name);
+        }
+            
+//        Log.d(TAG, "getProvider - " + context.getPackageName() + " (" + Binder.getCallingUid() + ") output: " + 
+//                (output != null ? "[real value]" : "[null]"));
+        return output;
+    }
+
+    @Override
+    public boolean isProviderEnabled(String provider) {
+        if (provider == null) return super.isProviderEnabled(provider);
+        
+        PrivacySettings pSet = pSetMan.getSettings(context.getPackageName(), Binder.getCallingUid());
+        boolean output = false;
+        
+        if (pSet != null) {
+            if (provider.equals(LocationManager.GPS_PROVIDER)) {
+                switch (pSet.getLocationGpsSetting()) {
+                    case PrivacySettings.REAL:
+                        output = super.isProviderEnabled(provider);
+                        break;
+                    case PrivacySettings.EMPTY:
+                        break;
+                    case PrivacySettings.CUSTOM:
+                    case PrivacySettings.RANDOM:
+                        output = true;
+                        break;
+                }
+            } else if (provider.equals(LocationManager.NETWORK_PROVIDER)) {
+                switch (pSet.getLocationNetworkSetting()) {
+                    case PrivacySettings.REAL:
+                        output = super.isProviderEnabled(provider);
+                        break;
+                    case PrivacySettings.EMPTY:
+                        break;
+                    case PrivacySettings.CUSTOM:
+                    case PrivacySettings.RANDOM:
+                        output = true;
+                        break;
+                }
+            } else if (provider.equals(LocationManager.PASSIVE_PROVIDER)) { // could get location from any of above
+                if (pSet.getLocationGpsSetting() == PrivacySettings.REAL || 
+                        pSet.getLocationNetworkSetting() == PrivacySettings.REAL) {
+                    output = super.isProviderEnabled(provider);
+                } else {
+                    output = false;
+                }
+            }
+        } else { // if querying unknown provider
+            output = super.isProviderEnabled(provider);
+        }
+        
+//        Log.d(TAG, "isProviderEnabled - " + context.getPackageName() + " (" + Binder.getCallingUid() + ") provider: " 
+//                + provider + "output: " + output);
+        return output;
+    }
+
+    @Override
+    public void requestLocationUpdates(long minTime, float minDistance, Criteria criteria, LocationListener listener,
+            Looper looper) {
+        if (criteria == null || listener == null) {
+            super.requestLocationUpdates(minTime, minDistance, criteria, listener, looper);
+            return;
+        }
+        if (requestLocationUpdates(criteria, listener, null)) return;
+        super.requestLocationUpdates(minTime, minDistance, criteria, listener, looper);
+    }
+
+    @Override
+    public void requestLocationUpdates(long minTime, float minDistance, Criteria criteria, PendingIntent intent) {
+        if (criteria == null || intent == null) {
+            super.requestLocationUpdates(minTime, minDistance, criteria, intent);
+            return;
+        }
+        if (requestLocationUpdates(criteria, null, intent)) return;
+        super.requestLocationUpdates(minTime, minDistance, criteria, intent);
+    }
+
+    @Override
+    public void requestLocationUpdates(String provider, long minTime, float minDistance, LocationListener listener,
+            Looper looper) {
+        if (provider == null || listener == null) {
+            super.requestLocationUpdates(provider, minTime, minDistance, listener, looper);
+            return;
+        }
+        if (requestLocationUpdates(provider, listener, null)) return;
+        super.requestLocationUpdates(provider, minTime, minDistance, listener, looper);
+    }
+
+    @Override
+    public void requestLocationUpdates(String provider, long minTime, float minDistance, LocationListener listener) {
+        if (provider == null || listener == null) {
+            super.requestLocationUpdates(provider, minTime, minDistance, listener);
+            return;
+        }
+        if (requestLocationUpdates(provider, listener, null)) return;
+        super.requestLocationUpdates(provider, minTime, minDistance, listener);
+    }
+
+    @Override
+    public void requestLocationUpdates(String provider, long minTime, float minDistance, PendingIntent intent) {
+        if (provider == null || intent == null) {
+            super.requestLocationUpdates(provider, minTime, minDistance, intent);
+            return;
+        }
+        if (requestLocationUpdates(provider, null, intent)) return;
+        super.requestLocationUpdates(provider, minTime, minDistance, intent);
+    }
+
+    @Override
+    public void requestSingleUpdate(Criteria criteria, LocationListener listener, Looper looper) {
+        if (criteria == null || listener == null) {
+            super.requestSingleUpdate(criteria, listener, looper);
+            return;
+        }
+        if (requestLocationUpdates(criteria, listener, null)) return;
+        super.requestSingleUpdate(criteria, listener, looper);
+    }
+
+    @Override
+    public void requestSingleUpdate(Criteria criteria, PendingIntent intent) {
+        if (criteria == null || intent == null) {
+            super.requestSingleUpdate(criteria, intent);
+            return;
+        }
+        if (requestLocationUpdates(criteria, null, intent)) return;
+        super.requestSingleUpdate(criteria, intent);
+    }
+
+    @Override
+    public void requestSingleUpdate(String provider, LocationListener listener, Looper looper) {
+        if (provider == null || listener == null) {
+            super.requestSingleUpdate(provider, listener, looper);
+            return;
+        }
+        if (requestLocationUpdates(provider, listener, null)) return;
+        super.requestSingleUpdate(provider, listener, looper);
+    }
+
+    @Override
+    public void requestSingleUpdate(String provider, PendingIntent intent) {
+        if (provider == null || intent == null) {
+            super.requestSingleUpdate(provider, intent);
+            return;
+        }
+        if (requestLocationUpdates(provider, null, intent)) return;
+        super.requestSingleUpdate(provider, intent);
+    }
+    
+    /**
+     * Monitoring purposes only
+     */
+//    @Override
+//    public boolean sendExtraCommand(String provider, String command, Bundle extras) {
+//        Log.d(TAG, "sendExtraCommand - " + context.getPackageName() + " (" + Binder.getCallingUid() + ")");
+//        return super.sendExtraCommand(provider, command, extras);
+//    }
+
+    /**
+     * Handles calls to requestLocationUpdates and requestSingleUpdate methods
+     * @return true, if action has been taken
+     *         false, if the processing needs to be passed to the default method
+     */
+    private boolean requestLocationUpdates(String provider, LocationListener listener, PendingIntent intent) {
+        synchronized (lock) { // custom listener should only return a value after this method has returned
+
+            String packageName = context.getPackageName();
+            int uid = Binder.getCallingUid();
+            PrivacySettings pSet = pSetMan.getSettings(packageName, uid);
+            boolean output = false;
+            
+            if (pSet != null) {
+                if (provider.equals(LocationManager.GPS_PROVIDER)) {
+                    switch (pSet.getLocationGpsSetting()) {
+                        case PrivacySettings.REAL:
+                            pSetMan.notification(packageName, uid, PrivacySettings.REAL, PrivacySettings.DATA_LOCATION_GPS, null, pSet);                            
+                            break;
+                        case PrivacySettings.EMPTY:
+                            if (intent != null) intent.cancel();
+                            output = true;
+                            pSetMan.notification(packageName, uid, PrivacySettings.EMPTY, PrivacySettings.DATA_LOCATION_GPS, null, pSet);                            
+                            break;
+                        case PrivacySettings.CUSTOM:
+                            try {
+                                new PrivacyLocationUpdater(provider, listener, intent, 
+                                        Double.parseDouble(pSet.getLocationGpsLat()), 
+                                        Double.parseDouble(pSet.getLocationGpsLon())).start();
+                                output = true;
+                            } catch (NumberFormatException e) {
+                                Log.e(TAG, "requestLocationUpdates: invalid coordinates");
+                                output = true;
+                            }
+                            pSetMan.notification(packageName, uid, PrivacySettings.CUSTOM, PrivacySettings.DATA_LOCATION_GPS, 
+                                    "Lat: " + pSet.getLocationGpsLat() + " Lon: " + pSet.getLocationGpsLon(), pSet);
+                            break;
+                        case PrivacySettings.RANDOM:
+                            try {
+                                new PrivacyLocationUpdater(provider, listener, intent, 
+                                        Double.parseDouble(pSet.getLocationGpsLat()), 
+                                        Double.parseDouble(pSet.getLocationGpsLon())).start();
+                                output = true;
+                            } catch (NumberFormatException e) {
+                                Log.e(TAG, "requestLocationUpdates: invalid coordinates");
+                                output = true;
+                            }
+                            pSetMan.notification(packageName, uid, PrivacySettings.RANDOM, PrivacySettings.DATA_LOCATION_GPS, 
+                                    "Lat: " + pSet.getLocationGpsLat() + " Lon: " + pSet.getLocationGpsLon(), pSet);
+                            break;
+                    }
+                } else if (provider.equals(LocationManager.NETWORK_PROVIDER)) {
+                    switch (pSet.getLocationNetworkSetting()) {
+                        case PrivacySettings.REAL:
+                            pSetMan.notification(packageName, uid, PrivacySettings.REAL, PrivacySettings.DATA_LOCATION_NETWORK, null, pSet);                            
+                            break;
+                        case PrivacySettings.EMPTY:
+                            if (intent != null) intent.cancel();
+                            output = true;
+                            pSetMan.notification(packageName, uid, PrivacySettings.EMPTY, PrivacySettings.DATA_LOCATION_NETWORK, null, pSet);                            
+                            break;
+                        case PrivacySettings.CUSTOM:
+                            try {
+                                new PrivacyLocationUpdater(provider, listener, intent, 
+                                        Double.parseDouble(pSet.getLocationNetworkLat()), 
+                                        Double.parseDouble(pSet.getLocationNetworkLon())).start();
+                                output = true;
+                            } catch (NumberFormatException e) {
+                                Log.e(TAG, "requestLocationUpdates: invalid coordinates");
+                                output = true;
+                            }
+                            pSetMan.notification(packageName, uid, PrivacySettings.CUSTOM, PrivacySettings.DATA_LOCATION_NETWORK, 
+                                    "Lat: " + pSet.getLocationNetworkLat() + " Lon: " + pSet.getLocationNetworkLon(), pSet);
+                            break;
+                        case PrivacySettings.RANDOM:
+                            try {
+                                new PrivacyLocationUpdater(provider, listener, intent, 
+                                        Double.parseDouble(pSet.getLocationNetworkLat()), 
+                                        Double.parseDouble(pSet.getLocationNetworkLon())).start();
+                                output = true;
+                            } catch (NumberFormatException e) {
+                                Log.e(TAG, "requestLocationUpdates: invalid coordinates");
+                                output = true;
+                            }
+                            pSetMan.notification(packageName, uid, PrivacySettings.RANDOM, PrivacySettings.DATA_LOCATION_NETWORK, 
+                                    "Lat: " + pSet.getLocationNetworkLat() + " Lon: " + pSet.getLocationNetworkLon(), pSet);
+                            break;
+                    }
+                } else if (provider.equals(LocationManager.PASSIVE_PROVIDER)) { // could get location from any of above
+                    if (pSet.getLocationGpsSetting() == PrivacySettings.REAL && 
+                            pSet.getLocationNetworkSetting() == PrivacySettings.REAL) {
+                        output = false;
+                        pSetMan.notification(packageName, uid, PrivacySettings.REAL, PrivacySettings.DATA_LOCATION_GPS, null, pSet);
+                    } else {
+                        output = true;
+                        pSetMan.notification(packageName, uid, PrivacySettings.EMPTY, PrivacySettings.DATA_LOCATION_GPS, null, pSet);
+                    }
+                }
+            } else {
+                if (provider.equals(LocationManager.NETWORK_PROVIDER)) {
+                    pSetMan.notification(packageName, uid, PrivacySettings.REAL, PrivacySettings.DATA_LOCATION_NETWORK, null, pSet);
+                } else { // including GPS and passive providers
+                    pSetMan.notification(packageName, uid, PrivacySettings.REAL, PrivacySettings.DATA_LOCATION_GPS, null, pSet);
+                }
+            }
+            
+//            Log.d(TAG, "requestLocationUpdates - " + context.getPackageName() + " (" + Binder.getCallingUid() + 
+//                    ") output: " + (output == true ? "[custom location]" : "[real value]"));
+            return output;
+        }
+    }
+    
+    /**
+     * Helper method for categorizing the different requestLocationUpdates calls by
+     * provider accuracy and handing them off to 
+     * {@link android.privacy.surrogate.PrivacyLocationManager#requestLocationUpdates(String, LocationListener, PendingIntent)}
+     * @param criteria
+     * @param listener
+     * @param intent
+     * @return see {@link android.privacy.surrogate.PrivacyLocationManager#requestLocationUpdates(String, LocationListener, PendingIntent)}
+     */
+    private boolean requestLocationUpdates(Criteria criteria, LocationListener listener, PendingIntent intent) {
+        if (criteria == null) return false;
+            // treat providers with high accuracy as GPS providers
+        else if (criteria.getAccuracy() == Criteria.ACCURACY_FINE || 
+                criteria.getBearingAccuracy() == Criteria.ACCURACY_HIGH || 
+                criteria.getHorizontalAccuracy() == Criteria.ACCURACY_HIGH || 
+                criteria.getVerticalAccuracy() == Criteria.ACCURACY_HIGH || 
+                criteria.getSpeedAccuracy() == Criteria.ACCURACY_HIGH) {
+            return requestLocationUpdates(LocationManager.GPS_PROVIDER, listener, intent);
+        } else { // treat all others as network providers
+            return requestLocationUpdates(LocationManager.NETWORK_PROVIDER, listener, intent);
+        }
+    }
+    
+    private class PrivacyLocationUpdater extends Thread {
+        
+        private String provider;
+        
+        private LocationListener listener;
+        
+        private PendingIntent intent;
+        
+        private double latitude;
+        
+        private double longitude;
+
+        public PrivacyLocationUpdater(String provider, LocationListener listener, PendingIntent intent,
+                double latitude, double longitude) {
+            this.provider = provider;
+            this.listener = listener;
+            this.intent = intent;
+            this.latitude = latitude;
+            this.longitude = longitude;
+        }
+
+        @Override
+        public void run() {
+            if (provider != null) {
+                Location location = new Location(provider);
+                location.setLatitude(latitude);
+                location.setLongitude(longitude);
+                for (int i = 0; i < CUSTOM_LOCATION_UPDATE_COUNT; i++) {
+                    if (listener != null) {
+                        listener.onLocationChanged(location);
+                    } else if (intent != null) {
+                        // no custom or random location implemented due to complexity
+                        intent.cancel();
+                    }
+                    try {
+                        sleep((int)(Math.random() * 1000));
+                    } catch (InterruptedException e) {
+                        e.printStackTrace();
+                    }
+                }
+            }
+        }
+        
+    }
+
+}
diff --git a/privacy/java/android/privacy/surrogate/PrivacyTelephonyManager.java b/privacy/java/android/privacy/surrogate/PrivacyTelephonyManager.java
new file mode 100644
index 0000000..59f8604
--- /dev/null
+++ b/privacy/java/android/privacy/surrogate/PrivacyTelephonyManager.java
@@ -0,0 +1,285 @@
+package android.privacy.surrogate;
+
+import com.android.internal.telephony.IPhoneStateListener;
+
+import android.content.Context;
+import android.os.Binder;
+import android.os.Bundle;
+import android.os.Handler;
+import android.os.Message;
+import android.os.ServiceManager;
+import android.privacy.IPrivacySettingsManager;
+import android.privacy.PrivacySettings;
+import android.privacy.PrivacySettingsManager;
+import android.telephony.CellLocation;
+import android.telephony.NeighboringCellInfo;
+import android.telephony.PhoneStateListener;
+import android.telephony.ServiceState;
+import android.telephony.SignalStrength;
+import android.telephony.TelephonyManager;
+import android.util.Log;
+
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.List;
+
+/**
+ * Provides privacy handling for {@link android.telephony.TelephonyManager}
+ * @author Svyatoslav Hresyk
+ * {@hide}
+ */
+public final class PrivacyTelephonyManager extends TelephonyManager {
+
+    private static final String TAG = "PrivacyTelephonyManager";
+    
+    private Context context;
+    
+    private PrivacySettingsManager pSetMan;
+    
+    /** {@hide} */
+    public PrivacyTelephonyManager(Context context) {
+        super(context);
+        this.context = context;
+//        pSetMan = (PrivacySettingsManager) context.getSystemService("privacy");
+        // don't call getSystemService to avoid getting java.lang.IllegalStateException: 
+        // System services not available to Activities before onCreate()
+        pSetMan = new PrivacySettingsManager(context, IPrivacySettingsManager.Stub.asInterface(ServiceManager.getService("privacy")));
+    }
+    
+    /**
+     * IMEI
+     */
+    @Override
+    public String getDeviceId() {
+        String packageName = context.getPackageName();
+        int uid = Binder.getCallingUid();
+        PrivacySettings pSet = pSetMan.getSettings(packageName, uid);
+        String output;
+        if (pSet != null && pSet.getDeviceIdSetting() != PrivacySettings.REAL) {
+            output = pSet.getDeviceId(); // can be empty, custom or random
+            pSetMan.notification(packageName, uid, pSet.getDeviceIdSetting(), PrivacySettings.DATA_DEVICE_ID, output, pSet);
+        } else {
+            output = super.getDeviceId();
+            pSetMan.notification(packageName, uid, PrivacySettings.REAL, PrivacySettings.DATA_DEVICE_ID, output, pSet);
+        }
+//        Log.d(TAG, "getDeviceId - " + context.getPackageName() + " (" + Binder.getCallingUid() + ") output: " + output);
+        return output;
+    }
+    
+    /**
+     * Phone number
+     */
+    @Override
+    public String getLine1Number() {
+        String packageName = context.getPackageName();
+        int uid = Binder.getCallingUid();
+        PrivacySettings pSet = pSetMan.getSettings(packageName, uid);
+        String output;
+        if (pSet != null && pSet.getLine1NumberSetting() != PrivacySettings.REAL) {
+            output = pSet.getLine1Number(); // can be empty, custom or random
+            pSetMan.notification(packageName, uid, pSet.getLine1NumberSetting(), PrivacySettings.DATA_LINE_1_NUMBER, output, pSet);
+        } else {
+            output = super.getLine1Number();
+            pSetMan.notification(packageName, uid, PrivacySettings.REAL, PrivacySettings.DATA_LINE_1_NUMBER, output, pSet);
+        }
+//        Log.d(TAG, "getLine1Number - " + context.getPackageName() + " (" + Binder.getCallingUid() + ") output: " + output);
+        return output;
+    }
+    
+    /**
+     * Will be handled like the Line1Number, since voice mailbox numbers often
+     * are similar to the phone number of the subscriber.
+     */
+    @Override
+    public String getVoiceMailNumber() {
+        String packageName = context.getPackageName();
+        int uid = Binder.getCallingUid();
+        PrivacySettings pSet = pSetMan.getSettings(packageName, uid);
+        String output;
+        if (pSet != null && pSet.getLine1NumberSetting() != PrivacySettings.REAL) {
+            output = pSet.getLine1Number(); // can be empty, custom or random
+            pSetMan.notification(packageName, uid, pSet.getLine1NumberSetting(), PrivacySettings.DATA_LINE_1_NUMBER, output, pSet);
+        } else {
+            output = super.getVoiceMailNumber();
+            pSetMan.notification(packageName, uid, PrivacySettings.REAL, PrivacySettings.DATA_LINE_1_NUMBER, output, pSet);
+        }
+//        Log.d(TAG, "getVoiceMailNumber - " + context.getPackageName() + " (" + Binder.getCallingUid() + ") output: " + output);
+        return output;
+    }
+    
+    /**
+     * Intercept requests for mobile network cell information. This can be used for tracking network
+     * based location.
+     */
+    @Override
+    public List<NeighboringCellInfo> getNeighboringCellInfo() {
+        PrivacySettings pSet = pSetMan.getSettings(context.getPackageName(), Binder.getCallingUid());
+        List<NeighboringCellInfo> output = null;
+        String output_label = "[null]";
+        
+        if (pSet != null) {
+            if (pSet.getLocationNetworkSetting() == PrivacySettings.EMPTY) {
+                // output = null;
+            } else if (pSet.getLocationNetworkSetting() != PrivacySettings.REAL) {
+                output = new ArrayList<NeighboringCellInfo>();
+                output_label = "[empty list of cells]";
+            } else {
+                output = super.getNeighboringCellInfo();
+                String cells = "";
+                for (NeighboringCellInfo i : output) cells += "\t" + i + "\n";
+                output_label = "[real value]:\n" + cells;
+            }
+        }
+        
+//        Log.d(TAG, "getNeighboringCellInfo - " + context.getPackageName() + " (" + Binder.getCallingUid() + ") output: " + output_label);
+        return output;
+    }
+    
+    @Override
+    public String getNetworkCountryIso() {
+        String output = getNetworkInfo();
+        if (output == null) output = super.getNetworkCountryIso();
+//        Log.d(TAG, "getNetworkCountryIso - " + context.getPackageName() + " (" + Binder.getCallingUid() + ") output: " + output);
+        return output;
+    }
+
+    @Override
+    public String getNetworkOperator() {
+        String output = getNetworkInfo();
+        if (output == null) output = super.getNetworkOperator();
+//        Log.d(TAG, "getNetworkOperator - " + context.getPackageName() + " (" + Binder.getCallingUid() + ") output: " + output);
+        return output;
+    }
+
+    @Override
+    public String getNetworkOperatorName() {
+        String output = getNetworkInfo();
+        if (output == null) output = super.getNetworkOperatorName();
+//        Log.d(TAG, "getNetworkOperatorName - " + context.getPackageName() + " (" + Binder.getCallingUid() + ") output: " + output);
+        return output;
+    }
+    
+    /**
+     * Handles following Network Information requests: CountryIso, Operator Code, Operator Name
+     * @return value to return if applicable or null if real value should be returned
+     */
+    private String getNetworkInfo() {
+        String packageName = context.getPackageName();
+        int uid = Binder.getCallingUid();
+        PrivacySettings pSet = pSetMan.getSettings(packageName, uid);
+        if (pSet != null && pSet.getNetworkInfoSetting() != PrivacySettings.REAL) {
+            pSetMan.notification(packageName, uid, PrivacySettings.EMPTY, PrivacySettings.DATA_NETWORK_INFO_CURRENT, null, pSet);            
+            return ""; // can only be empty
+        } else {
+            pSetMan.notification(packageName, uid, PrivacySettings.REAL, PrivacySettings.DATA_NETWORK_INFO_CURRENT, null, pSet);            
+            return null;
+        }        
+    }
+    
+    @Override
+    public String getSimCountryIso() {
+        String output = getSimInfo();
+        if (output == null) output = super.getSimCountryIso();
+//        Log.d(TAG, "getSimCountryIso - " + context.getPackageName() + " (" + Binder.getCallingUid() + ") output: " + output);
+        return output;
+    }
+
+    @Override
+    public String getSimOperator() {
+        String output = getSimInfo();
+        if (output == null) output = super.getSimOperator();
+//        Log.d(TAG, "getSimOperator - " + context.getPackageName() + " (" + Binder.getCallingUid() + ") output: " + output);
+        return output;
+    }
+
+    @Override
+    public String getSimOperatorName() {
+        String output = getSimInfo();
+        if (output == null) output = super.getSimOperatorName();
+//        Log.d(TAG, "getSimOperatorName - " + context.getPackageName() + " (" + Binder.getCallingUid() + ") output: " + output);
+        return output;
+    }
+    
+    /**
+     * Handles following SIM Card information requests: CountryIso, Operator Code, Operator Name
+     * @return value to return if applicable or null if real value should be returned
+     */    
+    private String getSimInfo() {
+        String packageName = context.getPackageName();
+        int uid = Binder.getCallingUid();
+        PrivacySettings pSet = pSetMan.getSettings(packageName, uid);
+        if (pSet != null && pSet.getSimInfoSetting() != PrivacySettings.REAL) {
+            pSetMan.notification(packageName, uid, PrivacySettings.EMPTY, PrivacySettings.DATA_NETWORK_INFO_SIM, null, pSet);            
+            return ""; // can only be empty
+        } else {
+            pSetMan.notification(packageName, uid, PrivacySettings.REAL, PrivacySettings.DATA_NETWORK_INFO_SIM, null, pSet);            
+            return null;
+        }                
+    }
+    
+    /**
+     * ICCID
+     */
+    @Override
+    public String getSimSerialNumber() {
+        String packageName = context.getPackageName();
+        int uid = Binder.getCallingUid();
+        PrivacySettings pSet = pSetMan.getSettings(packageName, uid);
+        String output;
+        if (pSet != null && pSet.getSimSerialNumberSetting() != PrivacySettings.REAL) {
+            output = pSet.getSimSerialNumber(); // can be empty, custom or random
+            pSetMan.notification(packageName, uid, pSet.getSimSerialNumberSetting(), PrivacySettings.DATA_SIM_SERIAL, output, pSet);            
+        } else {
+            output = super.getSimSerialNumber();
+            pSetMan.notification(packageName, uid, PrivacySettings.REAL, PrivacySettings.DATA_SIM_SERIAL, output, pSet);            
+        }
+//        Log.d(TAG, "getSimSerialNumber - " + context.getPackageName() + " (" + Binder.getCallingUid() + ") output: " + output);
+        return output;
+    }
+    
+    /**
+     * IMSI
+     */
+    @Override
+    public String getSubscriberId() {
+        String packageName = context.getPackageName();
+        int uid = Binder.getCallingUid();
+        PrivacySettings pSet = pSetMan.getSettings(packageName, uid);
+        String output;
+        if (pSet != null && pSet.getSubscriberIdSetting() != PrivacySettings.REAL) {
+            output = pSet.getSubscriberId(); // can be empty, custom or random
+            pSetMan.notification(packageName, uid, pSet.getSubscriberIdSetting(), PrivacySettings.DATA_SUBSCRIBER_ID, output, pSet);            
+        } else {
+            output = super.getSubscriberId();
+            pSetMan.notification(packageName, uid, PrivacySettings.REAL, PrivacySettings.DATA_SUBSCRIBER_ID, output, pSet);            
+        }
+//        Log.d(TAG, "getSubscriberId - " + context.getPackageName() + " (" + Binder.getCallingUid() + ") output: " + output);
+        return output;
+    }
+
+    /**
+     * For monitoring purposes only
+     */    
+//    @Override
+//    public void enableLocationUpdates() {
+////        Log.d(TAG, "enableLocationUpdates - " + context.getPackageName() + " (" + Binder.getCallingUid() + ")");
+//        super.enableLocationUpdates();
+//    }
+
+    @Override
+    public void listen(PhoneStateListener listener, int events) {
+//        Log.d(TAG, "listen - package:" + context.getPackageName() + " uid:" + Binder.getCallingUid() + " events: " + events);
+        if (((events & PhoneStateListener.LISTEN_CELL_LOCATION) != 0) ||
+                ((events & PhoneStateListener.LISTEN_CALL_STATE) != 0)) {
+            listener.setContext(context);
+            listener.setPackageName(context.getPackageName());
+            listener.setUid(Binder.getCallingUid());
+            super.listen(listener, events);
+//            Log.d(TAG, "listen for cell location or call state - " + context.getPackageName() + " (" + 
+//                    Binder.getCallingUid() + ") output: custom listener");
+        } else {
+            super.listen(listener, events);
+        }
+    }
+    
+}
diff --git a/services/audioflinger/AudioFlinger.cpp b/services/audioflinger/AudioFlinger.cpp
index 7c25380..1c1c3a8 100644
--- a/services/audioflinger/AudioFlinger.cpp
+++ b/services/audioflinger/AudioFlinger.cpp
@@ -233,6 +233,7 @@ void AudioFlinger::onFirstRef()
             mHardwareStatus = AUDIO_HW_IDLE;
         }
     }
+
 }
 
 status_t AudioFlinger::initCheck() const
@@ -266,6 +267,9 @@ AudioFlinger::~AudioFlinger()
         audio_hw_device_close(dev);
     }
     mAudioHwDevs.clear();
+#ifdef STE_AUDIO
+    delete mInputFMStream;
+#endif
 }
 
 audio_hw_device_t* AudioFlinger::findSuitableHwDev_l(uint32_t devices)
@@ -1144,6 +1148,17 @@ unsigned int AudioFlinger::getInputFramesLost(int ioHandle)
     return 0;
 }
 
+#ifdef STE_AUDIO
+size_t AudioFlinger::readInput(uint32_t *input, uint32_t inputClientId, void *buffer, uint32_t bytes, uint32_t *pOverwrittenBytes)
+{
+    if (input == NULL || buffer == NULL) {
+        return 0;
+    }
+
+    AudioStreamIn* stream = (AudioStreamIn*)input;
+    return 0; //return stream->read(buffer, bytes);
+}
+#endif
 status_t AudioFlinger::setVoiceVolume(float value)
 {
     status_t ret = initCheck();
@@ -2733,6 +2748,9 @@ void AudioFlinger::MixerThread::deleteTrackName_l(int name)
 bool AudioFlinger::MixerThread::checkForNewParameters_l()
 {
     bool reconfig = false;
+#ifdef STE_HARDWARE
+    bool updateLatency = false;
+#endif
 
     while (!mNewParameters.isEmpty()) {
         status_t status = NO_ERROR;
@@ -2796,6 +2814,11 @@ bool AudioFlinger::MixerThread::checkForNewParameters_l()
                 mEffectChains[i]->setDevice_l(mDevice);
             }
         }
+#ifdef STE_HARDWARE
+        if (param.getInt(String8(AudioParameter::keyLatency), value) == NO_ERROR) {
+            updateLatency = true;
+        }
+#endif
 
         if (status == NO_ERROR) {
             status = mOutput->stream->common.set_parameters(&mOutput->stream->common,
@@ -2822,6 +2845,11 @@ bool AudioFlinger::MixerThread::checkForNewParameters_l()
                 }
                 sendConfigEvent_l(AudioSystem::OUTPUT_CONFIG_CHANGED);
             }
+#ifdef STE_HARDWARE
+            if (status == NO_ERROR && updateLatency) {
+                sendConfigEvent_l(AudioSystem::OUTPUT_CONFIG_CHANGED);
+            }
+#endif
         }
 
         mNewParameters.removeAt(0);
@@ -4643,7 +4671,12 @@ AudioFlinger::RecordThread::RecordThread(const sp<AudioFlinger>& audioFlinger,
                                          uint32_t sampleRate,
                                          uint32_t channels,
                                          int id,
+#ifdef STE_AUDIO
+                                         uint32_t device,
+                                         audio_input_clients pInputClientId) :
+#else
                                          uint32_t device) :
+#endif
     ThreadBase(audioFlinger, id, device),
     mInput(input), mTrack(NULL), mResampler(0), mRsmpOutBuffer(0), mRsmpInBuffer(0)
 {
@@ -4653,6 +4686,9 @@ AudioFlinger::RecordThread::RecordThread(const sp<AudioFlinger>& audioFlinger,
 
     mReqChannelCount = popcount(channels);
     mReqSampleRate = sampleRate;
+#ifdef STE_AUDIO
+    mInputClientId = pInputClientId;
+#endif
     readInputParameters();
 }
 
@@ -5567,11 +5603,49 @@ status_t AudioFlinger::restoreOutput(int output)
     return NO_ERROR;
 }
 
+#ifdef STE_AUDIO
+uint32_t *AudioFlinger::addInputClient(uint32_t clientId)
+{
+    Mutex::Autolock _l(mLock);
+
+    uint32_t *pNewClient = new uint32_t;
+    if (pNewClient) {
+        *pNewClient = clientId;
+        mInputClients.add(pNewClient);
+    }
+
+    return pNewClient;
+}
+
+status_t AudioFlinger::removeInputClient(uint32_t *pClientId)
+{
+    status_t result = NO_ERROR;
+
+    Mutex::Autolock _l(mLock);
+
+    if (pClientId == NULL) {
+        result = BAD_VALUE;
+    } else if (mInputClients.remove(pClientId) < 0) {
+        result = BAD_VALUE;
+    } else {
+        // the pointer was found in the vector and is non-NULL, so it must point to memory
+        // allocated by addInputClient => free it.
+        delete pClientId;
+    }
+
+    return result;
+}
+#endif
 int AudioFlinger::openInput(uint32_t *pDevices,
                                 uint32_t *pSamplingRate,
                                 uint32_t *pFormat,
                                 uint32_t *pChannels,
+#ifdef STE_AUDIO
+                                uint32_t acoustics,
+                                uint32_t *pInputClientId)
+#else
                                 uint32_t acoustics)
+#endif
 {
     status_t status;
     RecordThread *thread = NULL;
@@ -5583,7 +5657,10 @@ int AudioFlinger::openInput(uint32_t *pDevices,
     uint32_t reqChannels = channels;
     audio_stream_in_t *inStream;
     audio_hw_device_t *inHwDev;
-
+#ifdef STE_AUDIO
+    bool returnRecordThread = true;
+    audio_input_clients inputClientId;
+#endif
     if (pDevices == NULL || *pDevices == 0) {
         return 0;
     }
@@ -5594,6 +5671,12 @@ int AudioFlinger::openInput(uint32_t *pDevices,
     if (inHwDev == NULL)
         return 0;
 
+#ifdef STE_AUDIO
+    if (pInputClientId != NULL && *pInputClientId == AUDIO_INPUT_CLIENT_PLAYBACK) {
+        returnRecordThread = false;
+    }
+#endif
+
     status = inHwDev->open_input_stream(inHwDev, *pDevices, (int *)&format,
                                         &channels, &samplingRate,
                                         (audio_in_acoustics_t)acoustics,
@@ -5620,6 +5703,7 @@ int AudioFlinger::openInput(uint32_t *pDevices,
                                             &inStream);
     }
 
+
     if (inStream != NULL) {
         AudioStreamIn *input = new AudioStreamIn(inHwDev, inStream);
 
@@ -5633,13 +5717,22 @@ int AudioFlinger::openInput(uint32_t *pDevices,
                                   reqSamplingRate,
                                   reqChannels,
                                   id,
+#ifdef STE_AUDIO
+                                  device,
+                                  inputClientId);
+#else
                                   device);
+#endif
         mRecordThreads.add(id, thread);
         LOGV("openInput() created record thread: ID %d thread %p", id, thread);
         if (pSamplingRate) *pSamplingRate = reqSamplingRate;
         if (pFormat) *pFormat = format;
         if (pChannels) *pChannels = reqChannels;
-
+#ifdef STE_AUDIO
+        if (pInputClientId != NULL) {
+            *pInputClientId = inputClientId;
+        }
+#endif
         input->stream->common.standby(&input->stream->common);
 
         // notify client processes of the new input creation
@@ -5650,10 +5743,17 @@ int AudioFlinger::openInput(uint32_t *pDevices,
     return 0;
 }
 
+#ifdef STE_AUDIO
+status_t AudioFlinger::closeInput(int input, uint32_t *inputClientId)
+#else
 status_t AudioFlinger::closeInput(int input)
+#endif
 {
-    // keep strong reference on the record thread so that
+   // keep strong reference on the record thread so that
     // it is not destroyed while exit() is executed
+#ifdef STE_AUDIO
+    audio_input_clients clientId = (audio_input_clients) *inputClientId;
+#endif
     sp <RecordThread> thread;
     {
         Mutex::Autolock _l(mLock);
@@ -5675,6 +5775,7 @@ status_t AudioFlinger::closeInput(int input)
     delete in;
 
     return NO_ERROR;
+
 }
 
 status_t AudioFlinger::setStreamOutput(uint32_t stream, int output)
@@ -6187,7 +6288,6 @@ status_t AudioFlinger::moveEffectChain_l(int sessionId,
     return NO_ERROR;
 }
 
-
 // PlaybackThread::createEffect_l() must be called with AudioFlinger::mLock held
 sp<AudioFlinger::EffectHandle> AudioFlinger::ThreadBase::createEffect_l(
         const sp<AudioFlinger::Client>& client,
diff --git a/services/audioflinger/AudioFlinger.h b/services/audioflinger/AudioFlinger.h
index ddc062b..c278613 100644
--- a/services/audioflinger/AudioFlinger.h
+++ b/services/audioflinger/AudioFlinger.h
@@ -70,7 +70,9 @@ class AudioFlinger :
     friend class BinderService<AudioFlinger>;
 public:
     static char const* getServiceName() { return "media.audio_flinger"; }
-
+#ifdef STE_AUDIO
+    int getNbrOfClients(audio_stream_in_t* input);
+#endif
     virtual     status_t    dump(int fd, const Vector<String16>& args);
 
     // IAudioFlinger interface
@@ -161,13 +163,27 @@ public:
 
     virtual status_t restoreOutput(int output);
 
+#ifdef STE_AUDIO
+    virtual uint32_t *addInputClient(uint32_t clientId);
+
+    virtual status_t removeInputClient(uint32_t *pClientId);
+#endif
     virtual int openInput(uint32_t *pDevices,
                             uint32_t *pSamplingRate,
                             uint32_t *pFormat,
                             uint32_t *pChannels,
+#ifdef STE_AUDIO
+                            uint32_t acoustics,
+                            uint32_t *pInputClientId = NULL);
+
+    virtual status_t closeInput(int input, uint32_t *inputClientId = NULL);
+
+    virtual size_t readInput(uint32_t *input, uint32_t inputClientId, void *buffer, uint32_t bytes, uint32_t *pOverwrittenBytes);
+#else
                             uint32_t acoustics);
 
     virtual status_t closeInput(int input);
+#endif
 
     virtual status_t setStreamOutput(uint32_t stream, int output);
 
@@ -1026,7 +1042,12 @@ private:
                         uint32_t sampleRate,
                         uint32_t channels,
                         int id,
+#ifdef STE_AUDIO
+                        uint32_t device,
+                        audio_input_clients pInputClientId);
+#else
                         uint32_t device);
+#endif
                 ~RecordThread();
 
         virtual bool        threadLoop();
@@ -1078,6 +1099,9 @@ private:
                 int                                 mReqChannelCount;
                 uint32_t                            mReqSampleRate;
                 ssize_t                             mBytesRead;
+#ifdef STE_AUDIO
+                audio_input_clients                 mInputClientId;
+#endif
     };
 
     class RecordHandle : public android::BnAudioRecord {
@@ -1469,6 +1493,9 @@ private:
 
                 mutable     Mutex                   mHardwareLock;
                 audio_hw_device_t*                  mPrimaryHardwareDev;
+#ifdef STE_AUDIO
+                AudioStreamIn*                      mInputFMStream;
+#endif
                 Vector<audio_hw_device_t*>          mAudioHwDevs;
     mutable     int                                 mHardwareStatus;
 
@@ -1501,7 +1528,9 @@ private:
 #endif
 
                 Vector<AudioSessionRef*> mAudioSessionRefs;
-
+#ifdef STE_AUDIO
+                SortedVector<uint32_t*> mInputClients;
+#endif
 #ifdef WITH_QCOM_LPA
                 public:
                 int                                 mLPASessionId;
diff --git a/services/audioflinger/AudioPolicyService.cpp b/services/audioflinger/AudioPolicyService.cpp
index b9a9115..37ca8fa 100644
--- a/services/audioflinger/AudioPolicyService.cpp
+++ b/services/audioflinger/AudioPolicyService.cpp
@@ -410,14 +410,23 @@ audio_io_handle_t AudioPolicyService::getInput(int inputSource,
                                     uint32_t format,
                                     uint32_t channels,
                                     audio_in_acoustics_t acoustics,
+#ifdef STE_AUDIO
+                                    int audioSession,
+                                    audio_input_clients *inputClientId)
+#else
                                     int audioSession)
+#endif
 {
     if (mpAudioPolicy == NULL) {
         return 0;
     }
     Mutex::Autolock _l(mLock);
     audio_io_handle_t input = mpAudioPolicy->get_input(mpAudioPolicy, inputSource, samplingRate,
+#ifdef STE_AUDIO
+                                                       format, channels, acoustics, inputClientId);
+#else
                                                        format, channels, acoustics);
+#endif
 
     if (input == 0) {
         return input;
@@ -1543,7 +1552,12 @@ static audio_io_handle_t aps_open_input(void *service,
                                             uint32_t *pSamplingRate,
                                             uint32_t *pFormat,
                                             uint32_t *pChannels,
+#ifdef STE_AUDIO
+                                            uint32_t acoustics,
+                                            uint32_t *inputClientId)
+#else
                                             uint32_t acoustics)
+#endif
 {
     sp<IAudioFlinger> af = AudioSystem::get_audio_flinger();
     if (af == NULL) {
@@ -1552,16 +1566,28 @@ static audio_io_handle_t aps_open_input(void *service,
     }
 
     return af->openInput(pDevices, pSamplingRate, pFormat, pChannels,
+#ifdef STE_AUDIO
+                         acoustics, inputClientId);
+#else
                          acoustics);
+#endif
 }
 
+#ifdef STE_AUDIO
+static int aps_close_input(void *service, audio_io_handle_t input, uint32_t *inputClientId = NULL)
+#else
 static int aps_close_input(void *service, audio_io_handle_t input)
+#endif
 {
     sp<IAudioFlinger> af = AudioSystem::get_audio_flinger();
     if (af == NULL)
         return PERMISSION_DENIED;
 
+#ifdef STE_AUDIO
+    return af->closeInput(input, inputClientId);
+#else
     return af->closeInput(input);
+#endif
 }
 
 static int aps_set_stream_output(void *service, audio_stream_type_t stream,
diff --git a/services/audioflinger/AudioPolicyService.h b/services/audioflinger/AudioPolicyService.h
index fe82d6d..f9d7cac 100644
--- a/services/audioflinger/AudioPolicyService.h
+++ b/services/audioflinger/AudioPolicyService.h
@@ -93,7 +93,12 @@ public:
                                     uint32_t channels = 0,
                                     audio_in_acoustics_t acoustics =
                                             (audio_in_acoustics_t)0,
+#ifdef STE_AUDIO
+                                    int audioSession = 0,
+                                    audio_input_clients *inputClientId = NULL);
+#else
                                     int audioSession = 0);
+#endif
     virtual status_t startInput(audio_io_handle_t input);
     virtual status_t stopInput(audio_io_handle_t input);
     virtual void releaseInput(audio_io_handle_t input);
diff --git a/services/camera/libcameraservice/CameraService.cpp b/services/camera/libcameraservice/CameraService.cpp
index 44df397..87a62fb 100644
--- a/services/camera/libcameraservice/CameraService.cpp
+++ b/services/camera/libcameraservice/CameraService.cpp
@@ -588,6 +588,9 @@ status_t CameraService::Client::setPreviewWindow(const sp<IBinder>& binder,
 #ifdef QCOM_HARDWARE
 #ifndef NO_UPDATE_PREVIEW
     } else {
+        if (window != 0) {
+            native_window_set_buffers_transform(window.get(), mOrientation);
+        }
         result = mHardware->setPreviewWindow(window);
 #endif
 #endif
diff --git a/services/java/com/android/server/SystemServer.java b/services/java/com/android/server/SystemServer.java
index c13a3e2..706dd57 100644
--- a/services/java/com/android/server/SystemServer.java
+++ b/services/java/com/android/server/SystemServer.java
@@ -39,6 +39,9 @@ import android.os.ServiceManager;
 import android.os.StrictMode;
 import android.os.SystemClock;
 import android.os.SystemProperties;
+// BEGIN privacy-added
+import android.privacy.PrivacySettingsManagerService;
+// END privacy-added
 import android.provider.Settings;
 import android.server.BluetoothA2dpService;
 import android.server.BluetoothService;
@@ -66,6 +69,8 @@ import dalvik.system.Zygote;
 import java.io.File;
 import java.util.Timer;
 import java.util.TimerTask;
+import com.stericsson.hardware.fm.FmReceiverService;
+import com.stericsson.hardware.fm.FmTransmitterService;
 
 class ServerThread extends Thread {
     private static final String TAG = "SystemServer";
@@ -207,6 +212,9 @@ class ServerThread extends Thread {
             Slog.i(TAG, "Content Manager");
             ContentService.main(context,
                     factoryTest == SystemServer.FACTORY_TEST_LOW_LEVEL);
+            // BEGIN privacy-added
+            addPrivacyService(context);
+            // END privacy-added
 
 
             Slog.i(TAG, "System Content Providers");
@@ -445,6 +453,22 @@ class ServerThread extends Thread {
             }
 
             try {
+                Slog.i(TAG, "FM receiver Service");
+                ServiceManager.addService("fm_receiver",
+                        new FmReceiverService(context));
+            } catch (Throwable e) {
+                Slog.e(TAG, "Failure starting FM receiver Service", e);
+            }
+
+            try {
+                Slog.i(TAG, "FM transmitter Service");
+                ServiceManager.addService("fm_transmitter",
+                        new FmTransmitterService(context));
+            } catch (Throwable e) {
+                Slog.e(TAG, "Failure starting FM transmitter Service", e);
+            }
+
+            try {
                 Slog.i(TAG, "Profile Manager");
                 profile = new ProfileManagerService(context);
                 ServiceManager.addService(Context.PROFILE_SERVICE, profile);
@@ -848,6 +872,17 @@ class ServerThread extends Thread {
         Slog.d(TAG, "Starting service: " + intent);
         context.startService(intent);
     }
+
+    // BEGIN privacy-added
+    private void addPrivacyService(Context context) {
+        try {
+            Log.i(TAG, "Privacy Service");
+            ServiceManager.addService("privacy", new PrivacySettingsManagerService(context));
+        } catch (Throwable e) {
+            Log.e(TAG, "Failure starting Privacy Service", e);
+        }        
+    }
+    // END privacy-added
 }
 
 public class SystemServer {
diff --git a/services/java/com/android/server/am/ActivityManagerService.java b/services/java/com/android/server/am/ActivityManagerService.java
index 580126e..9859fbb 100644
--- a/services/java/com/android/server/am/ActivityManagerService.java
+++ b/services/java/com/android/server/am/ActivityManagerService.java
@@ -151,6 +151,9 @@ import java.util.Set;
 import java.util.concurrent.atomic.AtomicBoolean;
 import java.util.concurrent.atomic.AtomicLong;
 import dalvik.system.Zygote;
+// BEGIN privacy-added
+import android.privacy.surrogate.PrivacyActivityManagerService;
+// END privacy-added
 
 public final class ActivityManagerService extends ActivityManagerNative
         implements Watchdog.Monitor, BatteryStatsImpl.BatteryCallback {
@@ -13108,6 +13111,9 @@ public final class ActivityManagerService extends ActivityManagerNative
             }
 
             Object nextReceiver = r.receivers.get(recIdx);
+            // BEGIN privacy-added
+            enforcePrivacyPermission(nextReceiver, r);
+            // END privacy-added
             if (nextReceiver instanceof BroadcastFilter) {
                 // Simple case: this is a registered receiver who gets
                 // a direct call.
@@ -13255,6 +13261,32 @@ public final class ActivityManagerService extends ActivityManagerNative
             mPendingBroadcastRecvIndex = recIdx;
         }
     }
+    // BEGIN privacy-added
+    private void enforcePrivacyPermission(Object nextReceiver, BroadcastRecord r) {
+        if (r != null && r.intent != null && r.intent.getAction() != null) {
+            
+            String packageName = null;
+            int uid = -1;
+            try { // try to get intent receiver information
+                if (nextReceiver instanceof BroadcastFilter) {
+                    packageName = ((BroadcastFilter) nextReceiver).receiverList.app.info.packageName;
+                    uid = ((BroadcastFilter) nextReceiver).receiverList.app.info.uid;
+                } else if (nextReceiver instanceof ResolveInfo) {
+                    packageName = ((ResolveInfo) nextReceiver).activityInfo.applicationInfo.packageName;
+                    uid = ((ResolveInfo) nextReceiver).activityInfo.applicationInfo.uid;
+                }
+            } catch (Exception e) {
+                // if above information is not available, exception will be thrown
+                // do nothing, this is not our intent
+                return;
+            }
+            
+            if (packageName != null && uid != -1) {
+                PrivacyActivityManagerService.enforcePrivacyPermission(packageName, uid, r.intent, mContext, r.receivers.size());
+            }
+        }
+    }
+    // END privacy-added
 
     // =========================================================
     // INSTRUMENTATION
diff --git a/services/surfaceflinger/DisplayHardware/DisplayHardware.cpp b/services/surfaceflinger/DisplayHardware/DisplayHardware.cpp
index 5b96587..c71328b 100755
--- a/services/surfaceflinger/DisplayHardware/DisplayHardware.cpp
+++ b/services/surfaceflinger/DisplayHardware/DisplayHardware.cpp
@@ -394,6 +394,10 @@ void DisplayHardware::flip(const Region& dirty) const
     if (mHwc->initCheck() == NO_ERROR) {
         mHwc->commit();
     } else {
+#ifdef STE_HARDWARE
+        // Make sure the swapbuffer call is done in sync
+        mNativeWindow->compositionComplete();
+#endif
         eglSwapBuffers(dpy, surface);
     }
     checkEGLErrors("eglSwapBuffers");
diff --git a/services/surfaceflinger/DisplayHardware/HWComposer.cpp b/services/surfaceflinger/DisplayHardware/HWComposer.cpp
index 1b843b1..6aaf238 100644
--- a/services/surfaceflinger/DisplayHardware/HWComposer.cpp
+++ b/services/surfaceflinger/DisplayHardware/HWComposer.cpp
@@ -239,5 +239,13 @@ void HWComposer::perform(int event, int value) {
 }
 #endif
 
+#ifdef STE_HDMI
+int HWComposer::setHDMIParameter(int event, int value) {
+int ret = NO_INIT;
+return ret;
+}
+
+#endif
+
 // ---------------------------------------------------------------------------
 }; // namespace android
diff --git a/services/surfaceflinger/DisplayHardware/HWComposer.h b/services/surfaceflinger/DisplayHardware/HWComposer.h
index faf7f16..e50ce67 100644
--- a/services/surfaceflinger/DisplayHardware/HWComposer.h
+++ b/services/surfaceflinger/DisplayHardware/HWComposer.h
@@ -72,6 +72,9 @@ public:
     uint32_t getFlags() const;
     void perform(int event, int value);
 #endif
+#ifdef STE_HDMI
+    int setHDMIParameter(int event, int value);
+#endif
 
     // for debugging
     void dump(String8& out, char* scratch, size_t SIZE,
diff --git a/services/surfaceflinger/Layer.cpp b/services/surfaceflinger/Layer.cpp
index a621f1b..a3cc063 100644
--- a/services/surfaceflinger/Layer.cpp
+++ b/services/surfaceflinger/Layer.cpp
@@ -289,6 +289,18 @@ void Layer::setPerFrameData(hwc_layer_t* hwcl) {
 
 void Layer::onDraw(const Region& clip) const
 {
+#ifdef STE_HARDWARE
+    // Convert the texture to a native format if need be.
+    // convert() returns immediately if no conversion is necessary.
+    if (mSurfaceTexture != NULL) {
+        status_t res = mSurfaceTexture->convert();
+        if (res != NO_ERROR) {
+            LOGE("Layer::onDraw: texture conversion failed. "
+                "Texture content for this layer will not be initialized.");
+        }
+    }
+#endif
+
     if (CC_UNLIKELY(mActiveBuffer == 0)) {
         // the texture has not been created yet, this Layer has
         // in fact never been drawn into. This happens frequently with
@@ -514,7 +526,11 @@ void Layer::lockPageFlip(bool& recomputeVisibleRegions)
 
         if (mSurfaceTexture->updateTexImage(isComposition) < NO_ERROR) {
 #else
+#ifndef STE_HARDWARE
         if (mSurfaceTexture->updateTexImage() < NO_ERROR) {
+#else
+        if (mSurfaceTexture->updateTexImage(true) < NO_ERROR) {
+#endif
 #endif
             // something happened!
             recomputeVisibleRegions = true;
diff --git a/services/surfaceflinger/SurfaceFlinger.cpp b/services/surfaceflinger/SurfaceFlinger.cpp
index 8bd687e..ca4f155 100644
--- a/services/surfaceflinger/SurfaceFlinger.cpp
+++ b/services/surfaceflinger/SurfaceFlinger.cpp
@@ -476,7 +476,9 @@ bool SurfaceFlinger::threadLoop()
 #else
 	// inform the h/w that we're done compositing
 	logger.log(GraphicLog::SF_COMPOSITION_COMPLETE, index);
+#ifndef STE_HARDWARE
 	hw.compositionComplete();
+#endif
 
 	logger.log(GraphicLog::SF_SWAP_BUFFERS, index);
 	postFramebuffer();
@@ -485,7 +487,9 @@ bool SurfaceFlinger::threadLoop()
         logger.log(GraphicLog::SF_REPAINT_DONE, index);
     } else {
         // pretend we did the post
+#ifndef STE_HARDWARE
         hw.compositionComplete();
+#endif
         usleep(16667); // 60 fps period
 
 #ifdef QCOM_HARDWARE
@@ -574,7 +578,6 @@ void SurfaceFlinger::handleTransactionLocked(uint32_t transactionFlags)
 {
     const LayerVector& currentLayers(mCurrentState.layersSortedByZ);
     const size_t count = currentLayers.size();
-
     /*
      * Traversal of the children
      * (perform the transaction for each of them if needed)
@@ -884,8 +887,10 @@ void SurfaceFlinger::handleRepaint()
 
     // set the frame buffer
     const DisplayHardware& hw(graphicPlane(0).displayHardware());
+#ifndef STE_HARDWARE
     glMatrixMode(GL_MODELVIEW);
     glLoadIdentity();
+#endif
 
     uint32_t flags = hw.getFlags();
     if ((flags & DisplayHardware::SWAP_RECTANGLE) ||
@@ -954,8 +959,15 @@ bool SurfaceFlinger::isGPULayerPresent()
 }
 #endif
 
+#ifdef STE_HARDWARE
+static bool checkDrawingWithGL(hwc_layer_t* const layers, size_t layerCount);
+#endif
+
 void SurfaceFlinger::setupHardwareComposer(Region& dirtyInOut)
 {
+#ifdef STE_HARDWARE
+    bool useGL = true;
+#endif
     const DisplayHardware& hw(graphicPlane(0).displayHardware());
     HWComposer& hwc(hw.getHwComposer());
     hwc_layer_t* const cur(hwc.getLayers());
@@ -990,6 +1002,23 @@ void SurfaceFlinger::setupHardwareComposer(Region& dirtyInOut)
 #ifdef QCOM_HARDWARE
     mCanSkipComposition = (hwc.getFlags() & HWC_SKIP_COMPOSITION) ? true : false;
 #endif
+#ifdef STE_HARDWARE
+    /*
+     * Check if GL will be used
+     */
+    useGL = checkDrawingWithGL(cur, count);
+
+    if (!useGL) {
+        return;
+    }
+    glMatrixMode(GL_MODELVIEW);
+    glLoadIdentity();
+    if (UNLIKELY(!mWormholeRegion.isEmpty())) {
+        // should never happen unless the window manager has a bug
+        // draw something...
+        drawWormhole();
+    }
+#endif
     if (err == NO_ERROR) {
         // what's happening here is tricky.
         // we want to clear all the layers with the CLEAR_FB flags
@@ -1072,12 +1101,28 @@ void SurfaceFlinger::setupHardwareComposer(Region& dirtyInOut)
     }
 }
 
+#ifdef STE_HARDWARE
+static bool checkDrawingWithGL(hwc_layer_t* const layers, size_t layerCount)
+{
+    bool useGL = false;
+    if (layers) {
+        for (size_t i=0 ; i<layerCount ; i++) {
+            if (layers[i].compositionType == HWC_FRAMEBUFFER) {
+                useGL = true;
+            }
+        }
+    }
+    return useGL;
+}
+#endif
+
 void SurfaceFlinger::composeSurfaces(const Region& dirty)
 {
     const DisplayHardware& hw(graphicPlane(0).displayHardware());
     HWComposer& hwc(hw.getHwComposer());
 
     const size_t fbLayerCount = hwc.getLayerCount(HWC_FRAMEBUFFER);
+#ifndef STE_HARDWARE
     if (UNLIKELY(fbLayerCount && !mWormholeRegion.isEmpty())) {
         // should never happen unless the window manager has a bug
         // draw something...
@@ -1098,6 +1143,7 @@ void SurfaceFlinger::composeSurfaces(const Region& dirty)
         drawWormhole();
 #endif
     }
+#endif
 
     /*
      * and then, render the layers targeted at the framebuffer
@@ -1428,6 +1474,14 @@ void SurfaceFlinger::enableExternalDisplay(int disp_type, int value)
 }
 #endif
 
+#ifdef STE_HDMI
+int SurfaceFlinger::setHDMIParameter(int disp_type, int value)
+{
+    HWComposer &hwc(graphicPlane(0).displayHardware().getHwComposer());
+    return hwc.setHDMIParameter(disp_type,value);
+}
+#endif
+
 sp<ISurface> SurfaceFlinger::createSurface(
         ISurfaceComposerClient::surface_data_t* params,
         const String8& name,
@@ -2541,7 +2595,9 @@ status_t SurfaceFlinger::captureScreenImplLocked(DisplayID dpy,
     glDeleteRenderbuffersOES(1, &tname);
     glDeleteFramebuffersOES(1, &name);
 
+#ifdef STE_HARDWARE
     hw.compositionComplete();
+#endif
 
     // LOGD("screenshot: result = %s", result<0 ? strerror(result) : "OK");
 
@@ -2769,9 +2825,15 @@ sp<GraphicBuffer> GraphicBufferAlloc::createGraphicBuffer(uint32_t w, uint32_t h
         if (err == NO_MEMORY) {
             GraphicBuffer::dumpAllocationsToSystemLog();
         }
+#ifndef STE_HARDWARE
         LOGE("GraphicBufferAlloc::createGraphicBuffer(w=%d, h=%d) "
              "failed (%s), handle=%p",
                 w, h, strerror(-err), graphicBuffer->handle);
+#else
+        LOGE("GraphicBufferAlloc::createGraphicBuffer(w=%d, h=%d, format=%#x) "
+             "failed (%s), handle=%p",
+                w, h, format, strerror(-err), graphicBuffer->handle);
+#endif
         return 0;
     }
 #ifdef QCOM_HARDWARE
diff --git a/services/surfaceflinger/SurfaceFlinger.h b/services/surfaceflinger/SurfaceFlinger.h
index b7a60f6..e6b465d 100644
--- a/services/surfaceflinger/SurfaceFlinger.h
+++ b/services/surfaceflinger/SurfaceFlinger.h
@@ -186,6 +186,10 @@ public:
     //HDMI Specific
     virtual void                        enableExternalDisplay(int disp_type, int externaltype);
 #endif
+#ifdef STE_HDMI
+    //HDMI Specific
+    virtual int                         setHDMIParameter(int disp_type, int externaltype);
+#endif
 
     virtual status_t captureScreen(DisplayID dpy,
             sp<IMemoryHeap>* heap,
diff --git a/telephony/java/android/telephony/PhoneStateListener.java b/telephony/java/android/telephony/PhoneStateListener.java
index eda9b71..0791494 100644
--- a/telephony/java/android/telephony/PhoneStateListener.java
+++ b/telephony/java/android/telephony/PhoneStateListener.java
@@ -16,15 +16,16 @@
 
 package android.telephony;
 
+// BEGIN privacy-added
+import com.android.internal.telephony.IPhoneStateListener;
+import android.privacy.PrivacySettings;
+import android.privacy.PrivacySettingsManager;
+// END privacy-added
+
+import android.content.Context;
 import android.os.Bundle;
 import android.os.Handler;
 import android.os.Message;
-import android.telephony.ServiceState;
-import android.telephony.SignalStrength;
-import android.telephony.CellLocation;
-import android.util.Log;
-
-import com.android.internal.telephony.IPhoneStateListener;
 import com.android.internal.telephony.Phone;
 
 /**
@@ -156,6 +157,28 @@ public class PhoneStateListener {
      */
     public static final int LISTEN_OTASP_CHANGED                            = 0x00000200;
 
+    // BEGIN privacy-added
+    private Context context;
+    private String packageName;
+    private int uid;
+    private final static String TAG = "PhoneStateListener"; 
+    
+    /** {@hide} */
+    public void setContext(Context context) {
+        this.context = context;
+    }
+    
+    /** {@hide} */
+    public void setPackageName(String packageName) {
+        this.packageName = packageName;
+    }
+    
+    /** {@hide} */
+    public void setUid(int uid) {
+        this.uid = uid;
+    }    
+    // END privacy-added
+    
     public PhoneStateListener() {
     }
 
@@ -300,11 +323,49 @@ public class PhoneStateListener {
 
         public void onCellLocationChanged(Bundle bundle) {
             CellLocation location = CellLocation.newFromBundle(bundle);
-            Message.obtain(mHandler, LISTEN_CELL_LOCATION, 0, 0, location).sendToTarget();
+            // BEGIN privacy-modified
+            if (context != null) {
+                PrivacySettingsManager pSetMan = (PrivacySettingsManager) context.getSystemService("privacy");
+                PrivacySettings pSet = pSetMan.getSettings(packageName, uid);
+//                String output;
+                if (pSet != null && pSet.getLocationNetworkSetting() != PrivacySettings.REAL) {
+                    // simply block the method call, since simulating cell location is not feasible
+//                    output = "[no output]";
+                    pSetMan.notification(packageName, uid, pSet.getLocationNetworkSetting(), PrivacySettings.DATA_LOCATION_NETWORK, null, pSet);            
+                } else {
+//                    output = location.toString();
+                    Message.obtain(mHandler, LISTEN_CELL_LOCATION, 0, 0, location).sendToTarget();
+                    pSetMan.notification(packageName, uid, PrivacySettings.REAL, PrivacySettings.DATA_LOCATION_NETWORK, null, pSet);            
+                }
+//                Log.d(TAG, "onCellLocationChanged - " + context.getPackageName() + " (" + 
+//                        Binder.getCallingUid() + ") output: " + output);
+            }
+            // END privacy-modified
         }
 
         public void onCallStateChanged(int state, String incomingNumber) {
-            Message.obtain(mHandler, LISTEN_CALL_STATE, state, 0, incomingNumber).sendToTarget();
+            // BEGIN privacy-modified
+//            Log.d(TAG, "onCallStateChanged - state:" + state + " incoming number:" + incomingNumber);
+            // only take action if an incoming phone number is actually transmitted
+            if (context != null && incomingNumber != null && !incomingNumber.isEmpty()) {
+                PrivacySettingsManager pSetMan = (PrivacySettingsManager) context.getSystemService("privacy");
+                PrivacySettings pSet = pSetMan.getSettings(packageName, uid);
+                String output;
+                if (pSet != null && pSet.getIncomingCallsSetting() != PrivacySettings.REAL) {
+                    output = "";
+                    Message.obtain(mHandler, LISTEN_CALL_STATE, state, 0, output).sendToTarget();
+//                    Log.d(TAG, "onCallStateChanged BLOCK - package:" + packageName + " uid:" + uid + " state:" + state + " output: " + output);
+                    pSetMan.notification(packageName, uid, PrivacySettings.EMPTY, PrivacySettings.DATA_INCOMING_CALL, output, pSet);
+                } else {
+                    Message.obtain(mHandler, LISTEN_CALL_STATE, state, 0, incomingNumber).sendToTarget();
+//                    Log.d(TAG, "onCallStateChanged REAL 1 - package:" + packageName + " uid:" + uid + " state:" + state + " output: " + incomingNumber);
+                    pSetMan.notification(packageName, uid, PrivacySettings.REAL, PrivacySettings.DATA_INCOMING_CALL, incomingNumber, pSet);
+                }
+            } else {
+//                Log.d(TAG, "onCallStateChanged REAL 2 - package:" + packageName + " uid:" + uid + " state:" + state + " output: " + incomingNumber);
+                Message.obtain(mHandler, LISTEN_CALL_STATE, state, 0, incomingNumber).sendToTarget();
+            }
+            // END privacy-modified
         }
 
         public void onDataConnectionStateChanged(int state, int networkType) {
diff --git a/telephony/java/com/android/internal/telephony/Smdk4210RIL.java b/telephony/java/com/android/internal/telephony/Smdk4210RIL.java
index b385627..cd9fd2a 100644
--- a/telephony/java/com/android/internal/telephony/Smdk4210RIL.java
+++ b/telephony/java/com/android/internal/telephony/Smdk4210RIL.java
@@ -159,6 +159,14 @@ public class Smdk4210RIL extends RIL implements CommandsInterface {
         audioManager = (AudioManager)mContext.getSystemService(Context.AUDIO_SERVICE);
     }
 
+    static String
+    requestToString(int request) {
+        switch (request) {
+            case RIL_REQUEST_DIAL_EMERGENCY: return "DIAL_EMERGENCY";
+            default: return RIL.requestToString(request);
+        }
+    }
+
     @Override
     public void setCurrentPreferredNetworkType() {
         if (RILJ_LOGD) riljLog("setCurrentPreferredNetworkType IGNORED");
@@ -438,6 +446,7 @@ public class Smdk4210RIL extends RIL implements CommandsInterface {
             case RIL_REQUEST_REPORT_STK_SERVICE_IS_RUNNING: ret = responseVoid(p); break;
             case RIL_REQUEST_CDMA_GET_SUBSCRIPTION_SOURCE: ret =  responseInts(p); break;
             case RIL_REQUEST_ISIM_AUTHENTICATION: ret =  responseString(p); break;
+            case RIL_REQUEST_DIAL_EMERGENCY: ret = responseVoid(p); break;
             default:
                 throw new RuntimeException("Unrecognized solicited response: " + rr.mRequest);
                 //break;
@@ -491,6 +500,50 @@ public class Smdk4210RIL extends RIL implements CommandsInterface {
     }
 
     @Override
+    public void
+    dial(String address, int clirMode, UUSInfo uusInfo, Message result) {
+        RILRequest rr;
+        if (PhoneNumberUtils.isEmergencyNumber(address)) {
+            dialEmergencyCall(address, clirMode, result);
+            return;
+        }
+
+        rr = RILRequest.obtain(RIL_REQUEST_DIAL, result);
+        rr.mp.writeString(address);
+        rr.mp.writeInt(clirMode);
+        rr.mp.writeInt(0); // UUS information is absent
+
+        if (uusInfo == null) {
+            rr.mp.writeInt(0); // UUS information is absent
+        } else {
+            rr.mp.writeInt(1); // UUS information is present
+            rr.mp.writeInt(uusInfo.getType());
+            rr.mp.writeInt(uusInfo.getDcs());
+            rr.mp.writeByteArray(uusInfo.getUserData());
+        }
+
+        if (RILJ_LOGD) riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
+
+        send(rr);
+    }
+
+    public void
+    dialEmergencyCall(String address, int clirMode, Message result) {
+        RILRequest rr;
+        Log.v(LOG_TAG, "Emergency dial: " + address);
+
+        rr = RILRequest.obtain(RIL_REQUEST_DIAL_EMERGENCY, result);
+        rr.mp.writeString(address + "/");
+        rr.mp.writeInt(clirMode);
+        rr.mp.writeInt(0);
+        rr.mp.writeInt(0);
+
+        if (RILJ_LOGD) riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
+
+        send(rr);
+    }
+
+    @Override
     protected void
     processUnsolicited (Parcel p) {
         Object ret;
